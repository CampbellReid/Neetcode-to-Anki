[
    {
        "Name": "Contains Duplicate",
        "NcLink": "duplicate-integer/",
        "Pattern": "Arrays & Hashing",
        "Description": "Given an integer array `nums`, return `true` if any value appears **more than once** in the array, otherwise return `false`.\n\n**Example 1:**\n\n```java\nInput: nums = [1, 2, 3, 3]\n\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: nums = [1, 2, 3, 4]\n\nOutput: false\n```\n",
        "Difficulty": "Easy",
        "Video": "3OamzN90kPg",
        "PythonSolution": "class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        hashset = set()\n\n        for n in nums:\n            if n in hashset:\n                return True\n            hashset.add(n)\n        return False\n    ",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve contains duplicate this is\nanother problem from the blind 75 list\nof questions we've been working on so i\nlike this problem because it's a good\nproblem for beginners but there's also\nmultiple solutions to it that i'd like\nto go over in this video so we're given\nan array of numbers we want to return\ntrue if there's any value in that list\nof numbers that appears at least twice\nbut maybe it could appear three times or\nfour times write just at least twice and\nwe want to return false if there aren't\nany values that appear at least twice\nbasically what that means is that every\nvalue in the array is distinct so let's\ntake a look at an example we have one\ntwo three and then we have 1 again so of\ncourse this has duplicates right so we\nreturn true and the easiest way we would\nbe able to detect that is by brute\nforcing this so given these numbers the\nfirst thing we do is look at the first\nnumber it's 1. how do we know if this is\na duplicate or not well we'd have to\ncompare it to every single number in the\nrest of the array so that would be a big\no of n time operation just to check if\nthe first number is a duplicate or not\nand then we'd have to do that for every\nnumber then we have to check is the\nsecond number a duplicate how do we know\nwe have to compare it to every other\nnumber we do the same thing with the\nthird one and the last one and so since\nwe're doing it for every number in the\narray the overall time complexity is\ngoing to become n squared and by the way\nin this case n is just the size of the\ninput array so the brute force solution\nis big o n squared time complexity but\nthe good thing is we don't need any\nextra memory so the memory complexity is\nbig of one it's definitely not a bad\nsolution but the question is can we do\nbetter than that and yes we definitely\ncan a second approach that will help us\nis sorting what happens if we took this\narray and we sorted it it would look a\nlittle bit different it would look like\nthis okay but how does sorting help us\nwell let's think about it if we sort the\ninput then any duplicates that do exist\nin the array and clearly we see that two\nduplicates exist at the beginning of the\narray they're going to be adjacent so\nwhen we're\ntrying to detect any duplicates in here\nwe only have to iterate through the\narray once and as we do that we're just\ngoing to be comparing two neighbors in\nthe array checking if they're duplicates\nnext we're going to shift our pointers\nto the next spot are these duplicates\nare these duplicates etc etc until we\nfinish the entire array in this case we\nsee that these two adjacent values are\nduplicates so we can return true and\nwhat's the time complexity of this well\nthe one pass is just going to be big o\nof n but we know that sorting does take\nextra memory or not extra memory it does\ntake uh extra time complexity and that\ntime complexity is n log n so that's the\nbottleneck in this solution but again we\ndon't need extra space if you don't\ncount the space that's used by the\nsorting algorithm so in this case we do\nhave a slightly better solution than\nbrute force but actually if we use a\nlittle bit extra memory and it's really\na trade-off if we sacrifice space\ncomplexity we can actually achieve\nbetter memory complexity and let me show\nyou how so suppose we don't sort our\ninput we're given the default input but\nwe use extra memory we use a hash set\nbut what exactly is a hash set gonna do\nfor us it's gonna allow us to insert\nelements into the hash set in big o of\none time but it's also gonna allow us to\ncheck we can ask our hashmap does a\ncertain value exist we want to know does\nthis 1 exist in the hashmap well if we\nstart at the beginning of the array so\nfar nothing is in our hashmap so a 1\ndoes not exist in our hashmap that means\nthis 1 is not a duplicate you can see\nthat this is an improvement over the\nbrute force previously to determine if\nthis was a duplicate we had to check\nevery other value in the array this time\nwe don't but after we have checked if\nthis is a duplicate we do have to add it\nto our hash set because later on if we\nencounter a one like over here then we\ndetermine that this is a duplicate\nbecause we know that there's already a\none in our hash set so next we're gonna\ncheck two two is not a duplicate added\nhere is three a duplicate nope add it\nhere one is this a duplicate yep there's\na one over here so we return true this\ndoes contain duplicates and by the way\nsince each operation was just big o of\none we had to do that for every value in\nthe input array and we only had to scan\nthrough the list of inputs once the time\ncomplexity is going to be big o of n but\nthe space complexity we did have to\nsacrifice a little bit we have to create\na hash set and the memory that that hash\nset will use could be up to the size of\nthe input array which is n so we do end\nup using extra memory but that's not too\nbad this is about as efficient as we can\nget in terms of time complexity so let's\nget into the code now okay so now let's\nget into the code so the first thing i'm\ngoing to do is create that hash set in\npython you can do that just like this\nit's just called a set and then the\nsimple thing is just going through every\nvalue in the input array nums and\nbefore we end up adding it to our hash\nset because remember we want to add\nevery one of these values to our hash\nset just like this but before we even do\nthat we want to know is n a duplicate\ndoes this value already exist in our\nhash set and if it does we know that our\narray contains duplicates so we don't\neven have to continue through the rest\nof the array we can immediately return\ntrue because we found a duplicate but if\nit doesn't contain a duplicate we're\ngoing to add that value then iterate\nthrough the rest of the array of nums\nand then the loop will exit and then we\ncan return false to indicate that we did\nnot find any duplicates in the array now\nlet's run the code to make sure that it\nworks and on the left you can see that\nyes it does work and it is about as\nefficient as we can get so i really hope\nthat this was helpful if it was please\nlike and subscribe it supports the\nchannel a lot consider checking out my\npatreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Valid Anagram",
        "NcLink": "is-anagram/",
        "Pattern": "Arrays & Hashing",
        "Description": "Given two strings `s` and `t`, return `true` if the two strings are anagrams of each other, otherwise return `false`.\n\nAn **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\n**Example 1:**\n\n```java\nInput: s = \"racecar\", t = \"carrace\"\n\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: s = \"jar\", t = \"jam\"\n\nOutput: false\n```\n\n**Constraints:**\n* `s` and `t` consist of lowercase English letters.\n",
        "Difficulty": "Easy",
        "Video": "9UtInBqnCgA",
        "PythonSolution": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        countS, countT = {}, {}\n\n        for i in range(len(s)):\n            countS[s[i]] = 1 + countS.get(s[i], 0)\n            countT[t[i]] = 1 + countT.get(t[i], 0)\n        return countS == countT\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem valid anagram and\nwe're actually going to be solving this\na few different ways so maybe you will\nlearn something today so we're given two\nstrings s and t and we want to return\ntrue if\nt is an anagram of s or basically if\nboth of the strings are anagrams of each\nother and false if they're not anagrams\nso main thing that they don't mention in\nthis problem is what exactly is an\nanagram and basically it means that you\nknow to call t an anagram of s is\nbasically saying that using the\ncharacters of s all of the characters\nright every single character we can\ncreate the string t so basically they're\nmade up of the exact same list of\ncharacters so\nso the string s you can see that it has\nthree a characters one n character a one\ng character one r character and one m\ncharacter so it's made up of in total\nseven characters so that must mean that\nif t is an anagram of s\nt has to have exactly seven characters\nas well which clearly it does have seven\ncharacters but are they the exact same\ncharacters as i wrote up above well\nlet's check okay does it have three a\ncharacters one two three yep it has\nthree a characters does it have a single\nn character yep it has exactly one n\ncharacter does it have a g character yes\nexactly one g character uh does it have\nan r exactly one r it has exactly one m\nas well so it has\nuh the exact same characters and the\nsame quantity of each character that's\nalso important right because three a's\nhave to exist in t as well so in this\ncase they're anagrams we can return true\nthat's great uh second example uh rat\nand car\nboth of them have an r both of them have\nan a character but one of them has a t\nwhile the other has a c character\nthey're both the same length they're\nboth length three but they have one\ndiffering character so they're not\nanagrams we return false in this case so\nthe first solution i wanted to talk\nabout is probably the most obvious one\nand probably uh by just listening to me\ntalk about anagrams you might be able to\ncome up with this by yourself we just\nwant to count the occurrences of each\ncharacter in both\nboth strings right\nwhat's the easiest way to do that well\nyou could use an array or a hash map\nthat's what i'm going to use i like hash\nmaps basically what the hash map is\ngoing to look like so basically we're\ngoing to have two hash maps one for each\nstring and the key value in the hash map\nis going to be the character so for\nexample a in string s right let's use a\ndifferent color so a in string s so how\nmany a's are there there's three a's\nright the the value is going to be the\ncount the key is just going to be the\ncharacter we're going to do that for\nevery single character in the string so\nthat's a n has one g has one r has one\nand m also has one and we know that t is\nthe exact same right as three a's one n\netcetera etcetera right i could continue\nthis so in the end you can see that\nthey're the exact same hash map right\nonce we've built these hash maps we can\nthen go through the keys and then\ncompare that the counts for each\ncharacter are the exact same which in\nthis case yes it is so then after that\ncomparison then we know that they're\nanagrams then we can return true and how\nexactly i'm going to do that is i'm just\ngoing to actually iterate through the\nkeys of one of these so in this case for\nexample i'm just going to iterate\nthrough all the keys in string s so a n\ng and then make sure the counts right we\nwant to make sure that the count of each\nof the characters is the exact same and\nif we make sure that both strings have\nthe exact same length before we actually\ndo the hash map stuff then we actually\nonly have to iterate through one of the\nhash maps and comparing it to the other\nhash map right because if we make sure\nthat\nt has exactly three a's t has exactly\none n t has exactly one g etcetera\netcetera if we make sure that all of\nthat is true and that's inside of t then\nwe pretty much know t is exactly the\nsame as s because they have to be if\nthey are the same length so that's the\nsolution uh time complexity of this is\nbig o of n uh or rather let's say big o\nof s plus t\nuh because we're gonna have to iterate\nthrough both of the strings so we uh so\nthat's the time complexity the memory\ncomplexity is the same s plus t because\nclearly we are building hash maps that\nare gonna be of size\npotentially up to the size of s and the\nsize of t so the downside of this\nsolution is we are going to need some\nextra memory and the second solution\nthat i show you is actually going to\nsolve that memory problem so stay tuned\nin the video if you want to see that but\nfor now let's jump into the coding\nsolution of\nthis hashmap solution that i'm talking\nabout okay so now let's code it up and\nlike i mentioned a main thing we're just\ngoing to be doing is counting the\ncharacters in both of the strings so\nwe're going to create hashmaps for that\nthis is how you can do that in python\nbut remember before we even do that we\nwant to make sure that the length of\nboth strings is exactly the same because\nif they're not the same length then of\ncourse it's impossible for them to be\npalindromes so we can immediately whoops\nthen we can immediately return false if\nthey are not the same length otherwise\nwe can actually run the algorithm so\nlet's just\nuh go through the strings at the same\ntime so we can iterate uh basically\nthrough the length of the string s\nbecause we know they're both the same\nlength so we can just use the index i\nfor both of the strings uh count s is\nbasically going to count the occurrence\nof each character in uh string s of\ncourse so each time we see the a\ncharacter so a character is basically\ngoing to be s at index i that's the key\nof the hashmap uh every time we see a\ncharacter we want to increment the count\nof that character by one so can we just\nsay one plus this can we just say one\nplus this well in python no because what\nif that character doesn't even exist in\nthe hashmap yet then this is gonna throw\na key error right key does not exist so\nto get around that in python at least\nthere's a nice little function uh with\nhash maps that you can use that's called\nget so\nget this uh you know this key and it'll\nbasically do exactly what's being done\nover here on the left side but the\nsecond parameter to this function is\nbasically a default value so 0 is the\ndefault value in this case that means\nthat if this key does not exist in the\nhashmap then the default value that this\nfunction is going to return is 0 which\nis of course what we would want it to\nreturn right so with this line we're\njust counting the occurrences of each\ncharacter in string s we can do the\nexact same thing uh with string t just\nby copy pasting this and then changing\neverything to t so making sure we use\nthe t hash map and making sure we\niterate through the string t right t at\nindex i so that's pretty much it for\nbuilding the hash maps next we want to\niterate through the hash maps and make\nsure the counts are the same so let's\nsay for c for the character in count uh\ns so we just want to make sure the\ncounts of both uh hash maps are the same\nso count that character i is equal to\ncount t\nat character i so the counts are the\nsame actually in this case we'd want to\nmake sure that the counts are not the\nsame because if they're not the same\nthen we basically know to return false\nimmediately because\nthen we know that they're not anagrams\nif you have noticed we're iterating\nthrough the keys in python at least\nwe're iterating through all the key\nvalues of account s right the the count\nmap of string s and c\nis going to be the key but what if that\nkey does not exist in the t map right\ncount t what if it doesn't exist in this\nmap well again we can use that default\nfunction of get so that it doesn't throw\na key error for us and it'll return a\ndefault value of zero so\nthat's uh basically the entire algorithm\nright we built the hash map we performed\nthe check and then if if we never return\nfalse here that must mean that they are\nanagram so then if the loop exits we can\ngo ahead and return true that's the\nentire code let's run it to make sure\nthat it works so you can see on the left\nit does run it's relatively efficient\nthough it doesn't reflect that on leak\ncode but basically you can actually do\nexactly what i just showed you with one\nline of code at least in python but i i\nthink this is kind of cheating and it\nprobably won't work in an interview but\ncounter is a data structure in python\nwhich is a hashmap but it basically\ncounts things automatically for you so\nwe can run a counter on s and we can run\na counter on t and if these counters are\nexactly equal basically by doing the\nequal sign i'm just doing what i did\ndown here right with the for loop but\nthe equal sign does it for us instantly\nso\nuh it does that and then we can just\nreturn the result if they're equal it'll\nreturn true if they're not equal it'll\nreturn false i can run that and make\nsure that it works which it does and\nit's actually slightly more efficient i\nguess the overall time complexity and\nspace complexity of both of these\nsolutions is exactly the same just this\ntakes more lines of code because we're\nactually explicitly writing out all the\noperations so now what if as a follow-up\nquestion your interviewer asks you how\ncan you make a solution where we don't\nactually need extra memory can you do a\nsolution with of one memory how would\nyou solve that problem it's a good\nquestion and the solution is actually\nsimpler than you might think\njust kind of thinking about how anagrams\nwork if you took all these characters\nand put them in a hash map where we can\ncount the occurrences then it's pretty\neasy to check if they're equal but isn't\nthere another way what if we\nmade sure that the characters show up in\nthe exact same order every single time\nwhat do we mean by order well one\npossible way would be sorted order right\nbecause if they're if they really are\nthe exact same characters then if we put\nthem in sorted order then they should\nactually become the exact same string\nthen we can literally just do an equals\noperation on both of the sorted strings\nand guarantee that they're going to be\nequal but the downside is what's the\ntime complexity of doing sort well in\nsome cases with bad sorting algorithms\nlike bubble sort or something it might\nbe n squared right\ngood sorting algorithms can do it in n\nlog n time right worst case big o of n\nlog n time uh but you know the space\ncomplexity is kind of iffy usually\nsorting algorithms at least good ones\nactually do use extra memory they use of\nn extra memory but sometimes they don't\nsometimes they can be really optimized\nand actually run on\nconstant memory constant extra memory it\nwill depend on which built-in library\nfunction you're using but usually for\nsome reason interviewers just assume\nthat sorting doesn't take extra space so\nit's definitely something to discuss\nwith your interviewer yeah so basically\nif you just sort it it solves the\nproblem for you right because if we took\nanagram and we sorted it we'd get aaa g\nm n r right it would be the same order\nand then if we take the this string t\nsort it it's the exact same characters\nso when we sort it it should be the\nexact same string and it is so now let's\nget into the code of this solution okay\nso now you can see that these were the\ntwo solutions we originally came up with\nnow let's do the third and final\nsolution\nwe can just run the sort function on s\nand the sort function\nthe built-in sort functions at least in\npython on t as well and if they're\nexactly equal it'll return true if\nthey're not equal it will return false\nlet's run it to make sure that it works\nand on the left you can see yes it does\nit's relatively efficient but\ntechnically it's not as efficient as the\ntwo previous solutions that we came up\nwith below and who knows maybe your\ninterviewer will actually want you to\nwrite out your own sorting function for\nthis but i really hope that this was\nhelpful if it was please like and\nsubscribe it supports the channel a lot\nconsider checking out my patreon where\nyou can further support the channel and\nhopefully i'll see you pretty soon\n"
    },
    {
        "Name": "Two Sum",
        "NcLink": "two-integer-sum/",
        "Pattern": "Arrays & Hashing",
        "Description": "Given an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.\n    \nYou may assume that *every* input has exactly one pair of indices `i` and `j` that satisfy the condition.\n\nReturn the answer with the smaller index first. \n\n**Example 1:**\n\n```java\nInput: \nnums = [3,4,5,6], target = 7\n\nOutput: [0,1]\n```\n\nExplanation: `nums[0] + nums[1] == 7`, so we return `[0, 1]`.\n\n**Example 2:**\n\n```java\nInput: nums = [4,5,6], target = 10\n\nOutput: [0,2]\n```\n\n**Example 3:**\n\n```java\nInput: nums = [5,5], target = 10\n\nOutput: [0,1]\n```\n\n**Constraints:**\n* `2 <= nums.length <= 1000`\n* `-10,000,000 <= nums[i] <= 10,000,000`\n* `-10,000,000 <= target <= 10,000,000`\n",
        "Difficulty": "Easy",
        "Video": "KLlXCFG5TnA",
        "PythonSolution": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        prevMap = {}  # val -> index\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i\n",
        "Transcript": "let's all leak code one to some the most\npopular leak code question so we're\ngiven an input array and some target in\nthis case 9 and we want to find the two\nvalues in this input array that sum to 9\nso in this case it's 2 &amp; 7 now we want\nto return the indices of these two\nvalues so the index of zero of the index\nof two is zero the index of 7 is 1 so we\nreturn 0 &amp; 1\nwe're guaranteed that there's exactly\none solution so we don't have to worry\nabout not finding a solution and we\ndon't have to worry about multiple\nsolutions now the most intuitive way to\nsolve this problem is basically just\ncheck every combination of two values\nand see if they can sum up to our target\nso we start at 2 we check every\ncombination we can make that includes 2\nso we scan through the remainder of the\narray 1 5 3 and check if any of those\nnumbers added to 2 some store target for\nin this case none of them do so next we\ncan repeat the process\nlet's check every combination including\none that sums up the target for so we\nscan through every element that comes\nafter at 5 &amp; 3 and we find that one\nadded with 3 sums up to our target 4\nnotice that we didn't have to check the\nvalues that came before 1 because we\nalready checked the combination 2 &amp; 1\nwhen we were up over here remember when\nwe checked every combination with 2 so\nwe didn't have to repeat that work down\nhere we only had to check the numbers\nthat came after 1\nso the runtime of this algorithm isn't\nsuper efficient this is basically brute\nforce we're going through the entire\narray of length and and we're gonna do\nthat worst case n times for each number\nthis means that over all worst case time\ncomplexity will be O of N squared so can\nwe do better now the thing to notice is\nthat for each number for example 1 the\nvalue we're looking for is the\ndifference between the target and this\nvalue 1 so we're looking for 4 minus 1\nwhich is equal to 3 so that means this\nis the only value we can add to one\nthat'll equal the target so we don't\nhave to check every number we just want\nto know if\nresist s-- now the easiest way we can do\nthis the most efficient is by making a\nhash map of every value in our input\narray so we can instantly check if the\nvalue 3 exists now let's try the same\nproblem except let's use a hash map this\ntime now in our hash map we're going to\nbe mapping each value to the index of\neach value so the index of 2 is 0 the\nindex of 1 is 1 the index of 5 is 2 the\nindex of 3 is 3 so let's so in our hash\nmap we're going to be mapping the value\nnow we could add every value in this\narray into the hash map before we start\niterating through it but there's\nactually an easier way to do it if we\nadded the entire array into the hash map\ninitially then we would get to the value\n2 first right we would want to checked\nas the difference between target 4 minus\nthis value 2 which is equal to 2 exists\nin our hash map and we would find that 2\ndoes exist in our hash map but we're not\nallowed to reuse the same one right\nbecause they're both at the same index\nwe can't use the same value twice so we\nwould have to compare the index of our\ncurrent 2 with the index of the 2 that's\nin our hash map there's actually an\neasier way to do this though and it's a\nlittle clever and let me show you how to\ndo it that way so doing it this clever\nway initially we say our hash map is\nempty so we get to the value 2 first of\nall right and we want to look for the\ndifference 4 minus 2 in our hash map our\nhash map is empty so we don't find 2 so\nthen after we visited this element then\nwe can add it to our hash map so now\nthat I'm done visiting it I'm gonna move\nto the second element 1 and before I do\nthat I'm gonna add this value 2 to our\nhash map and the index of this value is\ngonna be 0 now I'm at 1 I'm looking for\n4 minus 1 which is 3\nI see 3 isn't in our hash map but it\nactually is in our array so what's the\nproblem well for now we're going to say\nwe don't find our find\nthree so we add one to our hash map the\nindex of this one is one and now we move\nto the next element five we check does\nfour minus five it's four minus five\nexists in our hash map that's negative\none so no it does not then we add this\nfive to our hash map and it's index\nwhich is two and we move to the last\nvalue in the array three we checked this\nfour minus three e\nexists in our hash map now that's one so\nwe see it does exist right right over\nhere it exists the value exists and it's\nindex is one so now we found our two\nvalues that sum to the target and we\nwant to return their indexes their\nindices which are going to be one and\nthree so with this algorithm we don't\nhave to initialize our hash map it can\nbe initially empty and then we can just\niterate through this array in one pass\nnow the reason the algorithm can work in\nthat way with just one pass is this so\nlet's say we had a giant array right we\nknow for sure that there are two\nelements in this array that sum to our\ntarget right we don't know where they\nare they're at some arbitrary location\nwhen we visit the first one of those\nelements our hash map is only going to\nbe this portion of the array it's only\ngoing to have the values that came\nbefore the first value so we're gonna\nwe're gonna notice that the second value\nthat can sum to the target is no is not\ngoing to be in our hash map yet but once\nwe get to the second value our hash map\nis going to be this portion so every\nvalue that comes before this right so\nwe're gonna be guaranteed that once we\nvisit the second element that sums up to\nthe target we're gonna be guaranteed\nthat the first one is already in our\nhash map so we're guaranteed to find the\nsolution now since we only have to\niterate through the array once and we're\nadding each value to our hash map which\nis a constant time operation and we're\nchecking if a value exists in our hash\nwhich is also a constant time operation\nthe time complexity is going to be Big O\nof n we are using extra memory right\nthat hash map isn't free so the memory\ncomplexity is also going to be O of n\nbecause we could potentially add every\nvalue to the hash map\nso now let's code the solution so\nremember we need a hash map right I'm\ngoing to call this previous map because\nit's basically every element that comes\nbefore the current home that every\nprevious element is going to be stored\nin this map where it can be mapping the\nvalue to the index of that value\nso now let's iterate through every value\nin this array we need the index as well\nas the actual number so let's do it like\nthis and Python before we add this to\nour map let's check if the difference\nwhich is equal to target minus n now\nlet's check if this difference is\nalready in the hash map if it is then we\ncan return the solution which is going\nto be a pair of the indices so I can get\nthe first index like this and the second\nindex is just AI now if we don't find\nthe solution then we have to update our\nhash map so for this value n I'm gonna\nsay the index is I and then we're going\nto continue since we're guaranteed that\na solution exists we don't have to\nreturn anything out here right but I'll\njust put a return for no reason now\nlet's see if it works and it works\nperfectly so with this kind of neat\nlittle trick but just doing it in one\npass you can reduce the amount of code\nyou have to write and not have to worry\nabout like edge cases and comparisons\n"
    },
    {
        "Name": "Group Anagrams",
        "NcLink": "anagram-groups/",
        "Pattern": "Arrays & Hashing",
        "Description": "Given an array of strings `strs`, group all *anagrams* together into sublists. You may return the output in **any order**.\n\nAn **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\n**Example 1:**\n\n```java\nInput: strs = [\"act\",\"pots\",\"tops\",\"cat\",\"stop\",\"hat\"]\n\nOutput: [[\"hat\"],[\"act\", \"cat\"],[\"stop\", \"pots\", \"tops\"]]\n```\n\n**Example 2:**\n\n```java\nInput: strs = [\"x\"]\n\nOutput: [[\"x\"]]\n```\n\n**Example 3:**\n\n```java\nInput: strs = [\"\"]\n\nOutput: [[\"\"]]\n```\n\n**Constraints:**\n* `1 <= strs.length <= 1000`.\n* `0 <= strs[i].length <= 100`\n* `strs[i]` is made up of lowercase English letters.\n",
        "Difficulty": "Medium",
        "Video": "vzdNOK2oB2E",
        "PythonSolution": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ans = defaultdict(list)\n\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord(\"a\")] += 1\n            ans[tuple(count)].append(s)\n        return ans.values()\n",
        "Transcript": "hey everyone welcome back now let's\nwrite some more neat code today so today\nlet's look at a good\nquestion to practice the fundamentals\ngroup anagrams\nso we're given just a list of strings\nand we want to group\nall anagrams together so for example we\nhave tan\nand we have nat and they are anagrams\ntogether\nso in the output we're gonna group them\ntogether\ninto one sub-list and how do we\nknow these two are anagrams of each\nother the first one\nis tan the second one is na\nand you see if we swap the n and the t\nthen we get we get tan right\nand that's the same as this so by\nrearranging\nthe characters we can get equivalent\nstrings so these two are equal\nso another way of looking at it is two\nstrings\nare anagrams of each other if we take\neach of them and sort them right so if\nwe sort both of these\nwe're gonna get ant right for both of\nthem\nbecause that's the sorted version so if\nthey're anagrams of each other\nwhen they are sorted they should be\nequal right so\nso one way to group anagrams together\nwould be to take\neach one of these strings in the input\nand then sort them\nbut the time complexity of that is going\nto be\nn log n where let's just say n\nis the average length of each of the\ninput strings\nso that's how much it takes to sort each\nof the strings\nand we have to do that m times where\nlet's say\nm is the length of\nhow many like basically how many input\nstrings were given in the first place\nso you can see that this is going to be\nthe overall time complexity\nso my question is can we do better than\nthis and actually\nthe simple solution in this case happens\nto be more efficient and let me show you\nthat solution right now so one also\ncondition that we're given\nis that each character is going to be\nfrom lowercase a\nto lowercase z so at most we have 26\nunique characters right so let's just\nhave\nan array called count so for\neach one of these strings we want to\ncount\nthe characters from a to z\nright how many does it have of each so\nwe know it has\none e one a and it has\none t and for this one\nwe would see that the exact same thing\nis true it has one e one a\nand one t so if we use a data structure\ncalled a hash map in this case and in\nthis case\nour key is going to be\nthis over here so this is what we can\nuse to\nidentify anagrams and then our value is\ngoing to be the list\nof anagrams so in this case how many\nstrings or which strings have\nthis pattern of count one e\none a and one t well we see there's one\neach there's one t and there's one last\none\na so those are gonna be the values we'll\nhave a list of them\ne t and then a right so we'll have three\nstrings\nand as you can see in the output it's a\nlittle messy but that's what we have\nhere right so these three\nare grouped together so we're going to\nuse a hash map\nto group them together since all we're\nand since we're using a hash map and all\nwe're doing is counting\nthe characters of each and\nwe know that we have a limit of 26\nlowercase characters\nthe overall time complexity is gonna be\nbig\no of m where m\nis the total number of input strings\nthat we're given\ntimes n where n is the\naverage length of a string because we\nhave to\ncount how many of each character it has\nso we're gonna have to go through\nevery single character in a string and\nsince we\nare using count right or this array\nin our hash map we're using it as a key\nin our hash map we kind of also have to\nmultiply this by 26\nbecause that's what's going to be the\nlength of our count array\nbut you know that this reduces anyway so\nthe actual time complexity is big\no m times n\nso now let's code it up as you can see\nthough this is basically one of those\nproblems that can be solved\nwith a hash map very efficiently so\nlet's create our hashmap we'll call it\nresult and so remember what we're doing\nis we're mapping\nthe character count of each string\nand we're mapping that to the list\nof anagrams so to do that we of course\nhave to go through every string that\nwe're given in the input\nand we want to count how many of each\ncharacter it has so we'll have\ninitially a array so it's we're going to\nhave\n0 in it we're going to have 26 zeros\nright because\none for each character so from lowercase\na\nall the way to lowercase z\nand now we want to go through every\nsingle character\nin each string and we want to count how\nmany of each character so we want to map\nin this case a to index 0\nand we want to map z to index 25 so how\ncan we do that well we can\none way at least is just take the ascii\nvalue of the current character we're at\nc and then subtract the ascii\nvalue of lowercase character\na so as you can see lowercase a\nminus lowercase a is going to be 0 z\nlowercase z minus lowercase a is going\nto be 25 so\nwe do have it correctly because for\nexample let's just say\na is ascii value 80 and i don't know if\nthis is actually correct but it's just a\nrandom value then\nb is going to be ascii value 81 and so\non\nbut if we want to map this to zero\nwe know one way to do that is take 80\nminus 80.\nif we want to map lowercase b to 1\nwe can take 81 minus 80 right\nso that's basically what i'm doing here\nin case you haven't seen something like\nthis before\nand so we're just going to increment\nthis by one\nwe're just counting how many of each\ncharacter we have and now\nin our result we want to\nadd so for this particular count\nwe want to add we want to append\nwe're going to append this string s\nso we want to group all anagrams with\nthis particular\ncount together now what if this count\ndoes not exist\nyet well i'm actually going to change\nthis dictionary to\na default dictionary or a default\nhashmap\nwhere the default value is a list so we\ndon't have to deal with one edge case\nand also right now our count is a list\nbut we know in python lists cannot be\nkeys so we're actually just going to\nchange this to a tuple\nbecause tuples are non-mutable\nbut mainly this is python stuff you\nmight not have to worry about this\nin other languages and so that's\nactually it\nso now in our dictionary we have grouped\nthe anagrams together so we just can\ntake\nresult.values we don't want the keys\nanymore we just want to return\nthe values the anagrams grouped together\nso we can\nreturn that and we're actually finished\nso this\nis the optimal m times n solution\nwhere m is the number of strings we're\ngiven and\nn is the average length of each string\nhow many characters are\nin each string so i hope this was\nhelpful if it was please like and\nsubscribe it supports the channel a lot\n"
    },
    {
        "Name": "Top K Frequent Elements",
        "NcLink": "top-k-elements-in-list/",
        "Pattern": "Arrays & Hashing",
        "Description": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements within the array.\n\nThe test cases are generated such that the answer is always **unique**.\n\nYou may return the output in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,2,3,3,3], k = 2\n\nOutput: [2,3]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7,7], k = 1\n\nOutput: [7]\n```\n\n**Constraints:**\n* `1 <= nums.length <= 10^4`.\n* `-1000 <= nums[i] <= 1000`\n* `1 <= k <= number of distinct elements in nums`.\n",
        "Difficulty": "Medium",
        "Video": "YPTqKIgVk-k",
        "PythonSolution": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        freq = [[] for i in range(len(nums) + 1)]\n\n        for n in nums:\n            count[n] = 1 + count.get(n, 0)\n        for n, c in count.items():\n            freq[c].append(n)\n\n        res = []\n        for i in range(len(freq) - 1, 0, -1):\n            for n in freq[i]:\n                res.append(n)\n                if len(res) == k:\n                    return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\ntop k frequent elements i really like\nthis problem because it's pretty\nclever and once you figure it out the\ncode is really easy to write\nso we're given an input array nums and\nan\ninteger k and we want to return the k\nmost frequent elements that appear in\nthe array nums\nwe can return the answer in any order so\nfor example we have this\ninput array three ones two twos\nand a single three and we wanna return\nthe two most\nfrequent elements right so we know that\nthe most frequent is of course\none it appears three times so we add a\none to the output\nthe second most frequent is two so then\nwe add a 2 to the output and that's all\nwe want now if\nif k was 3 of course we'd add the last\nelement\nk is never going to be greater than the\ndistinct number of elements in the input\narray so that's good for us\nand our input array is always going to\nbe non-empty so for example for each\nvalue right we're going to\ncount how many occurrences it has so for\nexample one\noccurs three times two occurs\ntwice and three occurs once\nand then we can take this basically this\nlist of pairs right then we can sort it\nin ascending order right so\nbasically it's already sorted in\nascending order right because the most\nfrequent is here\nthe second most frequent is here the\nthird most frequent is here right\nnow of course sorting it in the worst\ncase right basically\nif every single value in here was\ndistinct and we wanted the top k\ndistinct values\nwe'd get a time complexity of n log\nn right but we don't necessarily need to\nsort the entire thing because\nwe only want the top k frequent elements\nso in another solution we could actually\nuse\na max heap so we would still do this\nwhole operation where we count the\nnumber of occurrences of each value and\nthen we'd add each pair\nto our max heap and the key of this max\nheap would\nof course be the number of occurrences\nright so the count right\nand then we'd pop from our heap exactly\nk times so why is this more efficient\nwell we know popping\nfrom the heap well first of all we when\nwe initialize our heap we're going to\nadd this entire set and there's a\nfunction called\nheapify i think that can do that in\nactually\nlinear time so big o of n time so that's\nthe good thing and of course we know\nwe're only going to be popping from the\nheap\nk times each pop is going to take log n\nand we're going to be doing that k times\nright so that's going to be\nk times log n right so that's a little\nbit better than\nn log n at least as long as k is\nless than n right but it turns out that\nthere's actually an\neven better solution there's actually a\nsolution that can be done\nin o of n time linear time\nso big o of n time and big o of n memory\nbut we are still going to be using this\nexact\na technique where for each value like\none we count the number of recurrences\nlike three so this problem can actually\nbe solved in linear time if you use the\nalgorithm called\nbucket sore so when you first think of\nbucket sort this is probably what you're\ngoing to think of\nthe way bucket sort is usually taught is\nthat for each value for example 1\nwe're going to take an input array right\nthis is our input array this\nthis row is the indices the index of the\narray and this is actually going to be\nthe value so for example for one\nwe're going to go to the posit the index\none and in the value we're gonna put\nokay one occurs exactly once now we're\ngonna see a second one we're gonna say\none occurs twice right basically we're\ngoing to go through the input array\ncount how many times\neach value occurs and then in our input\narray\nput that count for that index right map\nthe value to the index and then put the\ncount of that value so 1 occurs 3 times\n2 occurs twice 100 in this case occurs\nonce now this algorithm would be\nlinear time if our input values right\nwere bounded for example if we knew for\na fact that every value\nwas between 1 and 10 then we would know\nthat the size of our input array is also\ngoing to be 10 right but in this case\nthe values are unbounded right like this\ncould have been\na million and then the size of our input\narray would have been a million even\nthough the total\ninput array size is only six right we\nhave six elements\nbut then that array where we actually\nstore the buckets\nsort values is going to be unbounded\nright and also we want the top k\nelements this still isn't very clear of\nwhere exactly the top k\nelements are actually going to be so in\nthis case this type of bucket sort\ndoesn't work but there's another way\nwe can do it so in this case you can see\nfor our\nfor our array where we're going to be\ndoing the bucket sort the index\ni was using the each value in the\ninquiry for example you know one was\nbeing mapped to index one right and\nthere we were storing the count\nthere's actually another tricky way that\nyou can do it that will lead us to a\nlinear time solution\nso if we're pretty clever this is what\nwe're going to do\nfor the index we're actually going to be\nmapping\nthe accounts of each value and in the\nvalues we're actually going to have a\nlist of which values have exactly\nthis particular count for example\na hundred right we know that a hundred\noccurs\none time so what we're gonna do is for\nthis position\none we're gonna say okay this value\noccurs only once a hundred a hundred\noccurs one single time which value\nfor another value in our input array 2\nwe see it occurs exactly twice right we\ncan count that with a hash map pretty\neasily\nand then we'll say okay this value\noccurs twice so in the position\n2 index position 2 of our array we're\ngoing to add that value 2.\n2 is the value that occurs twice we see\na\nlast distinct value in our input array\n1. we count it occurs exactly three\ntimes so in this position\nindex 3 we're gonna say okay there's a\nvalue a single value a one\nthat occurs three times now it's\npossible maybe we had a third\nthree right maybe two occurs three times\nin that case\nwe would actually have multiple values\nin this position right but in this case\nwe can see one occurs three times two\noccurs twice\n100 occurs once so they're all going to\ngo in separate positions\nand then you know once we've taken every\nsingle input value and then\nand counted how many times each value\noccurs and then put it in the\nappropriate spot in this array what are\nwe going to do well\nwe want the top k values right the\nvalues that occur\nthe top k values that occur most\nfrequently right so what are we going to\ndo we're going to start at this\nend of the array we want all the values\nthat occur\nsix times why are we stopping at six\nthough why don't i extend this array\nfarther right seven\neight a hundred right why did the\nindices stop at six\nnotice something about our input array\nour input array is\nsize six right so that means if every\nsingle\nvalue in the input array was the exact\nsame the\nmost number of times a value could occur\nwould be exactly\nsix time so the cool thing about this in\nabout this new array that we're creating\nis it's bounded\nby six or well technically six plus one\nbecause we do have a zero but that's not\nactually necessary\nbut it's basically it's proportionate to\nthe size of the input array right so\nso you know when we're scanning from\nright to left or\nhowever we do it we're only going to be\ndoing that we can scan through the\nentire thing in linear time\nnow in this case we see six there's no\nvalues that occur six times so we can't\nfind our top k element\nin that position we'll try the same\nthing with five\nfive no values occur five times four\nno values occur four times three oh a\nsingle value we're going to go through\nevery\nvalue in this array there's only a\nsingle value in this case\nbut we do see a 1 occur so to our result\nwe want the top k values\nthe top k occurring values we are going\nto add a 1 to that\n1 occurs most frequently in the input\narray so\nwe add one to our result we need one\nmore because i think we were looking for\nthe top\ntwo values k in this case is going to be\ntwo so now we're going to go here which\nvalues occur\ntwice a single value and that value is\ntwo\nso we're going to add that to our output\narray so now we've gotten the top two\nvalues\nand then we can return this array now\nwhy is this linear time again\nbecause remember the max size that this\narray could possibly be is going to be\nabout equal to the size of the input\narray right because we could have a\nvalue for example one could occur six\ntimes in that case we'd have\none over here now what if every single\nvalue in the input array was distinct\nright that's another extreme what if we\nhad one\ntwo three four five six\nin that case this position would be\nempty because no values occur six times\nno values occur\nfive times four times three times or two\ntimes\nevery one of these six values would go\nin\nthis position at index one reason being\neach one of these occurs exactly once so\nin that case we'll have\nall six values concentrated over here\nand that's still going to be linear time\nbecause yes we are going to be iterating\nthrough this entire input array which is\ngoing to be big o\nof n and then we're going to add another\nbig o of n\nto that right big o of n plus big o of n\nbecause we're going to have to iterate\nthrough six values in exactly one\nposition\nso that's still technically linear time\nnow we are creating this\nuh array to help us and we're also going\nto be needing a hash map to\ncount the occurrences of each value in\nthe input array so the memory complexity\nis also going to be big o\nof n with that being said let's jump\ninto the linear time code it's pretty\neasy once you can identify this\ntrick so we are going to use a hash map\nto count the occurrences of each value\nor also\nthe array the special array that's going\nto be the same size as the input array\nabout\nis going to be called frequency\nbasically you know\nthe index is going to be the frequency\nof an element or the count of an element\nand the value is just going to be the\nlist of\nvalues that occur that particular many\nnumber of times\nso i'm going to have an empty i'm going\nto initialize this as an empty array\nthe number of empty arrays that go in\nthis is going to be about\nthe size of our input plus one\nso now i'm just going to go through\nevery value in nums and just count how\nmany times it occurs so for count of\nthis particular end value we're going to\ndo\n1 plus what its current count is count\ndot\nget n now if n doesn't already exist in\nour hash map or dictionary\nwe're just going to put a default value\nof zero so this will return zero if it\ndoesn't exist but this is\nhow we're going to be counting the\nnumber of times each value in nums\noccurs\nnext we're going to be going through\neach value that we counted so\nn c in count\ndot items because that's going to return\nthe key value pair every single key\nvalue pair that we added to\nour dictionary and for every key value\npair for every number\nand count i want to change the free i\nwant to in the frequency array i want to\ninsert so for this particular\ncount remember the count is what's going\nto be the index so\nat index count we're going to append to\nthat list\nthis value n what we're saying is this\nvalue\nn occurs exactly c number of times\nand once we've done this we've basically\ninitialized everything we need to so now\nwe're going to have our\nresult output right we want the top k\nelements so\n4 and so we're going to be iterating\nthrough this array frequency in\ndescending order right because we want\nto start with the numbers that occur\nmost frequently so for i\nin range length of frequency\nminus one which is the last index and\nwe're going to go all the way\nup until zero and we're going to be\ngoing in descending order so we're going\nto put a negative 1 as the decrementer\nand we're going to go through every\nvalue so for every let's say\nn value in frequency at this index\ni because we know everything inserted in\ni is actually another sub list so it\ncould be empty or it could have some\nvalues whatever it does so let's say\nn is non-empty then we're going to go\nahead and take that\nend value and append it to our result\nbecause we're basically getting the end\nvalue that occurs\nmost frequently now when are we going to\nstop at some point our result\noutput is going to be the exact same\nsize as k\nbecause we're guaranteed to have at\nleast k values in our input array so\nonce that happens\nonce if the length of result is matching\nexactly k\nthat's when we can go ahead and return\nresult we know this is\nguaranteed to execute at some point so\nwe don't have to put a return statement\noutside of the loop\nand that is the entire code so we could\nhave solved this problem\nin decent time if we used a heap it\nwouldn't be too bad k\nlog n i think that's a doable solution\nbut with this kind of neat trick\nwe can do this in big o of n time and i\nhope that you did learn something maybe\na little about\na little bit about bucket sort this\nproblem definitely taught me something\nwhen i first solved it\nand i know many people have been\nrequesting problems and i'm trying to\nget\nto all those requested problems as\nquickly as i can so i hope it was\nhelpful\nif it was please like and subscribe it\nsupports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Encode and Decode Strings",
        "NcLink": "string-encode-and-decode/",
        "Pattern": "Arrays & Hashing",
        "Description": "Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.\n\nPlease implement `encode` and `decode`\n\n**Example 1:**\n\n```java\nInput: [\"neet\",\"code\",\"love\",\"you\"]\n\nOutput:[\"neet\",\"code\",\"love\",\"you\"]\n```\n\n**Example 2:**\n```java\nInput: [\"we\",\"say\",\":\",\"yes\"]\n\nOutput: [\"we\",\"say\",\":\",\"yes\"]\n```\n\n**Constraints:**\n* `0 <= strs.length < 100`\n* `0 <= strs[i].length < 200`\n* `strs[i]` contains only UTF-8 characters.\n",
        "Difficulty": "Medium",
        "Video": "B1k_sxOSgv8",
        "PythonSolution": "class Solution:\n    \n    def encode(self, strs: List[str]) -> str:\n        res = \"\"\n        for s in strs:\n            res += str(len(s)) + \"#\" + s\n        return res\n\n    def decode(self, s: str) -> List[str]:\n        res = []\n        i = 0\n        \n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            i = j + 1\n            j = i + length\n            res.append(s[i:j])\n            i = j\n            \n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem in code and\ndecode strings so you can tell the\ninterface is a little bit different this\ntime and that's because we are going to\nbe solving this problem on lint code\nbecause this is a premium leak code\nproblem and we can solve it for free on\nthe website lint code and also this is a\nproblem from the blind 75 list a list of\n75 common leak code questions that we've\nbeen tracking on this spreadsheet the\nlink to this will be in the description\nif you want to take a look and we're\npretty much done with the main problems\ni'm going to be solving another one\ntoday a premium one in code and decode\nstrings this is a pretty decent problem\nto understand so let's get into it so\nit's a bit of a design algorithm because\nwe're going to have two different\nfunctions that we want to implement so\nwe're given a list of strings and we\nwant to write two functions we want to\nencode this list of strings into a\nsingle string and you can kind of see\nthat down here we were given an input\nlist of strings lint code love you and\nwe want it to be a single string such as\nthis one in the bottom right and then\nthe d code is just going to be the\nopposite of in code we're going to be\ngiven a single string and we want to be\nable to convert this string in into back\ninto that original list of strings that\nwe were given and it's up to us on how\nwe want to design this algorithm but the\ntricky part is going to be that where\nthe basic assumption is that in our\ninput we could have any possible\ncharacter in the inputs not just limited\nto lowercase a to z so the difficult\nthing is going to be how do we create\nsome kind of delimiter between each word\nhow do we know when one word ends and\nanother word begins that's kind of what\nwe're going to be focusing on so let's\nget into that solution so suppose we\nwere given two strings like this neat\nand code and we want to convert it into\nanother string basically into a single\nstring right so a naive way would be\nsomething like this right just say okay\nneat code now the problem is okay we did\nthat the encode was fine but now we want\nto decode this back into the two\noriginal strings that we had but there's\nno way for us to determine right because\nwe can't remember where one word ends\nand another word begins right so we need\nto have some kind of uh character or\nsomething to separate words what if we\nused a pound sign or something right\nsomething like this or any character\nmaybe a question mark or something right\nbut this is like our special character\nthat's what's going to separate words\nfor us so in this case it works out\nright we'll go character by character in\nthe input once we get to a pound sign\nokay we'll say that this word ends so\nwe'll say okay we have\nthe first word neat and this is not\nincluded in any of the words so we skip\nit and then we get to the remaining\nportion code and there aren't any more\npound signs so that works out in this\ncase right but basically our assumption\nwhen we're using this pound sign is that\nthe pound is never going to actually\nshow up in any words what happens if we\nhave a word suppose in our word code in\nthe middle of the word we have a pound\nsign right there's no reason why we\ncan't have something like this so in\nthat case when we when we take this and\nencode it we're gonna get something like\nthis as the encoded string right and\nthen when we split it we're gonna have\nthree different words neat co and d e\nbut in the original you can see we only\nhad two words but when we get our output\nwe're gonna end up splitting this into\nthree words which is not what we wanted\nto do right we want to transform it back\ninto what was originally given to us so\nhaving just a single special character\ndelimiter is not going to work because\nthat delimiter could actually show up in\nsome of the words wouldn't it be nice if\nin the encoded string we somehow already\nknew how many characters would go in the\nfirst word how many characters would go\nin the second word etc etc so then we\ncould just say okay let's take the first\nfour characters encode it back into the\nfirst word then take the next five\ncharacters and code it into the second\nword so how could we you know do\nsomething like that well one way would\nbasically be by maintaining some kind of\narray right when we're given this uh\ninputs a list of strings and we want to\nencode it to a single string we can for\nevery single word basically have an\ninteger right the first word is four\ncharacters the next word is five\ncharacters etc but then where are we\ngonna store this list because you know\nthis is a valid solution if we're\nstoring this list somewhere but\nbasically in the description they don't\nwant us to store any kind of state\nvariable this encode and decode needs to\nbe stateless so when we have this list 4\n5 we cannot store it in a separate data\nstructure is it possible for us to store\nit in the string itself how about when\nwe're encoding this we want to know okay\nstarting at the beginning here how many\nof these characters are going to be in\nthe first word well why not just put\nthat number at the beginning right 4 at\nthe beginning of this encoded string\nthat works because then we can look at\nthe beginning transform it into an\ninteger but one thing is what if the\nword itself had some integers in it well\nnow we need another delimiter right\nwe're gonna have our integer always at\nthe beginning there's always going to be\nan integer at the beginning the string\nis always going to start with an integer\nthat integer is going to represent what\nthe length of the following word is\ngoing to be but we're going to have a\ndelimiter in between the integer and\nbetween the word itself\nso basically we're going to read each\ncharacter until we reach the delimiter\nand once we reach the delimiter we're\ngoing to take all the characters that we\njust read which are going to be\ntransformed into an integer so this 4 is\ngoing to be mapped to four and then\nwe're going to count the next four\ncharacters after the delimiter which in\nthis case is going to be pound and that\nworks because we're only going to read\none delimiter we're always gonna we're\ngonna expect a single pound sign no\nmatter what right so even if the first\ncharacter here was a pound it still\nworks because we're gonna read an\ninteger four read a single pound sign\nand then say okay take the next four\ncharacters even if they include pound\neven if they included some integer like\neight or you know six or something right\nif they include integer pound it doesn't\nmatter because this tells us how many\ncharacters are going to be in the first\nword and then once we read those four\ncharacters what are we going to expect\nto be next well we're going to expect\nsome word but we want to know how long\nthat word is going to be so we're going\nto do exactly what we just did over here\nhaving an integer followed by a pound\nsign and we're going to put that same\nthing over here so in this case we're\ngoing to have a 5 and a pound sign\nbecause the next word is going to be\nfive characters long so this is kind of\nhow we're storing the integers inside of\nthe encoded string so that we know how\nto decode it we know how long each of\nthe strings is going to be so i hope\nthis makes sense now i'm going to show\nyou how to actually code it up by the\nway the overall time complexity of\nencode and decode is going to be of n\nwhere n is going to be the total number\nof characters given to us in the list of\nwords so with that being said we are\nready to get into the code okay so now\nlet's get into the code you can see the\ninterface is a little bit different yes\nwe are doing this on lint code rather\nthan leak code because it's free on\nthere so let's start with the encode\nfunction it's a little bit easier so\nremember we're given a list of strings\nand we want to encode it into a single\nstring how are we going to do that well\nwe're going to go string by string in\nthe input and to the result we want to\nappend this encoded string s how are we\nencoding it again well remember we're\ngoing to take the length of the string\nand you know this the length of the\nstring is going to be an integer but we\nwant to transform that into a string so\nlet's do that in python pretty easily\njust like this\nplus\nwe want to add the delimiter to the\npound sign so we have the length of the\nstring followed by the delimiter pound\nsign followed by the string itself s so\nthen you know this is kind of the format\nthat we agreed upon this is how we're\ngoing to be encoding it because it's\ngoing to be easy for us to decode this\nas well so we're going to do this for\nevery single string in the input add it\nto the result and then we can go ahead\nand return that result so encode was\npretty straightforward d decode is going\nto be a little bit more tricky but we\nknow the rules that we can follow so\nthis time we're given a single string a\nsingle encoded string which is going to\nbe you know encoded using the function\nthat we just wrote so how are we going\nto decode it into a list of strings in\nthis case our result is going to be a\nlist of strings and i'm also going to\nhave a pointer i which is going to tell\nus what position that we're at in the\ninput string so far so i'm going to just\niterate character by character so while\ni is still in bounds we are going to\nread character by character basically\ndecoding each string so when we start\noff the first position that we're going\nto be at is going to be an integer right\nso what we want to do is we want to find\nthe delimiter we want to find the end of\nthe integer so we're going to have a\nsecond pointer j initially it's going to\nbe at i and while the characters the\ncharacter at\npointer j is not equal to the pound\nmeaning that we're still at an integer\ncharacter we're going to keep\nincrementing j by 1. and we're\nguaranteed to find a pound character\nright because we that's kind of how we\nencoded it up above so we're going to\nkeep incrementing until we get to that\npound character and then once we get to\nthe pound character we know that our\ninteger the length of the following\nstring is going to be from our string\nstarting at index i going all the way up\nuntil index j but not including index j\nright so that's this portion is going to\nbe the integer right now it's a string\nso we want to uh transform it into or\nconvert it into an integer we can do\nthat in python pretty easily just like\nthis so now this length variable tells\nus how many following characters we have\nto read after j in order to get every\ncharacter of the string so in other\nwords if we start string at index j plus\n1 because remember j is at the delimiter\ncharacter so j plus one is going to be\nthe first character in the string itself\nand we want to go all the way until the\nend of that string how do we get that\nwell right now we have the length of\nthat string so we can say j\nplus 1 plus length this will give us the\nentire string and what do we want to do\nwith the string well we want to append\nit to the result so let's go ahead and\ndo just that so basically each iteration\nof this loop is gonna read one entire\nword and then we're gonna go again loop\nagain and read more words until we reach\nthe end of the string but one thing we\nforgot is how are we gonna update our\npointer i well we just read a single\nword so now we want to start at the next\nword how do we get that well our pointer\ni is just going to be set to j\nplus 1 plus length because this is\nactually not this is going to be\nbasically the beginning of the next\nstring or it could be the end of the\nentire string right but either way this\nis how we are going to be updating our j\neach iteration of the loop once we're\ndone with that our result will be\ncontaining all the decoded strings so we\ncan go ahead and return that result\nand as you can see i just ran the code\nand it looks like it works and it is\npretty efficient so i hope that this was\nhelpful let me hide that so i hope that\nthis was helpful if it was please like\nand subscribe it supports the channel a\nlot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Product of Array Except Self",
        "NcLink": "products-of-array-discluding-self/",
        "Pattern": "Arrays & Hashing",
        "Description": "Given an integer array `nums`, return an array `output` where `output[i]` is the product of all the elements of `nums` except `nums[i]`.\n\nEach product is **guaranteed** to fit in a **32-bit** integer.   \n\nFollow-up: Could you solve it in $O(n)$ time without using the division operation?\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,4,6]\n\nOutput: [48,24,12,8]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [-1,0,1,2,3]\n\nOutput: [0,-6,0,0,0]\n```\n\n**Constraints:**\n* `2 <= nums.length <= 1000`\n* `-20 <= nums[i] <= 20`\n",
        "Difficulty": "Medium",
        "Video": "bNvIQI2wAjk",
        "PythonSolution": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * (len(nums))\n\n        for i in range(1, len(nums)):\n            res[i] = res[i-1] * nums[i-1]\n        postfix = 1\n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nproduct of array except itself so this\nis another problem from the blind 75\nlist as you can see it's over here\nproduct breaks itself so i'm going to be\nadding that video solution today\nand we're getting one step closer to\nhaving every problem in this entire list\nfilled out\nso for this problem we're given an input\narray of integers\nnums and we want to return an output\narray for every single number that we're\ngiven\nwhere for each value in the input array\nnums we're basically multiplying\nevery single number except that value\nand then returning that as the result\nfor example in this example you can see\nwe're given\n1 two three four so for example for this\nvalue\none we would want to return the\nmultiplication the product of\nevery other value so for these three\nvalues the product would be two times\nthree times four\nthat's going to be 24 so for the first\nvalue in the output we're going to put\n24.\nsimilarly for the second value we want\nto multiply every value in nums except\nfor this value so that's going to be 1\ntimes 3 times 4 that's going to be 12\nso the second value in the output array\nis going to be\n12. now the hard part about this problem\nis basically the restrictions that they\ngive us\nso we have to solve this problem in big\no\nof n time and we have to do it without\nusing the division\noperator it would be really easy if we\ncould use the division operator\nbecause what we could basically do is\ntake the product of\nall of these values and then and we know\nthat would basically be 24 so if we\nwanted\nthe first value so if we wanted 24 we\nwould take\nthis total product and divide it by one\nright that would give us 24 if we wanted\nwhat the second value would be\nwe would take the entire product 24\nwhich would be all of this\nand then divide it by 2 which would give\nus 12\nwhich would be over here right because\nthe division is basically\ntaking the entire product of the entire\nthing\nwithout multiplying by this dividing\nthis\nwould do exactly that but we are not\nallowed to use the division operator\nso if we wanted the product of every\nvalue in here except\nthe three one way we can break it down\nis basically get the product of\nevery value before three in the input\narray\nand get every and get the product of\nevery value\nafter three in the array and then\nmultiply these\ntwo values together and then that's\ngoing to give us\nuh the value that we would want to put\nin this position in our\nresult so it would be helpful for us if\nwe want to do that for every single\nvalue in the input array if we basically\njust compute the\nthe prefix product for every single\nposition in the input array right and\nthen put it\nin a prefix array and since we're also\ngoing to be wanting the product of\nvalues\nafter it would also be helpful if we\ncomputed the postfix\nproduct of every single position in the\nentire input array right and we can\ncompute both of these\nin big o of n time it's a pretty simple\nalgorithm right we basically start\nat the first position okay this is going\nto be one so\nif we're adding this value we're just\ngoing to take the previous value and\nmultiply it by two so this is going to\nbe two\nsimilarly we're gonna take two multiply\nit by three we're gonna get six here\nfour multiply it by six we're going to\nget 24 here\nand for post fix we're basically going\nto do the exact same thing and do it in\nreverse order so here we would get four\nhere we would get three times four here\nwe would get two times 12\nand then here we just get one times 24\nwhich is just going to still be 24.\nnow for every single values for example\n1 we would want\nthe prefix of every value before it now\nsince\nthere are no values before we can just\nsay okay the prefix for that is just\ngoing to be a default value of 1 to keep\nit neutral\nand so we'd also want the postfix of\nevery value that comes after it\nwe can get that in the position to the\nright\nof 1. so we'd want to multiply those\ntogether so 1 times 24. so in the output\nfor this we would get 24. that makes\nsense because if you multiply\nall these together except for this one\nwe do get 24 and then we just repeat the\nexact same process\nfor every value so over here we'd want\nthe prefix of the values that come\nbefore it\nand we'd want the postfix of the values\nthat come after it\nso 1 times 12 is just going to be 12\nthat's going to be the output\nagain repeat the same thing for here the\nprefix is 2\npostfix is 4. we're going to get 8 as\nthe output that makes sense if you take\n24\nif you take every value in here multiply\nit except for three we do get eight\nand similarly for this four we'd want\nthe prefix six and the postfix there are\nno\nso we just assume that there's a one\nover here so six times one\nthis would be the output so this is a\nvery valid solution this is a big of n\ntime solution we're not using any\ndivision operator\nbut the downside is this is also big o\nof n memory\nbut we can actually use this idea\nbecause what they tell us is the output\narray does not count\nas extra memory so we actually don't\nneed these\nprefix and postfix arrays because we can\ncompute these\nand we can compute these prefixes and\npostfixes\nand then store them in our output array\nand\nthat is going to end up making things\neasier for us because we're not going to\nhave to use this extra postfix prefix\nmemory so what we're going to do is\nwe're going to do two passes on our\ninput array nums\nfirst we're going to start at the\nbeginning and then go all the way to the\nend\nbasically computing every single prefix\nfor the input array and then storing\nthe prefix so for example the prefix of\nthis is going to be stored\nover here right because that that prefix\nis needed to compute\nuh the result for this position and so\nat that point what we're going to say is\nevery prefix is going to be\nin the output basically the prefix over\nhere is going to be stored\nin the second position the prefix over\nhere is going to be stored here the\nprefix from this is going to be stored\nhere and remember how for the first\nposition there is no prefix so we're\ngoing to put a default value of 1 over\nhere\nand then after that we're going to do a\npass going from the end to the beginning\ncomputing every post fix so for example\nthis post fix\nand then in the result we're already\ngoing to have the prefix stored over\nhere\nthis prefix right the first two values\nis going to be stored over here so what\nwe're going to do is we're going to take\nthis prefix and multiply it by whatever\nis in this position\nthat's what's going to give us the\nresult that we want for this position\nso let's start off so so far the prefix\nthat we're going to be\nat is just going to be the default the\ndefault value of one so we're going to\nput a one over here\nthen we're going to multiply it by what\nvalue comes over here\none times one is going to stay one so\nwe're going to leave our prefix as it\nis now we're going to be at the second\nposition so what we're going to do is\ntake our prefix\nof which it basically tells us the\nprefix up until this point we're going\nto take that and then put it in the\noutput\nso 1 is going to be here and then we're\ngoing to take the value that we just\nreached multiply by the prefix so now\nthe prefix is going to be\na 2. so now we're going to be at the\nthird position so what we're going to do\nis take our prefix up until\nthis point and go ahead and put it in\nthe output\nso 2 is going to be placed in the output\nthen we're going to take the 3 and then\nmultiply it by 2 that's going to give us\na 6\nfor the prefix so far so at this point\nwe're going to take our prefix\n6 it tells us the prefix up until this\npoint so we're going to take it put it\nin the output\n6 is going to be put in the last\nposition then we're going to multiply 4\nby 6 which is going to give us 24\nbut that value 24 is not going to be put\nanywhere because\nclearly we have run out of room to put\nit so we don't need to store it in the\noutput\nso now we've visited every single value\nfrom the beginning to the end computing\nthe prefixes and then putting them in\nthe output array\nso now we're going to start at the end\nand go to the beginning\nand do the exact same thing except we're\ngoing to be doing post fixes which are\nbasically\nstarting from the end of the input array\nand computing the products\nonce again the post fix is initially\ngoing to be set to 1\nso what we're going to do is take the 1\nwhich tells us the post fix up until\nthis point basically an\nempty thing and that makes sense because\nfor this value 4 we would want the\nprefix of it as well as the postfix\nbut there is no postfix so that's just\ngoing to be a one so we can take that\none\nmultiply it by six so six is going to\nstay the same so that's gonna be the\nresult value\nfor this position but then we're gonna\ntake four and multiply it by the one in\nour postfix so\nfour four so our postfix is now going to\nbe four\nso we visited this position now we're\ngoing to be at this second position so\nwe're going to take our postfix\nwhich tells us the postfix up until this\npoint and then multiply\nby the two that's in this position so 4\ntimes 2\nis going to give us an 8 for the output\nvalue\nthen we can take this value 3 multiply\nit by\nour 4 which is going to give us a 12. so\nnow we visited this value\nnow we're at the next value two so we're\ngoing to take our postfix up until\nthis point multiply it by the one that's\nhere so this is now going to be a\n12 and we can also take the two and\nmultiply it by 12 which is going to give\nus 24\nwhich tells us the postfix up until this\npoint which is going to be useful for us\nbecause we know that if we want to get\nthe product\nfor this position we're going to need\nthat postfix so we can take that postfix\n24\nmultiply it by the one that's over here\nso this is just going to be a\n24 now and you know that's the entire\nresult so we basically did the exact\nsame thing that we did with our prefix\nand post fix arrays but this case we did\nit without\nusing the extra memory and we ended up\narriving at the exact same result\nso it was linear time complexity big o\nof one memory complexity now let's jump\ninto the code\nso the first thing we're going to do is\ncreate a result output array so this\ntechnically does not count as extra\nmemory in the context of this problem\ni'm just going to give each position an\ninitial value of 1\nand we want this to be the length of the\ninput array so\nwe can multiply it by the length of nums\nso first we're going to be doing the\nprefixes so i am going to initialize\nprefix as 1 and then we're going to go\nthrough every position\nin our input array so for each position\nin our result output array i\nwe're going to take that prefix and then\njust put it in\nthat position i right and then after\nwe've done that is when we're going to\ntake\nthe posit the input array value nums\nof i and multiply it by whatever the\nprefix happens to be so prefix is just\ngoing to be\nmultiplied by this value so that's how\nwe're going to be computing the prefixes\nas we iterate through the input array\nnums\nand we're going to be storing the\nprefixes in the result output array\nafter we've done that we're going to do\nthe exact same thing with the postfix\narray\nwell almost the exact same thing so\nwe're going to start at the\nend of the input array\nand then go up until the beginning and\nthat's how you can do this in python\nand so in this case the result of i\nwe're not just going to be simply\nstoring the postfix value because we\nknow that would end up\noverwriting in the result whatever the\nprefix we stored was what we're going to\nbe doing with the postfix is we're going\nto be multiplying it\nby the value that's already in results\nbecause that's\nsimply multiplying the prefix and the\npostfix together\nonce we've done that we know we do have\nto continuously update the postfix so\nwith postfix we're just going to\nmultiply it by whatever value\nhappens to be in the input array nums\nand once that is done we're actually\ndone with the entire problem then we can\njust return the output array\nresult so this is pretty much the most\nefficient\nway to solve this problem as you can see\nbest memory complexity best time\ncomplexity as well so i hope this was\nhelpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Valid Sudoku",
        "NcLink": "valid-sudoku/",
        "Pattern": "Arrays & Hashing",
        "Description": "You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:\n\n1. Each row must contain the digits `1-9` without duplicates.\n2. Each column must contain the digits `1-9` without duplicates.\n3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.\n\nReturn `true` if the Sudoku board is valid, otherwise return `false`\n\nNote: A board does not need to be full or be solvable to be valid.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)\n\n```java\nInput: board = \n[[\"1\",\"2\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\"],\n [\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\".\",\"3\"],\n [\"5\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"4\"],\n [\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"5\"],\n [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\"],\n [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"8\"],\n [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: board = \n[[\"1\",\"2\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\"],\n [\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\"9\",\"1\",\".\",\".\",\".\",\".\",\".\",\"3\"],\n [\"5\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"4\"],\n [\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"5\"],\n [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\"],\n [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"8\"],\n [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput: false\n```\n\nExplanation: There are two 1's in the top-left 3x3 sub-box.\n\n**Constraints:**\n* `board.length == 9`\n* `board[i].length == 9`\n* `board[i][j]` is a digit `1-9` or `'.'`.\n",
        "Difficulty": "Medium",
        "Video": "TjFXEUCMqI8",
        "PythonSolution": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        squares = defaultdict(set)  # key = (r /3, c /3)\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                if (\n                    board[r][c] in rows[r]\n                    or board[r][c] in cols[c]\n                    or board[r][c] in squares[(r // 3, c // 3)]\n                ):\n                    return False\n                cols[c].add(board[r][c])\n                rows[r].add(board[r][c])\n                squares[(r // 3, c // 3)].add(board[r][c])\n\n        return True\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem valid sudoku and\ni'm going to be recording this on the\n4th of july so hopefully there aren't\ntoo many firework noises in the\nbackground so we are given a 9x9 sudoku\nboard and all we want to do is determine\nif the board in its current state is\nvalid or not\nand they tell us only the filled in\ncells need to be validated according to\nthe three rules of sudoku so basically\neach row must only contain digits\nbetween 1 through 9 without repetition\nthe same is true for every single column\nin this board it can only contain digits\n1 through nine without repetition that\nmeans we can't have duplicates in any\nparticular row or any particular column\nand the third part which is going to be\nthe most tricky is each three by three\nsub box basically you know you can kind\nof see it in the drawing right three by\nthis entire nine by nine grid is made up\nof nine three by three grids right\nthere's one here one here one here and\nyou know basically nine of them as you\ncan see so basically for each of these\nthree by three\nsub grids we also want to check that it\nonly contains digits one through nine\nwithout repetition basically without\nrepetition that means it has to contain\nevery single digit from one through nine\nnow of course the sudoku board doesn't\nnecessarily have to be filled in you can\nsee this 3x3 is not filled in but in\nthis case we are going to say ok this\nthis one is valid because it you know it\nonly has a 6 and it doesn't have any\nduplicates right but we do we don't only\nhave to check each 3x3 grid we also have\nto check every single column and every\nsingle row now before i get into the\nsolution let me just very quickly\nclarify what this problem wants from us\nyou might over complicate it and think\nsomething like this what if we had a row\nsuch as this one it has one two three\nfour five six seven eight that must mean\neven though this spot is empty that must\nmean a nine has to go here right that's\npretty obvious but take a look at this\ncolumn it has two three four five six\nseven eight nine that must mean that the\nvalue that goes here has to be a one so\nwe have a contradiction we have to\neither put a 1 or a 9 but we know that\nboth need to be in this position so in\nthis case this is not a valid sudoku\nboard right well that's technically true\nbut for this problem we are going to\nconsider this board yes it's valid\nbecause\nas of right now based on what the cells\nare filled in like what cells are filled\nin there aren't any contradictions we're\nnot going to assume anything for any of\nthese empty positions even though we\nknow for sure yes a 9 would have to go\nhere based on this row we're not going\nto assume that so it's actually a little\nbit easier than you might think so the\nalgorithm is going to be pretty standard\nright we're going to go through every\nsingle row and make sure every\nparticular row does not have any\nduplicates how could we do that we could\ndo it a bunch of different ways but i'm\ngoing to do a hash set right so a hash\nset will be easy for us to detect if\nthere are any duplicates so we're going\nto have a unique hash set for every\nsingle row in the entire grid right so\nthen we can easily determine if any\nparticular row has any filled in\nduplicates right this row obviously\ndoesn't a five a three and a seven no\nduplicates right so that portion is\npretty easy right number one is pretty\neasy to check what about number two\nchecking each column we can do the exact\nsame thing just have a hash set for\nevery single column right every single\ncolumn has a hash set and then we can\ndetermine if there are any duplicates or\nnot right and for you know adding an\nelement to the hash set is of one\nchecking duplicates is also o of one so\nso far we have a time complexity for\njust checking the columns and the rows\nwe have a time complexity which is\nbasically the size of the entire grid\nwhich is nine squared pretty much now\nthe last part in theory should also be\npretty easy but coding it up is a little\nbit more tricky there are many ways to\ndo it i'm going to show you the easiest\nway we want to be able to tell okay for\nevery three by three grid which there\nare nine of does any of them have any\nduplicates so again we can use a hash\nset to represent each of these three by\nthree grids but the question is how are\nwe gonna do it how can it be easy to\ncode something like that and that's what\ni'm gonna quickly explain to you right\nnow and after i do we can jump into the\ncode the overall solution is yes though\ngoing to be o of n 9 squared we're\npretty much just going to have to\niterate through over the entire grid and\nnothing else but we are going to have\nextra space also of 9 squared because\nwe're going to have three hash sets\nwhich are going to be this exact size so\nroughly this is the memory complexity as\nwell so we want to represent each of\nthese three by three grids with a hash\nset but how do we know if we're at any\nparticular value right like i have\nlabeled the indices right this is going\nto represent what row this is going to\nrepresent which column how do we know if\nwe're if any particular value such as 1\n1 happens to be in this 3 by three grid\nwhereas a different\ncell such as four four happens to be in\nthis three by three grid how can we\ndifferentiate them\nnotice how each of these three by three\nsub squares happens to be three by three\nright so one way is to basically make it\nso that we can\nhave an index right so maybe zero\nrepresents this row of of the three\ndifferent squares right and a 1\nrepresents this row of 3 squares and a 2\nrepresents a row of this right and\nsimilarly for the columns right a 0 over\nhere represents this column a 1 over\nhere represents this column and a 2 over\nhere represents this column then if we\nhad two indices right if we can somehow\ntake 4 4 and convert it to 1\n1 then we know it goes inside this sub\nsquare right so basically we have nine\ndifferent sub squares we're gonna have\nindices to represent them right a one\none means that this is the sub square\nthat we're talking about right this one\nand the way the math is going to work\nout is since each of these is three by\nthree we can just take the actual index\nsuch as four let's say we were given\nfour four right this is the square we're\ntalking about we can take four which is\nthe row divide it by three integer\ndivision right we're talking about\ninteger division 4 divided by 3 is going\nto give us a 1. similarly we do the same\nthing with the column right 4 divided by\n3 is going to give us a 1. right so if\nwe take the actual coordinates 4 4\ndivide the coordinates integer division\nby three then we get the index for the\nrow column and it basically identifies\nwhich square this is a part of now let's\njust check that the edge cases work out\nlet's try a8 right this is the boundary\nwhat happens if we take 8 divided by 3\nand 8 divided by 3 right well then we\nget 2 2 right integer division we always\nround down 2 2 that works out for us\nright let's do a different edge case\nmaybe we try this this square right on\nthe boundary does this\ndoes this identify zero zero because\nthat's what it should well let's take\nthe positions the indices two two divide\nthem by three two divided by three two\ndivided by three we round these down so\nwe get 0 0 that does uniquely identify\nor it you know correctly identifies that\nit belongs to this 3x3 grid so that's\nkind of how we're going to identify when\nwe go through every position every cell\nin the entire sudoku board which of the\nthree which of the three by three uh\ngrids is it a part of and then we can\nand then we can add them to that right\nso we're gonna have a hash set where the\nkey of the hash set is going to be a\npair of values the row column not the\nactual row column right but the you know\nwhen we convert it to the row column\nbasically row divided by three and\ncolumn divided by three that's what the\nkey of the hash hashmap is going to be\nand the value is similarly going to be a\nhash set where we can tell do we have\nany duplicates in this 3x3 grid or not\nright same for every single 3x3 grid\nwe're just checking does it have any\nduplicates if not then we can continue\nif it does have a duplicate that means\nour sudoku board is not valid and then\nwe would have to return false but if it\nis valid we're just going to continue so\nwe're basically going to go over the\nentire grid right every single uh\nposition in the entire grid if we find\nany duplicates we return false if we\ndon't at the end we can return true so\nnow we have enough information to\nactually write out the code so let's do\nthat okay so now we can write the code\nlike i mentioned i'm going to be\ndetecting duplicates with a hash set but\nyou could do it with arrays if you\nwanted to as well because we know the\ndimensions of this sudoku board it's\nnine by nine but i'm going to be using a\nhash set or dictionary just because it's\neasier so\nin this case i'm actually using a hash\nmap where the uh key is just going is\ngoing to be the column number and the\nvalue is going to be another set\nbasically the set is going to represent\nall particular values in this column and\nwe're going to do the same thing for\nrows this is only so we can detect\nduplicates so let's create another\nuh hash map\nwith rows and another hash map with the\nsquares and remember the key for the\nsquares is going to be a pair of values\nbasically the row divided by three and\nthe\ncolumn divided by three so now we just\nwant to iterate over the entire grid\nand we know the dimensions are nine by\nnine so i'm just going to hard code that\nin to these loops and so we know that a\nposition in the sudoku board actually\ncould be empty and they tell us that an\nempty position is represented by a dot\nso the first thing we're going to check\nis if this is an empty space then we can\njust skip it right then we're just going\nto continue to the next iteration of the\nloop the next thing we want to check is\nhave we found a duplicate because if we\nhave then we return false immediately so\nwe want to know does this this uh value\nif it's not empty it has it already been\ndetected so if the board is in\nrows at this current row what does this\nmean we're saying okay the current row\nthat we're in\nbasically this is our hash map right\nrows is our hash map the key we're\nputting in is the current row that we're\nin so that's so this basically\nrepresents a hash set as you can see up\nabove a set a hash set of all values\nthat occur in this particular row number\nso if so so basically if this uh this\ncurrent number that we're at is already\ninside the current row meaning we've\nalready seen this value before in the\ncurrent row that we're in that means\nit's a duplicate right in which case we\ncan return false but that's not it\nbasically the exact same thing is going\nto be true\nif this value has already occurred in\nthe same column before so we're going to\nchange this to columns at the current\ncolumn that we're at so if this value\nhas already occurred in the current\ncolumn then we're in that we're in that\nmeans we've detected another duplicate\nin which case we can return false and\nlast but not least we have to check if\nthis value has already occurred in the\ncurrent square that we're in before so\nhow do we get the current square that\nwe're in uh right now well\nwe we know the key for that is going to\nbe a pair of values basically as i wrote\nabove rho divided by three and column\ndivided by three so that tells us the\ncurrent square that we're in and this\nwill return a set as you can see up\nabove of all the values that we have\nseen in the current square before and if\nthis value that we're at right now is a\nduplicate that means it's already going\nto be in this this hash set in which\ncase we can also return false so this is\nbasically our way of validating that\nthis current sudoku board is valid if we\nhave any duplicates that means it's not\nvalid we return false if it is valid we\ncontinue and we basically update all\nthree of our hash maps up above so\ncolumns of the current column we're\ngoing to add to it the current character\nthat we just saw and we're going to do\nthe same thing with the current row that\nwe're in and we're going to do the exact\nsame thing with the current square that\nwe're in of course this has a pair of\nvalues as the key so this makes sure\nthat our hash sets are updated and we'll\nmake sure to detect any duplicates when\nwe get to the next iteration of the\nloops so in this way we're iterating\nover the entire board and if we never\ndetect any duplicates then we can\noutside of the loop just return true\nthat means the current sudoku board with\nthe current values populated and it is\nvalid as you can see the solution runs\nand is pretty efficient so i hope this\nwas helpful this is one of the easier\nways the more neat ways of writing this\ncode of course there are some more\ncomplex ways as well but i think this is\nfairly readable and the main you know\nthe trick that we use is just this whole\nrow divided by three column divided by\nthree which just makes the code a lot\neasier in my opinion so i hope that this\nwas helpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Longest Consecutive Sequence",
        "NcLink": "longest-consecutive-sequence/",
        "Pattern": "Arrays & Hashing",
        "Description": "Given an array of integers `nums`, return *the length* of the longest consecutive sequence of elements.\n\nA *consecutive sequence* is a sequence of elements in which each element is exactly `1` greater than the previous element.\n\nYou must write an algorithm that runs in `O(n)` time.\n\n**Example 1:**\n\n```java\nInput: nums = [2,20,4,10,3,4,5]\n\nOutput: 4\n```\n\nExplanation: The longest consecutive sequence is `[2, 3, 4, 5]`.\n\n**Example 2:**\n\n```java\nInput: nums = [0,3,2,5,4,6,1,1]\n\nOutput: 7\n```\n\n**Constraints:**\n* `0 <= nums.length <= 1000`\n* `-10^9 <= nums[i] <= 10^9`\n",
        "Difficulty": "Medium",
        "Video": "P6RZZMu_maU",
        "PythonSolution": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n\n        for n in numSet:\n            if (n - 1) not in numSet:\n                length = 1\n                while (n + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest\n",
        "Transcript": "let's all eat code 128 longest\nconsecutive sequence this is a pretty\ninteresting problem and it's actually\nbeen asked by a lot of companies\nincluding Google for a coding interview\nso I think it's a good problem to\nunderstand so we're given an input array\nof numbers right in this case we have\nsix numbers and we want to find the\nlongest consecutive sequence in this\ncase the longest consecutive sequence is\none two three four right\nit doesn't matter what order of the\nnumbers appear in and the input array we\njust want to know the longest\nconsecutive sequence that we can make\nfrom the input array now the most\nobvious way to solve this problem is\njust by sorting right so if you look at\nthe sorted array over here we have\nobviously one consecutive sequence of\nlength four right one two three four\nthey're all consecutive numbers we also\nhave another one that's length one just\n100 and we have the last one that's also\nlength one just 200 right now this is\ndefinitely a valid solution we can\ndefinitely code this up but the time\ncomplexity is going to be o n log n so\nthe question is can we do better so this\nis a leak code hard obviously the\nsolution wouldn't be this simple so we\ncan do better but how do we get there\nnow the first thing to do is try to\nvisualize the problem in a way that it\nmakes the problem really easy to\nunderstand so I visualized the problem\nby drawing out an imaginary number line\nright so we can kind of see what the\nsequences actually look like this makes\nit a lot easier to recognize the\npatterns so we know we have one sequence\nthat starts at one two three and four we\nhave another sequence that comes after\nit with just one number 100 we have the\nlast sequence with also only one number\n200 so just by looking at it we can tell\nwe have three distinct sequences right\nthat's something to recognize now by\nvisualizing it we can kind of try to\napproach how would a human solve it well\nthe easiest way is just look at each of\nthe sequences right and count how long\nthey are\nso let's look at the first sequence\nright we have one two three and four so\nthis sequence has four numbers in it we\nhave the second sequence just 100 so it\nonly has one number in it so it's a\nsequence of length 1 the last one is\nalso a sequence of length 1 now this is\nso easy to solve when you visualize it\nand try to approach it how a human would\nbut can we actually convert this into\ncode somehow the answer is yes so the\nmost important thing to notice is that\nwe have three sequences but how can we\nidentify what makes a sequence how can\nwe actually start at the beginning of a\nsequence the thing to notice and this is\nreally easy when you actually look at\nthe picture that each sequence has a\nstart value the start value in this case\nthe start value for the first range or\nthe first sequence has no left neighbour\nthe first value 1 has no left neighbour\nright that's really obvious look at the\nsecond range 100 it doesn't have a left\nneighbour the third range 200 doesn't\nhave a left neighbour so we can get the\nstart of each sequence by just looking\nat our entire array of numbers right and\nfiguring out which numbers don't have a\nleft neighbour so meaning if we were if\nwe wanted to check if one had a left\nneighbour we would check does our array\ncontain the number 0 if we wanted to\nknow if 100 have had a left neighbour we\nchecked does the array contain 99 the\neasiest way to do this and the most\nefficient way to do it is by taking our\ninitial array and converting it into a\nset so now to find the start ranges\nlet's start iterating through our array\nso we got we get to the first element\n100 does it have a left neighbour well\nwe can check our set it doesn't have 99\nin it so this is the first so this is\nthe start of a sequence so let's get the\nlength of the sequence we start at 100\nnow to get the length of the sequence we\nwant to count how many consecutive\nnumbers come after 100 so we want to\nknow does 101 exist in our sequence\nlooking at the number line obviously it\ndoesn't\nhow can we check this efficiently with\ncode well we already have a set that\ntakes up this entire array so let's just\nuse our set to check if 101 exists since\nit doesn't we can no longer continue\nthis sequence so now we go we get to the\nnext number for is for the start of a\nsequence let's look at our picture we\ndrove for is not the start of a sequence\nand we can check this using our set we\nwould check that it does have a left\nneighbor right three so it's not the\nstart of a sequence we're not going to\nmake a range from it we get to the next\nnumber 200 is this the start of a\nsequence looking at our picture yes it\nis and we know that 199 does not exist\nlet's try to make it as long as we can\nwe check this 201 exists no it doesn't\nwe can tell that from our picture and we\nwould use the set to determine that so\nnow we'll this is as long as we can make\nthis set so let's get to the next number\none is one the start of a sequence at\nour picture we can tell one does not\nhave a left neighbor so what is the\nstart of a sequence now let's check if\ntwo exists in our set it does so we can\nmake this sequence a little bit longer\nnow let's check if the next number three\nexists in our set yes it does so let's\nmake it even longer now does four exist\nnow let's check if five exists in our\nset it doesn't right there is no there\nis no 5 so we can't make this sequence\nany longer so now let's continue through\nthe array 3 is to read the start of a\nsequence no it's not it has a left\nneighbor too now let's try 2 this 2 is\nto the start of a sequence it's not\nbecause it has a left neighbor 1 so we\nwent through the entire array we created\nall the sequences we could the first\nsequence is length 1 the second sequence\nis also length 1\nthe third sequence is length 4 so this\nis the longest sequence now we took a\nreally complicated problem or seemingly\ncomplicated and we broke it down so\neasily all we had to do is\niterate through the initial array use a\nset and check if I've nodes had values\nhad left neighbors and if they didn't\nthen they were the start of sequences we\nmade this problem so easy with only\nusing one data structure since we only\nhad to iterate through the entire array\nand we had to expand each range we know\nthat we're only going to visit each\nnumber at most twice so our solution is\nvery efficient and we did have to use an\nadditional memory to create a set\nbecause we wanted to check if neighbors\nexisted so we so for the memory\ncomplexity it is also Big O of N in this\ncase n is the size of the input array so\nnow let's get to the code so we remember\nwe need to create a set from the initial\narray nums\nso it's really easy to do that in Python\nwe can just pass their D array into a\nset constructor next we want to keep\ntrack of what the longest consecutive\nsequence is initially we can say it's 0\nso we want to iterate through every\nnumber in the number Rea and we want to\ncheck if it's the start of a sequence\nand we can check that simply by checking\nif n minus 1 does not exist in our num\nset if this number doesn't have a left\nneighbour that means the start of a\nsequence so now we want to get the\nlength of the sequence initially we can\nsay the length is 0 and we want to keep\ngetting each consecutive number and\nchecking if it exists in our num set if\nit does then we can keep expanding the\nlength so initially I'm going to check n\nplus lengths because that's going to\ncheck the current number initially\nlength is 0 so we're just checking the\ncurrent number as it as the length grows\nwe'll check more consecutive numbers at\nthe end we could have potentially found\nthe longest sequence so we want to\npotentially update our longest by just\ntaking the max of the current length we\njust computed as well as what the\nlongest originally was\nand it's really that simple so now all\nwe have left to do is just return what\nthe longest subsequence was that we just\ncomputed so we did this in such a small\namount of code now let's just run it to\nsee that it works and it works perfectly\nso this is a linear time solution in a\nlinear memory complexity solution once\nwe visualize the problem the solution\n"
    },
    {
        "Name": "Valid Palindrome",
        "NcLink": "is-palindrome/",
        "Pattern": "Two Pointers",
        "Description": "Given a string `s`, return `true` if it is a **palindrome**, otherwise return `false`.\n    \nA **palindrome** is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.\n\n**Example 1:**\n\n```java\nInput: s = \"Was it a car or a cat I saw?\"\n\nOutput: true\n```\n\nExplanation: After considering only alphanumerical characters we have \"wasitacaroracatisaw\", which is a palindrome.\n\n**Example 2:**\n\n```java\nInput: s = \"tab a cat\"\n\nOutput: false\n```\n\nExplanation: \"tabacat\" is not a palindrome.\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `s` is made up of only printable ASCII characters.\n",
        "Difficulty": "Easy",
        "Video": "jJXJ16kPFWg",
        "PythonSolution": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n\n        while l < r:\n            while l < r and not self.alphaNum(s[l]):\n                l += 1\n            while r > l and not self.alphaNum(s[r]):\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l, r = l + 1, r - 1\n        return True\n    \n    def alphaNum(self, c):\n        return (ord('A') <= ord(c) <= ord('Z') or \n                ord('a') <= ord(c) <= ord('z') or \n                ord('0') <= ord(c) <= ord('9'))\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more new code today so today\nlet's solve the problem valid palindrome\ni'm actually going to be solving this\ntwo different ways and i think both ways\nare definitely going to be helpful to\nknow in an interview setting before we\nstart i just want to quickly mention\nthat this problem is actually a part of\nthe blind 75 list of questions and\nluckily we have actually solved the vast\nmajority of the blind 75 questions i\neven have a playlist of all of these\nquestions in the description if you want\nto take a look and of course we will be\nfinishing one more today getting one\nstep closer to 100 completion of blind\n75 so we are given a string s all we\nwant to do is determine if it's a\npalindrome uh if it is we can return\ntrue if it's not we return false uh only\none catch is that we are only\nconsidering alphanumeric characters in\nthe list and we are ignoring cases by\nignoring cases they mean upper and lower\ncase so in the input string you can see\nthe leftmost character is capital a the\nrightmost character is lowercase a both\nof these characters are considered the\nsame so if we had a string an input\nstring like big a lower a this string\nitself is a palindrome so we do return\ntrue even though one is uppercase and\none is lowercase we are ignoring the\ncases of the characters uh and also when\nthey say we're only considering\nalphanumeric characters basically it\nmeans we can ignore everything that's\nnot an alphanumeric character what is\nalphanumeric basically everything from\nuppercase a to uppercase z everything\nfrom lowercase a to lowercase c and\neverything from zero all the way to nine\nright every character and every digit so\nbasically in this input string it might\nnot look like a palindrome initially but\nthe answer is yes true it is a\npalindrome because and actually before\nwe even get into that what is a\npalindrome if you don't remember well\nbasically the easiest way to check if a\nstring is a palindrome is basically if\nit reads uh the same way as it does when\nit is reversed meaning if the string is\nthe exact same even after it's been\nreversed so for example a b a if we\nreverse this string it's still a b a so\nit is a palindrome right so and let's\ntake this string if we reverse it is it\nstill the exact same basically if we\nread it in reverse order and the answer\nis yes let's just compare a few\ncharacters initially let's start at the\nbeginning right a uh and remember we're\nignoring case so when i say ignoring\ncase i'm just going to basically convert\nit to lowercase so everything is just\ngoing to be lower okay so we have an a\nokay next character is a space character\nbut remember we're only considering\nalphanumeric so we don't even consider\nthe space we want to skip that space so\njust delete it right\nnext character m\nand then next character a next character\nn so we just took this from the\nbeginning of the string a man right so\nlet's start at the end of the string uh\nwe have a lowercase a right and then we\nhave a lowercase m then we have a\nlowercase a then we have lowercase n so\neven starting at the end of the string\nit looks like it's the same as the\nbeginning when we read it in reverse and\nit turns out that if we you know take\nthis string and remove\nall the spaces all the special\ncharacters and then convert everything\nelse to lowercase and then we reverse it\nit will be the exact same string and\nthat's the approach i'm going to be\ntaking i'm just going to be removing i'm\ngoing to be filtering all the useless\ncharacters from this keeping the\ncharacters that we want and then\nconverting them to lowercase then\nreversing the string and then checking\nif it's still equal so now let's get\ninto the coding solution at least the\nfirst coding solution okay so now let's\ncode it up and remember we're going to\nbe building the new string which is just\ngoing to be removing all the\nnon-alphanumeric characters from the\ninput string so this solution is kind of\nthe cheating solution where i'm going to\nbe using a lot of built-in functions and\nextra memory as well so we're going to\njust iterate through every single\ncharacter in the string s if that\ncharacter is alphanumerical and the good\nthing is python and actually i think\nmost uh libraries most languages like\njava have a built-in function to check\nif a character or a string is\nalphanumerical python at least does so\nwe're checking if this character is\nalphanumerical if it is we want to\ninclude it in the new string so we're\ngoing to go ahead and take that\ncharacter and add it to the new string\nbut one thing you don't want to forget\nis we want to make sure that every\ncharacter is lowercase so before we add\nit to the new string we want to make\nsure that it is lowercase so we'll\nconvert it to lowercase and then we're\ndone with that we have the new string we\nremoved all the other characters from it\nnow we just want to check if it is the\nexact same when it has been reversed\nso we're just going to take this new\nstring compare it to the reversed string\nwhich in python you can do like this\nby you know this is the syntax for\nreversing a string so if they are equal\nthen we can return true if they're not\nequal this will return false which is\nwhat we want to do to determine if it's\na palindrome so now let's run the code\nand make sure that it works as you can\nsee on the left yes it does work but\nthere are some deficiencies with the\nsolution that maybe your interviewer\nwon't want you to use maybe they won't\nwant you to use this alphanumerical\nfunction and they want you to implement\nit yourself and maybe they don't want\nyou to use extra memory clearly we use\nextra memory by building the new string\nand we actually used extra memory over\nhere when we reversed the string we\ncreated a new string that was the\nreversal of the original so let's see\nhow we can actually improve this\nsolution okay so now let's see how we\ncan actually solve this problem with\nconstant extra memory without using\nextra memory without creating a new\nversion of this string and the main way\nis going to be by using pointers so\nwe're going to have two pointers a left\npointer and a right pointer because\nremember there are multiple ways to\ncheck if a string is a palindrome we\ndon't have to reverse it we can just\ncompare the left character and the\nrightmost character if they're equal\nthen we shift the pointers in the left\npointer comes here and the right pointer\ngoes here and then we can continue to\ncheck to make sure that the characters\nare equal if they're not equal then we\nreturn but how do we know when to stop\nwell we're going to keep incrementing\nthe left pointer and we're going to keep\ndecrementing the right pointer until\neventually they meet in the middle or\nthe left pointer you know passes the\nright pointer right the left pointer\nbecomes here and the right pointer is\nover here that's how we know when we can\nstop or maybe they will meet\nexactly at the same character if the\nlength of the string happens to be odd\nokay so that's actually pretty simple\nnot too bad so what are we gonna do okay\nleft is here right is here this is\ncapital a but of course we're gonna\nconvert it to lowercase this is\nlowercase a so they're equal right okay\nso then right pointer is gonna be\ndecremented by one so the right pointer\nis going to be over here at the m\ncharacter left corner is going to be\nincremented by one and it's going to be\nhere well we're at the space character\nbut remember we want to ignore spaces we\nwant to ignore everything except for\nalphanumerical characters and can we try\nto do this without using a built-in\nfunction well let me show you how we can\nkind of do that basically i did some\nquick googling and we're actually going\nto use ascii values to determine if a\ncharacter is alphanumerical basically\nwhat you need to know is that each\nsymbol\nyou know ascii symbols is 128 of them\nand lowercase and uppercase english\ncharacters happen to have an ascii value\nassociated with them you can see the\ninteger 0 has an ascii value associated\n48 uh integer 1 has 49 integer 2 has 50\nso they are contiguous all the way down\nto integer 9 which is at 57. so that's\nimportant and we also have uppercase a\nstarting at 65 going all the way down\nto 90. they are contiguous as well and\nthen eventually we can get to lowercase\nstarting at 97 going all the way down to\n122. these are contiguous as well using\nthis information in pretty much every\nlanguage you can write your own\nalphanumerical character detecting\nfunction and i'll show you how to do\nthat in a few minutes but for now just\nassume that we do have our own\nalphanumerical function and our left\npointer is over here what do we want to\ndo we don't really want to compare this\ncharacter with the character m on the\nright side do we because we want to skip\nthis character so how do we skip it well\nwe can create a while loop\nso while our left pointer is not\nalphanumerical then we're gonna\nincrement left right we're gonna do left\nplus plus we're gonna keep incrementing\nleft while it is not a alphanumerical\ncharacter because we want to ignore uh\ncharacters that are not alphanumeric so\nwe're gonna increment left one more time\nnow luckily it is a alphanumerical\ncharacter it's the character m so we\ncompare left and right they're exactly\nthe same so we continue with our\nalgorithm we uh decrement r over here\nincrement left over here right now\nthey're both at the same character and\nwe're going to continue the algorithm so\nthat's the main idea i won't run through\nthis entire string because it's pretty\nlong but eventually the strings will\nmeet in the middle for example over here\nsomewhere maybe at that point we'll see\nokay they're at the same character and\nthen we'll say we can stop our algorithm\nwe've determined it is a palindrome and\nthen we can return true so now let me\nshow you how to code it up the benefit\nof this solution it is still a linear\ntime algorithm it's still big o of n\nbecause we have to iterate through the\nentire string but the memory complexity\nis big o of one because we're not using\nany extra memory in this case okay so\nnow let's get into the code first thing\ni'm going to do is write our alpha\nnumerical function so\nit's going to take in a single parameter\njust going to take in a character and\nthen we're going to determine if that\ncharacter is alphanumeric or not how can\nwe determine that well i was using the\nascii values a moment ago right i was\ntalking about them so in python you can\nget the ascii value of a character uh\nusing the ord function we just want to\nknow that the ascii value of this\ncharacter if it is an uppercase\ncharacter how can we check that well as\ni showed you a moment ago ascii values\nare contiguous for uppercase characters\nright so from uppercase a to uppercase z\nuh they're contiguous so if the ascii\nvalue of the c character of whatever\nthis character happens to be is between\nthe ascii value of uppercase a and\nuppercase z that means it's an uppercase\ncharacter so that's good good so far\nright that's progress for now we can\ncheck that this is an uppercase\ncharacter but we want to check if it's\nalphanumeric so we have to extend this\nidea so how about we say okay that or\nsecond condition i'm actually just going\nto copy and paste this because it's\ngoing to be similar we want to check if\nit's a lowercase character right because\nthat's the next thing is it uppercase or\nis it lowercase we can do that by taking\nthe ascii values of the lowercase a and\nlowercase z and last it could be a digit\nfrom zero to one or zero to nine\nactually so let's do that same thing\nright starting at zero is in between\nzero or uh the integer nine if any of\nthese is true this will be true so\nbasically we've determined if it's an\nalphanumeric or not that will that's\nwhat this condition will be so we can go\nahead and return this so if it is\nalphanumeric of course this will return\ntrue if it's not alphanumeric this will\nreturn false okay so we got our helper\nfunction out of the way now let's\nactually write the algorithm as i showed\nin the drawing we're going to have two\npointers left and right left is gonna\ninitially be at zero right is initially\ngoing to be all the way at the right\nside so the length of the string minus\none and remember we want to continue the\nalgorithm we want to check if it's a\npaundrome while the left pointer is less\nthan the right point the pointers have\nnot met each other yet or crossed each\nother and so now we get to the point\nwhere we actually want to compare the\ncharacters so we want to take the\ncharacter at position left and the\ncharacter at position right and if\nthey're not equal we want to return\nimmediately right because if we find a\nsingle pair that's not equal then we\nknow it's not a palindrome so we can\nreturn false immediately\nbut did we forget about anything well\nthe first thing we forgot about is we\nwant to make sure to only compare the\nlowercase versions of each character so\nlet's convert this to lower and convert\nthis to lower\nso that's good we're so if one of these\nis upper case one of them is lowercase\nwe're still good but did we forget about\nanything else well we never called our\nalphanumeric function right what if one\nof these is not an alphanumeric\ncharacter well we can't have that right\nwe shouldn't allow that to happen so\nbefore we even execute this if statement\nlet's make sure both characters at left\nand right are alphanumeric so while it's\nnot alphanumeric so for example while\nthe character at position left is not\nalphanumeric what do we want to do well\nwe want to increment that left pointer\nright so we can uh plus 1 to this but\none thing we want to make sure is that\nthe pointer never goes out of bounds so\nlet's just add a checks to make sure\nleft is less than right for example this\nwill make sure that of course it never\npasses the other pointer and it'll also\nmake sure that the pointer doesn't go\nout of bounds and we want to make sure\nto do the exact same thing\nfor the other position as well for the\nright pointer so\nmake sure that right is greater than\nleft and\nthe character at the position right is\nif it's not alphanumeric then what do we\nwant to do we want to decrement the\nright pointer by one instead of\nincrementing but but both of these while\nloops will make sure that both\ncharacters are alphanumeric before we do\nthe comparison which is what we wanted\nto achieve so\nthen this will return false if it's not\na palindrome if the entire loop finishes\nthat must mean that the string is a\npalindrome so then we can just go ahead\nand return\ntrue oh and actually one more thing\nbefore i forget\nafter we do do the comparison we want to\nupdate our left and right pointers right\nwe want to compare the next position so\nto the left pointer we're going to\nincrement it by one to the right pointer\nwe're going to decrement it by one so\njust moving to the next position to do\nthe next comparison on the next\niteration of the while loop so now this\nis the entire code so let's just run it\nto make sure that it works okay i was\ndumb in python if you want to call\nanother function inside of an object you\nhave to use the self keyword so let's\ntry that one more time and as you can\nsee on the left yes it does work but\nit's actually slightly less efficient\nthan the other solution even though the\nbig o time complexity is the exact same\nand the memory complexity of the\nsolution is actually better than the\nother one this is no extra memory needed\nas you can see so i really hope that\nthis was helpful if it was please like\nand subscribe it really supports the\nchannel a lot consider checking out my\npatreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Two Sum II Input Array Is Sorted",
        "NcLink": "two-integer-sum-ii/",
        "Pattern": "Two Pointers",
        "Description": "Given an array of integers `numbers` that is sorted in **non-decreasing order**.\n\nReturn the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.\n\nThere will always be **exactly one valid solution**.\n\nYour solution must use $O(1)$ additional space.\n\n**Example 1:**\n\n```java\nInput: numbers = [1,2,3,4], target = 3\n\nOutput: [1,2]\n```\n\nExplanation:\nThe sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.\n\n**Constraints:**\n* `2 <= numbers.length <= 1000`\n* `-1000 <= numbers[i] <= 1000`\n* `-1000 <= target <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "cQ1Oz4ckceM",
        "PythonSolution": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l < r:\n            curSum = numbers[l] + numbers[r]\n\n            if curSum > target:\n                r -= 1\n            elif curSum < target:\n                l += 1\n            else:\n                return [l + 1, r + 1]\n",
        "Transcript": "what solve leak code 167 to some to so\nwe're given an input array that's\nalready sorted in ascending order and we\nwant to find two numbers that sum up to\nsome target that we're also given so in\nthis case the target is nine the two\nnumbers that sum up to nine in this\narray are two and seven and we want to\nreturn the indices of these two values\nbut the catch here is that the indexes\nare one based they're not zero based so\nthe first element has index 1 the second\nelement has index 2\nI don't know why exactly they did that\nin this problem it's kind of weird but\nthey did for some reason we're also\nguaranteed that there's exactly one\nsolution and we can't use the same\nnumber twice so in this example that\nthey gave us the two numbers the two\nfirst numbers sum up to the target so\nthat's not really a good example so I'm\ngonna look at my example over here that\nI drew so the first idea that might come\nto your mind is just look at every\nsingle combination of two numbers so\nlet's say we're starting at the first\nnumber one let's look at every number\ncombined with one and see if it can sum\nup to the target nine so first we check\n1 plus 3 that is 4 so it's not 9 then we\ncheck 1 plus 4 that's 5 then we check 1\nplus 5 that's 6 1 plus 7 is 8 and 1 plus\n10 is 11 so now we've gotten to the\npoint where at 1 plus 10 but the\ninteresting thing about this is this is\nthe first combination that's greater\nthan our target 9 so do we have to keep\nlooking at the next element since we\nknow the array is already sorted there's\nno number that's gonna come after 10\nthat's gonna be added to 1 that could\npossibly some to the target 9 so since 1\nplus 10 is already greater than the\ntarget we don't have to look at the\nremainder of the array because there's\nno number that could possibly come after\n10 added to 1 that would ever be the\ntarget every number is gonna be greater\nthan the target so we don't have to\nconsider 11 anymore\nso we basically remove it from\nconsideration from our array so we\ndidn't find the two numbers that sum to\nthe target so now let's try if there's\nany combination with 3 that could\npossibly some 2\nso we start at 4 so 3 plus 4 is 7 3 plus\n5 is 8 3 plus 7 is 10 so this is the\nfirst combination 3 plus 7 which is 10\nis greater than the target 9 so we don't\nhave to look at any number that comes\nafter 7 because we know that it will\nnever equal the target so we can\nbasically say well 10 is removed from\nconsideration we don't even have to look\nat it so we couldn't find a combination\nwith 3 that could sum to the target 9 so\nnow let's check the next number for the\nfirst number after 4 is 5 in this case 4\nplus 5 is exactly our target 9 so we\nfound the solution of course since we\nfound the solution we don't have to\nconsider any element that comes after it\nso in this case 7 is removed from\nconsideration and we can return our\nsolution and remember that these indices\nare based on 1 so the first index is 1\nthe second index is 2 3 &amp; 4 so the\nindices that we're going to be returning\nare 3 &amp; 4 so since this is a brute force\nsolution and we're having to iterate\nthrough the entire array which is length\nN and we're going to potentially do that\nin the worst case n times for each\nnumber in the array so then that means\nour worst case time complexity is Big O\nof N squared so it's not very efficient\nbut can we use the fact that this array\nis sorted to our advantage let's look at\nthe picture we just drew first we\neliminated 11 from consideration in the\narray then we eliminated 10 then we\neliminated 7 so we're basically\neliminating elements from the end of the\narray in reverse order can we use this\nto our advantage this is basically the\nintuition remember this array is sorted\nwe can use that to our advantage so\nlet's try the exact same problem with a\nslightly different algorithm using what\nwe just learned\nour target is still 9 since we're\neliminating elements from the end of the\narray we can use two pointers one\npointer is going to be at the beginning\nor a left pointer one pointer is going\nto be at the end or\nthe right pointer so we currently have a\none and an eleven let's add these\ntogether one plus 11 is equal to 12 so\nthat's greater than our target of nine\nremember so since this target is too big\nwe need to decrease it we have a choice\nof which pointer to shift if we shift\nour left pointer here to three we're\ngoing to be increasing the sum we don't\nwant to do that since the sum is already\ntoo big so instead let's take our right\npointer and shift it to the left now\nwe've decreased the total sum so let's\nrecompute it one plus seven now it's\neight this is too small we went a little\n- we decreased our sum too much so now\nwe need to increase it so since the\narray is sorted we can take our left\npointer and shift it to the right to\nincrease our total sum now we've\nincreased our sum so it's now three plus\nseven but we went too far again right\nnow it's too big again it's bigger than\nnine so what do we have to do this time\nwell we want to decrease our sum so\nwe're going to take the right pointer\nand shift it left so now we decreased\nour sum let's recompute it three plus\nfive but that's eight so again we got to\na it's too small again but we're\nguaranteed a solution so we're gonna\nkeep looking\nsince our sum is too small we're gonna\nincrease it by taking our left pointer\nand shifting it right now we can't\nreally shift our pointers anymore so we\nbetter be at the right solution let's\ncheck four plus five that's exactly nine\nso we got our target and so we want to\nreturn the indices of these which are\ngoing to be three and four right in this\ncase we don't have to iterate through\nthe entire array more than once and\nthese left and right pointers are never\ngoing to cross each other we don't need\nextra memory either so our time\ncomplexity in the worst case is a Big O\nof n we found a linear algorithm using\ntwo pointers to solve this problem we\ndidn't even need extra\nnow we're ready to code up the solution\nso we remember we have two pointers left\nand right the left pointer is going to\nbe at the beginning of the array so\nindex 0 the right pointer is going to be\nat the last index length of numbers\nminus 1 and we need a loop to iterate\nthrough our array the condition in this\ncase is left is less than right but it\ndoesn't really matter because we're\nguaranteed a solution so we're going to\nreturn a solution no matter what so like\nwe just did in the example let's compute\nthe current sum and we remember if our\ncurrent sum is too big so if it's\ngreater than the target we can decrease\nour sum by taking our right pointer and\nshifting it to the left on the other\nhand if the current sum is too small we\nwant to increase our sum by taking the\nleft pointer and shifting it to the\nright the last case is that our current\nsum is exactly equal to the target in\nthat case we want to return the indices\nleft and right but remember they're\nbased on 1 so we're going to add 1 to\neach of them we can put our return out\nhere but it's not needed because we're\nguaranteed a solutions where a loop will\nreturn the solution and it works\nperfectly a linear time algorithm with\nno extra space make sure to like if this\nwas helpful and subscribe if you want\nmore\n"
    },
    {
        "Name": "3Sum",
        "NcLink": "three-integer-sum/",
        "Pattern": "Two Pointers",
        "Description": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` where `nums[i] + nums[j] + nums[k] == 0`, and the indices `i`, `j` and `k` are all distinct.\n\nThe output should *not* contain any duplicate triplets. You may return the output and the triplets in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [-1,0,1,2,-1,-4]\n\nOutput: [[-1,-1,2],[-1,0,1]]\n```\n\nExplanation: \n`nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.`\n`nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.`\n`nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.`\nThe distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.\n\n**Example 2:**\n\n```java\nInput: nums = [0,1,1]\n\nOutput: []\n```\n\nExplanation: The only possible triplet does not sum up to 0.\n\n**Example 3:**\n\n```java\nInput: nums = [0,0,0]\n\nOutput: [[0,0,0]]\n```\n\nExplanation: The only possible triplet sums up to 0.\n\n\n**Constraints:**\n* `3 <= nums.length <= 1000`\n* `-10^5 <= nums[i] <= 10^5`\n",
        "Difficulty": "Medium",
        "Video": "jzZsG8n2R9A",
        "PythonSolution": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        for i, a in enumerate(nums):\n            if a > 0:\n                break\n\n            if i > 0 and a == nums[i - 1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([a, nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n                        \n        return res\n",
        "Transcript": "okay let's solve leak code 15 threesome\nthe sequel to the popular question to\nsome so before you solve this question\nthe first thing you should do is make\nsure that you've solved twosome which is\nthe most popular question on leak code\nso you've probably solved it or at least\nseen it before\nI also recommend solving twosome 2 which\nis basically to some except the input\narray sorted a lot of people skip this\nquestion I think that's what makes\nthreesome a little harder because they\ndon't solve this one first if you solve\ntwosome n to sum to this question\nthreesome is pretty straightforward in\nmy opinion but ok let's get into the\nquestion so we're given an input array\nof n integers as per usual this array\nthough can have duplicates as we can see\nin the example right two negative ones\nin this case now what we want to do is\nfind 3 numbers of this array so a B and\nC and they and we want them to sum to 0\nso in the example there were two\nelements or two triplets that summed it\nto the total 0 now one problem is that\nwe cannot have duplicates in our\nsolution so we're gonna have to keep\nthat in the back of our minds so let's\njust start the most brute force way you\nwe see that we need three numbers so why\nnot just have a triple loop right just\nget every single combination of three\nnumbers that's probably the first thing\nyou're gonna try right so let's say our\nfirst number is negative three\nthis is our a so we're gonna try each of\nthese numbers for B right this could be\na B this could be a B this could be a B\nthis could be a B this last one can't be\na B because we need at least one number\nto come after it so that it's a C now if\nwe did that if we did that with our\ntriple loop we would find that there is\none such combination starting with\nnegative three that will sum to zero if\nwe take one as our B and we take two as\nour C value because then we'll have\nnegative three plus one plus two that's\nobviously zero so to our solution set we\ncan say okay there's a negative three a\none and A two\nso now when we move we can consider this\nas our first element right but\neventually we'll see that we go through\nthe entire thing and we don't find\nanything that cannot be added to three\nthat'll give us a sum of zero we all do\nthe same for this one and there isn't\nanything now we get to with negative\nthree again though because remember\nthere are duplicates in this array so\nnow we're saying again that we're gonna\nput negative three in this first spot\nnow this is a recipe for finding\nduplicates this is not good and we'll\nsee in this example that's exactly\nwhat's gonna happen does another we'll\ntake this as our B we'll take this as\nour C again we find negative three plus\none plus two sums to zero so then we're\ngonna add that again to our result set\nright but that's not what we want we\nwant to eliminate the duplicates so the\nproblem was we took negative three as\nour a value right and then we search the\nrest of the array for two numbers one\nand two that add to zero but then we\nwent back here right and we found the\nnegative three again and we did the\nexact same thing the problem is we don't\nwant to have the same number in this\nposition in the a position twice because\nthen if there are the numbers that come\nafter it we could potentially find\nduplicates the solution to this problem\nis to sort the input array let me show\nyou what I mean so here you can see that\nthe array is now sorted let's cross out\nour top right which was unsorted so now\nwe are going to sort the input array so\nnow when we're looking for all\ncombinations if we find negative three\nfirst then that's good okay we'll say\nnegative three then we find these two\nnumbers 1 plus 2 and then we find our\nsolution great now if we get to negative\n3 again we'll say hey wait a minute this\nnumber was already in this position\nright and we know that because it's its\nneighbor it's left neighbor is the same\nvalue we don't want to put it twice here\nbecause if we do we'll get the same\nduplicate so we're gonna tell ourselves\nthat we already computed all\ncombinations that start with a negative\n3 so we don't need to do that anymore\nwe already visited this one we're gonna\nskip this one and then we're gonna go\nhere so that means in this case we're\nnot going to find any more\nresults in the remaining portion of the\narea because they're all positive\nthey're never going to sum to zero so\nthen in our result we're only gonna have\nthe one triplet negative three one and\ntwo we eliminated duplicates by not\nreusing the same element twice I think\nit helps to understand a little bit\nabout the statistics of like\ncombinations and permutations to like\nunderstand exactly why this eliminates\nduplicates but I hope this explanation\nat least helped a little bit so now that\nwe know to sort the input array and we\nknow how to eliminate duplicates once we\nfind our first number notice right so\nlet's say we have a negative 3 so then\nthe remaining part of the problem\nthere's only two elements right so it\nbasically reduces to twosome and you\nprobably know how to solve twosome right\nobviously we can put the numbers let's\nsay that this is our first a right so\nthen for the remaining portion we're\nbasically going to do to sum and you can\ndo that with a hash map or a hash set\nbut if you've solved the problem to some\ntwo you know that we don't need to use a\nhash map we can use a left and right\npointer so this is our left and this is\nour right and if we find numbers such\nthat left and right added to our\nnegative three sum to zero then we're\ngonna add them to the solution set if\nthe sum though is too big for example if\nour sum was greater than zero we want to\ndecrease our sum now we can do that by\ntaking our right pointer and shifting it\nso our right pointer would be shifted\nhere notice how that decreases the sum\nbecause the numbers are sorted so if\nyou've sold to some two before you know\nexactly why this works and I encourage\nyou to watch that video if you want a\ndeeper explanation now on the other hand\nmaybe our sum is too small our sum is\nsmaller than zero in that case we would\nshift our left pointer because the input\narray is sorted if we shift our left\npointer we're increasing the sum now\nthere could be duplicates among these\nleft and right values too for example if\nthis this one was a negative three\ninstead right in that case we don't want\nto reuse the same element twice even\nour left and right values so we would\nnot use the same we would shift our\npointer once more over here we don't\nwant to reuse the same value for left\nand right either so we don't get any\nduplicates now in terms of time\ncomplexity remember we are sorting the\narray which is Big O of n log N and then\nwe are not doing the brute force with\ntriple loops that would be n cubed we\nare using the fact that this input array\nis sorted to our advantage\nwe're using one loop to get to tell us\nthe first value and we're using the\nsecond loop to basically solve two sums\nso we're gonna have two nested loops and\nthat's going to give us o N squared so\nthat means obviously the time complexity\nreduces to just of N squared now the\nspace complexity will depend so for the\nimplementation I'm showing it could be\nBig O of 1 or it could be Big O of n\nbecause sorting actually does take extra\nmemory in some libraries so it depends\non your implementation of sorting it\ncould be O of n ok now let's get to the\ncode so we remember we have to return\nthis result as a list of lists and\nremember the first thing you want to do\nis sort the input array next we want to\nuse each number in the input array as a\npossible first value so I will iterate\nthrough the index and the value and\nremember we don't want to reuse the same\nvalue in the same position twice so if I\nis greater than zero meaning this isn't\nthe first value in the input array and\nthis value a is equal to nums\nof I minus 1 that means it's the same\nvalue as before that means we want to\ncontinue we don't want to reuse the same\nvalue twice so we're going to continue\nto the next iteration of the loop next\nwe're going to use our two pointer\nsolution for the remaining portion of\nthe array to basically solve to sum so\nwe'll have left and right pointers left\nwill initially be I've\nplus one right will be the end of the\nlist length minus one left and right\ncan't be equal so we're gonna say left\nis less than right now we're going to\nactually compute the sums so we'll say\nour three sum is a plus numbers of left\nplus numbers of right so if the sum is\ntoo great remember if it's greater than\nzero which is what we're looking for\nthen we need to decrease it in which\ncase we would say our right pointer\nneeds to be decremented on the other\nhand if it's too small we need to make\nthe sum bigger\nif only I could type today if it's too\nsmall we need to make it bigger so shift\nour left pointer to the right the last\ncase is if this is equal to zero so of\ncourse we have to add it to our result\nso to our result we're going to append\nall three numbers so the numbers are a\nnumber of left and nums of right now of\ncourse we got to update our pointers\nabout how do we update it there's a lot\nof ways you can do it but I'm going to\nshow you the way that you can do it with\nwriting the minimal amount of code so\nlet me just write a comment to show you\na little bit what if we had the to sum\nbasically for these left and right and\nwe were at negative 2 negative 2 so\nnegative 2 0 0 2 &amp; 2 what if our left\npointer was here and our right pointer\nwas here in that case we might have we\nfound a solution let's say right then\nwe'd want to update our left pointer\nright so then our left pointer gets to\nnegative 2 again but that's the same one\nas before so in that case we want to\nupdate it one more time to get it over\nhere right now in that case now our sum\nis going to be too big because we're\ngoing to be at 0 plus 2 so that's\ngreater than 0 so then our loop is gonna\nexecute saying that this is too big and\nwe're gonna shift the right pointer to\nthe left but notice how that right value\nis now the same as it previously was to\nbut that's ok\nbecause our sum is gonna our sum is\ngoing to evaluate as too big\nto our right corner is going to be\nshifted again notice how each value is\nonly going to have one corresponding\nvalue that it can sum equal to the\ntarget which is zero so we only have to\nupdate one pointer and there are two\nconditions up here we'll update the\nother pointer by itself we don't even\nhave to worry about it\nso in this case we're only going to\nshift our left pointer because we don't\nwant to have the same sum we're gonna\nhave to use a loop so in this case if\nnums of left is equal to num of left\nminus one that means it's the same value\nso we have to keep shifting our pointer\nbut remember we don't want our left\npointer to ever pass the right pointer\nso we're gonna add that to the condition\nso this is all we need to do now I\nbelieve unless I've made another stupid\nbug we should be able to just return our\nresult and pass the problem with the\nmost optimized solution okay I'm praying\nthat this works on the first try let's\nsee we passed the test case the first\ntest case they really want you to buy\nleak code premium this is taking okay so\nit did pass usually have some stupid\nbugs where I mess up a condition but\nokay so we passed it this is pretty\ncomplicated I'm not gonna lie this is a\npretty hard problem to solve if you've\nonly just solved to some so I really\nrecommend solving to some two as well\nbefore solving this problem I might have\nmade it look easy with the amount of\ncode I wrote but don't let it fool you I\nreally struggled with this problem the\nfirst time I was doing it and you can\nsee here and by looking at the evidence\na long time ago well ten months ago I\nwas pretty bad at this as well so don't\nget discouraged if this was helpful\nthough please leave a like and subscribe\n"
    },
    {
        "Name": "Container With Most Water",
        "NcLink": "max-water-container/",
        "Pattern": "Two Pointers",
        "Description": "You are given an integer array `heights` where `heights[i]` represents the height of the $i^{th}$ bar.\n\nYou may choose any two bars to form a container. Return the *maximum* amount of water a container can store.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public)\n\n```java\nInput: height = [1,7,2,5,4,7,3,6]\n\nOutput: 36\n```\n\n**Example 2:**\n\n```java\nInput: height = [2,2,2]\n\nOutput: 4\n```\n\n**Constraints:**\n* `2 <= height.length <= 1000`\n* `0 <= height[i] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "UuiTKBwPgAo",
        "PythonSolution": "class Solution:\n    def maxArea(self, heights: List[int]) -> int:\n        l, r = 0, len(heights) - 1\n        res = 0\n\n        while l < r:\n            res = max(res, min(heights[l], heights[r]) * (r - l))\n            if heights[l] < heights[r]:\n                l += 1\n            elif heights[r] <= heights[l]:\n                r -= 1\n            \n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code so today we're\ngoing to be solving\nleak code 11 container with most water\nso we're given an array of heights so\nthis is a height 1 this is i\n8 6 so on and so on and\nusing these heights we want to see\nwhat's the biggest\narea we can form with a container that\nhas a\nleft height and a right height so in\nthis example\nyou can see that if we take this one\nwith a height of eight\nand this one with a height of seven we\ncan create an\narea let's see how wide this is at one\ntwo three\none two three seven wide and seven tall\nso that's seven by seven\nand the area is going to be 49 and they\ntell us that much\nin the explanation so since we're given\na list of heights and we want to\nmaximize the area\nwe can potentially just take every\nsingle combination right so check every\nleft pointer\nand every right pointer so my first\nthought with this\nis what's the brute force way what's the\neasiest way to solve this problem\nwell let's just try every single\ncombination of left and right let's just\ntry\nevery single possible container we could\nmake\nand see if it works so let's say this is\nour left\nand this is our right what's the most\nwhat's the max area we can make with\nthis well\nlet's fill it up to 1 and if we keep\nfilling\nit up with water notice how it's going\nto spill to the left right\nso this left pointer is our bottleneck\nright\nwe have a height of 1 and we have a\nheight of seven\nthe minimum one is one so you know\nwe can't fill it up any higher the width\nof this is also\none so we get a we get an area of one by\none\nwith water and of course if this one\nremains our left pointer we can try this\none as our right pointer\nand in this case the width is going to\nbe two\nbut the height is still going to be one\nour\nremember our left height is only one so\nour bottleneck is one so we get an area\nof two by one\nso i'm starting to notice a bit of a\npattern but let's just keep continuing\nwith the brute force\nso next we can try this area\nthat's going to be three next we can try\nthis area that's going to be 4.\nnext we try this one that's going to be\n5 and we can just keep going\nthe height is going to stay 1 because\nour left pointer has a height\nof 1. next we move our left pointer\nhere and again we're just going to\ncontinue with the brute force solution\neventually we're going to have our right\npointer set here and then we're going to\nfind\nour result right it's going to be 7 by 7\nthat's the biggest area we can do and\nsince we're checking every single\ncombination we know we're eventually\ngoing to find\nthe correct solution the only downside\nis that this algorithm\nis big o of n squared now is that good\nenough\ni guess it depends on your interviewer\nand let me just quickly code up the\nsolution\nfor that so this is the brute force of\nn solution let's first initialize our\nresult\nwhich is our area i'm going to\ninitialize it to 0 because you can't\nreally have a negative area\nat least not in this context and we want\nto go through every single combination\nso\ni'm going to have our left pointer go\nthrough\nevery single indices of height\nso i'm going to get the length of height\nwhich is our\narray so left is going to\nbe at every single position at least\nonce now\nright pointer we can just have this one\nbe always at least one position ahead of\nleft so left plus one\nbecause it all our right pointer of\ncourse always needs to be\nto the right of our left pointer right\nand for each of these\ncombinations we want to compute the area\nso let's do that\narea is going to be equal let me just\nremember\nhow to i don't know about you guys but\nsometimes even i forget how to compute\nthe area of a rectangle\nso we're going to do width times height\nso the width\nis going to be right minus left\nmultiplied by the height now how do we\nfind the height so how do we find the\nheight\nremember we're focusing on what the\nbottleneck is\nand by bottleneck in this case we mean\nthe minimum height because\nno matter how tall our right no matter\nhow tall one of the heights is right\nwe could extend this to a million but\nlook how small this one is it's just too\nsmall the water is going to spill out\nso we care about the minimum height of\nthe left and right\npointers so let's get that minimum so\nminimum\nof height of left\nand minimum of height of right\nso now that we've computed the area\nremember we want the max area so we can\nset our result\nequal to the max of\nitself and of the area that we just\ncomputed\nso every time we compute an area if it's\nthe max we're going to update our result\nand now all we need to do is return that\nresult that we computed\nlet's see if it works unfortunately it\ndoesn't work we got time limit exceeded\nso\nnow we need to figure out how we can\nmake this a little bit better\ncan we get a linear time solution so now\nlet's take a look at the\nlinear time solution the one that will\nactually work in late code\nso remember how we said that the minimum\nheight\nis our limiting factor we really don't\nwant\nsmall heights so let's see if we can try\na two pointer technique now i'm gonna\ninitialize\nthe left pointer all the way at the left\nand i'm going to initialize the right\npointer all the way at the right\nwhy because we want to maximize the area\nso\nwhy would i initialize them like\nbecause we want the width to be as big\nas possible because if this left height\nis super tall and this right height is\nsuper tall\nthen we've instantly found our result\nbut of course in this case that doesn't\nwork we get an\narea of 1 by 8 i think so that's\nobviously\nnot the result so what do we do how do\nso the first area that we computed was\nan 8 which is\nour max because our initial max because\nthis is basically the maximum so far\nso now how are we going to update our\npointer well\nwe're going to look at what's the\nminimum height this one has a height of\none\nthis one has a height of seven so why\nwould i shift my right pointer when it\nhas a height of\nseven when i could instead shift my left\npointer\nwhich has a height of one and\npotentially increase it\nso now left is over here and we have a\nheight of 8\nand lucky for us we've basically found\nour solution but i'm just going to keep\ngoing with the algorithm\njust to kind of show you how it works so\nnow we have an\narea of seven by seven which we know is\n49\nso our max area gets updated our max is\nno longer eight it's 49\nwhich we know is the correct solution\nnext i'm gonna take the minimum\nof eight and seven\nis smaller so we're going to shift our\nright pointer to the left\nnow our right height is looks like three\nso the area that we're going to compute\nis going to be 3\nby 6\nwhich is 18 but that's too small that's\nnot bigger than our maximum\nso we don't need to update our max area\nnow our minimum\nis 3 so we're going to shift\nnow we have an 8 by 5 rectangle which is\n40 but that's still not greater than 49\nand\nand now we get to a nice little edge\ncase where both of the values\nare equal in this case it doesn't\nactually matter which pointer that we\nshift\nbut if you wanted to you could shift\nthe one that has a larger height coming\nlike\nfor example like this height is at six\nwhereas this height is at four\nwe could choose to shift this one just\nbecause we know that a larger height\nexists over here\nbut it actually doesn't matter you could\nso now our left is six so we get\nsix by four which is 24 too small\nwe don't care about it let's just keep\ngoing\nso now our minimum height is six let's\nnow we get a two by three rectangle\nwhich is too small\nlet's shift our left pointer one more\ntime\nhey this time we got a five by two\nthat's a little better than before but\nstill not better than our max and so\nthis is basically the last\nrectangle or water container that we can\nform\nit's going to be four by one and now if\nwe try to shift our left pointer\nwe get to the terminating condition we\nget to the condition that's going to\nend our code so now that we shift our\nleft pointer\nhere we're going to get our left here\nleft and right are at the same\nposition so let's get rid of this let's\nget a solution that can actually work\non leak code and maybe you might need\nthis solution in your interview if the\nbrute force is not good enough\nso once again i'm going to set our\nresult equal to zero\ni'm going to do what i did in the\nexplanation our left pointer is going to\nbe initialized\nall the way to the\nleft which is zero and our right pointer\nis going to be initialized all the way\nto the right\nso these values are zero and length\nof heights minus one\nand remember our condition for the loop\nis while\nleft is less than right because if\nthey're equal that's no\ngood and if they if left passes right\nthat's no good either\nso let's compute the area again i'm just\ngoing to copy and paste it from my above\nsolution because\nthat's what the brute force solution is\nfor right you can learn\nthe basic problem the basic parts of the\nproblem before doing\nthe clever stuff i can also just copy\nand paste the part where we update our\nresult as well\nnow the part that we have to change\nthough is\nwhen we're updating our left and right\npointers we're doing it\nbased on a certain condition if\nthe height at position left is less than\nthe height at position\nright we're going to shift our left\npointer to the right\nwe're going to increment our left\npointer because we want to maximize\nboth of these heights now the other\ncondition\nis the opposite case so if height of\nleft\nthen we would want to shift our right\npointer and we want to decrement it\nand the last case is if they're equal\nright that's our else condition\nand remember how i said we could do\neither one if\nuh if they're both equal right we could\nincrement our left pointer or we could\ndecrement our\nright pointer uh notice how both of\nthese are doing the same thing\nso i'm just going to condense this i'm\njust going to get rid of\nnow all we need to do is return the\nmaximum that we computed\nlet's see if it actually works this time\nokay of course i had\na typo so i had a s at the end of\nheights\nlet's run it one more time and this time\nit'll work so\nthis is the actual linear time solution\nthe big o of n solution\nas always thank you so much for watching\nlike and subscribe if this was helpful\nyou\n"
    },
    {
        "Name": "Trapping Rain Water",
        "NcLink": "trapping-rain-water/",
        "Pattern": "Two Pointers",
        "Description": "You are given an array non-negative integers `heights` which represent an elevation map. Each value `heights[i]` represents the height of a bar, which has a width of `1`.\n\nReturn the maximum area of water that can be trapped between the bars.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0c25cb81-1095-4382-fff2-6ef77c1fd100/public)\n\n```java\nInput: height = [0,2,0,3,1,0,1,3,2,1]\n\nOutput: 9\n```\n\n**Constraints:**\n* `1 <= height.length <= 1000`\n* `0 <= height[i] <= 1000`\n",
        "Difficulty": "Hard",
        "Video": "ZI2z5pq0TqA",
        "PythonSolution": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n\n        l, r = 0, len(height) - 1\n        leftMax, rightMax = height[l], height[r]\n        res = 0\n        while l < r:\n            if leftMax < rightMax:\n                l += 1\n                leftMax = max(leftMax, height[l])\n                res += leftMax - height[l]\n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])\n                res += rightMax - height[r]\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so it's\nbeen a while for me sorry i've been\npretty busy but let's\ntoday solve leak code 42 trapping rain\nwater\nso we're given an integer array\nrepresenting the\nheights of certain elevations or\nwhatever right so\nit's a one-dimensional array the first\nvalue is zero\nmeaning a height of zero so that's over\nhere the next value is one so that means\na height of\none some have heights of two this one\nhas a height of two\nthis one has a height of three right and\nso given this\nentire structure we basically want to\nknow how like what's the\nmaximum amount of rain water could\nthis structure trap right given an\nunlimited amount of\nrain so you can see this is one unit\nright over here\nthis is roughly four units right\none two three four and then this is\nanother one right so when you count all\nof those you get a total of\nsix squares right so the output is six\nthis can trap a maximum of six blocks of\nwater\nso with a picture it's pretty easy but\nwhat how do you\nknow right like what's the algorithm to\ndetermine how much\neach position could trap right like for\nexample\nthis position is the first one right so\nthere's no\nboundary on the left of it right so no\nmatter how much\nwater we would add over here it would\nall just spill\nto the left and the same is true for\nthis position right no matter how much\nwater we put on top of here even though\nthere's a right boundary over here right\nthere's nothing on the left of it so all\nthe water is just going to spill out to\nthe left so it's not going to trap any\nwater\nbut you can see in the third position we\nare able to\ntrap exactly one block of water so\nwhat's the algorithm to determine why is\nit one\nright because we care about the height\nbecause we want to know how much water\nand it's actually pretty simple right\ntake a look so here we have\none block of water what if i added a\nsecond block of water\nwell we can see that there is a boundary\non the right this is good right\nbut what about the left side there's no\nboundary over here right meaning\nany water i add is just going to spill\nout the boundary only has a height of\none so we're seeing that the height on\nthe left is one the height on the right\nis two so we're\nwe need to take the minimum of that we\nneed to take the minimum of one and two\nbecause that\nis our bottleneck that is what's\ndetermining\nexactly how much water we are able to\ntrap\nper position right for every single\nposition we need\nthe max height on the left and the max\nheight on the right left and right and\nthen we need to take the minimum\nof those two let's take a look at this\nposition clearly we can't trap any water\nhere but\nwhy exactly is that the case well when\nyou look at the right position right\nin the entire right section the maximum\nheight is a\nthree right so that's good three here\nwhat's the maximum height on the left\nside\nit's a one right this position\nis a two if we take the minimum of one\nand three we get\none so that's our boundary that doesn't\nmean we can trap\nany water here we can trap zero water\nhere the reason is\nbecause the actual calculation is we're\ngonna take the minimum\nwe're gonna take the minimum of the\nmaximum left height and the maximum\nright height we're gonna take the\nminimum of those two and\nwe're going to take the height that\nwe're currently at right so let's say\nh of the index i that we're at\nso this is the equation we're going to\nuse to determine at every single\nposition\ni let's say this is our i position right\nso you can see i is in this equation\nthis is going to determine how much\nwater we can trap\nin position i so we know the minimum of\nthe\nmax of the left and right right because\nthe left was one the right was three the\nminimum of those is just going to be\none and h of i so the height at position\ni\nis two over here right two so we're\ngonna take one\nminus two that's actually going to give\nus a negative\nnumber right that's going to give us\nnegative 1\nbut we know we can't trap negative water\nright so we're always going to round\nup we're never going to use negative\nnumbers because it doesn't really make\nsense\nto trap negative water over here so\nreally since the\nsolution is negative that really means\nthat we can trap\nzero water in this position but let's\njust\nmove to a couple more positions before\nyou probably get the idea so over here\nright\nin this position the height is one right\nand the max height on the left is two\nthe max height on the right is three\nagain right so we take the minimum of\ntwo and three\nso we're going to get two right two is\nthe minimum\nand height of i is one right the height\nat this position\nis one so that means we can trap exactly\none water in this position\nright clearly that is the case right\nwe're trapping one unit of water\nand basically if you did this exact same\ncalculation\nfor every single position including this\nposition you'd get\nthe appropriate water count so this\nposition would give us\ntwo units of water this is going to give\nus one\nthese are going to give us zero this is\ngoing to give us one and the rest are\ngoing to give us\nzero water that we can trap once we take\nthe sum of all those we are going to get\nour answer\nsix so now let me actually show you the\nefficient ways to\nsolve this problem okay so i'm going to\nshow you two different ways to solve\nthis problem\nboth of the solutions are linear time\nsolutions right so big o\nof n is going to be the time complexity\nof the solution\nbut the first solution i show you is\ngoing to actually require big\no and of memory as well there's an\nactual optimization you can do with two\npointers\nto reduce the memory from linear memory\nbig o of n\nto constant memory so i'm going to show\nyou both\nof the solutions and it's actually not a\nlot of code the code is actually pretty\neasy\nsince for every single position right to\nknow how much water we can trap at index\ni we need to know what's the max\nleft and right height of every single\nposition right so for this position the\nmax on the left is going to be 2\nright over here and the max on the right\nis going to be 3\nright over here right so we're going to\nneed to be doing that calculation a lot\nso we can actually make an array and\nthen store\nthat calculation for us so that we only\nhave to do it\na single time each so first we can scan\nthrough the array right just go iterate\nthrough the entire array\ncalculating every single max left\nposition meaning\nfor this position what's the max height\non the left of it\nwell there aren't any heights on the\nleft of it so it's going to be zero\nwhat's the max height of this well the\nmax height is\nzero right that's the only height that\ncame before it what's the max height\non the left of this well it's a one\nright so\nwe can do this in linear time big o of n\ntime so i'm just gonna do that right\nwhat's the max height on the left of\nthis\none max height on the left of this we\nhave a new max it's two\nright we just keep track of what the\ncurrent max is so far\nright now it's two two we got a new\nheight a new maximum that's three so now\nthree\nis going to be the max left height for\nthe remainder of these\nright so we calculated the max left\nheight we can actually calculate the max\nright height pretty easily as well when\nwe iterate through this\nin reverse order right we go from right\nto left\nso initially the max right height is\nzero because there's nothing on the\nright of this\nnext it's going to be one now it's going\nto be two\nand now we got to a three so the max\nright height for the\nremainder of this is just going to be 3.\nand remember we actually need to take\nthe minimum of the max\nleft and the max right for every single\nposition right so for this position we\nwant the minimum\nof these two values for this position\nright\nzero we want the minimum of these two\nvalues right\nbecause the minimum is going to help us\ndetermine how much\nwater we can trap in this position right\nand clearly we can actually find the\nminimum of these two arrays as well\nin linear time so here is the minimum is\nzero\nminimum is zero minimum is one one two\ntwo one and zero\nand so now for every single position\nwe're going to determine how much\nwater we can trap and we can do that\nremember with our calculation we can\ntake the minimum\nof the left and the right and subtract\nfrom it the height at position i right\nand we're always going to round\nup we always want it to be greater than\nor equal to zero and then we can add the\nsum\nof all of those values and then get the\ntotal water that we can trap\nso in this position we have zero minus\nzero minus zero right so here the amount\nof water we can trap\nis zero here we have zero\nminus one that's going to be negative\none but we don't count negative so\nthe amount of water we can trap here is\nzero here we have\none minus zero the height at this\nposition so we can actually trap\none water in this position here\nwe have one minus two that's going to be\nnegative\nso we can't trap any water here here we\nhave\ntwo minus one so that's going to be one\nthat means we can trap\none water here this is two\nso the maximum boundary is two minus\nzero that means we can trap two units of\nwater here\nnext position we have a two minus one we\ncan trap\none water here here we have two minus\nthree that's going to be negative\nwe can't trap any water here this is\ngoing to be\n2 minus 2 again 0 water that we can trap\nhere\n2 minus 1 that's\n1. so we can trap one unit of water here\nhere we're gonna get\none minus two that's negative can't trap\nany water here\nhere we have zero minus one that's also\nnegative so can't trap\nany water here and that makes sense why\nwould be we why would we be able to trap\nwater here when there's no\nright boundary but okay so we have all\nof our values we take one plus one plus\ntwo\nplus one plus one and\nwe get exactly what we expected right we\nget a six\nwe can trap six units of water here so\nthis is the solution\ntaking extra linear memory okay so\nnow i'm going to show you the o of one\nmemory solution it's still linear time\nbig o of n time but this time we're not\ngonna need any of this\nextra memory that we just allocated\nwe're actually gonna do this\nwe're gonna do this with two pointers so\ninitially i'm gonna have my left\npointer over here i'm gonna have my\nright pointer here\nso the right pointer is going to be all\nthe way at the end of the\ninput array so we're going to have our\ntwo pointers initialized we're also\ngoing to have two variables\nmax left and max right which are going\nto be keeping track of the maximum\nleft pointer and maximum right pointer\nso far so you can see\nleft is initially zero so the max so far\non the left is zero\nyou can see right is initially one so\nthe max on the right so far\nis one so now we are gonna have to\nupdate our pointer now which pointer are\nwe gonna shift\nwe're gonna take the one that has the\nsmaller max\nvalue so right now you can see max\nleft has zero max right has one so we're\ngoing to shift the smaller one\nwhich is left so we're going to take our\nleft pointer and shift it\nso now our left pointer is over here and\njust\njust uh fyi we know that we can't have\nany water stored on the end points right\non the left and the right\npositions we can't have any water\nbecause they're endpoints right they\ncan't contain any water\nbut this position technically can have\nsome water\nand how are we going to determine that\nwell we're going to take our\nhow much water this can contain right\nwe're going to take the max\nleft value that we have in our variable\nright now right\nhow how come we don't need the right\nvalue\nwell i'm going to show you so this is\nthe part that you kind of need to notice\nthe trick\ni guess right so we're in this position\nright\nnow remember originally we wanted the\nminimum down here you can see we wanted\nthe minimum of the max\nleft and max right well we know what the\nmax left\nis so far right the max left is zero\nright that's what's over here\nnow we technically don't know what the\nmax right is even though this variable\nsays\none yes so far it's one\nbut we know that the max right could\nactually be three\nright that's what the true max right is\nof this position right because there's a\nthree over here\nso why is it that we don't need that\nvalue\nbecause remember we want the minimum of\nthe max\nleft and the max right now we clearly\nknow that the max\nleft is zero right so it's smaller\nthan what's even at this position right\nand we want the minimum\nof it so no matter how big this value is\nright right now it's a three it could be\na 10\nright it doesn't matter how big it is\nbecause we want the max of the left\nand the right and we already know that\nthe left\nis pretty small right it's it's zero\nso it doesn't matter what's in all of\nthese values\nbecause we know that the max left is our\nbottleneck right remember we\nshifted our left pointer from here\nto the next position because left\nwas smaller than right that's why we\nshifted it\nthat's how we're able to calculate the\nwater that's trapped in this position\nwithout knowing what the max right is\nso with that being explained let's\nactually go through this so we can get\nto the code\nso what's the amount of water that we\ncan trap over here it's actually\nzero because the max left which is the\nvalue that we need is zero right so zero\nminus what the actual height is in this\nposition is\none we know that's going to be a\nnegative one we don't count negative\nones\nso we're not gonna use that so we're\ngonna say that zero water can be trapped\nhere\nbut you can see look this is a one right\nour left pointer is here so we can\nactually\nupdate this we can cross the zero out\nmax left is now actually going to be one\nso now we're actually at a dilemma right\nbecause take a look our max\nleft and our max right are both one so\nit doesn't really matter which one we\nshift let's just shift\nthe left one again so we're shifting our\nleft pointer over here now right\nand since they're equal this is going to\nbe the bottleneck which is\nleft pointer and the max left and it's\none so far\nso no matter how big anything over here\nis we know that one is gonna be the\nbottleneck\nwe're gonna do one which is the max left\npointer or the minimum of the max of the\nleft and right pointers right\nso we're gonna take that one minus the\nvalue that's\nin this position the height of the index\ni\nwhich is zero so that's going to give us\na water\nlevel that is one so that means\nin this position we can store one block\nof water so basically i'm running\nthrough the\nalgorithm with two pointers so i'm just\ngoing to quickly go through the rest of\nwhat this example would be\nso again we're going to shift our left\npointer because left and right are equal\nso it doesn't matter which one we shift\nwe're shifting the left one over here\nso now to calculate how much water would\nbe stored\nhere we're gonna take the max left\npointer which is one\nand subtract from it the height that's\nin this position\ntwo that's clearly negative negative one\nso what we're gonna say\nis that zero water could be stored here\nand so since we reached a height of two\nthat means we can update max\nleft and set it to two now so now\nremember we wanna shift the minimum\npointer and right now the minimum\npointer is\nthe the right pointer which is a max\nheight of one so we're going to take our\nright pointer and shift it\nand since we shift the shift to the\nright pointer now we have to calculate\nthe height\nor the water that we can contain in this\nposition right\nand so remember now the bottleneck right\nis going to be this the max right height\nfor this position\nis one right so it doesn't matter how\nbig heights over here are right there's\na three here but we don't care about\nthat because the max\nright height is one and remember we're\ntaking the minimum of\nthe max left and right height so\nno matter what we do that's always going\nto be 1 for this position\nso we're going to take 1 minus the\nheight in this position which is 2.\nthat's obviously going to be negative so\nwe don't have any water here so we can\nsay\nzero water here and since this is a two\nthat means we can also update our max\nright height now to two so this is going\nto be set to\ntwo now the max right height is 2. and\nsince they're now once again equal\nthey're both set to 2\ni'm going to be updating the left\npointer because it doesn't really matter\nwhich one we do\nokay so let's calculate the water in\nthis position so we're at a left\nposition so we're going to take the max\nleft height which is 2 minus the height\nin this position\n1 that's going to give us a 1 meaning\nthat we can contain\n1 unit of water and the height in this\nposition is 1 so we don't update our max\nleft height but we can now shift our\nleft pointer one more position\nnow our left pointer is over here our\nmax\nleft height stayed the same it's two so\nlet's compute the water we can store\nhere\ntwo which is you know the boundary uh\nsubtracted by\nthe level here which is zero so that's\ngoing to give us\ntwo units of water that we can store\nhere so a two here\nand let's shift our left pointer again\nbecause the max left and right\nare equal so now we're over here what's\nthe max left it's still\ntwo minus the height in this position\nwhich is one\nthat's going to give us a one so that\nmeans one unit of water can be stored\nhere\nlet's shift our left pointer again\nawesome so now our left pointer is\nactually at\na three so what we're going to do is 2\nwhich is the max\nleft height minus 3 which is the height\nin this position that's going to give us\na negative right so what that tells us\nis that we can't store any water here\nthat's a zero\nright but you can see our max left\nheight can actually be\nupdated now right it's going to be set\nto three now\nso this is a little bit messy but let's\njust say our max\nleft height is three right and our max\nright height is still two remember we're\nshifting the minimum\nheight so we're taking now the right\nheight and shifting it so now\nwe can take so we're at a right position\nwe can take the max right which is 2\nsubtract it from the height in this\nposition 2 minus one is going to give us\na one that means we can store one unit\nof water here\nnow let's shift our right pointer again\nbecause two\nis less than three so now we're\nbasically at the last\nposition right so the the max right\nheight is two\nthe height in this position is two so\nwhat we're gonna do is two minus two\nthat's gonna be zero right so we can't\nstore\nany water here that's gonna be a zero\nand now you can see\nwe filled in the the water levels that\nwe wanted right when you take this\none plus one plus two plus one plus one\nonce again you're going to get the total\nsix right because\nsix is the amount of water that we can\nstore i just show you\nshowed you now how to actually do it\nwithout any extra memory right we took\naway this big chunk of memory that we\nwere using\nand we did it with two pointers and if\nit doesn't make\na ton of sense right now it might make\neven more sense when you take a look at\nthe code\nwhich is actually shorter than you would\nexpect let me show you that right now\nso one short edge case we have to take\ncare of is if not height meaning the\ninput is\nempty we can return zero this is needed\nfor this problem\nand just like in the explanation i'm\ngoing to initialize\ntwo pointers left is going to be at the\nbeginning so index 0\nand right is going to be at the last\nindex so length\nof height minus 1.\ni'm also going to have two maxes so the\nleft max and\nthe right max which are initially going\nto be set to\nheight of the respective indices so\nheight of left\nheight of right i'm also going to have a\nresult which is going to total the water\nfor us\nso i'm gonna run this loop while\nleft is less than right so before they\nmeet each other\nand remember we're gonna decide which\ncell to compute\nand which pointer to shift depending on\nthe comparison between the maxes so if\nleft max is less than right max\nthen we're going to be shifting the left\npointer otherwise we're going to shift\nthe right pointer so if left max is\nsmaller we're going to increment left by\none in the opposite case we're going to\ndecrement\nright by one and remember we're also\ngoing to be\nupdating the the left max right so which\nis so if we get to let's say compare\nleft max with\nthe current height at position left\nright so whichever is greater we're\ngoing to be updating the left max\nwith that value and we're going to do\nsimilarly\nin the opposite case so right max would\nalso be updated to the max\nof itself and the new height that we get\nto height r\nand remember so in this case right we're\ngoing to be taking the left\nmax and then subtracting the height at\nthe position i\nor the position l right at the left\npointer position\nright so we're going to be making this\ncomputation right\nand then we're going to be adding that\nto the result\nright so this is going to be added to\nthe result\nnow notice how i'm not making any check\nto check that this\nis negative because technically this is\nnever going to be negative\nand you can dig into that if you want\nit's because i'm updating the left max\nhere\nbefore i'm doing this computation but if\nyou were to swap the order of these two\nyou would\nneed to make sure that you're not adding\na negative to the result but that's just\na minor detail that you can probably\nconfirm on your own\nthe bulk of this is that you have to\ntake the left max and then subtract it\nfrom the height\nat that current position right and so in\nthe else condition we're going to be\ndoing the opposite we're going to be\nadding to the result\nthe difference between the right max and\nthe height at the right pointer\nso this is really what i was just doing\nin the picture\nright this probably makes it a little\nmore clear because we actually have\ngood uh variable names and stuff but\nyeah\nafter all this is done the last thing\nthat you have to do is just return the\nresult let me just prove to you that it\nruns\nand runs efficiently and you can see\nthat it does exactly that so i hope that\nthis was helpful\nif it was please like and subscribe it\nsupports the channel a lot i showed you\nhow to do this in linear time and\nconstant memory\ncomplexity\n"
    },
    {
        "Name": "Best Time to Buy And Sell Stock",
        "NcLink": "buy-and-sell-crypto/",
        "Pattern": "Sliding Window",
        "Description": "You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.\n\nYou may choose a **single day** to buy one NeetCoin and choose a **different day in the future** to sell it.\n\nReturn the maximum profit you can achieve. You may choose to **not make any transactions**, in which case the profit would be `0`.\n\n**Example 1:**\n\n```java\nInput: prices = [10,1,5,6,7,1]\n\nOutput: 6\n```\nExplanation: Buy `prices[1]` and sell `prices[4]`, `profit = 7 - 1 = 6`.\n\n**Example 2:**\n\n```java\nInput: prices = [10,8,7,5,2]\n\nOutput: 0\n```\n\nExplanation: No profitable transactions can be made, thus the max profit is 0.\n\n**Constraints:**\n* `1 <= prices.length <= 100`\n* `0 <= prices[i] <= 100`\n",
        "Difficulty": "Easy",
        "Video": "1pkOgXD63yU",
        "PythonSolution": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        res = 0\n        \n        lowest = prices[0]\n        for price in prices:\n            if price < lowest:\n                lowest = price\n            res = max(res, price - lowest)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today\nand don't forget to hit the like button\nit supports the channel a lot so today\nlet's look at leak code 121\nbest time to buy and sell a stock so if\nyou know a little about the stock market\nthe saying is usually buy low\nand sell high so in this case\nwe're given an input array now each\nvalue\nrepresents the price of the of a stock\nat a particular day and we we\nare given one transaction meaning we can\nbuy\non one of these days and then sell on\nanother day\nand we want a transaction that maximizes\nour profit and then we want to return\nthat profit in this\ncase if we buy on day two when the price\nis\none and sell day five when the price is\nsix\nthat's what's going to maximize the\nprofit for us so as always\ni'm going to draw a picture and show you\nthat this problem is actually not too\nbad\neven the optimal solution so on day one\nit was at price seven and then it went\ndown all the way to price one\nthe next day it went from price one all\nthe way up to price\nfive and we could just keep going with\nthis right so\nnext day went down and the next day it\nwent up\nand the last day it went down again\nso looking at the picture it's pretty\nclear that\nthe max profit we can get is simply by\ntaking\nthe minimum here and the max\nhere and if we look at the actual values\nfor that\nwe see that this is one this\nis six so the profit is gonna be\nsix minus one which is\nfive but notice how we there's actually\na greater\nmaximum than this one right like this is\nsix but this is\nseven so why can't we just do this\nbecause then we get seven minus one\nwhich is six which is\neven bigger than five well it turns out\nwe know that time\nmoves in one direction right we can't go\nback in time to sell at this price\nso how are we going to solve that\nproblem well there's a pretty common\nprogramming technique two pointers so\nwe're gonna initialize\na left pointer on day one\nand our right pointer on day two which\nmakes sense\nright is gonna be to the right of left\nand so we're going to see\nwhat's the current profit right now from\nhere\nto here well it's going down right\nthat's not good it's negative\nand in this case left is going to be the\nday that we buy\nand write is gonna be the day that we\nsell\nso the first thing you're gonna notice\nis it's down right it's negative\nthis is not good we don't want a\nnegative profit why would we\nbuy left when we can buy right right\nis less than left why would i pay\nseven when i could wait one day and pay\none\nso that's basically how the algorithm\nworks since\nour right value is less than left we're\ngonna update our pointer\nleft so left is now gonna be\non day two and right is gonna be on\nday three so now we see\nthat the right value is actually greater\nthan the left value\nthe profit in this case is going to be 5\nminus\n1 which we know equals 4\nwhich is so far our current max profit\nso for the current max i'm going to put\na 4.\nand in this case since our left pointer\nis less than our right pointer\nsince we're buying low and selling high\nthat means we can leave\nour left pointer over here and we only\nhave to update our right pointer\nnow let's compare our left and right so\nwe're buying here we're selling here\nin that case the profit is going to be 3\nminus 1 which is only\n2. so if you take a look at our current\nmax it's 4 so we're not going to update\nour max profit\nand we notice that our left pointer\nwe're buying low and we're still\nselling high it's not as high as this\nbut we still\ndon't need to update the left pointer\nand so now\nwe get to the actual uh result case that\nwe already know about but\nlet's compute it so this is at six\nthis is at one so we found\na new max profit six minus one\nso our algorithm is gonna keep going\neven though we can tell by the picture\nthat we did find the mac so it's gonna\nend up checking this last case\nwhich left we're buying one and we're\nselling at i think this is\nfour so we know four minus one is three\nnot greater than five so our algorithm\nis complete we\nfound our max profit of\nfive and if we wanna know the memory\nand extra space we used we know we\ndidn't really use extra memory we used a\ncouple pointers but no array so\nextra memory is 01 time is going to be\nlinear because this is a two pointer\nsolution\nwe're not doing any brute force stuff\nthis is going to be\nbig o of and we only have to scan\nthrough the array\nuh one time even though we have two\npointers\nokay now let's code it up so we do have\na left and right pointer\nleft is going to be initialized to 0 and\nright is going to be initialized to 1\njust like in our picture we know left\nis buying right\nis selling we can initialize our max\nprofit\nto zero as like the default case and\nwe're gonna\nkeep iterating through prices while our\nright pointer\nhas not uh passed the end of prices\nnow we wanna check is this a profitable\ntransaction and how do we check that\nwell\nif prices of left\nis less than prices of right\nnow if this is profitable let's\ncalculate that profit\nso this is just the math right price is\na right minus left\nand now we can potentially update our\nmax profit but we don't know for sure so\nwe're going to check\nthe maximum of the current max profit\nas well as the profit that we just\ncomputed so whatever the max is is going\nto be assigned\nto the new max profit but it might\nnot be a profitable transaction which in\nthat case\nwe can update our left pointer\nnow regardless of the conditions we want\nto\nupdate our right pointer and so this is\nobviously going to keep going\nuntil our right pointer is out of bounds\nin which case we've gone through\nall of the values and we know that max p\nhas the result that we want to return so\ni actually had a small\nbug over here instead of incrementing\nleft by one\nif the left price is not less than the\nright price we don't just want to shift\nour left pointer by one we want to shift\nit\nall the way to the right because we\nfound\na really low price we found the lowest\nprice\nthat we could pretty much we basically\nwant our left pointer to be\nat the minimum and you can tell from\nthis picture\nthat if our left was here and our right\nwas over here\nwe don't just want to shift our left\npointer by one because then it's up here\nwe want the left pointer to be low right\nwe want to buy\nlow sell high so we would shift our left\npointer\nall the way over here\nso we'd cross this out put the left here\nand then the right pointer would be over\nhere\nand we can see that this would be a\nsuper good profit for us\nand now we can submit our solution and\nit's\nover 90 so we're in the clear we found a\nvery optimal solution for this problem\ni hope it was helpful please like and\nsubscribe to support the channel\n"
    },
    {
        "Name": "Longest Substring Without Repeating Characters",
        "NcLink": "longest-substring-without-duplicates/",
        "Pattern": "Sliding Window",
        "Description": "Given a string `s`, find the *length of the longest substring* without duplicate characters.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n**Example 1:**\n\n```java\nInput: s = \"zxyzxyz\"\n\nOutput: 3\n```\n\nExplanation: The string \"xyz\" is the longest without duplicate characters.\n\n**Example 2:**\n\n```java\nInput: s = \"xxxx\"\n\nOutput: 1\n```\n\n**Constraints:**\n* `0 <= s.length <= 1000`\n* `s` may consist of printable ASCII characters.\n",
        "Difficulty": "Medium",
        "Video": "wiGpQwVHdE0",
        "PythonSolution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        charSet = set()\n        l = 0\n        res = 0\n\n        for r in range(len(s)):\n            while s[r] in charSet:\n                charSet.remove(s[l])\n                l += 1\n            charSet.add(s[r])\n            res = max(res, r - l + 1)\n        return res\n",
        "Transcript": "what solve leak code 3 longest substring\nwithout repeating characters or back to\na classic leak code problem the third\none so this one's pretty simple we're\njust given a string and we want to find\nthe longest sub screen without any\nrepeating characters right like how\nthese three don't have any duplicate\ncharacters ABC this one has two A's so\nthis would not count as a substring\nwithout repeating characters and we only\nneed to return the length of this\nsubstring so the first idea that comes\nto my mind at least is so just check\nevery single substring check if it has\nany duplicates if it doesn't then it\nthen we're just going to take the\nlongest one of those strings and return\nthe length so how would that algorithm\nrun okay first we'd start at a we want\nto get every substring starting at a so\njust this one a well that doesn't have\nany duplicates a B that doesn't have any\nduplicates a C that doesn't have any\nduplicates either and then we get to\nthis first duplicate a we have two A's\nnow but remember we're checking every\nsingle sub screen starting at this first\na so we're gonna keep this algorithm\ngoing even though we don't have to every\nsubstring we get after that like see how\nwe're doing it every single substring\nafter is also gonna have duplicates so\ndo we even need to check all of these\nstarting at value a this is the repeated\nwork that we're gonna eliminate with our\nvery fundamental technique the sliding\nwindow so we want to only check sub\nstrings without any repeated characters\nso let's actually just do that let's\nmake sure that our window right our sub\narray our substring is always not\ncontaining any duplicates so once we get\nto this next a we're gonna say well now\nwe have to a so we need to start\nremoving from the left wing to start\nshrinking our sliding window until we no\nlonger have duplicates so I'm gonna say\nremove this one from our substring now\nour substring runs from here from the B\nall the way to the a now it's perfectly\nvalid so now we can keep going it's\nstill only length three though so now\nso we're gonna add this bead but wait a\nminute now we have two bees but my\nquestion is how would we even know\ninstantly whether we had a duplicate or\nnot well we can use a set for that sets\nwill only contain one of each character\nso we'll automatically know if we have a\nduplicate we can check it instantly so\nwe're going to check that we have two\nbees so now we're going to keep popping\nfrom the left we're going to keep\nshrinking our window from the left until\nwe don't have until we remove a bee and\nwe're gonna see that the first one we\nremove is the Beast and now we're done\nso now our substring runs from this C\nall the way to this D now we're gonna\nadd another character once again we have\na duplicate and once again we can\nliterally just remove the farthest left\ncharacter and now we're valid again no\nmore duplicates we're running all the\nway from A to C next we add a B the\ninteresting thing about this is that now\nwe have to remove this a because we have\nto shrink our window our sub string has\nto be contiguous so we have to remove\nthis a but notice we still have two bees\nin our substring so we got to remove\nanother character we have to remove this\nB so now our substring runs from C to B\nso we are valid again but now our\nsubstring is only length two next we'll\nget to the last B last character we're\nadding and C yep it's a duplicate again\nand don't forget that as we're removing\nthese characters from the left we're\nremoving a C we're not just removing it\nfrom our window but we also have to\nremove it from our set because our set\nis going to correspond to all the\ncharacters inside of our substring that\nwe're at so we have to remove our see\nfrom the window and move it from the set\nwe have to take this B and do the same\nthing and now we have no more characters\nto add with this sliding window\ntechnique which is a very fundamental\ntechnique that you'll probably see a lot\nmore in a lot of different problems we\ncan cut the time complexity down to Big\nO of n we just have to go through the\nentire list well we might have to add\nand remove values from our set but\nthat's a very quick operation the memory\ncomplexity because of our set is also\ngoing to be Big O of n because potential\nevery character and the string could be\nunique and will add all of them to our\nset and I didn't really show it while we\nwere going through the problem but we\nwould want to maintain what's the\nlongest substring we found in our case\nit was obvious that the long as we found\nwas of length three so I remember the\nfirst thing we need to do is get a set\nto make sure we have all the characters\nin our window so I'll call it character\nset and we're going to do a sliding\nwindow so any week so we need two\npointers a left pointer and a right\npointer to determine our sliding window\nour left will be initialized to zero and\nour right pointer is going to\ncontinuously be changing as we visit\nevery character so I can just use it in\nthis for loop so the right pointer is\ngoing to go through every single\ncharacter now remember if we get to a\nduplicate character that means we have\nto update our window and our set so\nwhile this character that we just visit\nat the right pointer s of R is equal is\nalready inside our character set meaning\nit's a duplicate then we got to update\nour window so we have to take the left\ncharacter and remove it from our set so\ncharacter set dot remove the leftmost\ncharacter and then of course we have to\nupdate that left pointer incremented by\n1 and we're going to keep doing this\nwhile that duplicate remains in the\ncharacter set after we've removed all\nduplicates then we can just add this\nrightmost character to our set and since\nat this point we know for sure that our\nsubstring doesn't have any duplicates we\ncan potentially update ours our result\nvariable which I never declared so let\nme declare it up here result is\ninitially going to be 0 and now we can\nupdate our results so we can potentially\nmake it larger than it is if the current\nwindow size is greater than what it is\nright now which we can compute by right\nminus left plus 1 and then at the end\nonce we've gone through the entire or\nsubstring we can return the result if\nthis was helpful leave a like in\n"
    },
    {
        "Name": "Longest Repeating Character Replacement",
        "NcLink": "longest-repeating-substring-with-replacement/",
        "Pattern": "Sliding Window",
        "Description": "You are given a string `s` consisting of only uppercase english characters and an integer `k`. You can choose up to `k` characters of the string and replace them with any other uppercase English character.\n\nAfter performing at most `k` replacements, return the length of the longest substring which contains only one distinct character.\n\n**Example 1:**\n\n```java\nInput: s = \"XYYX\", k = 2\n\nOutput: 4\n```\n\nExplanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.\n\n**Example 2:**\n\n```java\nInput: s = \"AAABABB\", k = 1\n\nOutput: 5\n```\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `0 <= k <= s.length`\n",
        "Difficulty": "Medium",
        "Video": "gqXU1UyA8pk",
        "PythonSolution": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = {}\n        \n        l = 0\n        maxf = 0\n        for r in range(len(s)):\n            count[s[r]] = 1 + count.get(s[r], 0)\n            maxf = max(maxf, count[s[r]])\n\n            if (r - l + 1) - maxf > k:\n                count[s[l]] -= 1\n                l += 1\n\n        return (r - l + 1)\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nwe're going to solve\nlongest repeating character replacement\nand so this is another problem from that\nblind 75 list\nso we are going to be one step closer to\ncompleting the entire list\nthe link will be in the description to\nthis spreadsheet if you do want to take\na look\nand hello to the six people that are\ncurrently viewing the\nspreadsheet right now you're gonna be in\nthe next video but okay so let's get\ninto this problem because it's another\npretty fundamental problem that's really\ngood to understand so we're given a\nstring\ns and a single integer k and so\nbasically they tell us that we can\nchoose\nany of the characters in the string and\nchange it to any other uppercase english\ncharacter so in this problem\nevery character in the input string is\ngoing to be limited to uppercase english\ncharacters and we know that there's 26\nuppercase english characters from\ncapital a to capital z\nand so basically we can perform a\nreplacement on\nany of the characters at most k times\nso we are allowed to replace k different\ncharacters in the string to any other\ncharacter we want\nand what we want to do is return the\nlength of the\nlongest substring containing the exact\nsame character we can get after\nperforming\nat most k different replacements\nso we just want to return that length we\ndon't actually have to make those\nreplacements in the input string\nso in this case when we take a look at\nthe input string we have a\nb a b and we're allowed to replace two\nof the characters\nso what's the longest substring we could\nget with the exact same character well\nwe could replace\none of the b's we could basically\nreplace both of the b's\nwith a capital a and then we get four\na's in a row\nwhich would give us an output of four\nand we could technically also do the\nopposite we could replace the a's\nwith capital b's and that would give us\nthe exact same result a length of four\nso i'm going to show you how you can\nsolve this problem in big\no of n time and technically it's going\nto be big o of\n26 multiplied by n which we know is also\nreduces to\nbig o of n but there's actually\ntechnically an easier\nway to do it or at least a more simple\nway to do it which is just going to be\na flat big o of n we don't even need\nthis 26 constant\nbut this way is actually pretty tricky\nto get to\nso i'll be going over a little bit of it\nbut this is kind of the main way that\nyou'd want to solve this problem\nso let's say we're given an input string\nlike this and we're given a k value now\nthe most brute force way would just be\ncheck every single substring right\nand if we were checking every single sub\nstring in the entire input array we know\nthere's n squared sub string so that\nwouldn't be the simple\nthat wouldn't be the most efficient way\nto do it but even if we were doing it\nlike that what exactly are we\nlooking for if we're looking at a\nparticular substring\nhow do we know if this substring is\nvalid because remember at the end of the\nday\nwe want to maximize the result right the\nresult is going to be the longest\nsub string that contains a single\ncharacter and we can make\ntwo replacements so let's look at this\nsubstring alone\nhow do we know if it's valid well which\ncharacter are we going to replace are we\ngoing to want to replace the b's\nin order to make it all be amount to\nmatch a or would we want to replace the\na in order to match it with the rest of\nthe b's\nof course we're going to replace the\ncharacter that occurs less frequently\nright because the number of replacements\nwe have is\nlimited so we would want to replace the\ncharacter\nthat the characters that are less\nfrequent so in other words\nwe want all characters in a particular\nwindow to\nmatch the most common character\nin that window so what we're going to be\ndoing is we are going to have a\nhash map or a array which is going to\ntake\nevery single character in this case we\nonly have characters a and b\nand we're going to count the number of\noccurrences of each character\nso for example if we were looking at\nthis substring we see that there's three\nb's and we have a single\na so how do we know if this window is\nvalid what we're gonna do is we're gonna\ntake\nthe length of the window which is gonna\nbe four\nright we're gonna take the length of the\nwindow right which we know in this case\nis four\nand we're gonna take the length or the\ncount of the most frequent character in\nthis case\nwe know that that's b and the count of\nit happens to be\nthree so we're gonna take four minus\nthree and\nfrom that we're gonna get a one now what\ndoes this value one tell us\nit tells us the number of characters in\nour window right\nnow that we need to replace in order to\nmake it\nmatch the most frequent character b\nright we have a b here\nwe want everything to match a b in this\ncase we only have an a right but it\ncould be possible like\nwho knows maybe that we would have a c\nover here right or an x\nover here and it doesn't really matter\nwhat the characters\nare we just know that b is the most\nfrequent character in the window\nand the other characters that are not b\na and z\nfor example are the characters we want\nto replace so we can calculate the\nnumber of characters we want to pull\nthat we want to replace just like this\nand so so we want to replace one\ncharacter how do we know if we have\nenough\nreplacements to do one character well of\ncourse that's our input parameter\nk right so what we're confirming here is\nthat\nthis value is less than or equal to\nk as long as this condition is true\nthat means our current window is valid\nthat means we have enough replacements\nto make those replacements\nin our current window so this is the\nmain condition that we're going to be\nchecking the other question is how are\nwe going to know which character is the\nmost frequent well\nthe brute force way is gonna be taking a\nlook at our map\nof counts and we know that the max size\nof this could possibly be\n26 because we'd only have 26 different\ncharacters\nso doing finding the max character is\ngoing to be big o of 26 so that's\na little bit more inefficient than we\nwould like but it's technically still\nlinear time like the overall algorithm\nis still going to be linear time\nthe the last thing that we're gonna have\nto do though is to this\nuh equation we're gonna have to add a\nsliding window technique so basically\nwhat we're gonna do is we're gonna take\nour window\nstart at the beginning expand it as much\nas we can as long as the\nthe condition that we mentioned is valid\nif the condition is not valid then we're\ngoing to take our left pointer\nand then take our left pointer and then\nshift it as well\nuntil the string becomes valid once\nagain\nso we're going to have a left and right\npointer so initially left is gonna be at\nthe beginning and\nright is also gonna be at the beginning\nand also the counts of a\nand b are initially gonna be zero now\nwe're gonna look at the first character\nright\nthat's where our right pointer happens\nto be we're gonna look at it we're gonna\nsay okay we have a\nwe have a single a right we're going to\ntake our count of a\nand set it to 1 now so is this\nwindow valid as in can this window be\nthe exact same character\nwith within two replacements of course\nit can right that's kind of the trivial\ncase but\nwe would still calculate it and the way\nwe would calculate it is get the size of\nour window right now we can see the size\nof our window is\none subtracted by the count of\nthe most frequent character in this case\nwe know the most frequent character is a\none minus one\nis that greater is that less than or\nequal to k we know k is two so of course\nuh this is going to equal zero zero is\nless than equal to two which is k\nright so of course this window is valid\nthat's kind of a trivial case\nnext we're going to shift our right\npointer to the next character right\nso now we have a b so we're going to\nincrement the count of b in our map\nso b is now going to be set to 1. in\nthis case the length of our window is 2\nthe most frequent character is either of\nthese right and the\nthe count of that frequent character is\ngonna be one so we're gonna have two\nminus one equal to one\nso this is the number of replacements\nthat we would have to do and\nlooking at our current window that makes\nsense right we'd have to replace at\nleast one of these two characters\nso we're going to ensure that this the\nnumber of replacements that we need to\ndo is less than or equal to k which is\ntwo of course that's true so\nour window is currently valid i guess i\ndid forget to\nupdate our result so since this window\nis valid the length of the window is\ngonna be\nset to the result right so right now the\nresult is two two is the length of the\nlongest window that we can get\nso that's our result for now so now\nlet's continue next we're gonna shift\nour right pointer to the third character\nso now\nwe get another a so we're gonna take the\ncount of a\nand increment it all the way to two and\nwe're basically going to repeat our\nalgorithm so once again we're gonna get\nthe length of the window three minus the\ncount of the most frequent character we\nsee the most frequent character is\na so the count of is two three minus two\nis one\nis that less than or equal to two which\nis k yes of course it is so\nthis window is also valid we can update\nour result now to three so we found\nanother window even longer so i'm going\nto take\nour right pointer once again and then\nshift it over to the b\nso now we're going to be since we\nreached another b we're going to\nincrement the count of b\nto 2 now and so the length of our window\nnow is 4\nand the count of the most frequent\ncharacter is either of these and that's\ngoing to be 2\n4 minus 2 is equal to 2. is that less\nthan or equal to k\nk is 2 in this case so of course once\nagain this condition does hold so\nonce again we found a window that's\nlonger than our result we found a window\nnow of length\nfour and so once again we're going to\ntake our right pointer and shift it so\nnow\nanother b let's increment the count of b\nto three so the length of the window now\nis five\nminus the count of the most frequent\ncharacter charac that character is b\nfive minus three is this two in that and\nless than or equal to k\nof course it's still true because when\nyou look at our window\nwe have three b's so that means we're\ngoing to be replacing the a's\nso we're gonna need to make two\nreplacements and we are allowed to make\ntwo replacements\nokay so now we're finally gonna get to\nthe case that i mentioned earlier where\nwe're gonna have to take our left\npointer and then slide it to the right\nwhich is why this is a sliding window\nproblem so now we reached an\na so we're gonna take the count of a and\nset it to three so now we have a\ncount three and b count three so let's\ntake the size of our window six\nsubtract from it the count of the most\nfrequent character it's gonna be\neither of these so six minus three means\nwe need to make three replacements\nis that less than or equal to k k is two\nso we exceeded k right we exceeded the\nnumber of replacements we're allowed to\nmake\nif we wanted this window to be valid we\nhave to replace three characters in it\nbut we're not allowed to do that so what\nwe have to do\nis shrink the size of our window until\nwe\nare valid so we're going to take our\nleft pointer and\nshift it to the right so now the left\npointer is going to be over here it's\ngoing to be at the b\nso since we removed this a from our\nwindow\nwe have to decrement the count of a in\nour window so i'm going to cross this\nthree out and now it's\nactually going to be set to 2. i kind of\nran out of room but i hope this is still\nreadable\nso now the count of a is two so now\nlet's once again\ncheck is our window valid well the size\nof the window now is\nfive and the count of the most frequent\ncharacter is\nb and that's gonna be three so five\nminus three is gonna be equal to two\nis that less than or equal to k yes we\nare once again\nvalid so this is technically a valid\nwindow and i think i forgot to update\nthe result earlier when we had a window\nof size five so\nthe result right now would be size five\nbecause the longest window we can make\nis either this window or the window that\nwe had\nuh earlier with you know these first\nfive characters\nbut yeah and so at this point we would\nstop our algorithm because we did find a\nwindow of\n5 that is valid and our right pointer\ncannot be shifted\nanymore so this is the general algorithm\nso it's a basic sliding it's a\nfundamental sliding window problem with\nthis particular condition\nbeing important but there's actually one\nway you can do it without\nhaving to look through the entire\nhashmap\nevery time you want to find the most\nfrequent character\nthat occurs and it's kind of tricky\nto arrive at the solution but it's\npretty easy to implement once you can\nfigure it out\ni'll explain the algorithm at a high\nlevel i don't want to waste too much\ntime on it but basically we're going to\nbe having another variable\nand it's going to be called max\nfrequency basically the count of the\nmost frequent character at any given\ntime\nso basically you know for example if we\nhad a as\na count of three and b is count two we'd\nsay okay the count of the mo\nthe most frequent character occurs three\ntimes so max f is going to be three\nand so any time you know if we got a b\nwe inc\nlet's say we incremented our b all the\nway up to four then we want to update\nour max frequency to four right so we'd\nalways want this to be the most frequent\ncharacter\nnow the one problem is if we're trying\nto maintain the count of the most\nfrequent character\nwhat happens when we take our left\npointer for example right and then\nshift it right when we do that we're\nbasically removing a character\nand therefore we're gonna have to update\nour count map right we are gonna do that\nbut and if that does happen right let's\nsay we took b and then\nfrom four we decremented it all the way\ndown to\ntwo for example then we have to rescan\nthis entire map\nand then find okay what's now what's the\nnew most frequent character right so\nwe'd have to take our max frequency\nand from four downgrade it all the way\nto\na three for example so then we'd have to\nset it to a three\nbut and that would basically defeat the\npurpose right we'd still have to do that\nbig o of 26 calculation to scan through\nthis\nbut it's technically true that you\ndon't have to decrement this max\nfrequency\nbut the main idea is this the result\nis only going to be maximized as we find\na\nnew max frequency right because remember\nwhat we were doing we were taking the\nlength of the window\nsubtracted by the max frequency right\nwhatever the most occurring character\nwas and we wanted to minimize this right\nso basically we want the\nlength we want the length to be\nmaximized because that's what our result\nis going to be set to\nso therefore we also want the max\nfrequency to be maximized because we\nwant to ensure\nthat this is less than or equal to\nk and k is going to be a constant\nso for example let's say i had a max\nfrequency of four\nbut let's say now the new max frequency\ngot downgraded to a three i'm\nstill gonna leave this as a four because\nit's not going to\nchange our result because for example if\ni had a\n6 minus 4 that was that was less than or\nequal to k which is 2 in our example\nand if i leave this as a 4 i'm basically\noverestimating what the max frequency is\nbut we know at least at\none given point in time it was a four so\ntherefore we were able to take the\nlength\nsix and then set it equal to our result\nand now\nif we're ever so let's say our result is\nnow six if we're\never going to increase the result from 6\nto another\nnumber like for example 7 we would\nrequire\nour max frequency to increase if it\nstays the same\nor if it decreases our result is never\ngoing to change because we only change\nour result\nwhen we increase our max frequency\nbecause that's the only way\nthis condition here is going to be true\nso\nif our max frequency is downgraded we\ndon't have to actually update it we\ndon't have to look through the entire\nhash map to find the new max\nfrequency but if we increase our max\nfrequency for example if i took this\na and then from three i set it equal to\na five\nthen that's that's something we can\ncheck and big o of\none time and then if we increase this\nthen we definitely\ndo want to update our max frequency and\nincrease it and that's something we can\ndo in big o of one time so\ni know i probably went a little too long\ninto this but the main idea here\ni'm trying to get at is the easy way to\nsolve this problem with a sliding window\nis going to be big o\nof 26 times n which is technically\nlinear but there is a\nclever way to do this in big o of end\ntime that honestly i didn't figure out\non my own and i wouldn't really expect\nother people to be able to figure it out\non their own like in an interview at all\nbut i will show this the standard\nsolution and i'll also show the code for\nthis more optimized solution\nokay so now let's jump into the code and\nthe code is actually a lot easier than\nthe visual example that i gave a lot\nshorter for sure so we're gonna have a\nhash map to count the occurrences\nof each character and we're also gonna\nhave a result which is going to tell us\nthe longest\nsubstring that we can create with k\nreplacements and we're going to have a\nleft pointer which is going to be at 0\nand then our right pointer is going to\ngo through every single position\nin the entire string s so what we're\ngoing to do\nis for the character at position r we're\ngoing to increment the count of it\nwe're going to take 1 plus whatever the\ncount currently was\ncount dot get this character and if the\ncharacter doesn't exist in our hash map\nwe're just going to return a default\nvalue of zero that's what this function\nis doing\nand so before what we're going to\nobviously do is update our result right\nand we want to set the result equal to\nthe max that it's ever been\nand set it basically equal to the size\nof the window we can get the size of the\nwindow\nso we're going to take the max of result\nand the size of the window the size of\nthe window can be gotten with\nright minus left plus one and\nbut before we do this before we update\nthe result we want to make sure that the\ncurrent window is\nvalid so what i'm going to do is\nbasically say while and i don't think\nyou'd actually need a while here you\ncould just do if but i'm just going to\ndo while just\nbecause so while the window is not valid\nand we would know that by taking the\nlength of the window which we have down\nhere so i'm just going to copy and paste\nthat the length of the window\nsubtracted by the most the count of the\nmost frequent character which can be\ngotten with max\nof count dot values\nright we're basically going through the\nhash map which could be size 26 and just\ngetting the max value from it\nso this is the number of replacements\nthat we have to do and if the number of\nreplacements was\ngreater than the number of replacements\nthat's allowed which is equal to k\nthat's when we would want to shift our\nleft pointer so we'd want to increment\nour left pointer\nbut before we increment the left pointer\nwe'd want to take the count of the\ncharacter\nat the left position and then decrement\nit\nby one and that is the entire algorithm\nafter all of that is done after we've\ngone through the entire string then we\ncan just simply return our result\nand as you can see this is pretty\nefficient it's linear time it's about\nas efficient as you would need i think\nbut i'm going to make that slight\noptimization that i showed you i'm going\nto maintain the max frequency in a\nsingle variable\nso that we won't have to do this\noperation where we're getting the max of\nthe entire\nhash map instead up here before we\nexecute that loop i'm going to say max\nfrequency is going to be equal\nto the max of what it currently is max\nfrequency or\nit's equal to the frequency of the\ncharacter that we just added a value to\nmaybe that character became the most\nfrequent character\nso we would have to update our max\nfrequency and we can do that\njust like this and this is a constant\ntime operation we're not scanning any\nlist or anything\nand then once we have this max frequency\nwe can use it in\nthis loop execution right so we can\nreplace this\nand just use max f for that and the\nthing is\nnotice how even when we're shifting left\nwe're incrementing the left pointer\nwe're potentially removing characters\nfrom our window we're still not\ndecrementing max f because we actually\ndon't need to\nit won't end up affecting the result if\nwe for if we just don't decrement it\nand that very slight optimization which\nis really simple\nin terms of code but it's kind of hard\nto see why we're allowed to do that\nwatch how much more efficient it makes\nour algorithm\nso as you can see look it definitely\nimproved it i think it was\n50 milliseconds different so this is\nsignificantly faster\nit's hard to see why though i would\ndefinitely\nnot expect most people to be able to\nfigure that out\nso i hope that this was helpful if it\nwas please like and subscribe it\nsupports the channel\na lot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Permutation In String",
        "NcLink": "permutation-string/",
        "Pattern": "Sliding Window",
        "Description": "You are given two strings `s1` and `s2`.\n    \nReturn `true` if `s2` contains a permutation of `s1`, or `false` otherwise. That means if a permutation of `s1` exists as a substring of `s2`, then return `true`.\n\nBoth strings only contain lowercase letters.\n\n**Example 1:**\n\n```java\nInput: s1 = \"abc\", s2 = \"lecabee\"\n\nOutput: true\n```\n\nExplanation: The substring `\"cab\"` is a permutation of `\"abc\"` and is present in `\"lecabee\"`.\n\n**Example 2:**\n\n```java\nInput: s1 = \"abc\", s2 = \"lecaabee\"\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= s1.length, s2.length <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "UbyhOgBN834",
        "PythonSolution": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        if len(s1) > len(s2):\n            return False\n\n        s1Count, s2Count = [0] * 26, [0] * 26\n        for i in range(len(s1)):\n            s1Count[ord(s1[i]) - ord(\"a\")] += 1\n            s2Count[ord(s2[i]) - ord(\"a\")] += 1\n\n        matches = 0\n        for i in range(26):\n            matches += 1 if s1Count[i] == s2Count[i] else 0\n\n        l = 0\n        for r in range(len(s1), len(s2)):\n            if matches == 26:\n                return True\n\n            index = ord(s2[r]) - ord(\"a\")\n            s2Count[index] += 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] + 1 == s2Count[index]:\n                matches -= 1\n\n            index = ord(s2[l]) - ord(\"a\")\n            s2Count[index] -= 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] - 1 == s2Count[index]:\n                matches -= 1\n            l += 1\n        return matches == 26\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem permutation in a\nstring and there's actually two\nsolutions to this problem one is the 26\ntimes n solution and there's another\nsolution that's actually just big o of n\nnow we know that a constant number here\ndoesn't actually affect the overall time\ncomplexity but that being said i'm still\ngoing to focus on the slightly more\noptimal solution uh because it's a\nlittle bit more difficult but it's also\ninteresting and it's a pattern that's\nactually used in other leak code\nproblems as well so we're given two\nstrings s1 and s2 and all we want to do\nis return true if the string s2 contains\na permutation of s1 and we return false\nif that's not the case now you can get\nbogged down and really confused with the\nexplanation of this problem like\nfocusing a ton on permutations but i'm\ngoing to try to simplify this for you\nimmediately without going down too many\nrabbit holes and let's actually take a\nlook at this first example so we see\nthat s1 is the target string that's what\nwe're trying to look for we're looking\nfor a permutation of this string\nsomewhere inside of s2 can we find it\nnow what does permutation mean well we\ncould actually you know create a\npermutation of the string which would be\nreally complex and annoying\nbut we see that over here there actually\nis a substring of s2 and it's a\npermutation that matches s1 it's ba\nright the exact same characters just in\na different order which is perfectly\nfine now by the way a b itself\ntechnically counts as a permutation of\nitself so this string is also allowed\nbut since you kind of see what we're\nreally just looking for is is there a\nsubstring of the exact same size so this\nis two characters so we have to look for\na substring of two characters here right\nwe can't just take three characters and\nsay that that's the permutation but you\nknow we're looking for a window same\nsize as this and it has to contain the\nexact same characters as s1 just maybe\nin a different order now does that kind\nof sound familiar to you well it's the\nsame thing as looking for an anagram\nright we're just looking for the exact\nsame characters we don't care about what\norder they're in right so it's looking\nfor an anagram so we can actually use a\ntypical sliding window technique we're\ngoing to look at every window in s2\nthat's the exact same size as s1 so in\nthis case length 2. so we're going to\nlook at the first two characters then\nthe next two characters the next two etc\netc until we find an exact match with s1\nnow if we were actually comparing the\nexact characters that would be pretty\nannoying the time complexity in that\ncase would let's say be n times m where\nn is the size of s2 m is the size of s1\nbecause we're looking at every single\nwindow but we can do it a little bit\nbetter we can reduce it to be 26 times n\nif we use a hash map because actually in\nthis problem it's written all the way at\nthe bottom of the description so it's\nnot on screen but they tell us that all\nthe characters in both of the strings\nare going to be limited to lowercase a\nthrough lowercase z so therefore the\nsize of our hashmap is going to be at\nmost size 26. there's only 26 characters\nso as we build that hash map we're\nactually going to have two hash maps\nwe're going to have one hash map for s1\nwhich is going to stay the exact same\nwe're also going to have a second hash\nmap for s2 which is going to have the\ncharacters of the current window that\nwe're at so every time we create a\nwindow right each time we shift our\nwindow to the right we're only just\nadding one character and maybe removing\nthe character that was on the left and\nthen once we have those two hash maps\nwe're going to compare them if they are\nequal which is a 26 operation right\nthere's only 26 characters and so that's\nwhere we get this time complexity from\nbut there actually is a better way this\nsolution is doable it's easy to code up\nand you can do so if you would like but\ni'm going to show you the slightly more\noptimal solution which is actually not\neven going to have this 26 it's just\ngonna be big o of n so let's look at the\nbig o of n solution and it's actually\nsimilar to the previous solution we\ndiscussed we're actually going to still\nhave two hash maps one for s1 so as you\ncan see we counted the occurrences of\neach character we call it s1 count so we\nhave one a we have one b and one c so we\nfilled our hash map with the same values\nand rs2 hash map is empty because first\nwe're going to set our window here and\nthen we're going to continue to shift it\nby one each time but the difference here\nis we're not actually going to be\ncomparing the two hash maps together we\nwon't need to because we're going to\nkeep track of one more variable we're\ngoing to call it matches\nwe're basically going to have a little\nshortcut initially this is going to be\nset to zero i'll just create a box for\nit even though it's just going to be a\nsingle\nvalue but we might be updating it to\nother values but this matches variable\nis basically going to be a shortcut\nthat's going to allow us to not have to\ncompare the entire hash maps each time\nwhich we know in the worst case could be\na 26 operation having to look through\nevery single character of the hashmaps\nbecause this matches variable is\nactually gonna maintain the total number\nof equal characters in each of these\nhash maps and actually even though i\ndidn't draw the entire\nmap for s1 and s2 in this case because\nactually we know that there's a through\nz there's 26 characters and i didn't\nactually draw the entire thing but we\nare gonna\nyou know fill in the values in the code\nbecause we know that the rest of the\ncharacters in s1 are gonna be of count\nzero right and matches is gonna tell us\nthe exact number of matches of each\ncharacter between the two hash maps so\nwe want to know does\nthe a count of s1 and of s2 match if it\ndoes match then that's a plus one if it\ndoesn't match then that's not a plus one\nright and we want to know the number of\nmatches for every single character and\nwe want to know that initially right it\ncould be 26 matches or it could be zero\nmatches right it could be any value in\nbetween but once we have 26 matches that\nmeans that for some window in s2 and by\nlooking at it we know that this is going\nto be the window we know that this\nwindow has 26 matches with this window\nbecause they both have a single a\ncharacter a single b character a single\nc character and for the other remaining\n23 characters they have\nthey both have zero of those characters\nso therefore they have 26 matches that's\nwhat we care about and we can do that\nwith a single variable without having to\nlook through the entire hashmap let me\nshow you the algorithm to do that it's\npretty straightforward actually so first\nthing we're going to do is actually just\nlook at the first three characters of s2\nand then fill up our hash map so we have\na single b we have a single a and we\nhave a single x now you can see that\nthis is what our hash maps actually look\nlike we have looked at the first three\ncharacters and now what we're actually\ngoing to do for the only time we are\nactually going to iterate through both\nof these hash maps comparing each\ncharacter we actually do have to do that\nat least one time but it's a single 26\noperation so and then after that we'll\nonly have to just iterate through this\nstring so the overall time complexity is\ngoing to be n plus 26 which we know is\ngoing to be equal to big o of n uh it's\nit's definitely better than if we were\njust doing 26 times n okay so we're\ngonna look at every character a they\nboth have one a they both have one b\ns one has a single c\nbut s two does not have any c's so\ntherefore they have two matches a and b\nbut c is not a match then we're going to\nlook at all the other characters after c\nand we're actually going to see that yes\nthere is a match\nright because they both have zero d's\nthey both have zero e's they have zero\nf's etc etc but then we're going to get\nto x okay\nthis has a single x but s1 does not have\nany x's that's not a match but they both\nhave zero y's and zero z's so all in all\nthey actually matched every single\ncharacter except for c and except for x\nthose were the only characters they\ndidn't match so actually initially we\nhave 24 matches next we're gonna look\nwe're gonna take our window which was\nlike this and we're gonna shift it to\nthe right by one when we shift it we're\nobviously removing a character from the\ns2 window we're removing a b now as we\nmake changes to the count we want to\nknow does it affect the number of\nmatches so here we have one right which\nwas equal to what it was supposed to be\nin s1 as well but now we're now changing\nit to a zero so therefore it's not\nmatching with what it previously was\nmatching with therefore our matches\ntotal is actually going to be updated\nnow to be 23 we're decrementing it by\none okay but we also added a character a\ny does this affect our matches was this\na character we were looking for well\nlet's increment our i by one and we see\nthat now it's one but what was the y\nvalue in s1's count it was equal to 0 so\nnow we actually created another mismatch\nso actually the total number of matches\nis gonna be 22 now and now we're going\nto actually shift one more time so this\na is no longer gonna be in our window\nnow we're gonna have x y z in our window\nso we remove the a a count is now gonna\nbe set to zero we created another\nmismatch so our matches count is now\ngonna be 21 but we added a z so\nour z count is one but the z count in s1\nis zero therefore we created another\nmismatch so now our total number of\nmatches is actually going to be 20. now\nlet's shift our window one more time\nlet's chop off this x so x count is now\ngoing to be set to zero so let's update\nthat x count is now set to zero which is\ngood for us because s1's x count was\nalso zero so therefore we can actually\nincrement our number of matches now\nright so let's uh set matches now equal\nto 21. we also added a character we\nadded this a character at the top so\nlet's actually increment the number of\na's we went from having zero a's to now\nhaving one a and that's what we were\nlooking for right because one a is also\nfound in s1 count so now we can\nincrement our number of matches from 21\nto b22 we're getting closer to our goal\nand i'm gonna kind of fast forward the\nremaining two spots clearly we're gonna\nsee that the y gets chopped off and then\nwe're gonna be two we're gonna add the b\ncharacter which is also what we wanted\nto do right we have one b and we have\nzero y's so that brings us to be 24\nmatches and then we're gonna shift one\nmore time uh to be at this last window\nwe're gonna get rid of the z that we\nthat we didn't really need so now our\nnumber of z's is zero that's good that's\nexactly what we want and we added a c\ncharacter so now we have one c now we\nhave the exact number of matches we were\nlooking for that our matches count is\ngoing to be 26 whenever we get to 26\nmatches that's our magic number we are\ngoing to go ahead and stop the algorithm\nand return true because all we're\nlooking for is does there exist a single\npermutation of this in s2 or in other\nwords does there exist an anagram of s1\nand there does we found it we return\ntrue immediately and we can stop the\nalgorithm that's the big o of end time\nalgorithm now let's actually code it up\nokay now let's write the code but\nthere's just one little edge case we\nactually have to look for that i didn't\ntalk about previously and that's if our\ns1 string is actually shorter or\nactually rather longer than our s2\nstring\nwhich would make it impossible for us to\nfind a permutation of s1 in s2 in that\ncase we can just return false\nimmediately but after that we can get\ninto our standard algorithm even though\ni was talking about hashmaps we can\nactually implement these with arrays as\nwell because we are getting fixed values\nuh lowercase a through lowercase z and\nwe can convert those characters to be\nuh integers and we can use those\nintegers as indices indexes of our two\narrays so initially i'm just going to\nset these to be 26\nnumbers and each of those numbers is\njust going to be a 0 for now uh we're\ngoing to go through every character in\ns1 and we're gonna go so suppose s1 is\nmaybe three characters long at the same\ntime as we're going through s1 we're\nalso going to go through the first let's\nsay three characters of s2 so we're\ngoing to initialize both of these hash\nmaps at the same time so let's do that\nnow so the way we're going to convert\nthese characters so in s1 we're going to\nget the character at the ith indexed and\nwe're going to use the ord function now\ndepending on your language it might be a\ndifferent function all we're doing is\ngetting the ascii value of this\ncharacter with our ord function and\nwe're going to subtract from it the\nascii value of lowercase\nlowercase a let's get this right and\nthis will map to an index this will map\nto one of the 26 indexes and to this all\nwe want to do is just add one to it and\ni'm just going to go ahead and copy and\npaste this line and do the exact same\nthing for s2 we're gonna in s2 count uh\nwe're going to update the count of this\ncharacter and just increment it by one\nso now before we actually get to our\nsliding window portion don't forget we\nactually have to initialize the number\nof matches we're initially going to set\nit to zero but let's compare\neach of these maps or arrays we know\nthat there's going to be 26 spots in the\narray so we can actually just hard code\nthat so now we're going to say\nto the number of matches we want to add\none to it only if\ns1 count at index i is equal to s2 count\nat index i that's the only case where\nwe'd want to increment this by 1 but if\nthat's not the case then we are not\ngoing to increment it by one so we can\njust say else zero right so else\nincremented by zero which is the same as\nnot incrementing it at all let's put\nparentheses here just to clean it up and\nnow we can move on so now we're going to\ndo the sliding window portion we're to\ninitialize a left pointer to be at the\nbeginning so at index uh\n0. so then we're going to have our right\npointer which is actually going to\niterate through every position in s2\nbut we know we don't actually have to\nstart at the first position because we\nalready initialized our windows so we're\nactually going to start at the length of\n1 the length of s1 because this will\nstart us at the next character that we\nleft off at right and this and this\nrange is actually non-inclusive so we\nstopped before we reached this index so\nnow we're actually going to go to that\nindex with our right pointer but\nremember what happens if matches is 26\nshouldn't we return immediately yeah we\ncan put a return statement outside of\nthis for loop but it'll be redundant so\nwe can actually put it as the first\nstatement inside of the for loop so\nbasically if matches is equal to 26 then\nwe are returning true if that ever\nhappens we can immediately return true\nno questions asked but if it's not the\ncase then we have to update the number\nof matches we know that we just visited\na character at index r and this is the\npart where you actually might have hoped\nthat you used a hash map rather than an\narray and that's fine if you want to\nrewrite the code that i'm about to write\nusing hash maps i think it's perfectly\nfine but i feel like i usually overuse\nhashmap so this time i actually wanted\nto kind of show you guys the array\nsolution even though it's a little bit\nmore annoying because remember our\ncharacter is not the key of our array we\nhave to map that character to an index\nand we can do that just like this so s2\nat index r uh minus ord of lowercase a\nso we're also going to take the ord of\nthis because that's how we're getting\nthe index of our count arrays so now we\ncan actually use this index but what are\nwe going to use it for well we know that\nthis character is the character that was\njust added to our uh window in our s2\nstring so we're gonna increment the\ncount of this by one but now that we\njust incremented the count of it by one\nit could be possible that now it exactly\nequals the count in s1 so if that's the\ncase if now that we incremented this and\nnow it finally equals exactly s1 count\nat the same index at the same character\nthen\nwe can increment our number of matches\nby one but it's possible that also by\nincrementing this instead of making it\nexactly equal we made it too\nlarge we made it exactly bigger than the\ntarget by one that's how you know we\nhave got to actually decrement the\nnumber of matches so basically else if\ns1\ncount at the same index plus 1 is now\nexactly equal to s2 count at the index\nand if this is the case that means they\nwere equal they were exactly equal but\nwe just incremented s2 count by one so\nnow we made them unequal so then we\nactually have to decrement the number of\nmatches by one okay and that's pretty\nmuch the entire algorithm but there's\none last thing and i'm just going to go\nahead and actually copy and paste this\nentire block\nbecause we're going to do the exact\nopposite thing we know that we're adding\na character to the right of our window\nbut at index l at index left we removed\na character so we're just going to\nreplace this with the opposite case\nright here i replace the r with an l and\nhere instead of incrementing the count\nwe're going to decrement the count\nbecause this is the character that we\njust removed from the left side of our\nwindow and here what we're going to say\nthis is actually going to stay the same\nif somehow by decrementing this we made\nthe counts exactly equal then we're\ngoing to increment our matches by 1. but\nif somehow by decrementing this value we\nchanged it from being exactly equal to\nnow being too small meaning it's now\ngoing to be equal to s count s1 count\nminus 1. if we changed it from being\nexactly equal to now being slightly too\nsmall that's when we are going to\ndecrement the number of matches right so\nwe really didn't have to make too many\nchanges to this block of code but that's\nactually the entire algorithm except we\nknow our right pointer is being\nincremented by one each time but we also\nwant to make sure our left pointer is\nbeing incremented by one each time as\nwell and after that we are done then\nfinally we can return false well not\nquite because it's possible that after\nour loop eggs are exited right the last\niteration of our loop we didn't check\nafter that if our matches were equal to\n26 so instead we're actually going to\nreturn\ndoes matches equal 26 so it's going to\nreturn true if it does equal 26 it's\ngoing to return false if it doesn't\nequal 26 now let's run the code to make\nsure that it works and on the left you\ncan see that it does and it's pretty\nefficient so i really hope that this was\nhelpful if it was please like and\nsubscribe it really supports the channel\na lot consider checking out my patreon\nwhere you can further support the\nchannel and hopefully i'll see you\n"
    },
    {
        "Name": "Minimum Window Substring",
        "NcLink": "minimum-window-with-characters/",
        "Pattern": "Sliding Window",
        "Description": "Given two strings `s` and `t`, return the shortest **substring** of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `\"\"`.\n\nYou may assume that the correct output is always unique.\n\n**Example 1:**\n\n```java\nInput: s = \"OUZODYXAZV\", t = \"XYZ\"\n\nOutput: \"YXAZ\"\n```\n\nExplanation: `\"YXAZ\"` is the shortest substring that includes `\"X\"`, `\"Y\"`, and `\"Z\"` from string `t`.\n\n**Example 2:**\n\n```java\nInput: s = \"xyz\", t = \"xyz\"\n\nOutput: \"xyz\"\n```\n\n**Example 3:**\n\n```java\nInput: s = \"x\", t = \"xy\"\n\nOutput: \"\"\n```\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `1 <= t.length <= 1000`\n* `s` and `t` consist of uppercase and lowercase English letters.\n",
        "Difficulty": "Hard",
        "Video": "jSto0O4AJbM",
        "PythonSolution": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if t == \"\":\n            return \"\"\n\n        countT, window = {}, {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n\n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n\n            if c in countT and window[c] == countT[c]:\n                have += 1\n\n            while have == need:\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n                    \n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l : r + 1] if resLen != float(\"infinity\") else \"\"\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nminimum window substring we're given two\nstrings\ns and t and we want to return the\nminimum\nwindow in the string s which contains\nevery single character present in\nstring t and it's possible that that\nmight not even exist\nin which case we can return an empty\nstring\nso in this case our string s is this big\nlong string\nand our string t is this a b\nand c so we just need we don't need to\nfind\na b c in here we just need to find\na substring of s that contains\nall these characters and we want to find\nthe minimum string that contains all\nthese characters\nso one possible string is\nthis right it has a d o b\ne c so it has a b and c\nbut there happens to be a shorter string\nthat has\nall of those as well this string b a\nand c so they are out of order so b\na c and there's an n in there as well\nbut this happens to be the shortest one\nit's length four and so that's the\nresult that we're going to output\nso what's even a brute force way to\nsolve this so we're given\ns and t right and we want like if we're\nchecking\na substring right like this substring\nmaybe this is our solution right\nhow do we even determine that well let's\nuse some hash maps\nso these two are our hash maps you can\nsee i have one for t\nwhat does this hash map represent well\nyou look at t right\nbecause for each of these substrings we\njust want to make sure\nthat it has at least one a right\none a has at least one b\nand it has at least one c because that's\nwhat we have over here we just want to\nmake sure\nthat we find the minimum substring in\ns that satisfies this condition\nso for every possible window that we\ncheck in s like maybe we check\nthis window we are gonna want to have a\nhash map for the window and we're gonna\ncount how many a's do we have initially\nwe're gonna start with zero right\nbecause\nbecause initially our window is gonna be\njust empty or whatever\nwe're gonna start with zero b's and zero\nc's but for this\ncurrent window you can see we have one a\none b and one c right so\nwe have one a one b and one c so\nas we compare right we compare how many\na's do we have versus how many do we\nneed right this is how many we need and\nthis is how many we have in our current\nwindow\nyou can see we need one and we have one\nright\nso the relationship we're looking for is\ngreater than or equal right we want the\ncounts\nall to be greater than or equal but one\nthing you can see is brute forcing\nis gonna be difficult right so let's say\nwe initially start with\nthis window right we see we just added\nan a so what are we gonna do we're gonna\nupdate this now let's just check is our\nwindow valid\nwell we have at least one a and so\nremembering that this is how many we\nhave in our current window and this is\nhow many we need to satisfy the\ncondition\nso initially let's start with this\nwindow just\none a so then we can update our count\nfor this window right add\na single a so now my question is have we\nsatisfied the condition do we have\neverything we need\nwell how are we going to check that well\nwe have to check\nall of these right so is the have count\ngreater than or equal to the need yes it\nis what about\nthis is the beat count uh greater than\nor equal to\nhow many we need the answer is no right\nso therefore we don't have how many we\nneed\nso therefore we have to actually expand\nour window right we have to add another\ncharacter\nthis d right but that's not actually\ngoing to update\nour window because we don't need any\ncharacters other than a b\nor c so we don't really care about the d\nthe same thing is true for the o\nbut now we have a b right that's good\nbecause we do need a b\nso we add a b so now we're gonna have to\nrun the same operation do we have\neverything that we need so we're gonna\nbe doing some repeated work do you\nnotice this repeated work we're doing\nwe have to check if we have enough a's\nwhich we know we do because we already\nchecked that when we first added this\nelement so we notice we do have enough\na's\ndo we have enough b's well this time we\nactually do because we just added a new\nb\nright that's the most recent character\nwe added great so we know we have enough\nb's\ndo we have enough c's we do not have any\nc's\nin our string the count is zero\ntherefore this condition is not\nmet so we do not have our result yet we\nhave an a and we have a b\nbut we need to add more so now we're\ngonna add an\ne which we don't really care about we're\ngonna add a c\nso finally we have so finally we can see\nthat we met\nour condition right but we with our\ncurrent algorithm our brute force way we\nhave to repeatedly check\nevery one of these even if we already\nknow the count is\nmet so this is basically where our\nrepeated work this is what i'm going to\nshow you how to eliminate but\nas you can see we have enough a's we\nhave enough\nb's we have enough c's so therefore this\nis a\npossible result it might not be the\nminimum but it's a possible result and\nwhat's the length of this\nit is 6. so we can say for now\nthat our result is length 6 and it goes\nfrom index\n0 all the way to index five\nso i'll put zero five that's our current\nresult\nso one thing we noticed is we're having\nto do a lot of repeated work\nto check that we have everything that we\nneed we have to check\nevery single one of these characters\nright\nbut we don't we know we don't always\nhave to do that so let me show you how\nto do it without repeating all of that\nwork\nwe're going to start out the same way so\nwe're going to add an a right that's our\nfirst character\nso now we're going to check so now what\nwe're going to say is a count\nis 1 right so now my question is do we\nhave to check\nevery single one of the halves because\ninitially we\nknow that none of the conditions have\nbeen met right\ninitially we start with all zeros we\nalso\nknow that the number of characters that\nwe need\nis gonna be three right meaning\nwe need to satisfy the count condition\nfor three\nunique characters right and we know that\nwe\nstart out with a have value of zero\nbecause we know for each of those three\ncharacters\nwe have met the condition for none of\nthem right initially we met the\ncondition for none of them because we\nstart out with all\nzeros but now you can see we just added\nan\na so let's check just for this one\ncharacter\nhave we met the condition is the count\ngreater than or equal\nthan one yes it is we have one and we\nonly\nneeded one so we met the condition so\nwhat does that mean\nwe can take our have value and update it\nso initially it was zero\nnow we can change it to one so now we\nhave one but my question\nnow is have we met the condition well we\nneed three but we only have one so we\nhaven't met the condition\nyou can see what i'm doing here right\nbefore we needed to check the condition\nfor\nall three of these each time now we only\nhave to check the condition\nfor one we have one value that tells us\nhow many we have\nwe have one value that tells us how many\nwe need so before we were\nwe had to continue running an operation\nof length\nt which is in this case 3 but who knows\nit could have been bigger\nt could have been 10 it could have been\n100 it could have been anything\nand we would be bounded by that but in\nthis case we only have to do\none operation for comparing these\nintegers\nand one operation for comparing the\nintegers of the character\nthat we just added so for each character\nthat we add\nwe only have to do an o of one operation\nso now let's add another character let's\nadd the d we know that doesn't really do\nanything\nwe add the o that doesn't do anything we\nadd a b this is good so\nhow am i going to do things differently\nthis time well like usual\ni'm going to change this one this zero\nto a one we know we have\none b so now i'm going to check has this\ncondition\nbeen met or is it equal\ni know last time i showed you greater\nthan or equal but really what we're\nlooking for is\nare they exactly equal because that's\nwhen we know the condition has been met\nso if these are exactly equal which they\nare in this case one equals one so what\nthat means\nis we can increment our have value by\none before it was it was one now we're\ngoing to actually change it\nto two and now let's check are these\nequal now have we me do we have what we\nneed\nit's not because two is less than three\nso we haven't met the condition yet so\nwe have to continue but notice how that\nwas an\no of one operation we just had to make\none comparison here\nand then one comparison here we didn't\nhave to go through the entire list\nso now we're gonna add an e which we\ndon't really care about\nnow we're going to add a c which we do\ncare about so let's update the length\nof this now are these exactly equal\nwe know we just met the condition for\nthese last two\nnow have we finally met our last\ncondition\nand yes they're both one so we can take\nthis\nthrough this two and replace it it's\ngetting a little messy\nbut i hope you can see it so we have a\nthree here so now let's make the\ncomparison\nbetween these two and yes they are\nexactly equal so what that tells us\nis this string contains we have exactly\nwhat we need\nright so we met the condition this is a\npossible result\nand i'm just going to take the two\nindices the start and\nthe ending of it which is 0 and 5 and\ni'm going to put that as our current\nresult\nso our current result is from 0 to 5.\nand the length of that result happens to\nbe\nsix right so now what are we gonna do\nare we just gonna keep adding elements\nagain and again\nwell we wanna find the minimum so let's\nat least try to find\na string that's less than six so what\nare we gonna do let's\nremove the leftmost character and\nkeep doing that until this condition is\nno longer valid until we\ndon't have what we need anymore so we\ncan try to at least find\na smaller result because ultimately\nwe're looking for the minimum string\nso i'm going to take this character and\nremove it from\nour current window and so we're removing\nan\na so what that means is we have to\nupdate this\nso it's no longer one we actually have a\nzero for count\na now and now we know that this\ncondition\nis this is less than what we need it to\nbe so this condition is no longer valid\nso\nthat also means we have to update this\nvalue\nso before we had a three but now we have\nto put a two we only have\ntwo of these conditions matt write these\ntwo characters b\nand c so now we're actually just going\nto keep adding characters we're going to\nkeep\nlooking for the minimum so we add an o\nbut we know we don't care about that we\nadd a d\nwe don't really care about that we add\nan e we don't care about that\nwe add a b over here right we do care\nabout b\nso what are we gonna do we're gonna take\nthe b count\nit's one currently now we have two\nnow that's great because we actually\nhave more than what we need right we\nwe need one but we have two so am i\ngonna take this\nand update it no because they're not\nequal\nwhat that means is we added an\nunnecessary character it's okay\nbut it didn't help satisfy the condition\nwe already know\nthis and this were satisfied this is the\none that needed to be satisfied\nso since it's not exactly equal we're\nnot going to\nincrement our have count so now let's\nadd another character\nthe a that we wanted so badly so\nwe added an a we update the count of a\nwe add one\nso now this is one we're gonna check are\nthey\nexactly equal have we met the condition\nnow\nby adding a character did we make these\nexactly equal\nand we did so what does that mean well\nwe met one more condition\nso we update our have count it's now\ngoing to be set\nto three and now these are actually\nequal\nso we actually met the we have exactly\nwhat we need so we potentially\nfound a result now the only problem is\nthis\nresult goes from index 1 all the way to\nroughly\nindex 10 so it's actually bigger than\nour current result which\nis a problem so we don't update our\nresult yet\nbut now we want to try to find an even\nsmaller substring than this so let's\nstart popping characters from the left\nso we pop a d\nbut d's we don't care about so we don't\nupdate our window\nand let's just keep popping values until\nthis condition is no longer met so\nnow let's pop a b so let's\nnow we have to update our value of b so\nthis was originally two now it's going\nto be set to one\nso now it's set to one so did we or\ndid we undo this condition is this\ncondition no longer valid nope\nbecause this is still greater than or\nequal to the count that we needed\nso the condition is still valid we don't\nhave to update our have count yet\nso actually this string is\nstill a possible result but notice\nthis string goes from index 4 all the\nway to index 10 so it's actually\nlength 7 and that's still greater than\nthis string so we cannot count this as a\nresult yet so now we remove\nthe e and then we remove the c\nso we have to actually update our count\nagain so this was originally\none now it's going to be zero\nand now you can see that this condition\nis actually no longer valid\nso even though these two are still valid\nthis one is not valid we have to update\nour have count\nso our have count was three but now we\nremoved one so it's going to be\ntwo so now it's no longer equal so our\nstring is no longer valid\nit's length five but it doesn't have\na c we have a b we have an a but we\ndon't have a c\nso we can't update our result so let's\nkeep\nadding characters now maybe we'll find\nanother valid string so we add an\nn but we don't care about ends we add\nthe c\nthat we want so we added a c so we\nupdate our c\ncount now it's set to one these are once\nagain\nequal so since they're exactly equal\nthat means we\njust now have met the condition so we\nmet one more condition\nso we can update our have count now to\nthree that means it's exactly equal to\nwhat it needs to be\nthat means this is a valid string so\nthis goes\nthis goes from index 6 all the way to\nindex 12\nthat's a length of 7 which is not\nsmaller than our current result\nbut that doesn't mean we can't shrink\nthis right so let's\nstart from the left and keep popping and\nmaking it smaller\nbut also keep going until it's no longer\nvalid anymore\nso we pop in oh let's remove a\nd but we're still valid right we didn't\nupdate any of these\nand now you see we have a string of\nlength\nfive so we can actually update our\nresult\nso now we're going from index 8 to index\n12\nand that leaves us with a length of 5\nbut we're not done yet we have an e we\ncan remove that\ne as well now you notice we're still\nvalid we have a b\nwe have an a and we have a c\nwe didn't have to update our map our\nhave count is exactly equal to the need\nso now we can update our result one more\ntime\nand it's gonna go from index nine all\nthe way to index\ntwelve that's the string the length of\nit\nis four and lastly we are going to\nremove\nthis b character from it as well and\nonce we remove the b\nyou can see okay we removed this one now\nwe have zero b's remaining\nuh that's less than how many we need so\nwe have to update the have count so we\nset it to\n2 the condition is no longer valid\nand so are we going to continue our\nalgorithm well we have no more\ncharacters\nleft to add we reach the end of the\nstring so\nsince this is our current minimum and\nour current result this is what we're\ngoing to end up returning\nand by the way we just solved this\nproblem\nin big o of n time because you see we\nadded each character\nonce that's an o of one we removed each\ncharacter once\nevery time we added or removed a\ncharacter we did at most\ntwo operations right we had to update\none spot in our map and we had to\npotentially update\nthis right okay so now let's finally get\ninto the code the first thing i'm going\nto do\nis actually handle a edge case so if\nthe input string t which is you know our\nstring is like the substring that we're\nlooking for if it's empty then what i'm\ngoing to do\nis return an empty string because that's\njust how they want us to handle it in\nthis problem\nand i'm going to have two windows that i\nshowed previously so\ncount of t and just the current window\nthat we have they're both initially\ngoing to be hash maps they're both\ninitially going to be empty\nand the first thing i want to do is\ninitialize\nour count t map because we know this map\nactually isn't going to change at all\nso for every character in string t i'm\ngoing to\nadd one to it but the\nvalue i'm going to get i can't just do\nthis because it's possible that\nc hasn't even been added to count t yet\nso i'm going to do some python stuff\ni'm going to use the function get which\nis good for this so i'm going to get c\ni'm going to get the count of c so if c\nexists\nin our map it will give me the value\nthat's stored in here\nif it doesn't exist i can put a default\nvalue which is going gonna be\nzero so if it doesn't exist this\nfunction will return\nzero so that's just a way that i like to\nhandle\nthis case so now that we've initialized\nthe count of t\nwe can have our variables have and\nneed so we know have initially is going\nto be\nzero because we have zero of the\ncharacters we need and\nneed is going to be initialized to the\nlength of\ncount t because that length of count t\ngives us the unique\ncharacters in the string t and then i'm\njust going to start\niterating through every character in\ns so i'm going to use a right pointer\nfor that the r is going to tell us the\nright boundary of our current\nwindow so i'm going to get the character\nthat we just\nreached which is s at index r so i'm\njust going to put it in a variable c\nso with c we know we can update our\ncurrent window so i'm going to do\nwindow of c and add one to it\nfor the character that we just reached\nand here i'm basically doing what i did\nabove if c has never been added to\nwindow we're just gonna\nreturn zero with this function so 1 plus\n0 we'll put a 1 here\nif it does already exist this function\nwill get us the count that was\nstored in here so we're updating our\nwindow we're adding the count to it\nnow we want to know does this count\ncompletely satisfy what we were looking\nfor does\nwindow of c equal exactly\ncount of t that means we just satisfied\na condition for the first time\nbut one thing i also want to check\nbefore i check this\nis that c is even a character in count\nd count t so if c is in\ncount t and this is true because we know\nwe don't actually care about the\ncharacters that aren't even\nin the string t to begin with and we\nknow if this is true we can\nupdate our have count so we can\nincrement it by one\nthis means we just satisfied a condition\nso now what we want to know does\nhave equal need exactly so are they\nactually\nequal if that's true i'm going to run a\nloop and i'm going to show you why it\nneeds to be a loop\nso we actually met the condition let's\none\nupdate our result potentially right so\nif we found a new minimum result let's\nupdate so this actually reminds me that\ni didn't even set a result so let's set\nour result\nand our result length so initially we\nknow our result is going to be a pointer\nlike a left and right pointer so i'm\njust going to give it a default value of\nnegative 1 negative 1.\nand for the result length i'm going to\nput float infinity\nbecause that's a good default value in\nthis case because we are looking for the\nminimum string so any value will\nobviously be less than infinity\nand i'm also going to initialize a left\npointer\nbecause we know r tells us the right\npointer left pointer will initially be\nset to zero\nbut so now we can actually update our\nresult we know the condition has been\nmet\nso if the current length of our string\nwhich is going to be\nr minus left plus 1 this is how you just\ncalculate\nthe size of our current window if it\nhappens to be\nless than the current result length\nwhich\ninitially starts at infinity so this\nwill definitely execute at least\nonce if this is true we can update our\nresult which is stored over here so we\ncan\nset our result to left and right this is\nthe window\nand we can set our result length equal\nto the size of this window which we just\ncomputed above but let's compute it\nagain\nthis is the size of the window and just\nlike i showed you in the drawing\nwhile the condition is met we want to\nkeep shrinking from the left we want to\nmake this string as\nsmall as it can possibly be so let's\npop from the left of our\nwindow right let's try to minimize it so\ni'm going to remove the leftmost\ncharacter from our window map so the\nleftmost character is\nis the string at index left right\nand from this i'm going to decrement it\nby\n1. so now since we removed a character\nit's possible that our have and need\ncondition is no longer met so i'm going\nto do something\nsimilar to what we did up here i'm going\nto check\nif this character s of l was in\ncount t meaning it's one of the\ncharacters that we need to satisfy our\ncondition\nand if somehow right now for the first\ntime\nthat we took this character from our\nwindow and\nnow the count is actually less than the\ncount that we\nneed which is present in count t so now\nif it's\nif the if by removing a character we\njust made it\nless than what it needed to be what we\ndid is we just took our halve\nand then decremented it by one right so\nthis\nis just a part of removing a character\nfrom the left we update our map\nwe update our have count if we need to\nand lastly we take our left pointer and\nincrement it by one because of course we\nhave to shift this by one\nif we're removing a character from the\nleft of our window\nso now after we do this we're going to\npotentially check the have and need\ncondition\nand it might be true it might not be\ntrue and whatever it is the\nloop is going to execute when it needs\nto\nso this is all we're doing we're taking\ncharacters adding it to our window map\nchecking if the condition has been met\nupdating the window accordingly\nthat's all we need to do by the end the\nresult if it exists\nwill be stored in our result variable so\nour result pointer\nwe can put it in uh left and right we\ncan take\nresult and extract it into left and\nright these these pointers in this case\nthese new left and rights will tell us\nthe result so what we can do is\nsay return from string s going from\npointer left all the way to pointer\nright but we need to add one\nfor the off by one error and we're only\ngonna do this\nif the result length has\nnot has been changed meaning it's no\nlonger infinity because we know\nit's actually possible that a result\ndoes not even exist\nif that's not true if a result doesn't\nexist we know we have to return\nan empty string so there it is this is\nthe entire code i'll probably have to\nlink this in the description because\nit's pretty long and even kind of messy\nand you can see it is definitely very\nefficient this is a linear\ntime algorithm so i really hope that\nthis was helpful\nif it was please like and subscribe it\nsupports the channel\nsoon\n"
    },
    {
        "Name": "Sliding Window Maximum",
        "NcLink": "sliding-window-maximum/",
        "Pattern": "Sliding Window",
        "Description": "You are given an array of integers `nums` and an integer `k`. There is a sliding window of size `k` that starts at the left edge of the array. The window slides one position to the right until it reaches the right edge of the array.\n\nReturn a list that contains the maximum element in the window at each step.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,1,0,4,2,6], k = 3\n\nOutput: [2,2,4,4,6]\n\nExplanation: \nWindow position            Max\n---------------           -----\n[1  2  1] 0  4  2  6        2\n 1 [2  1  0] 4  2  6        2\n 1  2 [1  0  4] 2  6        4\n 1  2  1 [0  4  2] 6        4\n 1  2  1  0 [4  2  6]       6\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n* `1 <= k <= nums.length`\n",
        "Difficulty": "Hard",
        "Video": "DfljaUwZsOk",
        "PythonSolution": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = deque()  # index\n        l = r = 0\n\n        while r < len(nums):\n            while q and nums[q[-1]] < nums[r]:\n                q.pop()\n            q.append(r)\n\n            if l > q[0]:\n                q.popleft()\n\n            if (r + 1) >= k:\n                output.append(nums[q[0]])\n                l += 1\n            r += 1\n\n        return output\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today let's look at\na sliding window problem a hard sliding\nwindow problem\nsliding window maximum the statement is\npretty\nstraightforward actually so we're given\nan array of numbers\nand we also are given a number k which\nis going to represent the size of our\nsliding window it starts at the very\nleft\nand then works its way to the right and\nso since it has and so since it's size k\nthere's only going to be k numbers\ninside the\nwindow and for each position that the\nwindow is in\nwe want to return the max value so you\ncan see that this\nis our input array and our our window is\ngoing to be size\n3 so this is our first window\nand the maximum value is 3\nso then we see and then we add a 3 to\nour\noutput array so the output is going to\nbe an array\nnext next we see that this is the next\nposition\nof the sliding window and the maximum\nvalue in this case\nis still three so we put a three in our\noutput and the next position we see that\nthis is our window the maximum value is\nfive so we put a five in the output now\nyou might recognize one solution to this\nproblem\nimmediately for each of these windows\nwhy don't we just scan through the array\nright like\nit's pretty easy to find the maximum in\nan array right like if we had one two\nthree\nwe just check every value and see okay\nthis is the maximum\nand then we just shift our window by one\ninto the next position right and we keep\ndoing that until we're done well the\ntime complexity of this\nis going to be roughly since the size\nfor our window is\nk how many windows are we actually going\nto have let's say the\nentire input is length n\nin that case we're going to have roughly\nk times\nn minus k that's how many windows we're\ngoing to have right\nand so this is going to be our time\ncomplexity but\ni'm asking is there a better solution\ncan we\nactually make a linear time solution\nwhere\nn is the size of the input array and the\nanswer is\nyes and i'm going to show you how to do\nthat right now\nso i'm going to show you the best\nsolution but one thing you have to\nnotice\nfirst is this so let's say this is our\ninput array we have four numbers and our\nwindow size is going to be\nthree so k equals three notice how these\nvalues are\nin increasing order right one two three\nfour okay so we notice that now look at\nour first window\nwe have one two three we see that two is\ngreater than\none we see three is greater than two now\nthat's\ngood and so we scan through every\nelement\none's not the max two is not the max\nthree is the max\nso then in our output for the first\nvalue we're gonna put a three\nokay and that's great now we shift our\nwindow\nto the next position so now i'm\ni'm literally just gonna repeat that\nprocess the brute force way now i'm\ngonna check two\nokay now i'm gonna check three three is\ngreater now i'm gonna check\nfor four is the greatest so we add 4 to\nour output\nand so then we're done we have our\noutput but we just did it the brute\nforce way but do you see the repeated\nwork that we just did\nas soon in our first window we\nsaw one two three we know three\nis greater so so we basically eliminate\ntwo and three and then when our window\nis at the next position\nit's over here right one is no longer a\npart of our window so we don't need to\nworry about one\nwhat about two well two is\ninside of our window right it's at the\nleftmost position\nbut since we know that this three\nis greater than the 2 anyway why would\nwe\never need to look at the 2 ever again\nit's never going to be the maximum\nand let me just make it even more\nobvious let's say our window size is\nsix and this is our input array okay so\nour\nso for our first window we have to check\nokay the one\nanother one another one another one\nanother one and then a four so the four\nis our max that's great so we can save\nthat\nand then we shift our window to the next\nposition\nand see we're repeating all that work\nover again the one\none one as soon as we see this\nfour we know that these elements as far\nas we're concerned are\nuseless to us we never have to look at\nthem again they will\nnever be the maximum inside of our\nwindow\nbecause our window is going to continue\nbeing shift\nto the right position and the 4 is still\ngoing to be in the window\neven after these elements have been\neliminated\nand so the data structure we're going to\nuse to eliminate these values\nis a deck or a dq and i'm going to show\nyou\nthe algorithm and just to repeat myself\nbasically what i'm saying is\nif we have a window and we see a a value\nthat's\ngreater than values that are previously\nin our window\nthen we can eliminate those values from\nour window and what you're so i'm going\nto show you the algorithm and what\nyou're going to notice\nis that the values in our deck are\nalways going to be\ndecreasing order so this says decreasing\nso we know our window our sliding window\nis\ninitially size six right k equals six so\nwe're gonna take the first one\nput it in our window the second one put\nit in our window\nand then just repeat that right we have\nfive ones we're gonna add all of them\nand then we get a 4 so since\n4 is greater\nthan the value at the top of our deck or\nat the rightmost position of our deck\nwhat we're going to do is we're going to\npop this value off\nwhat we're going to do is pop the top of\nthe deck\nright and now we're going to make the\ncomparison again we see there's still\na 1 so 4 is still greater than the top\nof our deck so we're gonna\npop we're gonna pop this we're gonna pop\nthat we're gonna pop\nall of them and after that\nwe're gonna add the new value for\nand so what are we gonna add to the\noutput so we have an\noutput array what value are we going to\nadd to it well the\nleftmost value in this case we only have\none value is going to be what we add\nto the output so a four and so we're\ndone with this comparison\nwe don't have to look at it again and we\ndon't even have to consider\nthese elements anymore and now we\nshift our window by one position so\nwe're introducing a new element\nfive so before we add the five\nto our deck what do we have to do we\nhave to check\nis five greater than the value at the\ntop\nof our deck it is because the top value\nis a 4.\nso why would we ever consider the 4\nas the maximum value ever again when we\nknow there's a 5\nright next to it the answer is we don't\nhave to so we remove\nthe 4 from our deck and then we can add\nthe 5\nto the top and then we know that there's\nonly one value\nin our deck and it's also the leftmost\nposition\nwe are going to add that to our output\nand now we're done this is our\noutput but what's the time complexity of\nthis algorithm\nfirst we took each one added it to our\ndeck\nright we we did that for every single\nvalue that was\nexpensive and then we also then we also\ncrossed out we had to remove every\nsingle\nvalue from our deck but adding and\nremoving we know\nadding and removing is an o of one\noperation\nto our deck and we had to do that for\nevery\nsingle value in here potentially\nbut that's still o of n\nright the result is o of n which is\nwhy this is a really good solution and\ni'm going to show you\none last example and by the way this is\ncalled\nthe type of problem this is is called a\nmonotonically\ndecreasing q and the reason is because\nour q is always going to be in\ndecreasing order which this next\nexample is going to demonstrate and the\nreason we're using a\nq rather than a stack is because\nwe want to be able to add and remove\nelements from the beginning in o of one\ntime\nbut not only that as our window shifts\nlike for example our windows here\nnext our window could be here we want to\nbe able to take an\nelement like this and remove it from the\nbeginning\nand we want to be able to do that in o\nof one time which is why we need\na q so let me quickly just run through\nthis last example so we have\nour first window over here eight and\nseven so we\nadd eight to our q and then we look at\nseven\nwell seven is not greater than eight\nright that's just not true so we're\nallowed to add the seven we only want to\nremove\nsmaller elements if they exist but in\nthis case that's not true so we add the\nseven\nand notice how these values are in\ndecreasing order we have\na and then we have a seven right they're\nin decreasing order\nso what that tells us is since we want\nthe max\nvalue in our sliding window we can just\nlook at the leftmost value\nin our deck and then add that to the\noutput\nso i'm going to add 8 for the first\nsliding window the max value\nhappens to be eight okay now the next\nsliding window\nwe have seven and we have eight\nokay the first thing to notice is that\nthe eight is no longer in\nbounds so we gotta pop from over here\nright\nand we wanna do that efficiently which\nis why we're using a deck\nbut so before we add anything we pop\nnext we see the six well\n6 is not greater than 7 that's not true\nso we're allowed to put a 6 here to keep\nthis\nin decreasing order and now the max\nvalue\nin this window is 7 which is the left\nmost\nvalue in our deck so we add it to the\noutput and\nlastly we look at the last sliding\nwindow which is these\nlast two elements and we know that the 7\nis no longer\nin bounds right so from the leftmost\nposition with it which is this\nwe pop from our deck we make one last\ncomparison right we just added a 9.\nlet's take a look\nis 9 greater than the top value\nof our stack is it greater than 6\nit is what does that mean that means we\nhave to\npop from this we have to pop from the\ntop of the stack the rightmost position\nor rather the q i don't know how many\ntimes i said stack but we're going to\npop from the rightmost position in our\nqueue\nand now we are allowed to take the 9 and\nappend it to our queue so we add the 9\nnow we know that this is the leftmost\nposition in our rq and we know that\nin this window nine is the maximum so we\ndid this correctly right so we can take\nthe nine\nadd it to our output so this is the\nresult that we're looking for\nand i hope this demonstrates a few of\nlike when you actually\nrun through examples it shows you\nlike what you need to know it shows you\nwhy we're using\nthis data structure and it shows you why\nit's so efficient so\nnow with that in mind the coding\nsolution is not too bad\nso we are going to have an output array\nto put\nthe values in we're also for our window\nwe're going to have\nsome pointers so left and right pointers\nthese are going to represent where our\nwindow currently is they're both\ninitially going to be set to zero\nand we're also gonna have a queue in\npython we can do\ncollections.deck and so we're gonna run\nthis until\nour right pointer is no longer inbound\nso\nwhile right is still in bounds\nso we want to to our q we want to be\nable to append\nthe value this value right r and\ninstead of doing nums of r i'm just\ngoing to do\nthe index itself so this is going to\ncontain indices because we know we can\ntake an\nindex like r and then easily find the\nnumber that maps do\nby just taking nums of r right but\nbefore we're even allowed to append\na value to our queue we have to make\nsure that no\nsmaller values exist in our queue so\nwhile\nthe queue is non-empty and the top\nvalue in our queue or the rightmost\nvalue in our queue\nis less than the value that we're\ninserting\nnums of r which is the current index\nwe're at\nso while smaller values exist in our\nqueue we just want to pop from the queue\njust remove\nvalues while that condition holds and\nonly after we do that are we allowed to\nadd the new value to the queue\nwe also if our window if the left value\nis out of bounds then remove the left\nvalue from the window\nso if our left index\nleft is currently greater than the\nleftmost value in our queue\nthen we can pop from the left of the\nqueue\nso basically we know left and right\nrepresent our window\nso if our window is out of if\nthis value the leftmost value in our\nqueue is out of\nbounds of our window we're gonna remove\nthat we have to remove that\nand this part is kind of an edge case uh\nsince we're since we are starting at our\nwindow being\nuh left and right both being at zero we\nhave to check\nthat our uh right plus\nour window is at least size k so\nso if we want to update the output we\nhave to make sure our window is at least\nsize\nk so that's basically what i'm doing\nhere and for each\niteration of the loop basically for each\nwindow we want to append\nour output with the maximum\nso we know the maximum is the left most\nposition in our queue\nand we want not the index but we want\nthe actual value itself\ndon't forget like me to update your\npointer so\nwe know right is always going to be\nincremented so\nat the end of our loop we can increment\nright\nleft though is only going to be\nincremented\nonce our window is at least size k\nso we're going to put that inside of\nthis condition\nand now the only thing left for us to do\nis return that\noutput and it works and we know that\nthis\nis the most efficient solution with the\ntime complexity being linear\nand the memory complexity also being\nlinear because we are using a data\nstructure\nour q so i hope this was helpful if you\nenjoyed\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Valid Parentheses",
        "NcLink": "validate-parentheses/",
        "Pattern": "Stack",
        "Description": "You are given a string `s` consisting of the following characters: `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`.\n\nThe input string `s` is valid if and only if:\n\n1. Every open bracket is closed by the same type of close bracket.\n2. Open brackets are closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nReturn `true` if `s` is a valid string, and `false` otherwise.\n\n**Example 1:**\n\n```java\nInput: s = \"[]\"\n\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: s = \"([{}])\"\n\nOutput: true\n```\n\n**Example 3:**\n\n```java\nInput: s = \"[(])\"\n\nOutput: false\n```\n\nExplanation: The brackets are not closed in the correct order.\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n",
        "Difficulty": "Easy",
        "Video": "WTzjTskDFMg",
        "PythonSolution": "class Solution:\n    def isValid(self, s: str) -> bool:\n        Map = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n        stack = []\n\n        for c in s:\n            if c not in Map:\n                stack.append(c)\n                continue\n            if not stack or stack[-1] != Map[c]:\n                return False\n            stack.pop()\n\n        return not stack\n    ",
        "Transcript": "I work ethic and Gentlemen I counted\nlstore Tunisia broke down for instance\nit recently Come and well furnished\nsomat Android phone and reviews and more\nwith Sweet shops are their work from no\nunderstand when you get is strange as\ncontaining all there is seeking the pace\nwith printer  shita kara brightest\nPromise to record and other three\npercent and opening Man And The clothes were at\nfree on uses it takes place\nOpen close Open and close and languages\nGerman with industry is well known and\nwhen it is the Open products over you\nwere right and high  Bright and\nsubscribed Accord indecorous tourists\nwhen it is proud and with importance is\nnot responsible to hunt For The First\nwhere is Wireless guido westerwelle\nopenings prince innawood Where's my\nkosta Francis I happen If There were the\nlatest work in progress every Open hard\nMarine corps of  this is one to\nreconstruct of Sweet Tea or the world of the\nweight of us will not work force\nPika stress Grand opening like is pink\ngirl's day teeth Neville question in to\nme Cause I need to go on their side with\nsome Oranges and spacious with more\nexcited for example We see Ok opening of\naggression and decorate economie norwich\nunimart opening Black Cat and discover\nsiriport anymore opening careprost\nLauren palladino Paladog Dragon Ball\nBattle of Los Angeles personal Jack\nwelch\nI can just want something like that she\nhas opened to live and work for\ninspiration to score in the one and we\nhave opening practice and workers in\npractice cam astrid the course of peace\nWorld jadedness word entries and weather is\nof great wishes in this course and\nprinciple of Bright and Open Project is\nyou now Not reflected Dock and Fall Out\nThe Best Dragon Wars mace live weather\nin the war is very selfish weather is\nworking as related to the world cup dai\nChanel nuestras appealing to people who\nsold For One Person you ain't seen the\nbest Western openings and speaking score\nin this Winter weather Open  grave of the\ncountry is open Kali bogleheads Dielac\nGrow Dinh plantigrade against them make\nit is never leave with you are there any\nI Apologize ever going to make nice\nflowers and later He is never be applied\nto your Present the weakest of the\nboring plan to have  to start with and of\nplenty of any Kind and want to start\nwork with She with enormous either many\nadvantages as well as the morning the\nworld and make clothes in the brighter\napple Open plan to Vietnam for using de\nculturas arabiya Accord trendnet laser\ndisc to massacre  at weekend and were\nMoving from interest rate will inform\nyou come from our lowest rates in out of the\nway or another of lifting Francis I\nwish I ate vinafreight Just One Day and\nwe can't move it to end the word which\nKeep Dreaming not solve  the musician\nand once more inclined to work with the\nGray and one Sweet Jumbo Vina Diep\ncnbui2 MTV Price of giants MV gentleman\nNobita motionflow Because we close of\nthe apprentice intumescent Lavigne What\nWe're also noted for arabic arthrozan\nfastest want and were moved from\nBeginning  of traditional vehicle will Move It is\nright now Switch explosion crack Ok\ngoogel move and gas Paloma vsmart\nsahuagin before Moving from the end the\nwest stood the pulse width of Star that\nI had Lost their way to Hold fast to use\nstart their to solve cross pictures  are\nthe first floor Apprentice Palace I like\nthe way the Frozen Princess Evil welcome\nPopin from the all goals in parentheses\novercommit to the Mouse to reset open in\nparentheses and shall have this dream of\nlifting gentacin\ncontestants Next Switch disk Awards in\npractice It has winners  house not sure\nHow do we know That's When print Asean\nem euticals this one day well paid\nsubject parapa spring-mass every\nquestion cuenta city tours muscle Black\nopenings anticipatory spacious with\nEndless Love and chords In Black III\nSmart array of conduct and because in\nchorus need  to mastery open Courage the\nway home When She was going of stay\nswanepoel our Hearts And tricks you\nreally want to How to start a minute\nechoes in practice in National press to\nreplace with the correct or live show\nExcel has been more impressed I will go\nof  in two hours as Per Second with Green\nFresh tomatoes please open plan to you\nok Google best of Voice that decides to\ntop\nI read articles in Transit doux Sting\nqmatic weekend for Women or from the\ngrave now the weather in this spring\nplantigrade mom wants to school  Go of the\nlast major for Get Me straight us\nforeign tourists press Ok ortega Opera\nthat Hurts instead we need DJ question\nis up Yours sol-ju massacre cross sport\nnow right person will we Heart goes in\npractice Ok temperature and track Your\nHeart map witness this  one is one of the\nbest of product uses The Witch and the\nsmarter and movement and now understand\nnow and the Lost age and we have and\nempty Words We have nothing is what\nremains of differences in the correct\nWords and weak and restaurant food\noutsystem\nsee  movie the Third and Wide the\nMinutes they Go of and Pika Your Hands\nTogether every import care were driving\nYou can't Love Is For You can I think we\ngo of and remember Piccolo sinh stacan be\nup to say that involved and all that\nmatters all  that people Go anycast\npokarekare downloadmod your use of\nstochastic Grand scale to fight for\nwhich is also worth reminding the words to\nopen gentleman DJ nha Heart Of the\nstreet King Floor Etown improving\nAmerican take Everything goes in\npractice with one I'm not to the opening\nversion  of Brothers Ana mandara for free\ntake the way because in grade of that to\nthe Open workers and Korean cuisine\npress to open chorus Adidas JP the\nwanted to and free\na What's what are we doing a first sight\nand Popin form and the court to occur in\nthe Spotlight first value is this card is\ngrowing plantasil Escape and cause to\nopen maps.me utica folk Fantasy and\nefficient With Me This is every millet\nav-test oyz correspond to love this\nrecord Dinh Francis I want is what makes\nour doubts That is not  and Which is and\nchords in Plant species and precise and\nwarm as directed towards the thoughts\nthat is the National Open printer\nresearch.net show Got To Dance With All\nStar Trek IV the one with this with all\nof Which are the act of Master Rising\nNational  Open Grand Minutes Walking Dead\nBite take out map and inverted Pendulum\nbecause inc\nin shopee my quick recall PCP tree\nask for motel Ms. Dinh Courage and earning\nHarris example with it is suggested that\nGod that means We can fall From A stand\nand continue her  IT IT IT IT IT necessary\nworld star cabin entidad meal Together\nfor example prince it's gonna save on\nthis page is now i Master plan to have\nintegral to see the short story\nnhattrung also with notch greatness\ncorinto gfriend Open Project as noted\nthat  were transferred to do is win anti\ncontrasted with nice work and rendering\nOpen process with logo Ford has No\nPromises fastest and its many Awards in\nyour parents want to see what you can\nstay Together and drop and liked\nWhy is it so sad with etienne the one to\none to Africa the waiting for me what's\nYours is Lost art mt6.app not that none\nof the white Wolf and ports this is this\nWeeks in card printer problems I hope\nyou understand What were you doing and\nstructure she hope that this next and\nnot to  school subjects and It Hurts A\nPerfect world wide Surprise that\nsupports I know well and hopefully\n"
    },
    {
        "Name": "Min Stack",
        "NcLink": "minimum-stack/",
        "Pattern": "Stack",
        "Description": "Design a stack class that supports the `push`, `pop`, `top`, and `getMin` operations.\n\n* `MinStack()` initializes the stack object.\n* `void push(int val)` pushes the element `val` onto the stack.\n* `void pop()` removes the element on the top of the stack.\n* `int top()` gets the top element of the stack.\n* `int getMin()` retrieves the minimum element in the stack.\n\nEach function should run in $O(1)$ time.\n\n**Example 1:**\n\n```java\nInput: [\"MinStack\", \"push\", 1, \"push\", 2, \"push\", 0, \"getMin\", \"pop\", \"top\", \"getMin\"]\n\nOutput: [null,null,null,null,0,null,2,1]\n\nExplanation:\nMinStack minStack = new MinStack();\nminStack.push(1);\nminStack.push(2);\nminStack.push(0);\nminStack.getMin(); // return 0\nminStack.pop();\nminStack.top();    // return 2\nminStack.getMin(); // return 1\n```\n\n**Constraints:**\n* `-2^31 <= val <= 2^31 - 1`.\n* `pop`, `top` and `getMin` will always be called on **non-empty** stacks.\n",
        "Difficulty": "Medium",
        "Video": "qkLl7nAwDPo",
        "PythonSolution": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n        self.minStack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.minStack[-1]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve min stack so this is a\npretty good design problem and the\ndescription is pretty simple so our job\nis to design a stack class that supports\nfour operations obviously we want to\npush on to the stack we want to be able\nto pop from the stack and we want to be\nable to get the top value on the stack\nand last but not least the fourth one\nthis is the part that's going to be\ntricky we want to be able to retrieve\nthe minimum element in constant time so\nwe want to be able to do all four of\nthese operations in constant time now if\nyou are familiar with a stack data\nstructure you know that by default a\nstack will be able to support adding a\nvalue popping a value and getting the\ntop value all three of those in of one\ntime now i'm not going to go into the\ndetails of how to actually implement a\nstack you can implement it with a linked\nlist or you can do it with an array in\nthis problem we're basically just going\nto use the built-in data structure that\nis pretty much implemented as a stack\nbut the main part of this problem is\nbeing able to do this last operation\ngetting the minimum value from the stack\nin o of one time\nright because by default a stack doesn't\nsupport this operation\nnow a stack let's say we're implementing\nit with an array so let's say this is\nour stack and let's say we do a few\noperations let's just look at this\nexample right we push a negative\nnegative two we push it let's say to the\nbottom of the stack we push another\nvalue a zero we push another value\nnegative three and now so we did three\npush operations now we wanna do a get\nmin so how exactly are we gonna be able\nto get the minimum here well a naive way\nwould be just look at every single value\nnegative three zero negative two so we\ncan look through the entire the entire\nstack that's gonna be o of n time to get\nthe minimum so at least we have a\nbaseline at least we know how to do it\nin o of n time that's not too bad but\nhow can we do better how can we actually\nget it to be o of one and if you want to\ntry to figure it out yourself i\nrecommend taking a look at this hint\nthat leak code actually provides they\nsay consider each value in the stack\nhaving a corresponding minimum value\nthink about that for a second so let's\ngo back to the basics when we were\nadding three values so when we first\nadded a value we added a negative two so\nwhat's the minimum at this point in our\nstack when we only had one value the\nminimum at that point was negative two\nright when we added another value we\nadded a zero what was the minimum at\nthis point when we added the zero\ndid this replace our current minimum\nnegative two no it did not so in other\nwords we can leave our minimum as it is\nbut that's not always going to work\nhaving a single value maintaining the\nminimum isn't always going to work\nbecause for example let's say we added\nanother negative 2. okay our minimum\nstays the exact same negative 2 right\nnow what if we pop this negative 2 okay\nwe pop that negative two now how do we\nknow what's the new minimum is the\nminimum gonna stay negative two or is it\ngonna be zero well of course we know\nit's gonna be stay it's gonna stay as\nnegative two but how can we do that so a\ngood workaround is let's for each\nposition\nwrite down what's the minimum at this\npoint so when we pop then we know okay\nthis is going to be the new minimum so\nlet's say at this point the minimum\nstays negative two and we added a third\nvalue remember we added a negative three\nso now what's the new minimum we can we\ncan compute it in o of one time by just\ncomparing this new value we added and\ncomparing the current minimum obviously\nnegative three is smaller so at this\npoint in our stack the minimum value is\nnegative three if we were to pop this\nnegative three then the new minimum\nwould be a negative two right this would\nbe the top of our stack this would be\nthe minimum so far so what you might be\nnoticing is on this right hand side i'm\nactually defining another stack right we\nhave two stacks one stack is telling us\nthe values that we've added so far in\nthe order that we added them the other\nthe other stack is telling us what's the\nminimum value that we have added so far\nin each position of the stack so if we\nadd a value we'll be inserting into both\nstacks if we pop a value we'll be\npopping from both stacks when we get the\ntop value of our stack right because\nremember that's an operation the top\nvalue we're going to be looking at the\nfirst stack we're just going to say okay\nthis is the most recently added value in\nthe stack when we do the get min\noperation we're going to look at the top\nof our minimum stack get that in o of\none time right we just have to get one\nvalue so we can do an o of one time\ndon't have to pop anything we just have\nto take a look at our second stack so\nthat is the main idea it's a little\ntricky to actually come up with this but\nonce you do it's very simple so now\nlet's actually jump into the code okay\nso now let's get into the coding portion\nso we know that we have to support four\noperations and in our constructor the\nfirst thing we're going to do is since\nwe know we're going to have two stacks\nlet's define those stacks first of all\nand like i said i'm going to be\nimplementing this with an array or at\nleast an array list if you were using\njava this is not just an ordinary array\nwe can append pop from it it's basically\npython's implementation of a like a\nregular stack we're going to have a\nsecond array which is going to be the\nmin stack and initially they're going to\nbe empty so the simple thing to do is\npush right that's the first operation so\non our first stack it's always going to\nbe easy right we're always going to take\nthe input value and append it to the\nfirst stack now with the second stack we\nneed to know for the second stack if\nthere's already a value inserted in the\nminimum stack then we're going to take\nthe minimum of the input value and the\nminimum value or at least the value at\nthe top of our min stack and take the\nminimum of those two and then append\nthat value to the min stack so let's\nupdate our value first of all let's set\nit equal to the minimum of itself and\nthe minimum of the top of our min stack\nso let's say self.min stack at negative\none at least that's how you do it in\npython but we know that this min stack\nactually could be\nnon-empty so we're gonna only do this if\nour self.min stack is non-empty\notherwise let's just take the minimum of\nval and val so i this might be a little\ncomplicated i probably could have just\ndone an if else statement but in python\ni feel like this is a little bit cleaner\nso we're just taking the minimum of\nvalue and the top of our stack if the\nstack is not empty if it is empty we're\njust taking the minimum of val and val\nbecause if the stack is empty then of\ncourse we're just going to take the\nmen's stack and append\nthe value to it right so when we append\nthis value it should be the minimum of\nthe input value and the minimum of the\ntop of the min stack so that's all for\nour push function now let's do the pop\nfunction we don't have to return\nanything all we have to do is pop from\nour stack but since we have two stacks\nwe're gonna have to pop from both of\nthese stacks so popping from the first\nstack and popping from the minimum stack\nso that definitely takes care of\neverything for us\nit feels like cheating since we're\npretty much using the built-in functions\nand to get the top value of the stack we\nare going to take from the top of the\nfirst stack right we by top we want to\nget the last value that was inserted and\nthis is always going to be called when\nour stack is non-empty so we don't have\nto take care of any edge cases the last\none get min is going to be returning\nfrom the top of the min stack right\nbecause we want the minimum value that's\nalways going to be on the top of the min\nstack and this function as well is only\ngoing to be called when our stack is\nnon-empty so that is the entire code and\nof course for some reason i didn't\nnotice that i didn't actually put the\nelse over here so if it was confusing\nbefore i'm really sorry about that so\nnow you can probably tell exactly what's\ngoing on because it's pretty simple so\nthis is what we're going to be\nevaluating if our stack is not empty\nelse this expression is going to\nevaluate just to this value and then\nwe'll of course take the minimum of\nthese two\nso now this code is complete you can see\nthat it's very efficient because every\nsingle one of these four functions is\ndone in o of one time so i hope that\nthis was helpful if it was please like\nand subscribe it supports the channel a\nlot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Evaluate Reverse Polish Notation",
        "NcLink": "evaluate-reverse-polish-notation/",
        "Pattern": "Stack",
        "Description": "You are given an array of strings `tokens` that represents a **valid** arithmetic expression in [Reverse Polish Notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nReturn the integer that represents the evaluation of the expression.\n\n* The operands may be integers or the results of other operations.\n* The operators include `'+'`, `'-'`, `'*'`, and `'/'`.\n* Assume that division between integers always truncates toward zero.\n\n**Example 1:**\n\n```java\nInput: tokens = [\"1\",\"2\",\"+\",\"3\",\"*\",\"4\",\"-\"]\n\nOutput: 5\n\nExplanation: ((1 + 2) * 3) - 4 = 5\n```\n\n**Constraints:**\n* `1 <= tokens.length <= 1000`.\n* tokens[i] is `\"+\"`, `\"-\"`, `\"*\"`, or `\"/\"`, or a string representing an integer in the range `[-100, 100]`.\n",
        "Difficulty": "Medium",
        "Video": "iu0082c4HDE",
        "PythonSolution": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for c in tokens:\n            if c == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif c == \"-\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif c == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif c == \"/\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(float(b) / a))\n            else:\n                stack.append(int(c))\n        return stack[0]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem evaluate reverse\npolish notation quite a mouthful but\nbasically this problem is about what the\nmeaning of that term even means and it's\njust kind of a way to compute\narithmetic expressions and the only\noperations we're really going to be\ndoing in this case are going to be the\nsimple ones add subtract multiply and\ndivide a one note that they tell us\nthough is division between two integers\nshould basically round towards zero\nsince i'm going to be doing this in\npython though if you you know take uh\nsome values and do integer division\nbetween them they always round down\nwhich is not rounding towards zero\nnecessarily because imagine if we had\nnegative 3 divided by 2 that's negative\n1.5 it rounds down to negative 2 in\npython but that's not what we want to do\nbut there's a trick in python that you\ncan do to make it round towards zero so\nwe can take care of that if you're using\njava though i think it automatically\nrounds towards zero same with like c\nplus plus in most languages uh one thing\nwe're told though in terms of the rn rpn\nrpn expression is that it's always going\nto be valid which is good so we don't\nreally have to worry about too many edge\ncases there's never going to be some\ndivide by zero or anything crazy like\nthat so now what does rpn even mean well\nlet's take a look at this example so\nwe're given a 2 a 1\nthen a plus operator then a 3 and then a\nmultiply operator now the way uh this is\ngonna work is we're gonna be reading\nfrom left to right we're gonna be\nreading the inputs uh so first one was a\ntwo next one is a one when we reach an\noperator though what exactly are we\nsupposed to do well any operator in this\ncase is going to be applied to the\nprevious two values and like i said\nthere's not going to be edge cases so\nwe're guaranteed that there are going to\nbe two previous values so in this case\nwhat we would do is replace these this\ntwo and this one\nby adding them together so where it's\ngoing to be replaced with a\nthree right so we can kind of forget\nthese and we already used this plus\noperator so we can kind of cross it out\nas well now we have a 3 again\nso i'm going to be kind of writing it\ndown here just to kind of you know\nbasically say that we've seen that 3\nbefore now we have the multiply operator\nit's going to be applied to the two\nprevious values now in the actual input\nitself you can see that the the previous\nvalue was a 3 and the value before that\nwas a plus operator when we say it's\ngoing to be applied to the two previous\nvalues that's not what we mean we don't\nwant to apply it to another operator\nright we mean the two previous values\nthat came so you can see that we had a\nthree and then the one before that was a\none but remember this two and this one\nthey were replaced by this three and\nthen we had a second 3 which we wrote\ndown here so this multiply is going to\nbe applied to these two values so we can\nmultiply both of them and then replace\nthem with the result which in this case\nis going to be a 9. so you can see that\nthat is our result and you can see that\nit is correct if you know the data\nstructure or you're familiar with the\ndata structure a stack and you've used\nthat in other problems before i think\nthis problem is pretty simple to figure\nout that a stack will be useful here\nbecause basically each operator is going\nto be applied to the previous values\nright but in the case of this 2 the\nprevious values are going to be removed\nfrom the stack right and then replaced\nwith the new value which is a three so\nyou know as we read through the input\neach value here is going to be added to\nthe stack anytime we reach an operator\nthe previous two values are going to be\nremoved from the stack and then we're\ngonna do the operation on them so in\nthis case two plus one and then we're\ngonna take the result of that which is\nthree and then push it back onto the\nstack and that's kind of what i was\ngetting at when i was doing the drawing\nexplanation so really quickly let's\nactually run through an example with a\nstack and just to make this problem a\nbit more interesting let's replace this\nuh\nplus operator with actually a subtract\nand this multiply with a divide because\nuh it's going to be a little bit\ndifferent with these two operations\nbecause with plus these two are going to\nbe added right two plus one but when you\nhave subtract which order are they going\nto be subtracted well the intuitive one\nwould be two minus one because that's\nthe order that they appear in but one\nminus two could be possible right well\nin this case if you looked at the second\nexample i think they clarify that yes\nit's going to be this way right 2 minus\n1. let's run through this with a stack\nvery quickly so we read the first value\nit's a 2 we add it to our stack second\nvalue is a one we add it to our stack\nnext we get the subtract operator what\ndoes that mean that means we pop these\nvalues from our stack and then do the\noperation so in this case it was two\nminus one that's going to be a one over\nhere next value is a 3 we add it to the\nstack next we have a divide operator so\nin this case it's going to be the same\norder that the values appear in so 1\ndivided by 3 we're going to round\ntowards 0. so in this case it's actually\ngonna be zero right so we pop this pop\nthis uh and then replace it with a zero\nand we're guaranteed since this is\nalways going to be valid that we're only\ngonna be left with a single value in our\nstack so that's the value we're gonna\nreturn so in this case the answer is 0.\nso that's pretty much the entire\nsolution\nnow we can code it up but i just want to\nmention that the overall time complexity\nis going to be big o of n because we're\njust reading through the input string\nadding each value to the stack and\nremoving it at most once each so you\nknow the time complexity is two times n\nin other words it's big o of n uh the\nmemory complexity since we do have the\nstack is also going to be big o of n so\nnow let's code it up let's code it up\nlike i said we're going to need a single\ndata structure in this problem which is\ngoing to be our stack in python you can\njust use a list\nand then most of this problem is just\ngoing to be boilerplate once you realize\nthat a stack works for this problem then\nit's just about coding it up so what\nwe're going to do is just iterate\nthrough every character in our tokens\ninput and then just have a bunch of\nconditional statements the first one is\nif the character\nwell there's five cases remember it\ncould be one of the four operators or it\ncould be any other character and any\nother character basically means that\nit's a digit or some number right so\nlet's basically make those conditions so\nfirst is that it's\nplus and let me just kind of you know\ncopy and paste this stuff and then get\nuh\nit updated so\nthe cases are plus minus multiply and\ndivide and then the last fifth case is\nwhere it's something else and if it's\nsomething else that means it's a number\nand that's the simplest case of all\nbecause that means we can just take that\ncharacter and then append it to our\nstack but it's a character remember but\nwe should probably convert it into a\nnumber before we actually add it to our\nstack because remember what we want to\nreturn is a number not a character okay\nso now let's start with the plus\ncondition well remember what i said we\ncan just pop from our stack twice and\nthen add those values together and then\nappend that to the stack so for this\nit's actually pretty simple as well we\npop from the stack twice take the return\nvalues add them together and then append\nthat to the stack so that the result is\nadded to the sac pretty simple and for\nmultiply that's also going to be almost\nthe exact the same thing right instead\nof plus we're going to be doing\nmultiplication so let's you know just\ncopy paste and then update that as well\nit's going to be a little bit more\ntricky though for subtract and divide\nbecause the order that we're popping it\nin is not the order that we want to\napply that subtract and divide\noperations so\nfor subtract well again we are going to\npop twice because we want to get those\ntwo values that were popped so let's do\nthat this is\nlet's call them just a and b arbitrarily\nyou could call them anything that you\nwant but when we\nsubtract them we want to subtract we\nwant to take the one that was popped\nsecond and subtract it from the one that\nwas popped first so b minus a and then\ntake that and then append it to our\nstack so this though is going to be very\nsimilar to what we do in our divide\noperation down here we're going to pop\ntwo values and then in that same order b\nand then a we're going to divide them\nrather than subtract them but in python\nwhen you do this this is actually\ndecimal division but we want to round it\ntowards zero so to do that we can\nactually just call the int function\nwhich will convert it to an integer and\nalso round it towards zero at the same\ntime so that's pretty much the entire\ncode you can see it's mostly just a\nbunch of boilerplate but once all that's\ndone let's go ahead and return the\nsingle value that is guaranteed to be in\nthe stack stack at index zero and then\nmake sure that our code works by running\nit and as you can see on the left yes it\ndoes and it's very efficient so i really\nhope that this was helpful if it was\nplease like and subscribe it really\nsupports the channel a lot consider\nchecking out my patreon where you can\nfurther support the channel and\nhopefully i'll see you pretty soon\n"
    },
    {
        "Name": "Generate Parentheses",
        "NcLink": "generate-parentheses/",
        "Pattern": "Stack",
        "Description": "You are given an integer `n`. Return all well-formed parentheses strings that you can generate with `n` pairs of parentheses.\n\n**Example 1:**\n\n```java\nInput: n = 1\n\nOutput: [\"()\"]\n```\n\n**Example 2:**\n\n```java\nInput: n = 3\n\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n```\n\nYou may return the answer in **any order**.\n\n**Constraints:**\n* `1 <= n <= 7`\n",
        "Difficulty": "Medium",
        "Video": "s9fokUqJ76A",
        "PythonSolution": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        stack = []\n        res = []\n\n        def backtrack(openN, closedN):\n            if openN == closedN == n:\n                res.append(\"\".join(stack))\n                return\n\n            if openN < n:\n                stack.append(\"(\")\n                backtrack(openN + 1, closedN)\n                stack.pop()\n            if closedN < openN:\n                stack.append(\")\")\n                backtrack(openN, closedN + 1)\n                stack.pop()\n\n        backtrack(0, 0)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\ngenerate parentheses so we are given a\npair\na certain number and pairs of\nparentheses and we want to write a\nfunction\nto generate combinations of all\nwell-formed\nparentheses and so you can see that\nthese are the examples\nand by well-formed they basically mean\nlike when you're writing code\nyou know you're nesting parentheses you\nwant\nuh them to be nested in a valid way\nright like\nwe can't have a right parentheses\ncome before a left parenthesis right\nlike this\ncould not be possible we would have to\ndo it like this\nright so you can see for each matching\nfor each left parenthesis we have a\nmatching right parenthesis that comes\nat some point after it right so like in\nthe first example\nthe first three are left parentheses\nthen the next three\nare right parentheses and when they say\nn equals three that means we have three\npairs of parentheses so in total\nwe have six parentheses because a pair\nis\ntwo parentheses and three are going to\nbe open parentheses\nand 3 are going to be closed parentheses\nright so this is a open parenthesis this\nis a closed parenthesis\nyou can see that when n equals 1 there's\nonly one possible way to\nmake them valid because this is one way\nand the other way would be this\nand we know that this is invalid so how\ncan we\nsolve this problem let's just try out\nthe\nbacktracking solution kind of right like\na a sort of brute force approach\nhow would we even do a brute force\napproach let's say\nn equals three so then we have three\nparentheses\nwhat does that tell us about valid\nparentheses right like this is one\nvalid parenthesis that satisfies this\ncondition right we have three open\nparentheses three closing parentheses\nwell the first thing it tells us is that\nwe need\nthree open parentheses and three closing\nparentheses right that\nmuch is pretty obvious right like you\ncould probably figure that out by\nyourself\nif we have three pairs then we\ndefinitely need three open and three\nclosing parentheses so in total\nsix parentheses but what about the order\nof parentheses so let's say i have\nso far i'm empty right we're empty can i\nstart out with an open parenthesis\nyes i can right but can i start out with\na closing parenthesis\nno we know that this is invalid no\nmatter what i do now\nthis is always going to mess up our\nparentheses\nso we can't start with a closing\nparenthesis we can only start with an\nopen parenthesis okay but now let's say\ni have one\nopen parenthesis now what can i do can i\nhave another\nopen parenthesis yup because our limit\nis\nthree open parenthesis and so far we\nhave two so we're allowed to do that\nwhat about a closing parenthesis can i\nhave a closing parenthesis\nyes because so far our open count\nis one and the initially the closing\ncount\nis zero and i can by adding this\nparentheses\ni'm just changing the closing count to\none now right\nso now let's look at it now can i add a\nanother open parenthesis yes i can\nbecause the limit is\nthree open parenthesis and so far we\nonly have one\nso i'm allowed to add a open parenthesis\nwhat about\na closing parenthesis can i add a\nclosing parenthesis right now\nno because you see that so far we have\none\npair right this pair of open and closing\nparentheses and then when you get rid of\nthat pair then we're just left with a\nsingle closed parenthesis\nthis closing parenthesis will never have\na matching\nopen parenthesis on the left of it so we\ncan't add this parentheses\nand how would you figure that out from\ncode well\njust take a look at the count we have so\nfar before we add\nthe parentheses we have a count of one\nfor closed\nwe have a count of one for open\nbasically what this\ntells us is that we can only add a\nclosing parenthesis if the count of\nclosing parentheses\nis less than the open count we can only\nif\nthis is true are we allowed to add a\nclosing parenthesis\nso if for example if i were to add\nanother opening parenthesis\nnow we update our open count to two\nso now we have two open parenthesis\nright so two\nis open one is closed from over here\nright\nso now i'm allowed to add a\nclosing parenthesis right so basically\nlet's say if we're gonna do backtracking\nthese are the two rules that we have to\nfollow\nthis is basically our base case once we\nhave three open and three closing\nparentheses\nthen we have a valid uh parenthesis\nformation right and this condition tells\nus\nwhen we're allowed to add closing\nparentheses we can add\nas many open parenthesis as we want as\nlong as it's\nunder the limit which is n right we can\nadd up to\nthree open parentheses but we can\nonly add a closing parenthesis if the\nnumber of\nclosing so far is less than the number\nof\nopen parentheses so with that said let's\nstart\nour backtracking solution so we so far\nwe're empty right\nso the first thing we're going to do is\nadd a open parenthesis so\nnow this is what we are so far a single\nopen parenthesis\nsince we added a open parenthesis that\nmeans the count of\nopen is greater than the count of close\nso now we have two choices\nwe can add a open parenthesis or we can\nadd\na closing parenthesis so we have\npotentially two open parentheses\nor a single open and a single close\nokay let's take a look at this decision\nhere we have\nopen is greater than or equal to close\nright and\nthe number of open is still less than\nthree so we can do both\nchoices so from here we can add another\nopening parenthesis so we have\npotentially\nthree and we can add a closing\nparenthesis\nso two open and one close from\nhere we see that the open and closed\ncount is actually\nequal right we have one of each so here\nwe don't have any choices we\nhave to add a open parenthesis\nso what we're going to do is have just\nanother open parenthesis come after okay\nso i'm running out of room but\nlet's continue so over here now we have\nthree opening parentheses right so we've\nreached our\nlimit which is n so we can only make one\nchoice and that's to add a closing\nparenthesis so we're now we're going to\nhave\nthree open and a single closing\nparenthesis\nhere you can see that we have two open\nparentheses\nand one closed parenthesis so we can\nactually add\nwe have two choices we can add an open\nand we can add a close\nso if we add an open we'll end up with\ntwo open\none close and then another open or we'll\nend up with\ntwo open parentheses and two closing\nparentheses\nover here we also have two choices\nbecause we see we have two open\nparenthesis\nand one closing parenthesis so we have\nso\nif we add a open parenthesis again we'll\nend up with\nopen close open open\nif we add a closing parenthesis we will\nend up with\nopen close open close okay so we're\nalmost done\nstart starting over here we see we we\nhave three open parenthesis so we can\nonly add a closing parenthesis now so\nopen open open close close from here we\nactually only have one choice even\nthough we have\nmore open we have three open and one\nclose\nwhich open is more than closed so we\nshould be able to add one of each but we\ncan't because we know that\nthree is the limit so we can't add any\nmore opening parenthesis we can only add\na closing one\nso the new parentheses we add is closing\nhere we also have one choice\neven though we only have two open and\ntoo close we know that\nthe open count is equal to the closing\ncount so we can't add another\nclosing parenthesis because that would\nmake it invalid right\nso we can only add a opening parenthesis\nso we'll just add a single\nopen here we all we also only have one\nchoice because we already have three\nopening parentheses so we can only add a\nclosing parenthesis at this point\nhere we also have one choice we can only\nadd a open parenthesis because if we add\na closing parenthesis that would make\nthis invalid because then\nthe close count which would be would be\ngreater than the open count right which\nwe cannot do\nand so at this point for each of these\nfive we only need to add a single more\nparentheses and since this has\nthree open three and two closed we know\nthat we need three of each so the only\nthing we can do\nis add another closing parenthesis to it\nright so this is going to be\none possible solution because now we\nactually have three of each which is\nwhat we wanted\nfor this one we have three open and\nthree\nand two closed so lastly we are going to\nadd another\nclosing parenthesis and and you might\nnotice that's what we're going to do for\neach of these right because each of\nthese now has\nthree open and too close so all we need\nto do is add another closing parenthesis\nand for this one we also are just adding\na closing parenthesis\nand lastly this one we're also adding a\nsingle\nclosing parentheses so now you if you\nlook at\nall five of these you see that they're\nall valid right\nand you see they have they have three of\neach and they come in a valid ordering\nso these\nfive are going to be returned as our\nresult these are the five ways we can\nmake\nvalid parentheses so now let's finally\nwrite the code\nthis is basically what we're gonna do\nyou can see i summarized it so we're\nonly gonna add an open parenthesis\nif open count is less than our input n\nwe're only going to add a closing\nparenthesis if the closed count is less\nthan\nopen and we're only going to stop adding\nparentheses altogether once our open\ncount\nequals our closed count which is going\nto equal n so i'm going to do this\nrecursively because that's basically the\nbest way to do it\nand i'm going to create a stack which is\ngoing to hold our parentheses\nand i'm going to create a variable\nresult which is going to have\nour list of valid parentheses\ncombinations\nand i'm going to do this recursively so\ni'm going to put a function\nbacktrack inside of another function so\nif we have this then we don't need to\npass in these two variables\ninto our function because this is nested\ninside of here we also don't need to\npass\nn in into this function either but we\nare going to have to pass in our open\nand closed count so i'll call it open\nn and closed n so we know the base case\nis if open n is equal to closed n\nwhich is equal to n so in that case we\nhave\nfinished and basically our stack will\ncontain the proper parentheses\nso what i'm going to do is basically\nsome python stuff but you could probably\nhandle this with a string\nif you wanted you don't actually need to\nuse a stack but i just like doing it\nso what i'm going to do is take every\ncharacter in\nthe stack and join them together into a\nempty string so\nonce they have been joined together they\nwill form a complete string and what i'm\ngoing to do is append that\nto our result list and once i've done\nthat i can just return right because\nthis is our base case\nremember if we want to add a open\nparenthesis we have to check that our\nopen\ncount is less than n if that's true what\nwe can do\nis to our stack we can append a open\nparenthesis\nso just an open parenthesis and then we\ncan recursively continue\nour backtrack and but if we do that we\nhave to increment our open count by one\nand the closed count remains the same\nand after that backtracking returns\nthough we do have to update our stack\nbecause we only have a\nsingle stack variable remember we're not\npassing this stack into every single\ncall this stack is basically a global\nvariable\nso every time we're done with\nbacktracking we're going to pop the\ncharacter that we just\nadded to the stack and if we want to\nadd a closing parenthesis we have to\nmake sure that the closed count\nis less than the open count so then we\ncan take our stack and append\na closing parenthesis and then we can\ncall our backtrack\nfunction our recursive backtrack except\nwe'll leave\nopen count the same this time and we'll\nactually increment the\nclosed count and as before we're also\ngonna need to clean up so we're gonna\nhave to update\nour stack by popping the character that\nwe just added\nand this is actually the entire function\nso you can see we\nbroke it up into three conditions which\ni commented up here\nand i explained in the visual\nexplanation\nso the only thing we have to do now is\ncall our backtrack function\npass in zero for the initial open and\nclosed count\nbecause our stack is initially empty and\nthen we can return\nwhat our result will contain which will\nbe the list of valid parentheses\nso as you can see this solution works\nand it is pretty efficient\nso i hope that this was helpful and if\nit was\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Daily Temperatures",
        "NcLink": "daily-temperatures/",
        "Pattern": "Stack",
        "Description": "You are given an array of integers `temperatures` where `temperatures[i]` represents the daily temperatures on the `ith` day.\n    \nReturn an array `result` where `result[i]` is the number of days after the `ith` day before a warmer temperature appears on a future day. If there is no day in the future where a warmer temperature will appear for the `ith` day, set `result[i]` to `0` instead.\n\n**Example 1:**\n\n```java\nInput: temperatures = [30,38,30,36,35,40,28]\n\nOutput: [1,4,1,2,1,0,0]\n```\n\n**Example 2:**\n\n```java\nInput: temperatures = [22,21,20]\n\nOutput: [0,0,0]\n```\n\n**Constraints:**\n* `1 <= temperatures.length <= 1000`.\n* `1 <= temperatures[i] <= 100`\n",
        "Difficulty": "Medium",
        "Video": "cTBiBSnjO3c",
        "PythonSolution": "class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        res = [0] * len(temperatures)\n        stack = []  # pair: [temp, index]\n\n        for i, t in enumerate(temperatures):\n            while stack and t > stack[-1][0]:\n                stackT, stackInd = stack.pop()\n                res[stackInd] = i - stackInd\n            stack.append((t, i))\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve a problem\ndaily temperatures we are just given an\narray of\nintegers which represent temperatures\nand we want to return an array\nanswer such that at every single\nposition in answer it's going to be the\nsame exact size as\nour temperatures array and at every\nsingle position in answer we want to\nknow\nfor the eighth day whatever the\ntemperature was on the i\nday we want to find how many days did it\ntake for us\nto find a temperature that was greater\nthan the temperature on the eighth day\nso for example let's take a look at this\nuh\ntemperatures array we can see there's\neight values in the temperatures array\nand there's eight values in the output\nfor\neach value in the temperatures array for\nexample 73\nhow many days did it take us in this\narray to\nto the right of of 73 how many days did\nit take us to find a new\ntemperature that was greater than 73\nwell on the\non the exact next day we found 74 which\nis greater than 73\nso it took us one day so in the first\nposition we're going to return a 1.\nwhat about 74 how many days did it take\nus to find a new temperature that was\ngreater than it\n75 one day later right okay for 75\nhow many days did it take us 71 is not\ngreater\n69 is not greater 72 is not greater but\n76\nis greater and you can see that took\nabout four\ndays right so then we return a four in\nthat position now there are some\ntemperatures\nthat never had a temperature greater\nthan them look at these\nlast two temperatures we had a 76\nnothing to the right of 76 is greater\nthan it and of course the last position\n73\nthere's no temperatures to the right of\nit in the first place so nothing\nwas greater than 73 to the right so for\nthese ones we're gonna return a default\nvalue of zero\nso we're gonna build an output array now\nlooking at the\nthe input what's the brute force way to\ndo it of course we could do an\nn squared approach right like for every\ntemperature we would look through the\nentire temperature array\nafter it right and see okay how many\ndays did it take us to find a\ntemperature that was greater than this\none right and then\ndo the same thing for the next\ntemperature over here look through the\nentire or i see\nyou know what's the first day that we\ncould find a greater temperature and\nkeep doing that now that's going to be\nbig o\nof n squared time complexity but there\nactually is an\neasier way to do this problem if we use\nsome extra memory\nnow let's just iterate through the input\narray once\ngoing to the right but we do need to\nknow that for example\nwe have to remember the previous\ntemperatures\nthat we looked at so if we you know\nlet's say the previous temperature here\nwas a 73 like in the input example and\nthen the next temperature\nwas a 74 when we get to this position we\nhave to somehow remember\nwhat was the temperature that came\nbefore it right now obviously we could\nuse a list for that or in this case a\nstack would be more intuitive\nbecause one thing we're going to notice\nis if we get a temperature\ngreater than at 74 right then we're\ngoing to say okay what was our previous\ntemperature 73 so this temperature is\ngreater than it right\nso we can we can keep track of what\nindex this\noccurred at and what index we're at\nright now and say okay the difference\nbetween these indexes\nwas one right we clearly found a\ntemperature the first temperature\ngreater than the 73 so then what are we\ngoing to do from our stack well then we\ndon't have to remember this anymore\nright we're going to say okay we're\ngoing to put a 1 in the output and we\ncan pop this\nfrom our stack right so we're going to\ndo stack.pop\nso this will be popped from the stack\nnow when we get to a 75 the exact same\nthing is going to happen right clearly\nwe see these temperatures are in\nincreasing order so we see okay one day\nit took us\nto get r to get a temperature greater\nthan this we'll put a one in the output\npop this from the stack and\nif we just had increasing temperatures\nthat would be really easy for us right\nbut it's not always going to happen\nwhere we have increasing temperatures\nwhat happens\nif we had a 72 that came after it\nwell we would we would look at the 72\nand compare it to the top of the stack\nsay okay this is not\ngreater so we can't pop from the stack\nbut we're also going to take this value\nand add it to the sec so now we're going\nto have two values\ninside of our stack and what happens if\nwe got another\nsmaller value 71 right so far for none\nof these values\ndo they have a temperature to the right\nof them that's greater right\nso all three of these are going to be on\nthe stack what are we noticing about our\nstack\nit's going to be in monotonic\ndecreasing order right\nthis is a type of stack problem that i\nhave solved on this channel a couple\ntimes but this is more of a beginner\nfriendly monotonic\ndecreasing stack problem what this means\nis that our stack is going to be in\ndecreasing order that's what monotonic\nmeans it's always in decreasing order\nnow technically\nwhat if what happens if we got another\n71 over here right\nwell in that case 71 is not greater than\nthis so\nall four of these would be on our stack\ncurrently right so it's technically not\nmonotonic\ndecreasing order it could be equal as\nwell right we're noticing it's not\nstrictly decreasing if two values are\nequal they're also going to go on the\nstack\nbut if we got a greater value if i got\nto a 72 right\nwhat am i gonna do clearly 72 is greater\nthan the top of our stack so i pop\nthis one right but now we have a new\nvalue on the top of our stack\nthis one is is our 72 greater than this\nit's not\nso so our stack is like this now we\nlooked on our stack we took\nthis guy out this is no longer in our\nstack but these three values are in our\nstack and still\nnotice how the the stack is still in\nmonotonic decreasing order it's always\ngoing to be the case\nwhat happens if instead of a 72 i had a\n73 then of course we'd still pop this 71\nand then we'd we'd also want to pop the\n72 because now 73\nis greater than 72 we pop this but it's\nnot the case\nfor this one but if you know we change\nthis value to a 74\nexcuse my bad handwriting over here but\nif we change this to a 74\nthen yes we are going to pop this one as\nwell so no matter what we do\nour stack is always going to be in\nmonotonic decreasing order if i\nadd a 70 over here it's we're not going\nto pop anything\nit's still in decreasing order so let's\njust run through a quick simulation let\nme show you how we can get this output\nin linear time\nusing a stack so first value 73\nwe're going to compare it to the top of\nour stack our stack is empty so we're\nnot going to do anything we're just\ngoing to take the 73 add it to the stack\nnext we're at 74 we're going to compare\nit to the top of the stack\n74 is greater than 73 right what index\ndid 73\noccur at at index 0 what index does 74\noccur\nat index one so we take the difference\none minus zero so\nit took us one position to find a value\ngreater than\n73 so we can pop 73 from our stack and\nthen 74\nis going to be on the top of our stack\nnow now exact same thing is going to\nhappen with 75 right\n75 is greater than this the difference\nbetween the indexes\nis one so we add a one to the output 474\nand we pop 74 now we're at and we add 75\nto the stack\nnext we get 71. 71 is not greater than\nthe top of our stack so all we do is add\nit\nwe don't update the output in either of\nthose positions\nagain we get a smaller value 69 so we\nadd it to the stack we can't pop any of\nthese 69's not\ngreater than either of these next we get\na 72 right\n72 is greater than 69 right so we pop 69\nwhat was the difference between the\nindices it was one so we're going to\ntake\nin the corresponding output position\nwhich is in this position for 69 we're\ngoing to say okay there was an\nindex difference of 1. now we're going\nto look at the next top for our stack\n71.\nso the difference between these two is\ntwo so for 71 we're going to say it took\ntwo days for us to find a greater\ntemperature than 71 so\nfor this position we add a 2 so we pop\n71 from our stack\nnow 72 is not greater than 75 so we\nstill have a hole in our output over\nhere we never found a greater\ntemperature than 75 yet\nand similarly for 72 we have a hole\nnext we get 76 and compare it to the top\nof our stack\nso 76 is greater than 72 we pop 72 the\ndifference\nthe number of days it took us was just\none day so we can add a one\nfor 72 and then we look at the next top\nof our stack\nyes we finally found a temperature\ngreater than 75\nit took us one two three four days to do\nthat so we can add a\nfour in the output in the corresponding\nposition over\nhere and we can pop 75 from our stack i\nthink i just need one more\nsquare over here because we have one\nlast temperature in our input 73 so\nwe're going to add 73\nsee 73 is not greater than 76 so we\ncan't pop that\nand now at the end we have no more\ntemperatures to add right we still have\ntwo temperatures\nleft in our stack and whatever the\ndefault value\nfor the unpopped uh temperatures is just\ngonna be zero right they told us\nin the uh description of the problem\nthat if we can't\nget a greater temperature we're just\ngonna put zero for these\nso that's how we build the output you\ncan see it exactly matches\nthe output that they built in the\nexample and\nwe did that in linear time by using this\nmonotonically\ndecreasing stack in o of end time of and\nmemory\nso now let's jump into the code so we\nare going to have a result or answer\narray and it's initially going to be\ndefault values of 0 because that's kind\nof what they tell us\nand it's going to be the exact same\nlength as the input array temperatures\ni'm also gonna have a stack remember\nthis is our extra memory it's gonna\nuh contain a pair of values in the in\nthe drawing example\ni only showed that we're adding the\ntemperature but we're also gonna add the\nindex of the temperature so we can\ncalculate the difference basically\ncalculate the number of days it took us\nto find a greater temperature so we're\ngoing to be adding two values\nto the stack a pair of temperature and\nthe index that that temperature occurred\nat\nnext we're just going to iterate through\nthe uh temperatures array we're going to\nenumerate this meaning we're going to\nget the in\nthe index of it and the value at the\nsame time it just makes the code a\nlittle bit cleaner\ni is the index t is the temperature\nfirst thing we're going to do is\nsee does is our stack empty and if it is\nis this temperature greater than the\ntemperature on the top of our stack\nthe top of our stack is index negative\none in python\nand the temperature is the first value\nin that pair so index\nzero and so if this is true of course we\ncan pop from our stack right so\nstack.pop\nso i'm going to call it the stack\ntemperature and the stack\nindex which we just popped right and for\nthis\ntemperature we want to you know in the\nresult output say okay\nwhatever the index of this temperature\nwas stack index we want to compute the\nnumber of days it took us to find a\ngreater temperature we can do that with\ni the current temperature that we're at\nminus\nthe temp the index of the\nuh temperature that we just popped and\nwe take the difference of those that\ngives us the number of days it took to\nfind a greater temperature and then\nwe're just adding it to the stack at the\ncorresponding position we want to\nand then once that while loop is done it\nmight execute zero times it might\nexecute multiple times\nafter it's done then we finally want to\nappend to the stack\nthe temperature that we're currently\ntraversing so a pair the\nt the temperature value and the index of\nthat temperature\nand once we're done with that we can go\nahead and return our result the reason\nwe don't have to fill\nin any extra zeros if our stack is\nnon-empty is because we already\ninitialized\nour result to b0 so if we never filled\nanything in\nthe default value is automatically gonna\nbe zero\nso you can see the solution works and is\npretty efficient so i hope this was\nhelpful\nif it was please like and subscribe it\nsupports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Car Fleet",
        "NcLink": "car-fleet/",
        "Pattern": "Stack",
        "Description": "There are `n` cars traveling to the same destination on a one-lane highway.\n\nYou are given two arrays of integers `position` and `speed`, both of length `n`. \n* `position[i]` is the position of the `ith car` (in miles)\n* `speed[i]` is the speed of the `ith` car (in miles per hour)\n\nThe **destination** is at position `target` miles.\n\nA car can **not** pass another car ahead of it. It can only catch up to another car and then drive at the same speed as the car ahead of it.\n\nA **car fleet** is a non-empty set of cars driving at the same position and same speed. A single car is also considered a car fleet.\n\nIf a car catches up to a car fleet the moment the fleet reaches the destination, then the car is considered to be part of the fleet.\n\nReturn the number of **different car fleets** that will arrive at the destination.\n\n**Example 1:**\n\n```java\nInput: target = 10, position = [1,4], speed = [3,2]\n\nOutput: 1\n```\n\nExplanation: The cars starting at 1 (speed 3) and 4 (speed 2) become a fleet, meeting each other at 10, the destination.\n\n**Example 2:**\n\n```java\nInput: target = 10, position = [4,1,0,7], speed = [2,2,1,1]\n\nOutput: 3\n```\n\nExplanation: The cars starting at 4 and 7 become a fleet at position 10. The cars starting at 1 and 0 never catch up to the car ahead of them. Thus, there are 3 car fleets that will arrive at the destination.\n\n**Constraints:**\n* `n == position.length == speed.length`.\n* `1 <= n <= 1000`\n* `0 < target <= 1000`\n* `0 < speed[i] <= 100`\n* `0 <= position[i] < target`\n* All the values of `position` are **unique**.\n",
        "Difficulty": "Medium",
        "Video": "Pr6T-3yB9RM",
        "PythonSolution": "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n        stack = []\n        for p, s in pair:  # Reverse Sorted Order\n            stack.append((target - p) / s)\n            if len(stack) >= 2 and stack[-1] <= stack[-2]:\n                stack.pop()\n        return len(stack)\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem car fleet i\nthink a lot of people don't end up\nsolving this problem but i think it's a\nvery good problem and interesting\nproblem to solve so we're given n cars\nthat are traveling along the same road\nit has one lane the road has only a\nsingle lane and this is important for\nthe rest of the problem all the cars are\ntraveling towards some destination which\nis at some target position right and\nevery car that we're given has a\nposition\nand it has a speed associated with it\nand remember they're all traveling in\nthe same direction towards the target\nand the position and speed are given in\ntheir own arrays so there's two separate\narrays given for b for each of these and\nthe important thing is that a car can\nnever pass another car that's because we\nhave one lane in the road right so\nimagine we have two cars like these you\nknow this one's traveling and then this\none's traveling right let's say this\none's traveling at 10 miles per hour and\nthe other one is traveling 20 miles per\nhour of course the faster one is\neventually gonna catch up to the slower\none but since they're in the same road\neven when they do catch up that faster\none uh is just going to be traveling\nright next to the slower one right so\nthe slower one was traveling at 10 once\nthe fast one catches up its speed is\ngoing to be reduced to 10 because it\ncan't pass the one that's ahead of it so\nonce cars are basically traveling right\nnext to each other that is called a car\nfleet and\nand by the way if these cars are right\nnext to each other they're basically\nassumed to have the same exact position\neven though technically one is behind\nthe other one they still are considered\nto have the same position uh that's what\nthey mentioned right here and they also\nmentioned a car fleet is just some\nnon-empty set of cars that are basically\nat the same position traveling at the\nsame speed and by the way even a single\ncar can be considered a car fleet so and\nthe last edge case you might be\nwondering is if what if a car catches up\nright at the moment that they both\narrive at the destination point because\nremember once they arrive at the\ndestination they're going to stop so\nwhat if a car catches up exactly at the\ndestination well they're considered a\ncar fleet and what we want to do\nis determine the total number of car\nfleets that will arrive at the\ndestination so you know in this case for\nexample this example problem we're given\nfive cars right so initially we have\nfive car fleets but when they actually\narrive at the destination which in this\ncase is at position 12 then they are\ngoing to be reduced down to three car\nfleets okay so now let's try to figure\nout how we can actually solve this\nproblem and let's take a look at our own\nexample so here you can see i'm\nbasically combining the two arrays that\nthey give us i know they give us a\nseparate array for position and speed\nbut i'm just going to combine it into an\narray of pairs so this pair represents\nuh you know the first is the position\nnext is the speed so this is at position\nthree with speed three this is at\nposition five with speed two this is at\nposition seven with speed one\nand our target in this case is ten so\ni'm gonna actually explain this problem\nin a way that you might not expect\nbecause when you actually think about\nwhat these cars are they're literally\njust a system of linear equations right\nwe have the time on one axis\nand we have the position on another axis\nright and if we take a single example\nsuch as this one right it starts at\nposition three so position three is over\nhere on the chart and it has a speed of\nthree what does the speed mean it means\nthat the slope is going to be three\nright so every unit of time that passes\nit will be in\nthree positions ahead right so in one\nsecond it'll be at position six in two\nseconds it'll be at position nine excuse\nmy kind of bad drawing here and then at\ntime 3 it'll be at position 12. so\nbasically it reaches it reaches the\ndestination 10 right remember 10 is our\ndestination it reaches it at let's say\ntwo point something seconds right and we\ncould calculate that if we really want\nto pretty easily it's just a linear\nequation but i'm just drawing it out\njust so you kind of get an idea of\nwhat's going on here so now let's do\nthis one seven one and let's use a\ndifferent color just to kind of\nillustrate things so it starts at\nposition seven and it has a slope of one\nso each unit of time is just going to go\nup one position so at time three is when\nit's going to uh reach the destination\nright so we can draw a\nyou know line like this one and what you\ncan already tell\nfrom this drawing is these intersect\nhere right they intersect before they\nreach the destination what does that\ntell us that tells us that they are\ngoing to become a car fleet this orange\none and the blue one right they\nintersected over here before the orange\none reached the destination over here so\nwhat's actually going to happen with\nthis orange one this part of the drawing\nis is not going to happen right\nbecause once they do intersect over here\nthe orange one is going to travel at the\nsame speed as the blue one because it\ncan't pass the blue one right on the\ndrawing we showed that the orange one\npassed the blue one but that's that's\nimpossible in the context of this\nproblem right so a better uh drawing for\nthe orange one would have been something\nlike this\nright like it starts at a high slope but\nthen it slows down and just to finish up\nthe drawing so this other one five two\nit starts at position five it has a\nslope of two so by the time it reaches\nthe destination it'll be at 2.5 which is\nabout over here i think so let's just\ndraw a continuous line and even though\nit's kind of hard to draw a straight\nline here but you can see again these\nintersected as well right so that must\nmean since all three of them intersected\nthat must mean that we're gonna have a\nsingle car fleet right and that's pretty\nobvious when you look at a drawing and\nactually when we look closer at the\ndrawing we see that the orange one\nintersected with the green one before it\nintersects with the blue one so actually\nwhen the orange one intersects here it's\nactually going to be traveling at the\nsame rate as the uh green one\nand you can continue with this drawing\nif it kind of gives you a good intuition\nof the problem i just wanted to kind of\nshow you like where i'm coming from with\nthis problem and that i'm not just\nimmediately jumping to the solution but\nknowing kind of this idea we can\nkind of get into the solution to this\nproblem and we can actually do it in\nlinear time so now you can see that i've\ndrawn the cars and their positions in\nsorted order and that makes sense right\nwouldn't we want to go through the cars\nin sorted order because of course we\nknow that they can't like the relative\norder of the cars is never gonna change\nso it makes sense to go through them in\nsorted order now for any two given cars\nsuch as these two how do we know if\nthey're gonna intersect or you know\nthey're gonna collide and become a\nsingle car fleet before they reach the\ndestination position well basically by\nthe drawing i showed you earlier if\nthese two intersect each other right so\nwhat we could do is actually calculate\nthe intersection point of these two if\nwe really wanted to but there's a\nslightly easier way we can just\ncalculate what time is this car going to\nreach the destination and what time is\nthis car going to reach the destination\nif this car reaches the destination\nbefore or at the same time as this one\nthat must mean that they became a car\nfleet right they became a car fleet\nsomewhere in the middle somewhere in\nhere so since this one is moving at one\nmile per hour and this one is moving at\ntwo miles per hour or whatever you know\nwhatever unit of speed or something that\nthey gave us we can calculate what time\nthey're going to reach the destination\nwe can do it pretty easily right we can\njust take the distance difference for\nyou know i'm gonna do the green one\nfirst we can take 10 minus seven right\nthat's the distance that we need to\ntravel three units of distance and\ndivide that by the speed in this case\none so this is going to reach the\ndestination at time equals 3. we can do\nthe same thing for this one so 10 minus\n5 divided by 2 that's going to be 2.5 so\nthis is going to reach the destination\nat time\n2.5 so that must mean that they are\ngoing to collide so we know they're\ngoing to be one car fleet so technically\nwe can kind of just like delete one of\nthese right\nand just not consider it anymore but\nwhich one of these two are we going to\nremove right like\nokay let's say i remove one and then you\nknow i start comparing the remainder of\nthe list that's on the left side well\ni'll tell you right now we're always\ngonna keep the one that comes ahead\nbecause if these collided they're gonna\nend up being reduced down to the speed\nof the one that's ahead right so this is\ngonna start traveling at one instead of\ntwo right that's gonna be the new speed\nso if we want to know if these two\nintersect it's going to be harder to\ncalculate because this one is going to\nhave two different speeds initially it's\ngoing to be 2 but at some portion it's\ngoing to change to 1. so it's easier if\nwe\nkeep this one because this one is always\ngoing to be traveling at speed one and\none more thing we're actually we're not\ngoing to go from left to right we're\ngoing to go from right to left when we\ndo this operation and the reason is\npretty much the same because if we\nstarted at the beginning and then we\nwere checking okay do does this one\ncollide with the blue one well we don't\neven know what speed the blue one is\ngoing to be traveling throughout the\nwhole thing we can't just assume it's\ntraveling at speed two the entire time\nbecause it could collide with somebody\nelse and slow down that's why it's\nbetter to start from the right and then\niterate through this in reverse order\nokay now and just to complete the\nexample so we know that this is going to\nend up colliding with this one so we can\njust assume that this car is a single\ncar fleet we have one more car over here\nand it's traveling at speed three so now\nwe wanna know is this one going to\ncollide with this one we already know\nwhat time this is gonna reach the\ndestination let's calculate the time\nthis is gonna reach the destination so\nwe can do 10 minus three so that's seven\ndivided by three that's going to be two\npoint something right let's just say two\npoint i think it's 2.3 or something but\nit's not too important but we know that\nthis uh since it has a smaller time than\nthe one ahead of it then they are going\nto collide and remember which one of\nthem are we gonna delete we are gonna\ndelete\nthis one because it's the one that's\nbehind okay so before we get into the\ncode just to mention the overall time\ncomplexity of this portion of the\nalgorithm where we're actually going\nthrough the cars is big o of n but of\ncourse we know we actually have to sort\nthe input based on the position so\nthat's going to make the overall time\ncomplexity end up being n log n uh and\nthe extra space is just going to be big\no of n\nbecause we're going to be creating a\nseparate array but we're also going to\nbe using a stack just to give you a\npreview of how we're going to be doing\nthis so so just to let you know\ninitially our stack is going to be empty\nwe're going to go through this in\nreverse order so first car we're going\nto go ahead and add it to the stack okay\nnext car we're going to go ahead and\ntake this and then add it to the top of\nthe stack but then we're going to\ncompare\nthis car with the other car that's\nadjacent to it on the stack right both\nof these are going to be on the stack if\nthey collide with each other which we\ncan calculate pretty easily then we're\ngoing to remove the one that's on the\ntop of the stack\nthis one is the one that's on the top of\nthe stack so this is the one we're going\nto pop from the stack and that's how\nwe're going to do the algorithm so you\nknow assuming we pop this from the stack\nbut then we add this one and and then we\nend up popping this one as well what\nwe're going to end up returning is the\nnumber of car fleets that actually exist\nat the end of the entire algorithm which\nwe can get easily because we can just\ntake the length of our stack and that'll\ntell us how many car fleets we actually\nhave and it's just going to be a single\none in this example problem so now let's\nget into the code okay now let's write\nthe code i love problems like these\nwhere we can spend most of our time\nactually explaining it and talking about\nit and then the code becomes easy the\nfirst thing i'm going to do is just kind\nof create an array of pairs uh in python\nit's pretty easy to do i'm just going to\niterate through both of the position and\nspeed array simultaneously i can do that\nwith zip but you can you know instead of\nusing an array of pairs you can also\njust uh have like a hash map or\nsomething and then just sort the\npositions if you want i'm doing it this\nway because it's easiest but you can do\nit how you'd like this is i think called\nlist comprehension in python if you want\nto google it we're just creating an\narray of pairs but next we don't want to\nforget to actually sort that array of\npairs so actually\nwhen we go ahead and iterate through the\narray of pairs p\nposition and speed in\nsorted pair and so we can iterate\nthrough this sorted but we also want to\nmake sure we iterate through it in\nreverse order in python that's pretty\neasy to do just like this so just to\nclarify what we're doing is reverse\nsorted order and we need one more\ndata structure just our stack which will\ntell us how many car fleets we have at\nthe end okay so we're going through\nevery single car remember when we get to\na car we want to know what time is it\ngoing to reach the destination we can\nget that easily just by taking target\nminus the position of this car and then\ndividing that by the speed in python\nthis is decimal division and that's very\nimportant because we know the time could\nbe a decimal we don't want to make an\ninteger of it we don't want to make an\ninteger division by adding two slashes\nso we're going to take this time and\nwe're going to go ahead and append it to\nour stack\nand once we've appended it to our stack\nwhoops there's a little typo we want to\nknow does it overlap with the other one\nat the top of our stack so first we want\nto make sure that our stack has at least\ntwo elements in it because if it just\nhas one element just one car then we\ndon't really need to do anything\nbut if it has at least two cars it could\nbe possible that we have a collision so\nif the\nthe time that the top of our stack at\nindex negative one that's how you can\nget to the top of the stack in python if\nit reaches the destination before the\none that's ahead of it at index negative\ntwo like if the time of it is less than\nthe next one that must mean they collide\nthat must mean we have to pop from the\nstop of the stack and by doing that\nwe're decreasing the number of car\nfleets if we don't pop then we leave it\nas it is and in case i didn't explain\nthis earlier you might be wondering why\nis this an if statement rather than a\nwhile loop and let me explain that for a\nsecond suppose that this is our stack\nright we have three elements so and when\nwe get to this one right and we find\nthat okay this collides with this one\nright so then what are we gonna do we're\njust gonna pop this from our stack right\nbut then you might be thinking okay well\nwhat if this one collides with this one\nright then we have to also remove this\none don't we but you're you might be\nforgetting that we already probably\nchecked that condition because we're\ntraversing this in reverse order right\nbefore we even get to this car over here\nwe're gonna check okay does this collide\nwith anybody nope okay does this collide\nwith this guy\nnope and then we get to this one and we\nfind yes this one actually does collide\nwith this guy but that's okay because\njust because it collides with this it'll\nnever collide with the next one because\nonce it does collide with the blue one\nthese two will be traveling at the same\nspeed and we determined that this won't\ncollide with that so it's impossible for\nthis to collide with this one so that's\nwhy we're doing it this way and that's\nactually all we have to do after we're\ndone with that we can just go ahead and\nreturn the length of the stack and let's\nrun this to make sure that it works and\nas you can see on the left it does work\nand it's relatively efficient so i\nreally hope that this was helpful if it\nwas please like and subscribe it really\nsupports the channel a lot consider\nchecking out my patreon where you can\nfurther support the channel if you would\nlike and hopefully i'll see you pretty\n"
    },
    {
        "Name": "Largest Rectangle In Histogram",
        "NcLink": "largest-rectangle-in-histogram/",
        "Pattern": "Stack",
        "Description": "You are given an array of integers `heights` where `heights[i]` represents the height of a bar. The width of each bar is `1`.\n    \nReturn the area of the largest rectangle that can be formed among the bars.\n\nNote: This chart is known as a [histogram](https://en.wikipedia.org/wiki/Histogram).\n\n**Example 1:**\n\n```java\nInput: heights = [7,1,7,2,2,4]\n\nOutput: 8\n```\n\n**Example 2:**\n\n```java\nInput: heights = [1,3,7]\n\nOutput: 7\n```\n\n**Constraints:**\n* `1 <= heights.length <= 1000`.\n* `0 <= heights[i] <= 1000`\n",
        "Difficulty": "Hard",
        "Video": "zx5Sw9130L0",
        "PythonSolution": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        maxArea = 0\n        stack = []  # pair: (index, height)\n\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i - index))\n                start = index\n            stack.append((start, h))\n\n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights) - i))\n        return maxArea\n",
        "Transcript": "let's Ollie code 84 largest rectangle\nand histogram so we're given a bunch of\nbar heights and each bar has a width of\n1 we want to find out what's the largest\nrectangle we can get and return the area\nof it so in this case the largest has an\narea of 10 width of 2 height 5 another\nrectangle we could get as an area 8 this\none has a width of 4 height of 2 another\nthere's also other rectangles we could\nget but these are a few of them so if we\njust draw the first two bars let's see\nif we can notice any patterns from them\nso if you look at them the first one is\nbigger than the second one\nthat means for the rectangle of height 2\nwe can't extend it any farther once we\nreach this one we can't extend it any\nfarther so the biggest rectangle we\ncould get with height 2 is just this one\nright here because there's a little hole\nover here so we can't push it any\nfarther but for this one we can push\nsince the height is 1 we can kind of\nextend it towards the left a little bit\nright and use the left rectangle and\nsince we can't extend the height 2 we\ncan still extend the height 1 because\nthere's no there's nothing coming after\nit that'll stop us just yet let's look\nat the opposite scenario what would\nhappen if the 1 came before the 2 in\nthis case the 1 comes first so we can\nkeep extending it to the right there's\nnothing stopping us right and the 2\nthere's nothing coming after it just yet\nthey'll stop us so we can actually\nextend this height of 2 a little farther\nbecause there's no smaller height that\nthe third case is if two rectangles were\neven right next to each other in this\ncase we can also keep extending it right\nbecause there's no hole these rectangles\nare the same height there's no smaller\nrectangle stopping\nfrom being extended farther to the right\nso this tells us that the current\nheights are going to be an increasing\norder because this two cannot be\nextended beyond this point so we can\nonly compute the area of height 2 from\nthis width and then we have to pop it\nright we can't extend it any farther so\nwe have to remove it from being\nconsidered so now let's look at the case\nwhere all the heights are in increasing\norder\nnotice how since they're all in\nincreasing order they can be extended to\nthe right continuously right so this one\nover here can continue to be extended to\nthe right this too can be extended to\nthe right this three can be extended to\nthe right and this four can be extended\nto the right none of them can be\nextended towards the left though right\nbecause the height to the left is\nsmaller so they can't be extended to the\nleft but what would happen if we\nintroduced a smaller height after so if\nwe introduced a three over here that\nwould mean that this four over here it\ncan't be extended any farther because\nthere's a three coming after it so all\nwe can do is say okay these are the\nboundaries of height four let's compute\nthe area which is going to be 4 in this\ncase because the width is 1 and then we\nhave to remove this from being\nconsidered right so we pop it what if we\nintroduced a 2 instead well the same\nthing will happen we can't extend this\nfor any farther right so all we can say\nis these are the boundaries of it right\nit's we started back here and then we\nextended all the way until we got to\nthis 2 so compute the area and then pop\nit right let's look at this 3 now we\ncan't extend this any farther either\nright because the 2 is less than the 3\nso we can say that these are the\nboundaries of the 3 let's see what the\narea it could have contributed was it's\n6 maybe that's the max area we don't\nknow yet but well you know we can't\nextend this three any farther so we have\nto pop it as well what about this 2 over\nhere\nwell since the new height that we got is\nalso 2 we can keep extending it there's\nan there's no reason we can't so we will\nall\nyou have to pop these two elements the\nthree and the four because we can't\nextend them any farther because now we\nreached a two let's look at one last\nexample to drive this point home so now\nwe have a one over here right so we\ncan't extend the four anymore either so\nwe compute the area four and then remove\nit from consideration also this three it\ncan't be extended any further so we\ncompute the area six and then remove it\nfrom consideration in this case even the\ntwo can't be extended any further right\nbecause the one is too small so we\ncompute the area in this case six and\nthen remove it from consideration so in\nthis case we had a 1 and then we popped\nso notice how we are popping elements\nand we're only popping the most recent\nelements we're not popping an element\nthat's in the middle\nwe're only popping them from the top to\nthe bottom from the most recent elements\nright so that tells us we should use a\nstack for this problem so the stack will\ncontain the current heights that are\nthat we are considering and we'll pop\nthem from the top when we are no longer\nconsidering them so now let's look at\nthe algorithm so I have a stack and in\nthe stack I'm not just gonna hold the\nindex and I'm not just gonna hold the\nheight I'm gonna hold both of them at\nthe same time so I'm holding the start\nindex and the corresponding height I'm\nalso gonna be maintaining what the max\narea is so far so now let's start at the\nbeginning of the array we get element\ntwo so since there's nothing in the\nstack we can't pop anything let's just\nadd it so I that's starting at index\nzero we have a height of two next we get\nto index one there's a height of one\nover here right so now we're gonna add\nthe height one to our stack but let's\nnotice let's look at our stack there's a\nheight one that's at the top of the\nstack right now that means that this -\nit can't be extended any farther we\nreached a height\nwas smaller than the two so that means\nwe're gonna pop the two from the stack\nbut before we pop it let's just see\nwhat's the max area we could have gotten\nwith this to height so it started at\nindex zero right we can see it started\nat index zero and it and we just reached\nindex one so that's the range of the\nwidth from zero to one so the width is\none the height is two so that means the\narea is two so so far we'll say our max\narea is two now and now we can pop the\ntwo from the stack so what's the index\nof this one now\nwell we're currently at index one right\nso we can say that that's the index but\nI'm actually gonna do it a little\ndifferently if you look at this two we\ncan actually extend this one all the way\nback because we just popped this - that\nmeans this one could have been extended\nback by one so instead of saying the\nindex of this one of this height one\nstarts at index one I'm gonna say it\nstarts at index zero because we can\nextend it all the way back to the zero\nover here next we're gonna get at index\ntwo we have a five right so we'll add\nthat to our stack the five is greater\nthan the one so there's no restriction\nthis one can still be extended so I'll\njust add the five and the corresponding\nindex which is two to the stack don't\nneed to pop anything next we get to\nindex three right there's a height of\nsix again this six is greater than this\nthan the value at the top of our stack\nwhich is five so the heights are in\nincreasing order so far which is good\nthat means we don't have to pop anything\nand the index we reach the six was at\nthree\nthat means this five can continue to be\nextended that's why we don't have to pop\nthe five now we get to index for this is\nwhere the interesting stuff happens so\nwell so this at this index four we have\na height - the problem is this six now\ncan't go any farther we reached a two so\nthis six which started at index 3 over\nhere ended up stopping at index 4 that\nmeans its width was only one so we have\nto pop it now but before we pop it let's\nget that\narea that it could have made so from in\ndepth so the width is one the height is\nsix that means the area it could have\nmade is six this is the max area that\nthis height of six could have created so\nwe'll update our max area six is greater\nthan two our max area is now six and\nokay now the top of our stack is five\nbut wait\nfive is greater than the two as well\nthat means this five can't be extended\nany farther so we look at the start\nindex of this five it was index two and\nwe stopped it all the way index four so\nthat means its width was to its height\nis five so the area it created was 10 so\nbefore we pop it let's just compute the\nmax area that it could have created it's\n10 so we update our max area our max\narea is now 10 greater than 6 and we\nremember to pop this 5 from our stack\nnow we look at the top of the stack it's\n1 right 2 is greater than 1 so we don't\nhave to pop this one because this one\ncan continue to be extended so we don't\nhave to pop it right and what about the\nstart index do we put for this height of\n2 can we put index 4 well yes we can but\nwe notice that we just popped two\nelements 6 and 5 that means this 2 can\nactually be extended backwards all the\nway to index 2\nright so instead of saying index 4 is\nthe start value of this - I'm gonna say\nindex 2 next we reach index 5 the last\nelement so this height is 3 let's put it\non our stack we see 3 is greater than 2\nthat means we don't have to pop the 2\nfrom the stack that means that this 2\ncan continue to be extended there's no\nneed to pop it and what about the start\nindex of this height 3\nwell we can't extend it backwards\nanymore so I'm just gonna say the start\nindex is 5 if you look we still have the\nelements left in our stack so what do we\ndo with them so we have three elements\nthat we didn't end up popping from the\nstack what that tells us is that we were\nable to extend them all the way to the\nend of the histogram so we still need to\ncompute the areas we could have created\nfrom these heights\nso let's iterate through them and figure\nthat out so let's start at this last one\nindex five it started and it had a\nheight of three so it started at index\nfive and went all the way to the end of\nthe histogram so that means the length\nof it was just one the height is three\nso we can compute the area as having an\nnow this area of three is not greater\nthan our current max of ten so we don't\nupdate our max let's go to the next\nelement in our stack it's indexed to\nheight two that means it started at\nindex two over here and it went all the\nway to the end of the histogram and it\nhad a height of two so that means the\nwidth was four\nthe height was to two times four is\neight is not greater than our max area\neither the max areas 10 so we don't\nupdate the max area the last element in\nour stack index zero height one that\ntells us it started all the way back\nhere at index zero and it extended all\nthe way to the end of the histogram so\nfrom zero to the end is a width of six\nthe height was one so that means the\narea it created was six this six is not\ngreater than our current max area of ten\neither so that means the max area at the\nend is ten so that's the result 10 so\nwith this algorithm we only had to\niterate through the histogram once we\nhad to push elements onto our stack but\nwe had to only push each element once\nand pop it once so that means the\nwe had to use a stack and the stack\ncould potentially be up to the entire\nsize of the of the input array so we did\nneed extra memory the memory is also\ngoing to be Big O of n ok now let's\nwrite the code so we know we have to\nkeep track of what the max area\ncurrently is so I'm going to initially\nsay the max area is 0 we also know we\nhave to have a stack in Python we can\nuse just a list to do that and in my\nstack I'm going to hold a pair of\nelements the pair of elements is gonna\nbe an index and the height so now let's\niterate through the index and height of\nthis Heights array before I add it to\nthe stack I'm gonna say the start index\nof this current height that we're at is\njust I because we don't know if we can\nextend it backwards just yet so let's\nnow check if our stack is not empty and\nif the stack if the top value in the\nstack and the top values height is\ngreater than the height that we just\nreached if that's the case that means we\nhave to pop our stack right we have to\npop the height and we have to check the\nmax rectangle we can create from that\nheight and we have to extend the current\nheight that we're at backwards so now we\nhave to pop from the stack because this\nheight is too great right so we're\npopping but we have to actually retrieve\nthe values who are popping so we're\npopping in index and we're popping the\nheight and we have to check if this\nheight that we're popping could have\nwe're gonna multiply the height by the\nwidth we can compute the width pretty\neasily right now we're at the current\nindex we're at is I and the index that\nthis height started out was what we just\npopped index so I minus index is going\nto be the width and since we know that\nthis height was greater than the current\nheight that were visiting that means we\ncan extend our start index backwards to\nthe index that we just popped now when\nwe actually add our element to the stack\nor add our pair to the stack we're gonna\nsay we're gonna add the pair start index\nand the height that we're visiting right\nnow we're not just adding I we're adding\nthe start index that we pushed all the\nway backwards and now we remember there\nstill might be some entries in our stack\nleft so these were able to be extended\nall the way to the end of the histogram\nso we still have to compute their\nheights and we can do that pretty easily\nso we potentially update our max area\nthe height is just what's stored in the\nstack so height multiplied by the width\nwe can compute the width pretty easily\nwe know that these were extended all the\nway to the end of the histogram so we\ncan get the length of the histogram\nsubtracted by the start value I that was\nstored in the stack and now all we have\nto do is return our max area and it\nworks perfectly I think this is the most\nintuitive solution at least from my\nperspective for this problem storing I\nthink the start index and the height in\n"
    },
    {
        "Name": "Binary Search",
        "NcLink": "binary-search/",
        "Pattern": "Binary Search",
        "Description": "You are given an array of **distinct** integers `nums`, sorted in ascending order, and an integer `target`.\n    \nImplement a function to search for `target` within `nums`. If it exists, then return its index, otherwise, return `-1`.\n\nYour solution must run in $O(log n)$ time.\n\n**Example 1:**\n\n```java\nInput: nums = [-1,0,2,4,6,8], target = 4\n\nOutput: 3\n```\n\n**Example 2:**\n\n```java\nInput: nums = [-1,0,2,4,6,8], target = 3\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= nums.length <= 10000`.\n* `-10000 < nums[i], target < 10000`\n",
        "Difficulty": "Easy",
        "Video": "s4DPM8ct1pI",
        "PythonSolution": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            m = l + ((r - l) // 2)  # (l + r) // 2 can lead to overflow\n            if nums[m] > target:\n                r = m - 1\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                return m\n        return -1\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem binary search\nwe're given an array of integers nums\nwhich are going to be sorted in\nascending order and we're also given a\ntarget integer that we're going to look\nfor if the target exists in the array\nthen we can return the index of it if it\ndoes not exist then we return one the\ngoal is to create an efficient algorithm\nthat can run in log n time so what\nalgorithm are we going to use well the\nproblem pretty much tells you binary\nsearch so while this is self-explanatory\nand a pretty basic algorithm i still\nthink it's really important because a\nlot of problems kind of extend the idea\nof binary search and then make it even\nharder and this is actually a pretty\ncommon interview question to be asked\nsome variation of binary search so this\nis a very good problem to practice and\nyour goal should be able to implement\nbinary search very quickly basically as\nif you were doing it in your sleep so\ni'll try to explain this quickly but\nalso in a beginner-friendly way so the\ninput array is sorted the target value\ncould exist anywhere in this array or it\nmight not exist at all when we start we\nare considering the entire input array\nhow are we going to do that well we're\ngoing to have two pointers one pointer\nis going to be at the leftmost index\nwhich is initially index zero another\npointer is going to be at the rightmost\nindex these pointers mean that we are\nconsidering the entire range now if we\ncould only look at one of these values\nwhich one should we look at should we\nlook at the leftmost if we do that and\nwe see that it's not equal to the target\nthen we've only eliminated one\npossibility and we still have to search\nall of these if we look at the rightmost\nsimilarly it's not the target so we've\nonly eliminated one possibility we still\nhave to look at the rest of them but if\nwe look at the midway point and\ntechnically either of these could be the\nmidway point the way we calculate it\nthough is going to be literally taking\nthe left and right indexes and dividing\nthem by two which i think will lead us\nto this position but approximately the\nhalfway point why should we look here\nwell we can compare it to the target\nit's not equal to the target so what\ndoes that tell us have we only\neliminated one possibility no because\nremember the input array is sorted so if\nthis is not equal to the target we\nshould also ask is it smaller than the\ntarget or is it larger than the target\nin this case it's smaller than the\ntarget so if this is smaller than the\ntarget then everything to the left of it\nis also going to be smaller than the\ntarget so this was our midway point\nwe'll call it m and we found that it's\nsmaller than the target so we can\neliminate these three values from\nconsideration everything over here how\nare we gonna you know represent that in\ncode well we're gonna take this left\npointer and then shift it to be m\nplus one so now our left pointer is\ngonna be over here this represents\npossible range of solutions is going to\nlie within you know these two pointers\nso at this point we're just going to\nrepeat the algorithm repeat what i\npretty much just did now if we take\nthese two add them together divide by\ntwo the middle is going to be over here\nso then we're going to check is this\nequal to the target that we're looking\nfor in this case yes it is so now we can\nreturn the index because that's what we\nwere trying to do we can return m\nwhatever it happened to be i think it's\n4 in this case so that is pretty much\nthe idea of binary search okay so now\nthe time complexity if you know binary\nsearch you already know that it runs in\nlog in time but let's quickly understand\nwhy so we're not considering this\nexample anymore but suppose we had 16\nvalues in the input array every time we\ngo to the midway point we either find\nthe target but if we don't find the\ntarget we know we're at least going to\neliminate half of the possibilities so\nwe would eliminate this down to a now\nwe're only looking at eight values we\nstill don't find the result we keep\ndividing it by two make it two remaining\nand then finally there would only be\none value remaining and either that's\ngoing to be the target or it's not going\nto be the target and then we're pretty\nmuch done with the algorithm anyway so\nthe question is if we have a while loop\nthe while loop is going to run as many\ntimes as we can divide the length of the\ninput array by two how many times can we\ndivide it by two well if you remember\nfrom your math class that is a math\nequation called log base two of n this\nevaluates to how many times can we\ndivide n by 2. and you know suppose it\nevaluates to be x that's equivalent to\nsaying that 2 to the power of x is going\nto be equal to n okay but this is too\nmuch math maybe you don't even care but\nthat's pretty much the idea that's why\nour loop is going to run x times which\nis going to be equal to log n so it's\nnot a big o of n algorithm it's a log\nbase 2 n algorithm which is much much\nmore efficient\nokay so now let's code it up and like i\ndid in the drawing initially we're\nconsidering the entire input array as\nour search area so our left pointer is\ngoing to be at zero our right pointer is\ngoing to be at the last index which is\njust the length of the array minus 1.\nnow we want to continue going until\nthere's no more possibilities left or we\nhave maybe found the result so the way\nto do that is to basically say that\nwhile our left pointer is less than or\nequal to our right pointer because i\ndidn't show it in the drawing picture\nbut suppose we just had a very small\ninput array just to illustrate the\nexample our left and right pointers\nwould both point here our midpointer\nwould also point here but suppose our\ntarget is actually equal to two okay\nwe'd say okay this is too small for our\ntarget so we're gonna set our left\npointer to be equal to mid plus one so\nthat means our left pointer would be one\nand our right pointer would be zero that\nbasically means our left pointer has\ncrossed our right pointer and that's how\nyou know that we have no more values\nleft to search we did not find the\nresult so that's why we're doing less\nthan or equal if they're both equal\nthough if they're both pointing at this\nvalue that means we haven't looked at\nthis value yet so that's the idea so\neach iteration of the loop we're just\ngoing to find the midway point which we\ncan get by taking l plus r and dividing\nby two if the value that this index is\nat is greater than the target then we\nwant to look at all values to the left\nof it so we're gonna take our right\npointer and set it to m minus one we\nwanna look at all values to the left\nwe're basically shrinking our criteria\nand in the other case else if that num\nis smaller than our target then we're\ngonna do the opposite we're gonna set\nleft equal to mid plus one just like in\nthe drawing explanation the last case is\nif neither of those are true that must\nmean that we found the target if it's\nnot greater and not smaller that means\nit must be equal that means we can\nreturn m which is the result but if we\nwent through every iteration of the loop\nand we didn't find the result then\noutside of it we are told that we should\nreturn negative one to indicate we did\nnot find a result so that's the solution\nlet's run it to make sure that it works\nand as you can see on the left yes it\ndoes and it's very efficient there's one\nmore thing though that i want to mention\nto you which probably won't come up in\nyour interview to be honest it's never\ncome up in mine but there's actually one\nlittle bug here i mean technically the\nbug doesn't exist in python because\npython\nintegers are unbounded they can pretty\nmuch be infinitely large but in most\nlanguages like java and c plus plus you\nmight encounter an overflow because\nsuppose we had a very large input array\nand then these two integers were very\nclose to the 32-bit integer max which is\nsomething like\n2 to the power of 31 suppose they were\nboth close to that then adding them\ntogether would possibly overflow and\nthen we would get the wrong result in\nthis\nvalue so possibly your interviewer might\nask you something about that and how\nwould you go about fixing that well\nthere's actually a way to do that we can\nstill calculate the midway point between\nleft and right without adding them\ntogether because we can take the\ndistance between them we can get the\ndistance between them by taking right\nminus left and then dividing that by two\nright that will give us half of the\ndistance between them and we can take\nthat and add it to the left index\nbecause if this is halfway of the\ndistance between them and then this is\nthe left index by adding these together\nwe are getting the midway point this is\njust a way to do the exact same\ncalculation but this way it will never\noverflow because right is always going\nto be greater than or equal to left and\nin this case we're not adding them\ntogether we're subtracting them so this\nwill always be positive or it will be\nzero so i'll run it and it does work\npretty much exactly the same as you can\nsee on the left but this is just\nsomething i think a lot of people don't\ntalk about and actually i pretty much\nnever implement it this way people have\nactually mentioned that in my comments\nbefore which is kind of why i'm talking\nabout it today but i really hope that\nthis was helpful if it was please like\nand subscribe it really supports the\nchannel a lot consider checking out my\npatreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Search a 2D Matrix",
        "NcLink": "search-2d-matrix/",
        "Pattern": "Binary Search",
        "Description": "You are given an `m x n` 2-D integer array `matrix` and an integer `target`.\n\n* Each row in `matrix` is sorted in *non-decreasing* order.\n* The first integer of every row is greater than the last integer of the previous row.\n\nReturn `true` if `target` exists within `matrix` or `false` otherwise.\n\nCan you write a solution that runs in `O(log(m * n))` time?\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7ca61f56-00d4-4fa0-26cf-56809028ac00/public)\n\n```java\nInput: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 10\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/f25f2085-ce04-4447-9cee-f0a66c32a300/public)\n\n```java\nInput: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 15\n\nOutput: false\n```\n\n**Constraints:**\n* `m == matrix.length`\n* `n == matrix[i].length`\n* `1 <= m, n <= 100`\n* `-10000 <= matrix[i][j], target <= 10000`\n",
        "Difficulty": "Medium",
        "Video": "Ber2pi2C0j0",
        "PythonSolution": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n\n        top, bot = 0, ROWS - 1\n        while top <= bot:\n            row = (top + bot) // 2\n            if target > matrix[row][-1]:\n                top = row + 1\n            elif target < matrix[row][0]:\n                bot = row - 1\n            else:\n                break\n\n        if not (top <= bot):\n            return False\n        row = (top + bot) // 2\n        l, r = 0, COLS - 1\n        while l <= r:\n            m = (l + r) // 2\n            if target > matrix[row][m]:\n                l = m + 1\n            elif target < matrix[row][m]:\n                r = m - 1\n            else:\n                return True\n        return False\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve search a 2d matrix and i\nreally like this problem because it's\nnot one of those problems that you need\na fancy trick for you can actually solve\nthis problem just by using logic so we\nare tasked with creating an efficient\nalgorithm for searching for a single\nvalue in an m by n matrix the matrix has\ntwo properties in every single row the\nintegers are sorted from left to right\nand the first integer of each row for\nexample this 10 is always going to be\ngreater than the last integer of the\nprevious row so greater than this one so\nin other words we know that each row is\nsorted and then the next row is going to\nbe greater than that so technically each\nvalue in total throughout the entire\nmatrix is going to be in sorted order so\nthat's pretty good in this example we\nwere given a target 3 so if we search\nfor the target we will find it right\nhere so then we can return true that it\ndoes exist if it does not exist then we\nsimply return false so how can we solve\nthis problem the key word here is create\nan efficient algorithm what would be the\nbrute force of course we could do an\nalgorithm o of m by n basically by\nsearching every single value in the\ninput array right that's a pretty easy\nalgorithm to do on a two-dimensional\nmatrix but can we do better of course we\ncan because they gave us a couple\nproperties that this matrix has some\nsorting already applied to it assume\nthat we just had a single row like\nforget that we had a matrix if we just\nhad a single row like this one and we\nknow it's in sorted order do you know an\nalgorithm that can search for a target\nvalue in a sorted array\ni know of one called binary search right\nand how efficient is binary search well\nlet's say\nthe size of this array is n we could do\na binary search in log n time right but\nof course we know that we actually have\nm\ndifferent rows right so let's say we ran\na binary search on every single row\nuntil we found the input target value\nright what would the time complexity be\nwell log n multiplied by m is going to\ngive us a solution like that so that's\nusing the first property knowing that\neach rows integers are sorted but and\nthis is a pretty good solution but can\nwe do even better than this i'll give\nyou a hint we're definitely gonna have\nto use this second property that they\ntold us each row itself is actually in\nsorted order as in we know that the\nvalues in this row are going to be\nsmaller than all of the values in this\nrow and all the values in this row are\ngoing to be smaller than all the values\nin this row so can we use that property\nto instead of searching through every\none of these m rows maybe we can\nactually do a binary search just to\nfigure out which one of these rows to\nsearch in the first place because for\nexample if we're looking for a target\nvalue 3 let's take a look at this row\nthis row could have any values between\n10 which is the lower bound and between\n20. so obviously the target value 3 is\nnot going to fall within that range\nbetween 10 and 20 right so then the\nquestion is okay if the if the target\nvalue is definitely not in this row we\ncan cross this row out but then which\ndirection are we going to go are we\ngoing to look at the row above it or are\nwe going to look at the row below it of\ncourse we would want to look at the one\nabove right because above the top row is\ngoing to have smaller values than the\nbottom row right so when we cross this\nrow out we can also say that you know\nlet's cross this row out too because of\ncourse this row is going to have greater\nvalues that's how the binary search is\ngoing to work to even figure out which\none of these m rows we're going to need\nto search right so we can reduce instead\nof m we can do a log m by running binary\nsearch after we've ran that log m search\nthen we know okay this is the row that\nwe have to do our second binary search\non so after we're done with that we're\ngoing to do another binary search so\nlet's plus here log\nn\nright log n\nfor binary searching the row itself so\nthat's a better time complexity than we\nhad previously right log m plus log n\nthat's pretty dang good so once we get\nto this row we're going to say okay 3 is\nwhat we're looking for does that fall in\nthe range between 1 and between 7 of\ncourse it does so either our target\nvalue exists in this row or it doesn't\nexist at all so let's run binary search\nhere so of course we're gonna have two\npointers left pointer and right pointer\nthen we're gonna check the middle value\nin this case i think the middle value is\ngonna end up being this one because zero\nplus three is gonna become index one but\nlet's just say it became this one just\nto kind of show you what it's going to\nlook like let's say our middle value is\nhere we're going to check okay 5 is that\n3 nope 3 is less than 5. so what we can\ndo in our binary search is cross out\nthese values cross out our pointers now\nour right pointer is going to be over\nhere and let's say we ran binary search\nagain we compute the mid to be over here\nwe check is this 3 nope 3 is greater\nthan this so we cross this out and we\nshift our left pointer over here left\nand right are both here middle is going\nto be here as well we're gonna see okay\neither this has to be three or nothing\nor three just doesn't exist of course\nthis is three so we found it we can\nreturn\ntrue and that's the entire solution so\nit's just a double binary search and we\ncan implement that pretty easily once\nyou kind of know how to do binary search\nand if you don't i'm going to show you\nhow to do it right now so now let's get\ninto the code so the first thing i like\nto do is actually get the dimensions of\nthe matrix so let's get the rows and the\nnumber of columns in this matrix we can\ndo that pretty easily because we know\nfor sure that the matrix is always going\nto be non-empty and now we're going to\ndo the first binary search we're going\nto look for the row that we need to find\nso i'm going to have two pointers one\nfor the top row and one for the bottom\nrow top row is zero the bottom row is\ngoing to be the number of rows minus one\nso now we're just going to continue to\ndo the binary search until we can either\nfind the target row or we we figure out\nthat the target row does not even exist\nin the binary search so one case is that\nthe target value is even greater than\nthe largest value in this row so let's\ngo to that row okay first before i do\nthat let me actually compute the row so\nwe want the middle row in this case\nwe'll take the top and bottom and divide\nit by two\nthat's kind of how binary search usually\ngoes right so and then we have that row\nso in our matrix we're going to look at\nthat row and we're going to look at the\nright most value in python you can do\nthat with negative 1 but we could also\njust do number of rows minus or the\nnumber of columns minus 1 but in python\nit's a little bit easier so we're going\nto check is this target value greater\nthan the largest value in this row if\nthat's the case what are we going to do\nwell then we need to look at rows with\neven larger values so what we're going\nto say is our bottom row is going to end\nup being the the current row plus one\nbecause now we want to look at rows that\nare uh larger than this row else if the\nexact opposite happens so let me copy\nand paste this if the target value was\neven less than the leftmost value in the\narray aka the target value was smaller\nthan the smallest value in this row and\nthat's in that case we need to look at\nrows with smaller values so we're going\nto shift our top pointer actually i\nthink i just did it backwards so when we\nlook for larger values we actually want\nto take our top pointer and then shift\nit down because when you go down in the\nmatrix is when you actually get larger\nvalues and when we if we want to look\nfor smaller values we're going to take\nour bottom pointer and then shift it up\nin that case we would want to set it to\nbe row minus one so that's the case if\nthe target value was either too big or\ntoo small if neither of those evaluates\nto true that means that the target value\nis actually\nactually does fall within this current\nrow in that case we just want to break\nout of this while loop and then we can\ndo the second portion of the binary\nsearch now it's possible that if we uh\ndid not break out maybe we just created\nan invalid condition where we figured\nout that the top and bottom\npointers are invalid right then our\nwhile loop would stop and what that\nwould tell us is that we crossed out\nevery single row in the matrix and none\nof the rows contained the target value\nin that case we have to return false\nimmediately so basically if not top is\nless than or equal to bottom that means\nthat none of the rows contain the target\nvalue and then we can just immediately\nreturn false if that's not the case then\nwe're going to move on to the second\nbinary search portion and we're going to\nrun binary search on the current row\nthat we found from the top and bottom\npointer so let me just copy and paste\nthat this is the row that we're going to\nrun binary search on and we're going to\nhave a couple pointers left and right\nwhich is going to be 0 and\ncolumns minus 1 because that's going to\nbe the right most position in the row\nand we're going to do the pretty much\nthe exact same thing that we just wrote\nabove a second binary search while left\nis less than or equal to right let's\ncompute the middle point we can do that\nby taking left plus right divided by 2\nand now we'll do the same thing so if we\nfind that the target value is greater\nthan the value in this target row at\nposition middle that means we have to\nsearch towards the right of the row we\nhave to search towards the right of this\nmiddle point in which case we'll say our\nleft pointer is going to be m\nplus 1. we're going to search towards\nthe right else if the exact opposite was\ntrue then we want to search towards the\nright so we can shift our right pointer\nto be mid minus one\nand else the last case is if we actually\ndid find the target value in that case\nof course we can return true now if this\nloop exited but we never returned to\ntrue then outside of the loop then we\nhave to return false meaning that we\nnever found the target value okay i just\nforgot that when we're copy and pasting\ni forgot to change this condition so the\nfirst one of course is if target is\ngreater the second else if is target if\ntarget is smaller then we want to shift\nthe opposite pointer and that is the\nentire code so you can see that it's\npretty efficient so i hope that this was\nhelpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Koko Eating Bananas",
        "NcLink": "eating-bananas/",
        "Pattern": "Binary Search",
        "Description": "You are given an integer array `piles` where `piles[i]` is the number of bananas in the `ith` pile. You are also given an integer `h`, which represents the number of hours you have to eat all the bananas.\n\nYou may decide your bananas-per-hour eating rate of `k`. Each hour, you may choose a pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, you may finish eating the pile but you can not eat from another pile in the same hour.\n\nReturn the minimum integer `k` such that you can eat all the bananas within `h` hours.\n\n**Example 1:**\n\n```java\nInput: piles = [1,4,3,2], h = 9\n\nOutput: 2\n```\n\nExplanation: With an eating rate of 2, you can eat the bananas in 6 hours. With an eating rate of 1, you would need 10 hours to eat all the bananas (which exceeds h=9), thus the minimum eating rate is 2.\n\n**Example 2:**\n\n```java\nInput: piles = [25,10,23,4], h = 4\n\nOutput: 25\n```\n\n**Constraints:**\n* `1 <= piles.length <= 1,000`\n* `piles.length <= h <= 1,000,000`\n* `1 <= piles[i] <= 1,000,000,000`\n",
        "Difficulty": "Medium",
        "Video": "U2SozAs9RzA",
        "PythonSolution": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        l, r = 1, max(piles)\n        res = r\n\n        while l <= r:\n            k = (l + r) // 2\n\n            totalTime = 0\n            for p in piles:\n                totalTime += math.ceil(float(p) / k)\n            if totalTime <= h:\n                res = k\n                r = k - 1\n            else:\n                l = k + 1\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve coco\neating bananas but before we do i just\nwant to say that if you do have any\nrequested problems you can feel free to\nleave those in the comments i do have a\nlarge backlog\nof requested problems that i'm working\nthrough so it may take some time for me\nto get there\nbut you can feel free to request at any\ntime and if you find this video helpful\ndon't forget to leave a like and\nsubscribe for more videos\nso this is a pretty interesting problem\nbecause there is a brute force solution\nthat we can arrive at and that brute\nforce solution can easily be\ntransitioned\ninto a binary search solution which is\nthe optimal solution for this problem so\nwe're going to be working our way\nfrom the brute force to that binary\nsearch solution so coco loves eating\nbananas and we have\nn piles of bananas given to us in a\npiles input array\nwe're also given a second parameter h\nwhich is the number of\nhours that we have in order to eat all\nof the bananas so we have to eat them\nwithin h hours and so coco has a certain\neating speed where she can eat a certain\nnumber of bananas per hour and that\nvariable happens to be\nk and k is not an input variable that's\nwhat we're trying to determine as the\nsolution for this problem\neach hour she can only choose one pile\nof bananas\nand eat k bananas from that pile so\nthat's what we're trying to determine\nthat k\nvalue if the pile has less than k\nbananas\nshe'll eat all of the bananas but she's\nnot gonna eat any extra bananas from a\ndifferent pile so what we're saying here\nis\ncoco can only eat at most one pile\none entire pile of bananas in a given\nhour\nso what does that tell us already we're\ngiven some key information\nlet's say we're given a certain number\nof piles right so basically the length\nof p h must be greater than or equal to\nthe length of p\nwhy is that because let's say we have\nfive piles right\nso let's say we had five piles and let's\nsay this is what the piles look like the\nvalues aren't too important right one\none two two\nthree and let's say we had h equals four\nhours\nwell let's say k equals some really big\nnumber like three right basically the\nmax of this input array okay cocoa eight\nthis entire pile cocaine this entire\npile this entire pile and this entire\npile\nbecause she could only eat four piles\nbecause we only have four hours right\ncoco can only eat one pile per hour so\nif she ate\nall four piles over here we'd still have\none left over\nthat's why they guarantee us that h is\nalways going to be greater than or equal\nto the number of piles so the minimum\nin this problem given this input array h\nthe minimum it could possibly be is\ngoing to be five\nand i sort of wrote over it but the last\nimportant thing that they tell us in the\nproblem is we\nwant to determine that eating speed k\nthat cocoa is going to eat at but we\nwant to know the\nminimum integer k the minimum eating\nspeed of cocoa\nthat she could eat all of the piles in\nexactly five\nhours or exactly whatever that time\ninterval that number of hours happens to\nbe\nso let's take a look at this example\nthey give us an input array of four\npiles and they give us\neight hours to eat all four of those\npiles what's the minimum\nk the minimum eating speed that coco\ncould use\nto eat all of these piles in at most\neight hours so we have to eat all the\npiles in eight hours\nor less well the brute force would be to\nstart at one right because coco could\ntry\nk equals one right can we eat all piles\nin eight hours then well it will take us\nthree hours to eat\nthe first pile right three divided by\none which is our k\nright three divided by one is going to\nbe three hours to eat this first pile\nand to eat the second pile is gonna be\neven more that's gonna be six hours\nright six divided by one\nsix hours so so far we already have nine\nhours and we haven't even eaten the\nentire\nnumber of piles so therefore k equals\none is not going to work\nand we could just continue this brute\nforce approach right now try k\nequals two right and then do the exact\nsame computation\nwith k equals 2. now my question to you\nis what's we know that the minimum like\npossible solution would be k\nequals 1 right k can't be zero because\nthat would mean we're not eating any\npile so the minimum is one\nwhat's the maximum that k could possibly\nbe\ngiven this in parade and given this\nnumber of hours\nwell remember the number of hours is\nalways going to be\ngreater than or equal to the number of\npiles so in the worst case\nk would basically be the max number that\nhappens to be in our piles for example\nif k\nequals 11 right that means we're able to\neat the max pile in exactly\none hour right and if we can eat the max\npile in one hour that means\nevery other pile is also going to take\nus only\none hour so therefore we're going to eat\nevery single pile\nin four hours and we know for sure that\nthis\nis going to be less than whatever is\ngiven to us as h\nright we could we guaranteed that at the\nbeginning so really what we're doing\nhere\nis we're going to try every single value\nfrom 1\nall the way up to 11 which happens to be\nthe max value of our piles\nand the first value that we get that\nthat allows us to eat\nevery single pile in less than or equal\nto eight hours is going to be our\noutput so we're gonna end up trying one\nwe're gonna end up trying two we're\ngonna end up trying three and we're\ngonna find that\nfour allows us to eat all the piles in\nless than or equal to eight hours\nso this is not a terrible solution right\neven though we're brute forcing the\nentire solution set\none through the max of piles it's not\ngonna be terrible what's gonna be the\ncomplexity of that well we're\npotentially gonna have to iterate\nthrough every\nvalue in this uh potential solution set\nwhat's that gonna be well one\nthrough the max value of our piles right\nso it's gonna be\nlet's say big o of the max value\nof piles so max of p multiplied\nby the length of p because for every k\nvalue we're potentially gonna have to\ntry okay\nif i e all these how many hours is that\ngonna take me right so we're gonna have\nto iterate through this entire array for\nevery\nk value that we try so we're gonna get a\ntime complexity of max of p\nmultiplied by p right but that's only\nwe're getting this max\np from the fact that we're having to\niterate through every single value\nin this k range but why should we\niterate from\none to the end of that k range why would\nin which case in the worst case we'll\nhave to go through every single value\nwhy don't we instead apply binary search\non this k\nrange what's that going to give us well\nwe can reduce max of p\nto the log of max p so if we can improve\nthis this is what our time complexity is\ngoing to be\nokay so i ran out of room but this is\nthe improved\ntime complexity basically we're taking\nthis variable and applying a\nlog to it which is going to reduce it a\nlittle bit so let me show you quickly\nhow that binary solution is gonna work\nit's pretty straightforward and then\nwe're gonna jump into the code\nso we're gonna be using binary search\nwe're given this input array and we\nwanna\neat every single pile in less than or\nequal to eight\nhours so we know that the potential\nrate that we're eating bananas at k is\ngonna be between\none that's the minimum it could possibly\nbe the max it could possibly be is going\nto be whatever the max in\nour input array is we know the max value\nis 11 we can find that in linear time\nso then we're going to initialize a\nrange like this\nright this entire range that we have\ngoing all the way from 1\nto that max value 11. so in other words\nwe're going to have a left pointer at\nthe minimum\nand a right pointer at the maximum then\nwe're going to compute the middle by\ntaking the average of left and right\n1 plus 11 divided by 2 is going to be 6\nso our middle\nis going to be here in other words our k\nthat we're trying\nis going to be here this is the rate\nthat we're going to eat bananas at so\nwe're trying the rate of six\ndoes this work can we eat all these\nbananas with a rate of six bananas per\nhour in less than or equal to eight\nhours can we do that well\nhow many uh hours does the first pile\ntake well three bananas right\ndivided by the rate which is six is\ngonna round up to one that means it took\nus\none hour to eat the first pile the\nsecond pile six divided by six is also\ngoing to take\none hour so let's just count the number\nof hours\nso the second or the rather the third\npile seven divided by six is going to\nround\nup to two so that's going to take two\nhours\nthe third pile 11 divided by six is\ngonna also round up to two that means\ntwo hours so\nwe just did this in six hours right is\nthat good does that mean we found our\nsolution\nwell six is less than or equal to eight\nthat means we were we were able to eat\nthis entire thing\nin the time threshold with a rate of six\nbananas per hour is this our solution\nwell remember\nwe were looking for the minimum k value\nthat allowed us to do this so this\nmight be the solution but let's try all\nthe smaller values or let's\nlet's start our binary search in this\ndirection to see\nis there a smaller value than six that\nwe can use for our k value\nso basically what i'm doing here is if\nwe're able to eat the entire pile in the\nthreshold what i'm gonna do\nis then start searching in the left\ndirection so what i'm gonna do is take\nmy right pointer\nand shift it to k minus 1 because we're\nnow we're searching this entire range\nwhat if the opposite was true what if i\ntried this k value but i was\nonly able to eat the entire banana pile\nand let's say\nh equals 10 hours that means i went\nover the threshold right that means i\nwent over\nthe time so what does that mean does\nthat modify our binary search well what\nthat tells us is our rate of eating\nbananas 6 was too small we\ndidn't have enough time to eat all the\nbananas in the given available time\nso what we have to do is increase our\nrate of k\nright so in that case what i would do is\ni would search the right portion\nof the range so what i would do is take\nthe left pointer and set it to k\nplus one over here at the seven so\nthat's how this binary search is going\nto be working but so far we do have one\npossible solution\nand that's six so now our new right\npointer is pointing over here and our\nresult is\nfor now going to be six so once again\nwe're going to take the left and right\nadd them together divide by two that's\ngoing to give us one plus five divided\nby two is three so our k\nis now going to be at this three value\nso now let's check\ncan we eat all the bananas in less than\nor equal\nto eight hours how many hours does the\nfirst take us well we're eating at a\nrate of three bananas per hour the first\npile\nis three that's going to take us one\nhour to eat it the second pile\nsix bananas divided by three that's\ngoing to take two hours the third pile\nseven divided by three rounding up\nis going to be three hours to eat that\npile\nlast pile 11 divided by three rounded up\nis going to be four hours so when we\ntotal all of this\nup it's going to give us i think 10\nhours so just like we discussed before\nwe went\nover our threshold we we took too long\nto eat these bananas so what that tells\nus is this did not work\nthree bananas per hour doesn't work\nlet's start searching to the right of\nour range\nand remember when we took this right\npointer and shifted it\nwhat we basically did was we said that\nnone of these values are ever going to\nbe considered again we're now searching\nin the other range that's how binary\nsearch works remember so since this did\nnot\nwork we're not searching it and we're\nnot going to search any of the values to\nthe left of it so what we're going to do\nis take this left pointer\nset it to k plus 1. so once again we're\ngoing to take our pointers add them\ntogether divide by 2\nand we'll in this case we'll just round\ndown so nine divided by two is going to\nbe four so i'm going to put my k value\nbasically where left happens to be at\nfour\nso let's see with a rate of k equals\nfour can we eat all the bananas in less\nthan or equal to eight hours the first\npile takes one hour the second pile\ntakes two hours\nthe third pile takes two hours and the\nlast pile takes three hours\nso totaling all of this up we get eight\nright so we were able to eat all the\nbananas\nin less than or equal to eight hours if\nwe had a rate of\nfour so basically let's compare that to\nour current result\nso far we found a value with six so\nreally we can update this six and say\nthere's a smaller rate that we can use\nthat happens to be\nfour so now that we did find a potential\nresult four let's see if we can find an\neven\nsmaller one remember that's what we did\nbefore if we find a k that works we're\ngonna try to find an even smaller one\nso what we're gonna do is we're gonna\nset our right pointer\nshifted over here but notice how now\nthe left and right pointers are not in\nthe correct order right\nleft should always be to the left of the\nright pointer that's basically how you\nknow\nthat our binary search has stopped we\ndon't have to continue the binary search\nanymore right and that makes sense\nbecause now we're searching values that\nwe previously crossed out we crossed\nthese out so how can we search them\nagain\nit makes no sense so now we can stop the\nbinary search\nand we can return the current result\nwhich happens to be four\nfour is the minimum rate of bananas that\ncocoa could eat to eat all bananas\nin less than or equal to eight hours\nwith that being said let's jump into the\ncode now\nso just like i mentioned we are gonna\nhave our left and right pointers\ninitially\nset to one left is going to be one and\nright is going to be the max that\nhappens to\nexist in our piles input array now the\nresult we're not going to initialize it\nto 0\ninitially because remember we're looking\nfor the minimum so i'm just going to\ninitialize it to r\nwhich is the max in our piles because we\nknow at least this will work this is the\nmax\nthat our solution could possibly be and\nnow we just start binary searching\nwhile our left and right pointers are in\nthe correct order\nwe can compute the k by adding the left\nand right together and dividing by two\nand we want to\ncount for this value k for this rate k\nhow many hours does it take to eat all\nbananas so let's initialize hours to\nzero and go through every pile\nin the input array piles so for any\ngiven pile p\nwe can divide it by k which tells us how\nmany hours it took but remember we have\nto round\nup so there's a function in python\nmath.ceiling which will round\nthis up for us and whatever that happens\nto be is what we can add to our hours\ntotal once we've done that then at the\nend\nof that loop we're going to check if\nhours happens to be less than or equal\nto\nh the given input if it is that means we\ncan update our result\nto a new minimum right take the minimum\nof the result and whatever\nk happens to be k is that rate that\nwe're looking for\nand if this is the case then how are we\ngoing to update our binary search well\nwe're going to look for an even\nsmaller k so what we're going to do is\nset our right pointer\nequal to k minus 1. we're going to\nsearch the left portion now\nif this wasn't true how would we update\nour binary search in the opposite case\nthen we would take our left pointer\nand set it to k plus 1 because that\nmeans the rate was too small so we need\nto find an even bigger\nrate that will allow us to eat the\nbananas in the given time interval\nand at the end of this loop once the\nbinary search has stopped we know that\nwe're going to be returning that result\nvariable which tells us what the minimum\nk happens to be\nand believe it or not that is the entire\nresult so i hope this was helpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Find Minimum In Rotated Sorted Array",
        "NcLink": "find-minimum-in-rotated-sorted-array/",
        "Pattern": "Binary Search",
        "Description": "You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:\n\n* `[3,4,5,6,1,2]` if it was rotated `4` times.\n* `[1,2,3,4,5,6]` if it was rotated `6` times.\n\nNotice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.\n\nAssuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.\n\nA solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?\n\n**Example 1:**\n\n```java\nInput: nums = [3,4,5,6,1,2]\n\nOutput: 1\n```\n\n**Example 2:**\n\n```java\nInput: nums = [4,5,0,1,2,3]\n\nOutput: 0\n```\n\n**Example 3:**\n\n```java\nInput: nums = [4,5,6,7]\n\nOutput: 4\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "nIVW4P8b1VA",
        "PythonSolution": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        start , end = 0, len(nums) - 1 \n        curr_min = float(\"inf\")\n        \n        while start  <  end :\n            mid = start + (end - start ) // 2\n            curr_min = min(curr_min,nums[mid])\n            \n            # right has the min \n            if nums[mid] > nums[end]:\n                start = mid + 1\n                \n            # left has the  min \n            else:\n                end = mid - 1 \n                \n        return min(curr_min,nums[start])\n    ",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem find minimum in\na rotated sorted array so we are given\nan input array of length n that is\nassorted in ascending order but it could\nbe rotated\none to n times for example if we have an\narray like one two\none zero one two right to rotate it by\none basically means to take the\nrightmost element you know move it to\nthe beginning\nlike this right so this has been rotated\nby one we could also rotate it by two by\ntaking the last two elements and moving\nthem to the beginning so something like\nthis right this has been rotated by two\nand so we want to find the minimum value\nand we want to do it in log n time as\nthey say the good thing is that we do\nhave some kind of sorting property that\nwe can use to our advantage to find this\nlog n time solution and we are\nguaranteed that every value in the array\nhappens to be unique of course it would\nbe easy to find a linear time solution\nbasically just scan through every single\nvalue in the array and then take the\nminimum value and return it but we can\nuse the sorting property to our\nadvantage even if the array has been\nrotated let me show you how we can do\nthat solution as you might be able to\nguess it is going to involve the binary\nsearch algorithm which is usually the\nalgorithm that runs in log and time so\nthe fact that the array was originally\nsorted is what hints to you that binary\nsearch might work in this case but it's\nnot going to be a traditional binary\nsearch now of course if the entire array\nwas sort was uh rotated n times that\nbasically means we took a sorted array\nsuch as one two three four five rotated\nit n times basically leaving it in the\noriginal sorted order now if we had an\narray that was completely sorted like\nthis one an easy binary search would\nwork on a sorted array but if the array\nis fully sorted then we know that the\nminimum value is going to be the\nleftmost right so if at any point we get\na you know binary search is going to run\nlike this a left pointer and a right\npointer if we ever get to a point where\nthe entire array is sorted we can just\nreturn the leftmost element or at least\nconsider this as being the minimum value\nso let's try a binary search and see how\nit's going to be different than a\nregular binary search now of course we\nwant to find the minimum value we're\ngoing to initialize our left pointer\nhere and our right pointer here\nbasically the current pointer situation\nmeans that we are considering this\nentire array to find the minimum the\nminimum could be from anywhere in this\narray and the result is going to be the\nminimum and i'm going to keep track of\nthat over here now of course one way we\ncould do this problem is basically find\nthe pivot right find the position where\nyou know the\nthe elements are not in\nincreasing order right from from here to\nhere three to four they're in an\nincreasing order from four to five there\nthey are in increasing order from one to\ntwo they're also in increasing order but\nfrom five to one they're in decreasing\norder this is the pivot right so\nbasically this value is going to be the\nminimum but i'm going to do it in a\nslightly different way where we don't\nnecessarily have to you know look\nexactly for the pivot i'm going to take\nokay left right take the half of them\nget our middle pointer our middle is\ngoing to be over here at 5. so i'm going\nto consider as 5 being the minimum value\nwe have seen so far right so our result\nis going to be five now\nnow we have to ask ourselves okay\nyou know this could have been the result\nbut now we don't want to you know look\nat this value again so the question\nbecomes are we going to search to the\nleft or are we going to search to the\nright where are we going to find the\nminimum value where are we going to find\na value that's even smaller than 5. well\nfirst consider this\nsince we rotated the array we have two\nportions of the array that are sorted\nright we have this portion of the array\nthat's sorted the left portion right and\nwe have the right sorted portion of the\narray which is also sorted so the\nquestion is for us with this middle\npointer at this value 5 are we currently\nin the left sorted portion or are we\ncurrently in the right sorted portion\nnow if we are in the left sorted portion\nof the array don't we want to search the\nright sorted portion reason being if we\nsorted the if we rotated the array the\nleft portion is always going to have\nvalues that are greater than every value\nin the right sorted portion right\nbecause when we rotate right suppose an\narray like this we're taking the the\nrightmost value the largest value and\nputting it over here right so we're\ntaking larger values putting them on the\nleft side right so therefore the values\non the right are going to be smaller now\nso that's why it's always going to be\nthat way so if our middle pointer is\ncurrently in a value that's in the left\nsorted portion then we want to search\nthe right sorted portion because it has\nsmaller values in it right so how can we\nknow if we are in the left sorted\nportion well like i said every value in\nthe right sorted portion is going to be\nsmaller than every value in the left\nsorted portion so one thing we can check\nis if the current middle value is\ngreater than or equal to the value all\nthe way at the left of our thing right\nbecause the left value is going to be\nthe smallest value if the middle value\nis greater than or equal to the leftmost\nvalue that means this middle value is a\npart of this left sorted portion right\nin which case we want to search to the\nright now if our middle pointer suppose\nin this case we can see five is greater\nthan or equal to three the the reason\nwe're doing greater than or equal is\ntechnically this middle pointer could\nactually be at the left position as well\nthat's one edge case and in that case we\nwould also you know this would be the\nleft sorted portion but suppose our\nmiddle pointer instead of being at five\nwas actually over here it was at one\nwhat would our condition evaluate to\nthat numbs of middle would be one is\nthat greater than or equal to the left\nvalue which is three it's not right\nbecause the values in this right sorted\nportion are going to be smaller than the\nleft sorted portion in which case this\nwould evaluate to false right if it's\nfalse that means you know if we're at a\nvalue that's in the right sorted portion\nthen we want to search to the left right\nbecause in this case the the right if if\nour middle was at this it makes sense\nthat okay you know all the values to the\nright of it are going to be greater so\nthen we want to search to the left but\nobviously these values are also greater\nbut that kind of doesn't illustrate the\npoint because what if our middle pointer\nwas over here right maybe we had some\nvalues over here\nyou know this is where our middle\npointer is we see two okay\ntwo could have been the minimum then we\nwant to search to the left because we\nwant to find even smaller values\nparticularly we would want to find this\none that happens to be smaller because\nwe don't know where the pivot is the\npivot could be here the pivot could be\nhere it could be anywhere we just know\nwe have to look to the left if we want\nto find smaller elements if we if our\nmiddle pointer happens to be in the\nright sorted portion then we want to\nsearch to the left if our middle pointer\nis in the left sorted portion then we\nwant to search to the right and i just\nshowed you the condition we can use to\ndetect that so now i'm going to run\nthrough the example and it'll probably\nmake more sense and by the way the\nalgorithm i'm describing only works on a\non a rotated sorted array if we ever got\nto a point where our let's say our right\npointer was over here meaning that you\nknow this is our entire search range\nthen we could not do this algorithm in\nthis case if we ever got to a a portion\nof the array that's completely sorted we\nwould just take the leftmost value and\nsee if it's smaller than our current\nresult and then we would stop the entire\nbinary search okay so now let's run\nthrough the example these are the\nconditions that i talked about that\nwe're going to be using so our middle\npointer is here let's check is so you\nknow we we checked that this might be\nthe minimum now we're never going to\nlook at this again so now we're going to\ncheck is this value greater than the\nvalue all the way to the left yes it is\nso we're going to search right since\nwe're searching right that means we're\nnever going to search these values again\nso we can cross them out we're going to\ntake our left pointer and\nshift it to mid plus one so our left\npointer is now going to be over here\nthis is our new search range and as you\ncan see this portion of the array is\nalready in sorted order right how do we\nknow that because our the point the\nvalue at our right pointer is greater\nthan the value at our left pointer so\nthat means that the array is entirely\nsorted and then we can just take the\nleftmost value here which is one see if\nit's smaller than our current result yes\nit is so then we can return one in this\ncase now just to kind of illustrate the\nopposite case arbitrarily i'm just going\nto say our middle pointer is actually\ngonna be over here for some random\nreason let's just see how our binary\nsearch would work in that case well we\nwould take this middle value say that it\nmight be our result so our result is\ngonna initially be one and then we're\ngonna run through these conditions is\nthe middle value greater than or equal\nto the leftmost value it's not so we\nexecute the else case which basically\nmeans we're searching left right so\nwe're going to take uh you know this is\nnot going to be considered again we're\ngoing to take our right pointer set it\nto mid minus 1. so our right pointer is\ngoing to be over here and we're going to\ncross out 2 because it's never going to\nbe searched right because we shifted our\npointer this is our new search range\nonce again you can see that this range\nis sorted basically the left value is\nsmaller than the right value so this is\nalready sorted we can take the leftmost\nvalue over here c is this smaller than\nour current result it's not so our\nresult stays the same and we don't have\nto search this entire portion because\nit's already sorted so that's kind of\nthe general idea of how this algorithm\nis going to work it's pretty easy once\nyou kind of figure out these two\nconditions with that being said we can\njump into the code okay so now let's get\ninto the code as i mentioned we are\ngoing to be maintaining a result now we\ncan set this to some arbitrary default\nvalue i'm just going to set it to nums\nof 0. we could just pick any value in\nthe input array nums but i'm just going\nto choose the leftmost\njust because\nwe're also going to have our two\npointers initially left is going to be\nall the way at the left index zero right\nis going to be at the rightmost index\nlength of nums minus one and we're going\nto keep running our binary search while\nour pointers are in a valid\nposition while left is less than or\nequal to right and like i mentioned if\nwe ever get to a subarray that's already\nsorted basically if the value at the\nleft is\nuh less than the value at the right then\nwe can update our result potentially\nsetting the result to the minimum of\nitself and the leftmost value of this\nsorted portion and then we can break out\nof this while loop\nif the array is not sorted that's when\nwe're actually going to be doing our\nbinary search portion so we can compute\nthe mid uh the midpointer basically left\nplus right integer division by two\nand with this mid value we're going to\npotentially update our results setting\nthe result equal to the minimum of\nitself and the value at the mid pointer\nand once we're done with that now we\nwant to know are we going to search to\nthe left or are we going to search to\nthe right so how can we determine that\nas i mentioned the condition we want to\nknow is this mid value a part of the\nleft sorted portion it is a part of the\nleft sorted portion if the value at the\nmiddle index is greater than or equal to\nthe value all the way at the left that\nmeans it is a part of the left sorted\nportion in which case we want to search\nthe right sorted portion so we can take\nour midpointer set it take our left\npointer set it to mid plus one now the\nelse case is if we're in the right\nsorted portion in which case we want to\nsearch to the left so we set the right\npointer equal to mid minus one and we're\ngoing to keep doing that until we find\nthe solution or until our binary search\nhas basically searched the entire array\nand then after that we can go ahead and\nreturn the result value as you can see\nthis solution does run it's pretty uh\nshort and concise i'm sure there are\nways you can make it even shorter but it\nruns pretty efficiently so i hope that\nthis was helpful if it was please like\nand subscribe it supports the channel a\nlot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Search In Rotated Sorted Array",
        "NcLink": "find-target-in-rotated-sorted-array/",
        "Pattern": "Binary Search",
        "Description": "You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:\n\n* `[3,4,5,6,1,2]` if it was rotated `4` times.\n* `[1,2,3,4,5,6]` if it was rotated `6` times.\n\nGiven the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.\n\nYou may assume all elements in the sorted rotated array `nums` are **unique**,\n\nA solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?\n\n**Example 1:**\n\n```java\nInput: nums = [3,4,5,6,1,2], target = 1\n\nOutput: 4\n```\n\n**Example 2:**\n\n```java\nInput: nums = [3,5,6,0,1,2], target = 4\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n* `-1000 <= target <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "U8XENwh8Oy8",
        "PythonSolution": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n            if target == nums[mid]:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if target > nums[mid] or target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n                    \n            else:\n                if target < nums[mid] or target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1\n",
        "Transcript": "okay let's solve leak code 33 search and\nrotated sorted array\nso we're basically given an array that\nwas originally sorted like this one but\nit then it became rotated like this one\nand by rotated they mean that they took\na certain pivot or index of the array\nlike right over here and then they cut\nit in half and then swap through the\nportions right so you can basically\nthink of this right-hand portion being\nswapped over to the left side over here\nright that's what happened as you can\nsee here right these two halves were put\nin the opposites position and we're also\ngiven a target value in this example\ntarget zero and we want to check if our\narray contains this value if it does we\nreturn the index if it doesn't we return\nnegative one the most straightforward\nway to approach this problem is\nliterally just check every single value\nis this our target is this our target\nand eventually we get here this is our\ntarget and then we return the index for\nnow this is just too trivial of a\nsolution right the time complexity isn't\nbad it's o of n but can we do better in\nthis problem they literally tell us to\nfind a solution and that's of log n so\nobviously we can and basically anytime\nyou're looking for a solution that's log\nN or better than linear almost every\ntime you're going to be looking for a\nbinary search type solution so since\nthis array was originally rotated can we\nuse that to our advantage to potentially\nfind a binary search type solution for\nthis problem let's try to analyze it and\nsee what we can find so given that the\noriginal array was sorted if we wanted\nto represent that as a graph we would\nbasically have a continuously increasing\nline it might not necessarily be linear\nbut it would always be increasing right\nand then we took some pivot like over\nhere and then swapped these halves\naround right so let's draw what that\nwould look like so let's say the left\nside was exclusively greater than the\nright side because that's what it means\nso I think this is a pretty good way to\nvisualize the problem to kind of\nunderstand what it would look like and\nyou can use this to your advantage to\nfind potential patterns that can help us\nfind a binary search solution so with a\nproblem like this you really have to\nbreak it down into discrete cases and\nthen use those cases to form a solution\nso the most obvious thing is that there\nare two portions of the array right\nthere's a left portion and a right\nportion both independently are sorted\nright so it's like we have two halves\nthat are sorted and so we know that a\nbinary search usually has three pointers\na left pointer a middle pointer and a\nright pointer the left is always going\nto be less than or equal to the right\nthis is just something you kind of know\nfrom binary search so let's say our\nmiddle value was six at some point right\nthis means that we're in the left sorted\nportion of the array so can we use that\nto our advantage so let's say our target\nwas greater than six in that case we\nknow for sure since we're in the left\nsorted portion of the array none of\nthese values are greater than six so we\ncan basically say these are eliminated\nlet's run binary search on this portion\nnow right so that's pretty easy if we\nknow that we're in the left sorted\nportion and our target is greater than\nthe middle this is what we can do\nwhat if our target is less than the\nmiddle value so what if our target was\nless than six well these two numbers are\nless than six and these three numbers\nare less than six so how do we know\nwhich way to go do we go left or do we\ngo right because we can't go both\ndirections in a binary search the key is\nto see that in our left sorted portion\nthe smallest value is right here right\nor on our graph it's right here\nso if our target is even smaller than\nthis left value for in that case we know\nthat we don't have to search for we\ndon't have to search five we don't have\nto search six week\nbinarysearch over here but if our value\nis greater than or equal to four then\nthat means we're gonna run binary search\non this on these two values right it's\nless than six but it's greater than or\nequal to four so we can run binary\nsearch on these two values we can\neliminate all of these from\nconsideration so all of that is if we\nwere in the left sorted portion of the\narray right now what happens if we're in\nthe right sorted portion of the array\nlet's say our middle was one and let's\nsay we knew somehow that we were in the\nright sorted portion of the array what\nif our target was less than one well\nthen we know we have to search the left\nthe only value less than one is right\nhere so we're gonna search the left\nportion of this array we're not gonna\nlook at one we're not gonna look at two\nanymore any value to the right of one is\ngreater than one so we don't have to\nlook at them we're just gonna run binary\nsearch on these elements we don't\nnecessarily have to know where the pivot\neven is we just know we have to go left\nbut what if our target was greater than\none well then our solution could\npossibly be two it could also be any of\nthese four values so then where do we go\nagain we can use this rightmost value or\nthe edge basically of our right to our\nadvantage\nso if our target is greater than one and\nit's also greater than two that means we\ncan again search this left portion we\ncan eliminate these two from\nconsideration but what if the opposite\nis true\nwhat if our target is greater than one\nbut it's less than or equal to two in\nthat case we only have to run binary\nsearch on the right portion of one every\nvalue to the right of one meaning we can\neliminate all of these from\nconsideration so that was a lot of\ndiscrete cases and it might be confusing\nI think it'll be a little easier to\nunderstand once we actually write the\ncode but I think it's also\nimportant to visualize it and actually\nunderstand what's going on before you\neven write a single line of code and\nknowing what we just learned let's just\ngo through this example of the target\nequal to zero and given this input array\nso initially our left pointer would be\nhere our right pointer would be here our\nmiddle would be here so how do we even\nknow if we're in the left sorted portion\nor the right sorted portion\nwell the way I check is just if our\nmiddle value is greater than or equal to\nour left the actual value at that index\nif this is true then that means our\nmiddle value belongs to the left sorted\nportion if this wasn't true that means\nour middle values in the right sorted\nportion and we would write our if\nstatements accordingly but knowing that\nwe are in this left sorted portion right\nlet's run through it so our target is\nzero that means our target is less than\nseven so our target is less than seven\nthat means we could be looking here or\nwe could be looking here so let's\ncompare it to four now is our target\nless than the leftmost value well zero\nis less than four okay so that means\nwe're all good we just have to search\nevery value to the right of our middle\nvalue so we can eliminate all of these\nwe can cross out our middle and left our\nnew left is going to be here and our new\nmiddle is going to be here now in this\ncase are we in the left sorted portion\nor the right sorted portion well among\nthese three values the entire array is\npretty much sorted so according to our\nthing according to our if statements\nwere basically going to say that middle\nbelongs to the left sorted portion\nbecause the entire thing is sorted so\nnow we compare middle to target well our\ntarget is less than one so now we have\nto go left and if we compared it to the\nleftmost value zero\nour target is greater than or equal to\nnot so we don't have to check anywhere\nelse we only have to go left so we can\neliminate these two from consideration\nand we're left with one value over here\nand that's our solution so\nthis is kind of a visualization for it\nnow let's actually look at the code to\nbetter understand what these cases are\ngoing to look like okay so when you're\ndoing binary search first thing you do\nis initialize your pointer so we have a\nleft and we have a right left is going\nto be 0 right is going to be the length\nof the array minus 1 our condition is\nwhile left is less than or equal to\nright because imagine we're given an\narray like this with just one value\nlet's say it had one left and right\nwould be equal in that case and we still\nhave to check that one value so now we\ncan compute the middle value middle is\njust going to be left + right / to the\naverage of them and it's possible to the\nmiddle value could be the target if it\nis we simply return the index if that's\nnot the case then we need to check which\nportion of the array are we in are we in\nthe left sorted portion and like I\nmentioned before we can check that if\nthe middle value is greater than the\nleft value well greater than or equal\nright because it's possible that the\nmiddle value in the left value could be\nthe same value the else condition would\nbe that we're in the right sorted\nportion so the simplest case is that our\ntarget is greater than the middle value\nin that case we're going to search right\nso we can say our left pointer is now\ngoing to be mid plus 1 so if the target\nis actually less than the middle then we\nneed to do something else so if the\ntarget is less than the middle but it's\nalso less than the left most value in\nnums then we also have to search the\nright portion so we're gonna do left is\nmid plus 1 now notice how these two\ncases are evaluating to the same thing\nthat means we can condense them we can\nget rid of this and say instead if the\ntop if target is greater than the middle\nor\nif the target is less than the left-most\nvalue then we have to search the right\nportion so we can get rid of this and if\nthis isn't true that means the target is\nless than the middle but it's greater\nthan the left that means we search the\nleft portions so we can update our right\npointer\nI had a typo over here we don't we're\nnot calling it left we're just calling\nit L for short and so this is if we were\nin the right sorted portion of the array\nthe easy thing is if target is less than\nthe middle that means we go left so we\ncan update our right pointer to mid\nminus one so if this isn't true meaning\ntarget is greater than middle and the\ntarget is greater than the rightmost\nvalue that means we have to go left as\nwell so write equals mid minus one\nnotice again how these two are doing the\nexact same thing so we can condense them\nwe can say at the top if the target is\nless than the middle or if target is\ngreater than the rightmost value then\nwe're going to search the left portion\nso we update our right pointer so we get\nrid of this and the else condition is\nthat the target is greater than the\nmiddle value and the target is less than\nthe right value in that case we only\nhave to search the right portion of the\narray so we update our left pointer to\nmid plus one these are all of the cases\nright so if we find our result we're\ngoing to return it up here but if we\ndon't find it we'll exit the loop and\nwe'll return negative one and just as I\nexpected because I just finished this\nproblem like a half hour ago it worked\nperfectly so this is not an easy problem\nthe code looks pretty easy but you\nreally have to understand the discrete\ncases like are we in the left sorted\nportion or the right sorted portion and\nthen what's going to happen as a result\nwhich part of the array do we have to\ncheck based on the\nHarrison conditions you really want to\ndry it out and kind of look at the\npicture before you write the code I hope\nthis was helpful if it was leave a like\n"
    },
    {
        "Name": "Time Based Key Value Store",
        "NcLink": "time-based-key-value-store/",
        "Pattern": "Binary Search",
        "Description": "Implement a time-based key-value data structure that supports:\n \n* Storing multiple values for the same key at specified time stamps\n* Retrieving the key's value at a specified timestamp\n\nImplement the `TimeMap` class:\n* `TimeMap()` Initializes the object.\n* `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time `timestamp`.\n* `String get(String key, int timestamp)` Returns the most recent value of `key` if `set` was previously called on it *and* the most recent timestamp for that key `prev_timestamp` is less than or equal to the given timestamp (`prev_timestamp <= timestamp`). If there are no values, it returns `\"\"`.\n\nNote: For all calls to `set`, the timestamps are in strictly increasing order.\n\n**Example 1:**\n\n```java\nInput:\n[\"TimeMap\", \"set\", [\"alice\", \"happy\", 1], \"get\", [\"alice\", 1], \"get\", [\"alice\", 2], \"set\", [\"alice\", \"sad\", 3], \"get\", [\"alice\", 3]]\n\nOutput:\n[null, null, \"happy\", \"happy\", null, \"sad\"]\n\nExplanation:\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"alice\", \"happy\", 1);  // store the key \"alice\" and value \"happy\" along with timestamp = 1.\ntimeMap.get(\"alice\", 1);           // return \"happy\"\ntimeMap.get(\"alice\", 2);           // return \"happy\", there is no value stored for timestamp 2, thus we return the value at timestamp 1.\ntimeMap.set(\"alice\", \"sad\", 3);    // store the key \"alice\" and value \"sad\" along with timestamp = 3.\ntimeMap.get(\"alice\", 3);           // return \"sad\"\n```\n\n**Constraints:**\n* `1 <= key.length, value.length <= 100`\n* `key` and `value` only include lowercase English letters and digits.\n* `1 <= timestamp <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "fu2cD_6E8Hw",
        "PythonSolution": "class TimeMap:\n\n    def __init__(self):\n        self.keyStore = {}  # key : list of [val, timestamp]\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.keyStore:\n            self.keyStore[key] = []\n        self.keyStore[key].append([value, timestamp])\n\n    def get(self, key: str, timestamp: int) -> str:\n        res, values = \"\", self.keyStore.get(key, [])\n        l, r = 0, len(values) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem time based key\nvalue store and this is one of my\nfavorite problems honestly on all of\nlate code because there's not a lot of\nfancy tricks involved you can really\nlogically uh you know dig your way\nthrough this problem so you can go ahead\nand read through this description if you\nwant but i'm going to go ahead and jump\nstraight into the explanation because i\nthink this is best understood by\nactually going through an example so our\nwhole objective here is to design a key\nvalue store so it's kind of like a hash\nmap we're gonna have some key value and\nthen we're gonna have a value associated\nwith that key but we're actually not\njust gonna have a single value we're\ngonna have a list of values\nuh so plural so it'll be a list and in\nthat list we're gonna have a pair of\nvalues so it's not just gonna be a\nsingle value each value is gonna have a\ntime stamp associated with it so for an\nexample we can have a key value of let's\nsay foo and we would have a list of\nvalues associated with that and one of\nthe values the pair of values right\nbecause we're going to have a value and\nthen a time so\nthe value let's say is going to be bar\nit's a string in this case and the time\nstamp associated with it let's just say\nin this case the example it's going to\nbe integer so let's just say it's 1 in\nthis case and then we could have a\nsecond value right associated with it as\nwell and that will have its own\ntimestamp as well right so basically\nit's going to be a list of values the\nand the values themselves are going to\nbe pairs a value and then a timestamp\nassociated with that so it's not super\ncomplicated but the main operations that\nwe're going to support are actually\npretty simple just two operations\nactually three if you count the\nconstructor so yes we're going to have a\nyou know constructor because it's an\nobject that we're designing a class and\nthe two operations we want to support on\nthis key value store are going to be set\nand get which is pretty straightforward\nthat's what we would expect so let's\njust go through this example and i think\nthe problem will actually make a lot of\nsense to you so the first operation we\nhave is a set operation the key is going\nto be the first value foo the value is\ngoing to be bar and the time stamp\nassociated with it is going to be 1. so\nlet's put the first value here it's\ngoing to be bar\nand the time associated with it is just\none and now we get the second operation\nget what are we getting we're getting\nthe key uh associated with foo\nand the the second parameter in our get\noperation is actually going to be the\ntime stamp so when we do a get operation\nnormally on a hashmap we just need a key\nbut in this case we need two values the\nkey and the timestamp right because we\nknow that for a single key it's not\nenough to identify a value right because\nthere could be multiple values over here\nwe need the time stamp to identify the\nactual value in this case we were given\na key value of foo and we were given a\ntimestamp of one right you can see up\nabove yeah it's one and by the way in\ncase i didn't mention we're actually\ngoing to be implementing this this\nentire key value store with a hash map\nso\nyou know the keys are just going to be\nnormal\nhash map keys and the value in this hash\nmap is going to be a list of values\nwith you know this schema right this the\nlist of values are going to be pairs so\nwhen we use the key in the hashmap we're\ngoing to get a list of values right in\nthis case this list only has one pair of\nvalues bar is that value and remember we\nwere given a timestamp of one so in this\nlist we're gonna basically iterate\nthrough the list to find the pair that\nhas a timestamp of one in this case we\ndid find it right it does exist so then\nwe can take this and uh the thing i\nthink we're returning is just the value\nitself so we can return bar and you can\nsee up above that's what they ended up\nreturning for this operation so we did\nour first get operation that's great now\nlet's do our second get operation in\nthis case we're given this pair we're\ngiven the key is going to be foo so\nright we can go to the same list and the\ntimestamp is actually three in this case\nbut if you scan through the entire list\nthat we have here you can see that none\nof these have a timestamp of three\nassociated with them so what does that\nmean are we just gonna return null in\nthis case no because remember what we're\ndoing here we're designing a key\na key value store based on time so we\nset this value at time one now it's time\nthree so the way this problem wants us\nto handle the timing is basically if you\ndon't find an exact match in our in our\nkey value store then just return the\nmost recent one so in this case we're\ndoing\nthe time is three right just return the\nmost recent one and by recent they mean\nthe the closest value to three that's\nless than three so for example there's\nonly a single value here right so in\nthis case we only have a single one and\nthe time with that is one so of course\none is going to be the closest to three\nbut what if instead we had something\nlike four\nfour is close to three but it's greater\nthan three so that's not allowed we\nwanna find the closest timestamp that's\nless than three now if we had multiple\nif we had another bar here or some other\nvalue and the time associated with that\nis two then in that case uh which of\nthese two would we want to return we\nwould want to return this one even\nthough the value is the exact same but\nwe'd want to return this one because it\nhas a closer time to the three but in\nthis case we only had a single value so\nwe're just going to return bar again and\nyou can see in the explanation and the\noutput that is the correct value so we\nreturn bar in this case okay so just\ncleaning up what we've already done so\nfar but now we're at a second set\noperation the values associated with\nthis set are well the key is foo so same\nyou know slot we're gonna go over here\nand the value in this case is bar two\npretty simple and the time associated\nwith it is four so that's the timestamp\nuh bar two and the time is four and by\nthe way the set operation that we're\ndoing is always going to be a constant\ntime operation big o of one right\nbecause the you know so finding the key\nis an o of one operation because we're\nusing a hash map and then uh you know\nthis list of values is gonna be a list\nand every time we add a value to this\nlist we're always going to add it to the\nend of the list so we can do that in big\no of one time\nso not too bad but where things get\ntricky uh now that we're done with the\nsecond set operation where things get\ntricky is when we get to the get\noperation so now we're at another get\noperation the key is foo and the time\nstamp is four so we're going to go to\nthe same slot here and then now that we\nactually have more values you're\nprobably getting at what the bottleneck\nis so in this case the timestamp is 4.\nso we want to look in this list we want\nto look for an exact match and if we\ncan't find an exact match we want to\nfind the closest value that's less than\n4. and how exactly are we going to be\ndoing that if we just do a linear scan\nthrough the array worst case it's going\nto be linear time now that's really not\nthat bad but the question is can we do\nany better well obviously very few\nalgorithms are better than big o of n\none of the algorithms that's better than\nbig o of n is binary search which we\nknow runs in log n time that's\ndefinitely an improvement over big o of\nn but that would require that our values\nare sorted but what exactly do these\nvalues have to be sorted by do they have\nto be sorted by the value or by the time\nstamp well since we're searching for an\nexact match with the time stamp these\nhave to be sorted by the timestamp so\nagain not too bad what are we supposed\nto do though are we supposed to sort\nthis every single time we want to do a\nget operation that's not going to make\nthings any better because if we have to\nsort the time complexity is not going to\nbe log n and it's not even going to be n\neither it's going to be n log n so\nthat's not an improvement at all and so\nthis is the part where we kind of have\nto be smart let's go down and read the\nproblem carefully if you scroll all the\nway down and read the fine print you can\nsee that all the time stamps every time\nwe we set a value the timestamp is going\nto be in increasing order strictly in\nincreasing order so how does this help\nus well basically it means if we have a\nlist here and every time we set a value\nwe just add it to the end of the list\nthen the list is actually going to be\nsorted by the timestamp by default so\nit's already in sorted order so that's\nwhy\nwe don't have to sort it again we\nactually can just run a binary search\nthat's really good for us but what if\nyou you know what if you didn't really\nread the fine print well the way this\nproblem is set up i think it's kind of\nintuitive that if you are in a real\ninterview the best question would be to\nask every time we set a value is it you\nknow is the timestamp gonna be in\nascending order because you know the way\na set operation would work in real life\nis you would use the the current time\nthat you know the current time that\nyou're setting the value and you know as\nmost of us know time really just flows\nin one direction so it makes sense that\nthese\nyou know the list that we're setting\nwould already be in sorted order but\nagain that's kind of why i like this\nquestion because even if you don't read\nthe fine print you might think to\nyourself are the set operations going to\nbe in sorted order and that would be a\nreally good question to ask in a real\ninterview so in this case we would want\nto run binary search which would be\nlogin time so that just means that the\nget operation worst case is going to be\na log in operation and by the way if\nwe're looking for the key value 4 we\nknow that it exists so this is what we\nwould end up returning we would return\nbar 2 and you can see that's exactly\nwhat they did return in the output so\nwe're done with another operation let's\ncross this out and let's do our last\noperation the get operation in this case\nthe key is foo so again over here and\nthe time stamp is five so again we're\ngonna run binary search right we're\nlooking for an exact match of five and\nif we can't find the five what's the\nclosest thing that we can get that's\nless than five well in this case it's\nfour so the value of that is bar two so\nagain we'd return bar two so that's kind\nof what i wanted to cover with this\nproblem of course we just had a single\nkey but you know this problem wouldn't\nbe much different if we had a second key\nor you know multiple keys so i think we\ncan actually go into the code now and\nsee how we can implement this binary\nsearch solution okay so now let's get\ninto the code and so you can see that\nthey already gave us like a class and a\nfew functions that we're going to define\nso\nthe only thing we really need to do in\nthe constructor is just initialize our\nstore like i mentioned it's just going\nto be a pretty simple hash map\nwhere the key value is going to end up\nbeing a string and the value of the\nhashmap is going to be a list of lists\nso\na list of pairs really but what we're\nactually going to be using to implement\nthat pair is going to be yes a\nanother sub list and the values of that\nsub-list are going to represent the\nvalue itself which is going to be a\nstring and the second is going to be the\ntime stamp uh and yeah just uh kind of\ncondense this uh basically we're gonna\nhave a key that key is gonna be mapped\nto a list of pairs okay so now let's get\ninto the set operation because it's a\nlittle bit more simple than the get\noperation the way i'm going to do this\nis first just check so of course we're\ninserting something based on this key\nvalue based on this key and based on\nthis value based on this timestamp so\nthis is going to be that pair of value\ntimestamp and this is just going to be\nthe key of the hashmap first of all we\nwant to know does this key even exist in\nour store and if it doesn't exist in our\nstore\nthe first thing we want to do is just\nyou know insert it into the store and\nyou know set it to let's say an empty\nlist so\nput this key\nand just set it to an empty list\nyou probably don't need to do this line\nwe could just use a default dictionary\nif we really wanted to but i don't want\nto abuse python too much because i think\nsometimes it makes things too easy and\nthis would kind of be\ni assume this is what you would want to\ndo if you were doing this in java or c\nplus or something like that yeah so\nafter we have uh you know we know that\nfor sure we have an empty list there\nthen all we want to do is to that list\nappend a value to it right append to the\nend of the list uh a pair of values the\nvalue itself and the timestamp\nassociated with it and that's really it\nright the set operation is pretty\nstraightforward in this case but the get\noperation is where things are going to\nget a little bit tricky so first i'm\njust going to initialize the result\ninitially it's just going to be an empty\nstring and the reason i'm doing this is\nbecause if this key doesn't even exist\nin the store itself then this is what\nthey want us to return they just want us\nto return an empty string that's why i'm\ninitializing it this way and the next\nthing we want to do is actually check\nwhat that list of values actually is so\nlet's go to our store and run the get\noperation reason i'm using the get is\nbecause if we find a match it'll return\nthat list if it doesn't find a match\nwith this key by default we can\ntell it to just return an empty list\nyeah so this is our list of values and\nnow is when we actually want to run the\nbinary search and then after we run the\nbinary search we're going to end up\nreturning whatever the result happens to\nbe as you may know\nbinary search has usually two pointers a\nleft and right pointer i have solved a\nvariety of binary search problems on\nthis channel i even have a binary search\nplaylist if you\nwant to practice uh but yeah so let's\nset the left and let's get the length of\nthe array minus one is going to be our\nright pointer and basically while the\nleft pointer hasn't crossed the right\npointer we are going to run the binary\nsearch\nactually should be equal if we want to\nmake sure to get the last value but yeah\nso we have a left and right pointer and\nusually we want to look at the middle\nvalue so we can just take left plus\nright divide it by two in in python\ninteger division you need two uh slashes\nto do that otherwise it does decimal\ndivision and\nthen we just want to know did we find\nthe result or not well if we found it\nlet's check in our values values at\nindex m and we know this is going to be\na pair of values we want to look at the\ntime stamp which is the second value up\nabove right you can see even in the\ncomments we said that the second value\nis the timestamp so we can go to index\n1. if this is equal to the timestamp\nthat we're searching for which was an\ninput parameter to this function called\ntimestamp actually instead of an exact\nmatch let's first check if it's less\nthan the timestamp less than or even\nequal to the timestamp because in that\ncase we know that it's a valid value\nbecause remember the else case from this\nis completely different than this one\nright if it's equal to the timestamp or\nless than the timestamp that's\ncompletely fine but if it's greater than\nthe timestamp that value is not allowed\nso we are going to be handling these two\ncases a little bit differently so with\nmost binary search if we\nif we know that this is less than the\ntimestamp what would we want to do we\nwould want to say the way we want to\nupdate the pointer is to set left equal\nto mid plus 1 because we want to search\nto the right portion if it was less than\nthe result but before we do that even we\nwant to say the result so far at this\npoint right since this is a valid value\nand this is the closest value we have\nseen so far we are going to set the\nresult equal to values uh you know\nbasically the value at index m\nand then you know this is going to be\nindex 0. right because this is the\nclosest we have seen so far that's how\nthis binary search is going to work this\nis the closest we've seen so far now\nlet's go to the next iteration of the\nloop and then see if we got any closer\nto the result but the else case is going\nto be\nwhoops the else case is going to be the\nopposite here all we're going to do is\nupdate the pointer if the value was too\nbig it was greater than the timestamp\nwhich is what the else case is we would\nwant to update the right pointer set it\nto mid minus one and then you know\nthat's just how we're going to be\nsearching but we're not going to assign\nthe result here because this is an\ninvalid value we cannot assign it to the\nresult technically this isn't as\noptimized as it could be because you\nknow in this uh equals in the first case\nif we even find the exact match to the\ntime stamp we're not even returning\nright we're still continuing the binary\nsearch which is kind of sub optimal but\nit doesn't change the overall time\ncomplexity it's still login and in this\ncase i kind of prefer the concise code\nso i'm going to leave it as it is\nbecause we are actually done with the\nfunction after you know this binary\nsearch is over we're going to go ahead\nand return the result whether it's an\nempty string or whether we actually\nfound the correct value\nyou know the closest value to that\ntimestamp that's the entire code let's\nrun it to make sure that it works\nand as you can see on the left yes it\ndoes work and it's pretty efficient\nprobably could be a little bit more\nefficient if we actually returned when\nwe find the value but that's okay i hope\nthat this was helpful if it was please\nlike and subscribe it really supports\nthe channel a lot consider checking out\nmy patreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Median of Two Sorted Arrays",
        "NcLink": "median-of-two-sorted-arrays/",
        "Pattern": "Binary Search",
        "Description": "You are given two integer arrays `nums1` and `nums2` of size `m` and `n` respectively, where each is sorted in ascending order. Return the [median](https://en.wikipedia.org/wiki/Median) value among all elements of the two arrays.\n\nYour solution must run in $O(log (m+n))$ time.\n\n**Example 1:**\n\n```java\nInput: nums1 = [1,2], nums2 = [3]\n\nOutput: 2.0\n```\n\nExplanation: Among `[1, 2, 3]` the median is 2.\n\n**Example 2:**\n\n```java\nInput: nums1 = [1,3], nums2 = [2,4]\n\nOutput: 2.5\n```\n\nExplanation: Among `[1, 2, 3, 4]` the median is (2 + 3) / 2 = 2.5.\n\n**Constraints:**\n* `nums1.length == m`\n* `nums2.length == n`\n* `0 <= m <= 1000`\n* `0 <= n <= 1000`\n* `-10^6 <= nums1[i], nums2[i] <= 10^6`\n",
        "Difficulty": "Hard",
        "Video": "q6IEA26hvXc",
        "PythonSolution": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n\n        if len(B) < len(A):\n            A, B = B, A\n\n        l, r = 0, len(A) - 1\n        while True:\n            i = (l + r) // 2\n            j = half - i - 2\n\n            Aleft = A[i] if i >= 0 else float(\"-infinity\")\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft > Bright:\n                r = i - 1\n            else:\n                l = i + 1\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve a pretty\ndifficult problem median of two sorted\narrays\nso we're given two arrays nums one and\nnums two that are already\nin sorted order but they could be of\ndifferent sizes\nm and n and we want to return the median\nof both of the arrays when they have\nbeen put together\nand sorted so not individually but we\nwant to put them together and then find\nthe median of both of them\nand not only that but we want to do it\nefficiently so log of m\nplus n worst case right so\none example we can see one array could\nbe one\nthree another array could be two and in\nthis case\nwhen you put the two arrays together\nit's pretty obvious that\ntwo is the median that the median is the\nmiddle value\nnow we know that there are other\nexamples where we might have an even\nnumber of total elements\none two three four when you put those\ntogether\nwe get one two three four in this case\nwe have\ntwo numbers that are in the middle two\nand three so what do we do we can just\ntake the average\nof these two and we know the average is\n2.5\nbut both of these examples used a\nmerged array but we know if we actually\nmerged\ntwo arrays together like one two and\nthree four\nthe worst case is actually big o n plus\nm and that's not log\nso we know in most cases when people\nwant a\nlog algorithm you need binary search and\nthat's exactly what i'm going to show\nyou right now how to solve this problem\nwith binary search so let's say we are\ngiven a different example let's call\nthis array b\nand let's call this array a so we know\nwe can\nmerge these two arrays right and then\nthe median is obvious but what exactly\nis a median well it's the middle\nvalue right in this case this is the\nmiddle value\nand we know that because we know to the\nleft of it\nthere are six elements and to the right\nof it\nthere are six elements so in this case\nwe have a\narray of 13 elements and this happens\nto be the middle the left partition\nof six elements is the same size as the\nright partition of six elements so what\nwe're doing\nis partitioning the array into two equal\nhalves\nroughly right because we know there's an\nodd case and an even case\nnow let's just take hypothetically this\neight doesn't exist\nthen in reality we have 12 elements so\nwe take the left partition to be six\nelements and the right partition to be\nsix elements\nso in that case we know we can take the\ntwo\nmiddle most elements or in other words\nthe right most value in\nour left partition and the leftmost\nvalue\nin our right partition and take the\naverage so add them together\nand divide by two we know that's going\nto be 3.5\nso how can we simulate that without\nactually\nmerging these two arrays how can we\nsimulate that with just\nthe original arrays which are still in\nsorted order right\nluckily for us they are given in sorted\norder so keep in mind that the total\nnumber of elements we have\nin this case is 13 and half the number\nof elements we have\nis roughly six i'm going to round down\nin this case and when we talk about\npartitioning we want our\nleft partition to be roughly equal\nto half so when we partition this\nwe want the left to be roughly 6. so the\nmost intuitive way to do this\nis let's get half of the elements of\nlet's say\na right so i'm going to have a left\npointer initialized here and i'm going\nto have a right pointer initialized\nhere and i'm gonna find the middle so we\nknow this is index zero this is index\nfour i add them together on average\nso we know that the middle is gonna be\ntwo right so what are we actually gonna\ndo\nso this is going to be our middle value\nright\nand basically what that means is our\nleft partition is going to include that\nso so far our left partition\ninitially is going to be like this now\nobviously we can increase it by adding\nan element\nwe can also decrease it by removing an\nelement\nbut initially let's have our left\npartition have\nthree values in it so it has three\nvalues great now can we repeat that same\nprocess\nup here well the good thing is we don't\nactually need to because look in this\ncase if we do that we're gonna get\nfour and we can basic if we want we can\nrun binary search up here too but is\nthat even necessary because\nlook at this half our elements are\nsix so really what we can do is say half\nminus three over here\nis going to be equal to three so if we\nrun binary search on just\nthis bottom ray on this bottom array we\ncan\ncompute the size of the left partition\nfor the second\narray right we can just compute it using\nour half\nvalue and since we know 6 minus three is\nthree we know initially we can say that\nthe left partition of this\nis gonna be three as well we don't even\nneed to keep\na left and right pointer for this array\nso these two\nuh sub arrays make up our left partition\nnow my question is how do we\nknow if we found the correct left\npartition or not\nwell we want them to be in order right\nso notice how we already know that this\n3 is going to be\nless than or equal to the element that\ncomes after it that's what sorted order\nmeans\nand we already know this value is going\nto be less than or equal\nto the value to the right of it because\nthis is also in sorted order\nbut we want to make sure that the left\npartition\nis less than or equal to every\nelement in the right partition and this\nis our right partition so\nhow can we determine that well one thing\nwe can ask\nis is this is the right most\nelement in this part of the partition\nless than or\nequal to this value\nand in this case it is we also want to\nask\nis this value less than or equal\nto the left most value in\nthis part of the partition in the right\npartition\nis it less than or equal to that in this\ncase\nit is and what this tells us is that\nour left partition has been done\ncorrectly\nand if it's not clear enough let me just\nwrite it out again so remember if we\nmerge these two arrays this is what it's\ngoing to look like\nand our left partition is going to be\nthis right we have 13 elements this is\nour left partition\nand we can say that this is our right\npartition\nbut since it's odd we can add that extra\nelement\nand you can see that that's exactly what\nwe found here right\nokay so we know we found the left\npartition correctly right so the left\nis going to be this sixth element but\nhow do we find that middle value\nwell in this case either of these two is\na\nfour so either of them is going to be\nthe median right we have two fours\neither of them could be the median but\nhypothetically let's say\none of these was a five so let's say\nmaybe in the top\nwe had a 5 so this would be a 5.\nhow would we find the median in that\ncase well\nfrom these two values right we know one\nof them has to be the median\nwhat we would do is take the minimum of\nboth of them\nso we take the minimum of the leftmost\nvalues in both partitions so\nso the min of 5 and 4 and we know that's\ngoing to be\n4 so 4 is our median so this example was\na little too\neasy because we didn't actually really\nneed to run a search\nso let's remove one element and let's\nupdate our total\nto 12 now instead of 13 because we just\nremoved one\nthe half is still going to be six so now\nlet's do the same thing our right\npointer is going to be here\nthis is index zero this is index three\nwe divide three by two\nwe're going to round down to one so\nthis is going to be our middle position\nand what that tells us is our left\npartition\nis going to be like this and now how do\nwe get the left partition\nof this well similarly we can take 6\nminus 2 which is the size of our left\npartition so we get four so the left\npartition\nof this is going to be of size four we\ntake the first\nfour elements so now let's check do we\nhave our left partition correctly have\nwe done it correctly how can we check\nthat well let's check that this\n2 is less than or equal to the 5. we\nknow that's true\nright 2 is less than 5. what about this\nvalue\nis the rightmost value in this partition\nless than or equal to this\nit's not right four is not less than or\nequal to three that's just not true\nso our left partition is not correct in\nthis case right how can our left\npartition\nhave a 4 where our right partition\nhas a 3 that means we have not\npartitioned it correctly\nso what that tells us is we have to\nupdate these pointers right because we\nare doing binary search\nso initially our left our middle was\nover here so what we're going to do\nis take our left pointer and then shift\nit\none plus the middle value the old middle\nvalue because we know\nthat we're going to need extra elements\nfrom array\na so with our left shifted over here\nwe're going to recompute the middle we\nknow the index of this is 2\nthis is 3 we add them together 2 plus\n3 divided by 2 if we round down is going\nto be 2. so what's going to end up\nhappening\nis our left partition is now going to be\nthese three elements because mid is\ngoing to be over here\nand so how many elements from our array\nb\nare we going to need well let's just\ncompute it right half is 6\nminus 3 because that's the size of this\npartition\nis going to total to be 3 so we know\nthat the partition from\nb is also going to be need to be size\nthree\nso let's get the first three elements of\nthis now let's\ncheck have we partitioned our\nleft have we partitioned this correctly\nso let's check\nis this three less than or equal\nto this value yes it is three is less\nthan four\nis this three less than or equal\nto this value yes three is less than or\nequal to four\nso that tells us we finally partitioned\nour our arrays correctly but you saw\noriginally we had 13 elements so it was\nodd and when it's odd in that case what\nwe had to do was take the minimum\nof these two values right but in this\ncase it's even so what are we actually\ngoing to do now\nso how are we going to find the median\nwell how would we do it if we had a\nsorted array so this is\nhow the sorted array would look if we\nmerged these two\nright and we can see that look at our\nleft partition we have one\ntwo and three right so this is our left\npartition right now\nright it's size six this is our\nright partition it's also size\nsix so clearly if we actually want to\nfind the median what we have to do is\ntake\nthe max value from\nour left partition and take the minimum\nvalue\nfrom our right partition right like\nthat's\npretty obvious so how do we translate\nthat when we actually have\ntwo separate arrays how do we actually\ntranslate that let me show you\nwell we can take the minimum of\nthese two values right and in this case\nthey're clearly\nthe same but if they were different we\nwould want to take the minimum\nof both of them right and we would want\nto take\nthe max of these two values\nof that and this right in this case\nthey're\nalso the same but they could be\ndifferent hypothetically so we would\ntake\nthat right and that's going to get us\nthe two values we need to compute the\nmedian and of course we can just divide\nthem\nby two so this is the main\nidea of this algorithm you can see that\nit's actually\nsomewhat intuitive once you understand\nsome of the basic ideas\nlet me just show you one last thing\nthat's gonna make the code a lot\neasier for us hypothetically our left\npartition\nfrom this array right a hypothetically\nit could be\none it could also be zero right we want\nour left partition to be six elements\nwhat if we just took\nthe six elements from over here that's\ngonna make edge cases a little annoying\nlike you know how we always wanna make\nsure that\nthe value from over here is less than or\nequal\nto that and we wanna make sure that this\nis going to be less than or equal to\nsomething like this but if we had 0\nvalues here\ni'm going to basically default that like\nthere's\na positive infinity over here and\nthere's a negative infinity over here\nso that if we wanted all elements to\ncome from a single array we would\nactually be checking okay is this less\nthan or equal to the positive infinity\nand i'm going to show you basically what\ni mean in the code but i hope that the\nmain idea\nof what we're doing the binary search to\nfind the median\nis at least somewhat obvious now so we\nhave two\narrays nums one and nums two i'm going\nto assign them\ntwo different variables we'll call them\na and b\nand you know how we only have to run\nbinary search on one of them i'm gonna\nmake sure that we run binary search on a\nand i'm gonna make sure that a\nis the smaller of these two arrays\nso we'll check if the length of a is\nbigger than b\nthen we're gonna we're gonna swap these\ntwo uh\narrays we're gonna swap a and b so let's\nalso\nget the total and half length of\neach of these so the total is just gonna\nbe the length of each\nadded together and half is just going to\nbe\ntotal divided by 2. in python we need\nthe double if we want to do integer\ndivision so now i'm going to run binary\nsearch on\na because a is the smaller so the left\nand right pointers are going to be\nzero and length of a minus one\nand remember that half is going to tell\nus the total elements\nin the left partition so now i'm just\ngonna be\nlazy and say while true we're going to\nstart\nlooping we're going to run our binary\nsearch because we know that there's\nguaranteed a minimum so once we\nare there's guaranteed a median so once\nwe find it we can just return\nit so now of course we want to compute\nthe middle value\nof array a that we're gonna use to get\nour left partition\nso we're gonna take left and right\npointers add them together\ndivide by two now how do we get the\nand so this is referring to a so we'll\ncall this\nthis is for a this is the pointer for b\nnow\nwe don't actually need to divide\nanything by two we can just take half\nand subtract i from it but one thing\nyou need to know that this is going to\nbe the index\nso to get rid of the off by one errors\nj is not actually the number of elements\nin array b it's actually the index of\nthe midpoint so we're going to take\nsubtract i and we're also going to\nsubtract 2 from it because we know\narrays are indexed at zero\nand we're doing this because we know j\nstarts at zero and i starts at zero so\nwe gotta do the extra minus by two\nso now we wanna get the values\nright the values that we're actually\ngonna need to compare to find\nto determine if we actually found the\nmedian right if we actually have a\ncorrect\nleft partition so you know we can take\na left to be a of index i right\nthat's going to be the value in the left\npartition that we're going to need to\nuse to compare\nand there's also going to be a value in\nthe right partition of\nof a right and we know it's adjacent\nright so what we can do is just take\ni plus one and we can repeat this with b\nright so b left is going to be b at\nindex j\nb right is going to be b at\nindex j plus one but here's the part\nwhere i'm gonna make our lives a lot\neasier and avoid some edge cases now any\nof these\nindices technically could be out of\nbounds right\nisn't that true so if i is out of bounds\nhypothetically what would that mean that\nwould mean i\nis less than zero so if i is less than\nzero is there a default value that we\ncan give to a\nleft there is and it's called\nnegative infinity right so it's going to\nbe set to a of i\nif i is greater than or equal to zero so\nif i\nis still in bounds set it to the value\nat this position if it's not let's\ndefault\nthe default value we can give this is\nnegative\ninfinity and we can do the exact same\nthing for this one\nif this j is actually out of bounds it's\ngoing to be that\nj is less than or equal is basically\nless than zero so it's gone too far to\nthe left\nso if j is greater than or equal to zero\nleave it as it is\notherwise set this to negative infinity\nand what about this value if i plus\n1 is out of bounds that must mean we\nwant\nall the values in array a to be a part\nof our left partition so if i\nplus 1 is out of bounds the default\nvalue\nthat means that the default value we\nwant to give it is infinity\nbecause we've gone too far to the right\nand otherwise if\ni is less than length\nof a then we will leave it as it is\nor i plus 1 rather right we're checking\nif i plus 1\nis out of bounds and we're going to do\nthe exact same thing for\nb so if j plus 1 is within bounds\nwe can leave it as it is get b of j plus\n1\notherwise we're going to set it to\npositive infinity\nso now finally with these you'll see\nthat we've actually just done\nthe algorithm now our life is so easy\nwe can check if a left is\nless than or equal to b right\nbecause that's what we were doing in the\npicture right\nif that's true and if b left\nis less than or equal to a right\nthat means our left partition is correct\nso we found the median but remember\nthere's two cases\nthere's one case that we have an odd\nnumber of elements so how do we know if\nwe have an odd number we can take the\ntotal number\nmod it by two if this equals one\nthen we have to compute the median\nodd so if you remember from the picture\nwe can get that by taking\nthe minimum of a right\nand b right we can take the minimum of\nthese two values\nand return it notice how if one of these\nvalues\nis an actual real number let's say four\nand one of them\nis positive infinity we're going to take\nthe minimum of these two so we're going\nto end up returning\n4. now both of these will never be\ninfinity you can run through some\nexamples to prove that to yourself\nand if it's not odd that means it's even\nlength\nso how can we get the median in that\ncase\nwell we take the max of\na left and b left just like we did in\nthe picture\nwe add that to the minimum of\na right and b right so these are going\nto be the two\nvalues in the middle and we can divide\nthem\nby two we want decimal division in this\ncase\nand then we can return that value so now\nin the case that we\ndon't find the median it could be\npossible that a\nleft is greater than b\nright like that's a possibility right\nand in that case\nbasically that tells us that a left is\ntoo big so we have\ntoo many elements from a so we're going\nto reduce the size of a\nso what we can do is take our right\npointer\nand shift it to i minus one so we're\nreducing the size of the left partition\nfrom a and the third case is just the\nelse case\nwhere it would be that this condition\nwas not true\nin that case we would need to increase\nthe size of our left partition from a\nso we would say left is equal to\ni plus 1. and that's actually the entire\ncode so we don't need a return statement\noutside because we know\nthat our loop is eventually going to\nfind a median and we're going to return\nit whether it's odd\nor whether it's even so you can see we\ndid this in about 30 lines of code\nand it would probably be less if i\nremoved some of the spaces in the\ncomments\nand the time complexity is basically\ngoing to be\nlog of the minimum of n\nof n or m because we're running binary\nsearch on the smaller of the two\nand as you can see it's a pretty\nefficient solution\nand i really hope that this was helpful\nto understand\nlike the big picture it's a difficult\nproblem i probably wouldn't be able to\nfigure this out on my own but you can\nsee it\nis definitely understandable once you\nknow some of the tricks behind it\ndon't forget to like and subscribe if\nthis was helpful it supports the channel\na lot and i'll hopefully\n"
    },
    {
        "Name": "Reverse Linked List",
        "NcLink": "reverse-a-linked-list/",
        "Pattern": "Linked List",
        "Description": "Given the beginning of a singly linked list `head`, reverse the list, and return the new beginning of the list.\n\n**Example 1:**\n\n```java\nInput: head = [0,1,2,3]\n\nOutput: [3,2,1,0]\n```\n\n**Example 2:**\n\n```java\nInput: head = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The length of the list <= 1000`.\n* `-1000 <= Node.val <= 1000`\n",
        "Difficulty": "Easy",
        "Video": "G0_I-ZF0S38",
        "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        prev, curr = None, head\n\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today it's\nactually raining outside right now\npretty hard so hopefully you can't hear\nit too well so today let's solve an easy\nquestion reverse a linked list and this\nquestion is actually like a sub problem\nthat's needed in a lot of other\nquestions like linked list related\nquestions so it's definitely\ngood to understand so just like the\nproblem says we have a linked list\nwe've got some nodes and and we just\nwant to take\neach of these links reverse them\nkeep doing that with everything and then\nthis is going to be the new head\nand then we're going to return that\nand they tell us that this can be done\ntwo ways iteratively meaning with just\npointers\nand also recursively and i'll show you\nhow to do it both ways\nso we can do this with two pointers\nbecause we want to reverse it so like\nfrom the perspective of this node\ninstead of\nthe next pointer pointing at three we\nwant it to point at the previous\nnode one so if we want to do this\niteratively we can use two\npointers like many problems\nnow what are the two pointers going to\nbe we can have initially\na current pointer so we can initialize\ncurrent to the first node\nwhich is our head and we can also\nmaintain\na previous pointer which initially\nis going to be set to null\nso for the first node 1 we're going to\ntake\nthe next pointer and reverse it so now\nthe next\npointer is going to be pointing at null\nso this is now going to be the last\nelement in our new reversed linked list\nso now we can shift our pointers\nso we're going to take the previous\npointer and then shift it to current\nand we're going to take the current\npointer and shift it\nto the next node now since we broke this\nlink we have to save this somewhere\nbefore we end up breaking this link and\ni'm going to show you how to do that\nin the code so now our current is 2\nwe want to take the next pointer\nand reverse it so the next is now going\nto be\nlike this so it's going to point at\nprevious\nso we can reverse the next pointer and\nset it to previous\nand once again we're going to shift our\nprevious pointer to current and our\ncurrent pointer is going to be shifted\nto next\nnow we're finally at the last node we\ncan once again\nupdate the next pointer of this current\nnode and so\nnow when we update our pointers previous\nwill be here\nand current is going to be at\nnull we've reached the end of our list\nnow we want to return the head\nhow do we return the head lucky for us\nthe previous pointer\nis equal to the new head right so this\nis going to be our result\njust like in the drawing we can\ninitialize our pointers first\nprevious will initially be null current\nwill start\nat the head and we want to keep going\nuntil we reach\nthe end of the list so while current is\nnot null\nwe're going to reverse the pointers so\nwe want\ncurrent dot next to be set to\nprevious and then we can shift our\npointers right so we can update previous\nset it to cur and\ncur is going to be equal to current.next\nbut notice how we set current.next\nto previous before so when we do this\nwe actually are going to have a\ntemporary variable\ncalled next which i will do at the\nfirst line when we start our loop so we\ncan save that in next\nso then when we update current.next\nyou know we still have that next pointer\nand lastly we return the result which we\nknow\nis stored in previous when this loop\nstops executing\nso it works and this is actually the\nmost optimal solution the time\nand the memory complexity is big o of 1\nbecause we're just using pointers right\nno\ndata structures or anything but if we\nwant to do the recursive solution\nthen the time complexity is also going\nto remain\nlinear but the memory complexity is\ngoing to be\nlinear as well so we're going to need\nextra memory so it's not the best\nsolution but i'll still show you how to\ndo it\nso usually the best way to think about\nrecursive problems\nis to break it down into a sub problem\nright so\nif our initial head is one\nwe start at one and this is our linked\nlist right\nbut let's say i want to do a recursive\ncall\ninstead of reversing the entire linked\nlist\ni'm gonna reverse the remainder of the\nlinked list\nso everything except this one\nso now i have a sub problem right now i\nonly have\ntwo nodes to deal with but let's take it\none step\nfurther this is now my new head right\nand i'm gonna break it down even more\ni'm gonna say reverse\nthis portion reverse the sub problem\nreverse only\none node so then if we try to break it\ndown even more then we're going to get\nthis is our sub list right but this is\njust\nnull so we can't really reverse that\nthat's the base case\nso now we're at this we only have one\nnode and we want to reverse\nit how do we do that well the next\npointer is pointing at\nnull instead of that we can take the\nnext pointer\nand set it to previous not really\nbecause this is recursive\nand at least the way i'm gonna do it i'm\ngonna set\ni'm gonna keep the pointer pointing at\nnull so we technically reversed this\nportion which is\njust this right it's just a link list of\none so now we're going to pop\nback up out of our recursive call\nand now our job is to reverse these two\nnodes so since we're at\n2 we can access three\nso what i'm gonna do is say okay the\nnext pointer of this\nis actually gonna be set to me to\nis gonna be set to two where i'm at\nright now\nbut my next pointer two's next pointer\nis gonna be set to null\nso notice that so far we have\ndone our job we reversed a linked list\nof size two right this is going to be\nthe new head and this is the tail this\nis the end of the list\nso we did our job of reversing it\nreversing these two nodes but we still\nhave one more node so we're going to\npop back up out of our recursive call\nokay so now we're finally at the last\ncall so our sub problem\nis to reverse these three nodes and we\ncan repeat the same thing we did over\nhere\nwe're gonna for one ins since one has\naccess to two\nwe're going to set two's next pointer\nover here instead of\nnull we're going to set it to\none and the next pointer\nof one is now going to be\nnull because we've reached the end\nthis is going to be the new end of our\nlinked list\nso we've done our job we recursively\ntook our linked list and reversed it\nthe only problem is that we are doing\nthis recursively so\nwe have to in our code we're gonna have\nto maintain\nso now let's code it up as with most\nrecursive functions\nyou want to do the base case first so if\nthe head is\nnull we can return\nnull and i'm going to make a variable\nto maintain the new head which i'm going\nto initially set to head\nhead is the current node that we're at\nin our recursive call so\nif head dot next\nis not null if there's still a sub\nproblem if we can keep\nuh reversing then we're gonna have our\nrecursive call so\nreverse the list\npass in head dot next and\nthe return value of this we are going to\nhave as the new head\nso if this returns something\nso we're going to set the result of that\nto\nnew head and since head dot next\nis the next node of head we want to\nreverse that link so what we can do\nis get the double\nso head dot next dot next\nis going to be set to head what this is\ndoing is just\nreversing the link between the next node\nand head\nand lastly we can say head dot\nnext is going to be equal to null so if\nhead happens to be the first node in the\nlist\nwe're setting the next pointer to null\nand\nof course this function wants us to\nreverse the list and return the new head\nso\nwe're gonna return the new head\nso i think so this works and i think it\nmight be a little confusing the way i\nwrote it because we have head.next.next\nbut if you want to understand it a\nlittle more\ni would try to like mentally\nrun through a couple test cases for\nexample if you were just given one node\nlike\nif you were just given a linked list of\nthis try to run through the code\nsee what the code does see what the\nfunction returns see which like this\nstatement would not ever execute if we\nwere given\na link list of size one this is not\ngoing to execute\nso just kind of like try that out see\nwhat happens if\nyou had a linked list of size two\nlike this and use pen and paper draw a\npicture\nand lastly the reason why the memory is\nlinear is because if we were given a\nlinked list\nof size two our recursive call\nis gonna be size two but i hope this was\nhelpful\nplease leave a like and subscribe thank\nyou and thank you so much for watching\n"
    },
    {
        "Name": "Merge Two Sorted Lists",
        "NcLink": "merge-two-sorted-linked-lists/",
        "Pattern": "Linked List",
        "Description": "You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists into one **sorted** linked list and return the head of the new sorted linked list.\n\nThe new list should be made up of nodes from `list1` and `list2`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/51adfea9-493a-4abb-ece7-fbb359d1c800/public)\n\n```java\nInput: list1 = [1,2,4], list2 = [1,3,5]\n\nOutput: [1,1,2,3,4,5]\n```\n\n**Example 2:**\n\n```java\nInput: list1 = [], list2 = [1,2]\n\nOutput: [1,2]\n```\n\n**Example 3:**\n\n```java\nInput: list1 = [], list2 = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The length of the each list <= 100`.\n* `-100 <= Node.val <= 100`\n",
        "Difficulty": "Easy",
        "Video": "XIdigk956u0",
        "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\n# Iterative Solution\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:\n        dummy = node = ListNode()\n\n        while list1 and list2:\n            if list1.val < list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n\n        node.next = list1 or list2\n\n        return dummy.next\n    \n# Recursive Solution\n# class Solution:\n#     def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n#         if not list1:\n#             return list2\n#         if not list2:\n#             return list1\n#         lil, big = (list1, list2) if list1.val < list2.val else (list2, list1)\n#         lil.next = self.mergeTwoLists(lil.next, big)\n#         return lil\n",
        "Transcript": "hey guys it's me again and let's solve\nanother leak code problem\nmerge two sorted lists so this is an\neasy problem\nit's a mainly fundamental problem\nthere's nothing crazy about it but it's\na pretty good problem to understand some\nbasic stuff so\nwe're given two linked lists right so\nthis is the first one\nthis is the second one both of them are\nalready sorted and we just want to merge\nthem\ninto an output linked list the only\ncatch\nis that we have to use the original\nnodes right like we can't create copies\nof the nodes so let's say we have\nlist one and we have list two i'm just\ngoing to take them exactly from the\nexample that they gave us\nso we can actually focus on the general\nalgorithm itself\nso your intuition will probably solve\nthis problem for you so\nit's basically since the lists are\nsorted we start at the beginning of both\nof them right\nnow we can just compare the values so\nthey're both\none so it doesn't really matter which\none we pick\nso we can just take uh i'll say list one\nright so we'll take\nthis one and insert it in our output and\nthen move to the next one\nand then just continue the algorithm the\nonly catch here is that right now our\noutput list\nis empty right so this kind of gives us\nan edge case because our we don't even\nhave a list itself yet so\nwhat i like to do is just create like a\ndummy node so\nthis is a pretty common technique and\nyou avoid\nany edge cases you avoid the edge case\nof the initial empty list\nso let's say we start out with a list\nright this is a dummy node it can have\nany possible value so now we're going to\ninsert one\ninto our list now we're going to compare\ntwo values\nof two and one in this case the value\nfrom list two is smaller so we're gonna\ntake it\ninsert it into our output list one now\nwe're gonna be comparing these two\nso two and three the value from list one\nis smaller\nwe take it and insert it into our output\ntwo and then of course we can move to\nthe last value in list one so now we're\nat\nfour and three which one of them is\nsmaller\nof course three which is the value in\nlist\ntwo i'm running out of space\nbut i think you get the idea at this\npoint so now we're at the two last\nvalues from each list\nwe'll just take the value from list one\nand add it\nwhich is four they're both the same so\nit doesn't matter now this is the last\nedge case that we have to worry about so\nnow\nfor list one there aren't any more\nvalues left right so we can't really\ncontinue our algorithm lucky for us\nthere's only one value left in list two\nbut it's not\nalways going to be the case right maybe\nthere could be a bunch of other values\nright four five six there could be other\nvalues\nin list 2. now what would we do in this\ncase well we can\ndo a really easy thing which is just\ntake the remaining\nportion of the list so if we\nrun out so if one of the lists is empty\nof course\nthe the list two in this case is still\nsorted so we can literally just take\nthat list\ninsert it into the end of our result\nright\nso that's basically the idea okay now\nlet's write the code so remember\ni like and most people like to use this\ntechnique of creating a dummy node\nso you don't have to worry about the\nedge case of inserting into an empty\nlist\nthe tail of our list is initially\ni'm just going to say you know the dummy\nso\nnow we're going to keep going we're\ngoing to iterate through these two lists\nwhat's the condition that we're going to\ndo that basically\nif both of them are non-empty right\nbecause that's\nwhen we can actually compare the two\nvalues so while list one and\nlist two are non-null so now we can do\nour comparison\nso if the value of list one\nthen of course we're going to take the\nlist1 value and insert it into\nour tail so tail dot\nnext is going to be the node itself\nright list one node\nand then we can of course update our\nnow the else case is if list two\nis less than or equal right so if they\nwere equal the else condition would\nevaluate so we're going to do the exact\nsame thing except\nand don't forget we do have to update\nour tail pointer but the tail pointer is\ngoing to be updated regardless of which\nnode we insert into our list so that's\nwhy i'm not putting it in either of the\nconditionals\nand you might be tempted to just say\nreturn\ndummy.next return the list but\ndon't forget our condition was list one\nand list two are non-null what if one of\nthem\nis empty but the other one isn't right\nnow well in that case we want to find\nthe non-empty list\nand then insert it at the end of our\nresult so if\nl1 is not null then we'll say tail\ndot next is equal to l1 so we're just\ntaking that remaining portion of l1\nand inserting it into the end of the\nlist\nelse if l2 is non-null we would do the\nexact same thing\nwith l2 uh only one of them can be\nnon-null so let me just run it to prove\nto myself that it still works\nand yep it does and some random\npercentages that always seem to change\nright now it's 65\nbut i'm sure if i submit it again it\ncould be 10 it could be 99\ni don't know why leak code is so\ninconsistent with this\nbut that's besides the point if this was\nhelpful please leave a like and\nsubscribe\nand thank you for watching and feel free\nto suggest any other problems that you\n"
    },
    {
        "Name": "Reorder List",
        "NcLink": "reorder-linked-list/",
        "Pattern": "Linked List",
        "Description": "You are given the head of a singly linked-list.\n    \nThe positions of a linked list of `length = 7` for example, can intially be represented as:\n\n`[0, 1, 2, 3, 4, 5, 6]`\n\nReorder the nodes of the linked list to be in the following order:\n\n`[0, 6, 1, 5, 2, 4, 3]`\n\nNotice that in the general case for a list of `length = n` the nodes are reordered to be in the following order:\n\n`[0, n-1, 1, n-2, 2, n-3, ...]`\n\nYou may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.\n\n**Example 1:**\n\n```java\nInput: head = [2,4,6,8]\n\nOutput: [2,8,4,6]\n```\n\n**Example 2:**\n\n```java\nInput: head = [2,4,6,8,10]\n\nOutput: [2,10,4,8,6]\n```\n\n**Constraints:**\n* `1 <= Length of the list <= 1000`.\n* `1 <= Node.val <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "S5bfdUTrKLM",
        "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        second = slow.next\n        prev = slow.next = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n\n        first, second = head, prev\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2\n",
        "Transcript": "Approach\nThis problem can be broken down into three simple sub problems and can be solve sequentially to arrive at our final solution.\n\nFinding the mid: take slow and fast ptr and find the start of the second half of Linked List\nReverse Linked List: reverse the second half and split the original Linked list into two independent linked list\nMerge Linked List: take each node one by one from both the sublists and merge them into single linked list."
    },
    {
        "Name": "Remove Nth Node From End of List",
        "NcLink": "remove-node-from-end-of-linked-list/",
        "Pattern": "Linked List",
        "Description": "You are given the beginning of a linked list `head`, and an integer `n`.\n    \nRemove the `nth` node from the end of the list and return the beginning of the list.\n\n**Example 1:**\n\n```java\nInput: head = [1,2,3,4], n = 2\n\nOutput: [1,2,4]\n```\n\n**Example 2:**\n\n```java\nInput: head = [5], n = 1\n\nOutput: []\n```\n\n**Example 3:**\n\n```java\nInput: head = [1,2], n = 2\n\nOutput: [2]\n```\n\n**Constraints:**\n* The number of nodes in the list is `sz`.\n* `1 <= sz <= 30`\n* `0 <= Node.val <= 100`\n* `1 <= n <= sz`\n",
        "Difficulty": "Medium",
        "Video": "XVuQxVej6y8",
        "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        while n > 0:\n            right = right.next\n            n -= 1\n\n        while right:\n            left = left.next\n            right = right.next\n\n        left.next = left.next.next\n        return dummy.next\n",
        "Transcript": "hey everyone welcome back let's write\nsome more neat code today today let's\nsolve remove nth node from the end of a\nlist\nso we're given a linked list and all we\nneed to do\nis remove the nth node from the end of\nthe list\nand then return the new list so that's\npretty straightforward right so in this\ncase we got five nodes\nwe just want to remove the n equals two\nso meaning the second node from the end\nof the list right so this is the first\nfrom the end of the list this is the\nsecond\nso we remove this and then we return\nthis list which now has four elements\nremaining\nso what's the easiest way to solve this\nwell they say from the\nend of the list that's inconvenient if\nit was from the beginning of the list\nit'd be\nsuper straightforward right n equals 2\nremove this node\nhow can we make that even easier i mean\nwhat if these pointers were reversed\ncan't we just reverse this linked list\nstart from\nhere and then remove the second node\nand then we're done that's definitely a\npossible solution but it requires\nreversing the linked list which we don't\nactually\nhave to do and i'm going to show you the\neasier way to do it\nso let's say n equals 2 again\nso we want to remove this node so how\ncan we\nidentify that this is the second node\nfrom the end of the list\nlike a lot of linked list questions we\ncan use two pointers\nbut how are we gonna make use of our two\npointers\nso what if i had two pointers right a\nleft pointer and a right pointer\nthe left pointer is at the beginning of\nthe list and the right pointer\nis shifted by n equals two so\nour right pointer is gonna be shifted\none and then it's gonna be shifted again\nand our right pointer is gonna be over\nhere so\nnow we're just gonna keep shifting our\npointers until this\nright pointer is at the end of the list\nand watch what happens\nwhen we do that so we're just going to\nbe shifting\neach pointer by one and this is going to\nmake sure\nthat the space between these pointers is\nexactly\nequal to n which is two right\nso now we're going to shift by one again\nmaking sure that the gap between them is\nstill two\nnow we're going to shift one last time\nbecause right is almost at the end so\nnow our\nright pointer is at null right it's at\nthe\nend of the list it can't go any farther\nand our left pointer\nis exactly at the node that we want to\ndelete\nand the reason is because remember the\noffset between these two\nis n making sure that we have the node\nwe want to delete\nnow there's only one problem we have\naccess to the node that we want to\ndelete but we want to delete it\nhow do we delete it the only thing we\nhave to do is take this pointer\ncross it out and then reassign it\nover here right once we've done that\nwe've gotten\nrid of this node so the problem is\nwe're at this node when really we want\nto be\nat this node if we want to delete this\nnode\nand this can actually be solved by\nanother\npretty common technique the dummy node\nright so we're going to actually have\nanother\nnode that we insert at the beginning of\nthis list that we don't really\nuse and the main thing that's going to\nhappen is happen is instead of our\nleft pointer instead of our left pointer\nbeing initialized here\nwe're actually going to initialize it at\nthe dummy node\nso left is really going to be\ninitialized here\nand our right pointer though is still\ngoing to be initialized over here\nso in reality when our right pointer\nreaches the end of the list\nwe will have a left pointer at 3\nand then we can update its pointer\nremoving this node that we want to\nremove\nand to return the new linked list\nall we have to do is take our dummy\npointer\nand say return dummy dot next\nwhich is going to be this node and since\nthis is a 2.0 technique\nthe time complexity is going to be big o\nof n\nso just like in the drawing the first\nthing we really want to do is create a\ndummy node\nwe don't really care what the value of\nthis node is but i'll just say\nzero but we want to make sure that the\nnext\npointer of this node is set to the head\nof the list because we're inserting it\nat the beginning\nnext we can initialize our left\npointer to dummy\nand we want our right pointer to be\nhead plus two right or\nhead plus n whatever n happens to be\nso we need a loop to do that right we\ncan't just do that\nwith a calculation so we can initially\nsay\nright is equal to head and while\nn is greater than zero and\nright is not null we want to keep\nshifting right\nso shift right by one\nand decrement n by one\nbecause once n equals zero that means\nwe've shifted by the amount that we\nwanted to shift by\nand the last thing we want to do is keep\nshifting\nboth of our pointers now now we're\nshifting left and right and we're going\nto keep\ngoing until right equals until\nright reaches the end of the list\nso we can shift our left pointer\nand we can shift our right pointer\nnow last but not least we actually want\nto delete the node and remember\nall we need to do to delete is update\nthe left node's next pointer\nand it's going to basically be shifted\nby one so left dot next is going to\nequal\nleft dot next dot next\nso for example if my left node was at\nmy left pointer was at this node its\nnext pointer is at 2 but i want to set\nits next pointer\nto 2's next pointer so\nbasically what i'm doing is this and we\nknow that\ndummy.next is at the head of our list\nwhich is what we want to return we want\nto return the\nupdated list so we can just return\ndummy.next we don't want to include\nour dummy node in the output we never\nwanted to add a node to the list we just\nwanted to remove a node\nso our solution works beautifully we\ncould have just reversed the list\nbut we definitely did not need to do\nthat i hope this was helpful\ndon't forget to like and subscribe it\nsupports the channel a lot and i'll\n"
    },
    {
        "Name": "Copy List With Random Pointer",
        "NcLink": "copy-linked-list-with-random-pointer/",
        "Pattern": "Linked List",
        "Description": "You are given the head of a linked list of length `n`. Unlike a singly linked list, each node contains an additional pointer `random`, which may point to any node in the list, or `null`.\n\nCreate a **deep copy** of the list. \n\nThe deep copy should consist of exactly `n` **new** nodes, each including:\n* The original value `val` of the copied node\n* A `next` pointer to the new node corresponding to the `next` pointer of the original node\n* A `random` pointer to the new node corresponding to the `random` pointer of the original node\n\nNote: None of the pointers in the new list should point to nodes in the original list.\n\n*Return the head of the copied linked list.*\n\nIn the examples, the linked list is represented as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]` where `random_index` is the index of the node (0-indexed) that the `random` pointer points to, or `null` if it does not point to any node.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5a5c2bdd-51e2-4795-4544-096af4b6cc00/public)\n\n```java\nInput: head = [[3,null],[7,3],[4,0],[5,1]]\n\nOutput: [[3,null],[7,3],[4,0],[5,1]]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6e56fa98-cf1e-4ca6-18d4-716dac4ba900/public)\n\n```java\nInput: head = [[1,null],[2,2],[3,2]]\n\nOutput: [[1,null],[2,2],[3,2]]\n```\n\n**Constraints:**\n* `0 <= n <= 100`\n* `-100 <= Node.val <= 100`\n* `random` is `null` or is pointing to some node in the linked list.\n",
        "Difficulty": "Medium",
        "Video": "5Y2EiZST97Y",
        "PythonSolution": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        oldToCopy = {None: None}\n\n        cur = head\n        while cur:\n            copy = Node(cur.val)\n            oldToCopy[cur] = copy\n            cur = cur.next\n        cur = head\n        while cur:\n            copy = oldToCopy[cur]\n            copy.next = oldToCopy[cur.next]\n            copy.random = oldToCopy[cur.random]\n            cur = cur.next\n        return oldToCopy[head]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today\nso today let's solve copy list with a\nrandom pointer so we're given a linked\nlist\nand so this is a pretty big description\nof the problem but it's actually more\nsimple than that so\nbasically you can see down in the\nexample this is what you should pay\nattention to\nwe have a pretty ordinary linked list\nright so this is a node and you can see\neach node has a next pointer right so it\njust keeps going it's singly linked list\nfor the most part right\nand then we get to the end right so this\nis the end of the list\nthis is the start the only difference\nbetween this and a regular linked list\nis that\nevery single node has one extra pointer\nit has a\nrandom pointer so you can see that the\nfirst node\nhas a random pointer going all the way\nto\nnull right you can see that the second\nnode has a random pointer going all the\nway back to the first node\nyou can see the third node has a random\npointer\ngoing all the way to the last node so\nbasically what the deal\nis is that every single node has a\nrandom pointer and that pointer could be\npointing\nanywhere right it could be at null it\ncould be at some random\nnode inside of the list it could be at\nany of those nodes\nso it has a random pointer but it also\nhas a next pointer which\nis as you would expect just pointing at\nthe next node all we really need to do\nwith this linked list is create a copy\nof it\nby that they mean a deep copy so really\nwhat we're doing is for every single\nnode\nwe're allocating new memory we're\nactually creating a\nnew node right and so you can see we\nhave five\nnodes in the input so we're gonna have\nto create five nodes\nin the output right so that's pretty\nstraightforward right the only\ndifficulty\ncomes though is from the random pointer\nright\nclearly these nodes are going to be\nlinked together\nright in linear fashion but we also have\nrandom pointers\nright so for this node we would have to\ncreate a random pointer pointing at null\nright which is pretty easy that's what\nwas happening with the first node\nbut for the second node right we'd have\na random pointer going back\nto the first node and for the third node\nwe'd have a random pointer going to the\nlast node so it's not too bad right\nthe only difficulty though with these\nrandom pointers\nis that take the third node for example\nright\nlet's say we start cloning the node\nright we create the\na clone of the first node then we create\na clone of the second node then we\ncreate a clone of the third node\nand you know the random pointers this\none's going to be at null\nthis one's gonna point back at the first\nnode but the third node right\nwe know its random pointer is going to\nbe at the\nfifth node but we haven't created a deep\ncopy of the fifth node yet\nso how can we assign a random pointer\nbefore it's even been created\nwell the answer is we're gonna do two\npasses we're gonna have\ntwo loops and so with these two passes\nwhat the first\npass is going to do is we're simply\ngoing to take each of these\ninput nodes right and we're going to\ncreate a deep copy of the nodes right\nthat's all we're doing we're just going\nto create\ncopies of these nodes we're not even\ngoing to link them yet\nright so that's what the first pass is\ngoing to do\nand in addition the first pass is also\ngoing to create a\nhash map where we map the original node\nto the new node right so we're going to\nmap every old\nnode to the new copy we're going to do\nthat with a hash map\nand this is going to take place in the\nfirst pass\nand in the actual second pass is where\nwe're going to actually do all the\npointer connecting so we know that every\nnode is going to have you know pointers\nto the next node they're also going to\nhave some random pointers\nas well right like this is going to have\na random pointer to the last node\nand we're going to leverage our hashmap\nthat we create in the first pass\nright that we create using the first\npass of our algorithm we're going to\nleverage that hashmap to\nget to map every old node to the new\nnode so for example\nwe see in the original third node its\nrandom pointer is pointing at the\noriginal\nfifth node right we can leverage that by\ntaking\nor using our hash map we can say okay in\nthe\ncopy of the third node we want it to\npoint to the copy\nof the fifth node right and we can use\nour hash map to get the\ncopy and so if this doesn't make sense\nyet this is just a basic illustration\nthis problem is actually straightforward\nenough with the code that i think even\nif this doesn't make sense\nwhen i show you the code it'll make a\nlot more sense because\nat the base this is a two-pass algorithm\nwhere we create a hashmap\nand can easily solve this problem in\nlinear time\nbecause each pass is going to be\niterating through the entire linked list\nand our hashmap is also going to take\nlinear memory of n memory because\nwe are having to store every single node\ninside\nof our hash map so with that being said\nlet me show you the code\nit's actually easier than you might\nthink so remember we are going to have a\nhash map i'm going to call it\nold to copy because we're going to be\nmapping\nevery single old node to the copy of\nthat node that we create\nso first we're going to iterate through\nthe linked list once right so we're\ngoing to have a current pointer pointing\nat the head\nwe're basically going to keep going\nuntil this current pointer reaches the\nend of the linked list\naka when the when the current node\nbecomes null\nso the first thing we want to do is\ncreate a copy of this node right so\nwe can do that with the node construct\nconstructor and we're going to pass in\nthe value of current so current.value\nwe're creating a clone of the node a\ndeep copy of the node putting it in copy\nand now we're going to take this copy\nand put it in our hash map\nso in our hashmap old to copy we're\ngoing to\nmap the old node to the copy\nthat we just created right this is\npretty straightforward right we're using\na hashmap\nmapping the old node to the copy node\nand\nnext all we really need to do is update\nour current pointer\nuntil it reaches null and then the first\npass of our loop is going to be done\nright so remember we're doing two passes\nthis is the first\npass all we're doing is cloning the\nlinked list\nnodes and adding it to the hashmap we're\nnot connecting the pointers yet that's\nwhat this\nloop is going to be for we're going to\nrun the loop one more time\nsetting current to the beginning of the\nlinked list keep going until we reach\nthe end of the linked list\nnow we're going to set the pointers so\nwe're at the first node let's say\nof our linked list right that's what\ncurrent is so let's get the copy of the\nnode remember we already created the\ncopy in our hashmap so old to copy\nwe use current and this gives us the\ncopy node\nof current right and now what we want to\ndo is for this current node we just want\nto set its\npointers because remember we we are\nrequired to set the pointers to create a\nfull deep copy of the linked list we\nneed to set the\nthe next pointer right so copy dot next\nwe have to set that pointer we also have\nto set copy copy.random\nso copy has two pointers and we need to\nfind those nodes right so copy.next how\ndo we get\ncopy.next well we know we have\na map that can map original nodes to the\ncopies right so if we take\ncurrent dot next that's gonna map us\nto the copy of current.next that we\ncreated\nand that copy can be stored in copy.next\nright\nthis is what our hashmap makes our life\nso much easier right\nwe already know we created a copy of\nevery single node so of course\ncurrent.next is going to be in copy.next\nexcept one case one edge case\nwhat if current.next was null\nwhat would we want our hashmap to return\nin that case\nwe'd want it to return null so in up\nhere\nin our initializing of the hashmap i'm\njust going to add\none value null is going to point is\ngoing to map to null so\nit's pretty straightforward right if we\nhad a old node that was null we want to\nthe copy is also going to be null right\nand last thing we're basically just\ndoing the exact same thing so\nfor the current node the current node\nhad or the original node it had a random\npointer right\nthat random pointer points to some node\nand that node has already\nha we have already created a copy of\nthat node and put it inside this hash\nmap so we can get that copy\nand then put it in copy dot random right\nso\nthe copy node is going to point to a\ncopy\nof that random node and that's actually\nit we just had\ntwo passes one pass where we actually\ncopy the nodes\nthe second pass where we set the\npointers and we had one data structure a\nhash map\nwith all that said we can return the\nhead of the copy list how do we get the\nhead\nwell our hashmap becomes useful for us\nonce again\nwe can take the head of the original\nlinked list\nand then map it to the copy right and\nthen return that head\nof the copy list okay i'm pretty dumb\nfor some reason i put old over here but\nit's actually cur\ncur is the old node and for some reason\ni also forgot\nin the original loop we do update cur i\nforgot to update\nkerr in the second loop so cur is\ncur.next\nnow we won't get an infinite loop and as\nyou can see this function\nis very efficient 96 because\nit's a linear time algorithm and we do\nhave a hash map speeding stuff\nup for us so i hope that this was\nhelpful if it was\nplease like and subscribe it supports\nthe channel a lot\n"
    },
    {
        "Name": "Add Two Numbers",
        "NcLink": "add-two-numbers/",
        "Pattern": "Linked List",
        "Description": "You are given two **non-empty** linked lists, `l1` and `l2`, where each represents a non-negative integer.\n    \nThe digits are stored in **reverse order**, e.g. the number 123 is represented as `3 -> 2 -> 1 ->` in the linked list.\n\nEach of the nodes contains a single digit. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nReturn the sum of the two numbers as a linked list.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fee72e19-6a21-45a5-365e-3cb45aba9700/public)\n\n```java\nInput: l1 = [1,2,3], l2 = [4,5,6]\n\nOutput: [5,7,9]\n\nExplanation: 321 + 654 = 975.\n```\n\n**Example 2:**\n\n```java\nInput: l1 = [9], l2 = [9]\n\nOutput: [8,1]\n```\n\n**Constraints:**\n* `1 <= l1.length, l2.length <= 100`.\n* `0 <= Node.val <= 9`\n",
        "Difficulty": "Medium",
        "Video": "wgFPrzTjm7s",
        "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        cur = dummy\n\n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            # new digit\n            val = v1 + v2 + carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)\n\n            # update ptrs\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next\n ",
        "Transcript": "hey guys i'm still unemployed so let's\nsolve another leak code problem today\nleak code 2\nadd two numbers together so just like\nthe problem\nsays all we're really doing is adding\ntwo numbers together right so like\nthis example 342 465\nadd them together right that's 807. well\nyou probably remember from elementary\nschool how to add two numbers together\nright so that's\nthe number one thing to know about this\nproblem right so\nwe're adding 342 and 465.\nso do you remember how to add two\nnumbers together from elementary school\nyou probably do but you might think you\ndon't so\nlet's just look at this right two plus\nfive that's seven\nfour plus six that's ten but that's a\ntwo digit number right so we gotta\ntake a carry for that so we'll put a\nzero here\nbut we know we have a carry so we're\ngonna have to put that one\nover here right so now we have one plus\nthree plus four\nthat's eight so we just did it right\nthat was the result\n807 so you do probably remember how to\nadd two numbers together that's really\nthe main part of this problem now the\nsecond\nthing to recognize though of this\nproblem is\nthat there's a lot of edge cases that's\nkind of why there's a lot of dislikes in\nthis problem\nyou can tell over here but so there's\ngoing to be a lot of edge cases and\nwe're going to\nreally talk about those edge cases and\nfocus on them\nso the first thing they tell us is we're\ngiven two non-empty linked lists\nright so these linked lists are\nrepresenting the integers\nthat we're adding together so they're\nnon-empty what does that mean for us\nthat means if we're adding two numbers\nright\nlike uh 500 plus\nsomething else right this second number\nit can't be empty there's always gonna\nbe some number here right so like eight\nfor example something like that\nit's never going to be empty the other\nthing is that they're\nnon-negative integers that's really\nconvenient for us\nbecause these are linked lists remember\nso having a negative number would kind\nof be inconvenient so good thing we\ndon't have to worry about that\nthe other thing is the digits are stored\nin reverse\norder now let's not worry about this too\nmuch yet\nso for example we see 342\ndown here in 465 right in the linked\nlists\nthey're stored in reverse order so 342\nis actually 243. uh 465\nis actually 564. so\nwe'll see we'll see later that having\nthem in reverse order actually helps us\nand so we want to add these two numbers\nand return it as a\nlinked list so for each digit we're\ngoing to have to create a separate\nnode so we we will keep that in mind\nso let's look at a slightly modified\nexample in the\nin the example given both the numbers\nhad the exact same number of digits\nright so there were three digits in each\nbut we're looking at it slightly\ndifferent we added one more digit\nto one of the numbers because this is\nkind of\na case that you have to consider so the\nfirst thing we're gonna do\nis obvious right we're just adding two\nnumbers together so we're gonna\ngo iterate through them right so five\nplus two that's gonna be 7 right that's\nour\nfirst node and notice that we're\nstarting\nat the ones place right because that's\nhow you add numbers\nand since the lists these linked lists\nare given to us\nin reverse order it makes it really easy\nfor us to start at the ones place\nthat's how you add two numbers together\nso they really made it easy for us\nso next we're just gonna basically keep\ndoing that right so now we're gonna get\nto the next\ntwo numbers add them together that's\ngoing to be 10 so we're going to\nremember\nthat we have to put a carry so we'll\nhave a zero here and we'll\nmake sure to remember we have a carry so\nnow we're gonna do one plus four plus\nthree\nthat's eight now we no longer have a\ncarry so the carry's gone\nand now we get to a weird place right\nthere's nothing here\nso we only have one node right so what\nare we gonna say is up here well we can\njust kind of\nuh assume that it's a zero right so\nthere's not actually any value but we'll\nassume that there's a zero here\nso zero plus three that's going to be\nthree\nand in this case this is going to be our\nresult so we just considered one edge\ncase of what if the two\nlinked lists that we're adding together\nare of different sizes right\nso we kind of know what we can do in\nthat case now there's one last edge case\nthat's kind of tricky\ni seem to never remember it when i'm\nsolving this problem but\nmaybe you'll be able to catch it so\nlet's say we were adding\nseven plus eight together right now when\nyou add it together\nwith addition right it's pretty obvious\nuh let me rewrite it\nso we know it's 15 right so we're going\nto put a\n5 here but we have a carry so the carry\nis going to go here right but there's no\nother number that we're adding here\nright\nwe know we can just put the 1 here but\nwhen you're solving this algorithm you\nmight forget to do that because\nwith a linked list seven plus eight\nyou add these together you get a five\nright that's our result\nand you'll put the carry here you'll say\nyeah there's a carry of one\nbut in our algorithm we have to make\nsure to remember\nto put the one in our result\nright even if there aren't any uh nodes\nhere right like there aren't any\ninput nodes that we're adding it with so\nwith all of that in mind let's actually\nget into the code and it'll probably\nmake even more sense\nso the first thing we want to do is we\nknow we're creating a resulting linked\nlist so\ni like to just put a dummy node to not\nhave to deal with any of the edge cases\nof inserting into a linked list\nand our current pointer is going to\npoint at the position that we're going\nto be inserting\na new node or the new digit into\nso we're going to iterate through these\nnodes now how long\nare we going to be iterating through\nthem while either of them has a digit so\nwhile\nl1 or l2 is non-null we're going to be\nadding them together\nnow we know one of them could be null so\nwe're going to get the digits from them\nonly if l1 is non-null if l1\nis null though we're gonna set it to\nzero right just like we did\nin our visual example we're gonna do the\nexact same thing\nnow we actually want to add them\ntogether but\nhold on remember we had a carry that we\nhave to maintain\nso i'm gonna have a carry value and\ninitially set it to zero outside of our\nloop so carry is initially zero\nso now we're gonna compute the new digit\nso how do we do that well we'll say\nv1 plus v2 plus carry right this is\nelementary school mathematics but now we\ncould potentially have a\nnew carry right so if our number that we\njust computed for example what if it's\n15\nright so that's a two digit number so\nwe're we want to get the carry out of\nthat so how do we get it\nuh we can just say value\ndivided by 10. also since\nour value could be greater than 10 right\nright like 15\nwe want only the the ones place\ndigit so we're gonna take our value and\nmod it by ten so that'll give us the\nones place\nso now that we have the digit we can\nfinally insert it into our list so we're\ngoing to say\ncurrent.next we're going to insert a new\nlist node\nwith the value that we just computed so\nnow we're going to be\nupdating our pointers so we have to\nupdate current\nso we're going to set current to the\nnext pointer\nwe're going to update our list one and\nlist two pointers\nif they are non-null so l1 is going to\nbe\nl1 dot next if l1 is non-null\nright you might you might say okay now\nwe're done we're just going to return\ndummy.next right so we're going to\nreturn the list that we just created\nbut remember that edge case that we\ntalked about right what if we had\neight plus seven uh our loop\nis is going to stop and we're going to\nforget about the carry\nso over here i'm going to add one last\nthing to our condition\nwhile our loop is going if our carry is\nnon-null\nwe want to continue the loop meaning if\nour carry for example 8 plus 7\nl1 and l2 are going to be null meaning\nv1 and v2 are going to evaluate to 0\nbut our carry is going to be 1 right\nso we're gonna say uh we're gonna insert\na value of zero\nplus zero plus one because our carry is\none and then\nof course our list is gonna need to have\nthat value in it so\ndon't forget about the edge cases that's\nreally what makes this problem annoying\ni hope this was helpful for you if it\nwas leave a like and subscribe\n"
    },
    {
        "Name": "Linked List Cycle",
        "NcLink": "linked-list-cycle-detection/",
        "Pattern": "Linked List",
        "Description": "Given the beginning of a linked list `head`, return `true` if there is a cycle in the linked list. Otherwise, return `false`.\n\nThere is a cycle in a linked list if at least one node in the list that can be visited again by following the `next` pointer.\n\nInternally, `index` determines the index of the beginning of the cycle, if it exists. The tail node of the list will set it's `next` pointer to the `index-th` node. If `index = -1`, then the tail node points to `null` and no cycle exists.\n\n**Note:** `index` is **not** given to you as a parameter.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/3ecdbcfc-70fc-429a-4654-cf4f6a7dbe00/public)\n\n```java\nInput: head = [1,2,3,4], index = 1\n\nOutput: true\n```\n\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/89e6716c-9f65-46da-d7b2-f04a93269700/public)\n\n```java\nInput: head = [1,2], index = -1\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= Length of the list <= 1000`.\n* `-1000 <= Node.val <= 1000`\n* `index` is `-1` or a valid index in the linked list.\n",
        "Difficulty": "Easy",
        "Video": "gBTe7lFR3vc",
        "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nlinked list cycle i know that we solved\na problem that's pretty much a harder\nversion of this exact problem\nbut in this explanation i'm going to\nexplain why the tortoise and hair\nalgorithm on a linkedlist cycle\nwhy exactly it works and why exactly\nwe know for sure that it's a linear time\nalgorithm because i think most people\njust kind of glance over why exactly\nthis is true so i'm going to go over\nthat today\nand you can see that this linked list\nproblem is another problem from the\nblind 75 list a list of 75 problems\nwe've been working through and tracking\non the spreadsheet the link to the\nspreadsheet will be in the description\nif you want to take a look\nwe are not quite done with this sheet\nyet even though we have done all\npretty much most of the difficult medium\nand hard problems on this list\nso basically we're given the head of a\nlinked list\nand we just want to determine if there\nexists a cycle in this linked list or\nnot\nand basically the definition of a cycle\nis if at some point you know you get\nto a node and you keep following the\npointers along that node eventually\nyou'll get back to the same node and if\nwe get back to the same node\nwe'll be able to do it again and again\nand again basically an infinite loop\nso we return true if there's a cycle we\nreturn false if there's no cycle now the\nfirst idea you might have is just start\nat the beginning\nkeep going to the end keep going keep\ngoing and eventually let's say that this\nof this negative four actually pointed\nto null in that case\nwe know okay we got to the end of a\nlinked list right so in that case we\nreturn\nfalse no cycle and that's always going\nto be the case so if there's no cycle\nit's really easy to detect that there's\nno cycle because eventually we reach\nnull but if we don't reach null\nright we we go along this node and we\nget to we get back to the same node we\nalready visited but for some reason we\ncan't detect that so then we go to the\nnext node\nthe next node and keep doing that and\nfrom our perspective we're just going to\nsay okay it's just a really\nlong linked list eventually we're going\nto get to null right but that's not\ngoing to be the case if there's a cycle\nwe never get to null we'll never break\nout of this loop so we really have to\ndetermine a way\nto detect that we're visiting the same\nnode twice\nso how can we determine if we're\nvisiting the same node twice well we\nstart at the beginning like usual and we\nmaintain\na hash map or a hash set in this case\nwhere basically we take every single\nnode and we take the\nnode itself and add it to the hash set\nafter we have visited this node we don't\nadd the value because i think in this\nproblem there could be duplicates\nright like the same value could show up\nmultiple times in multiple nodes\nso we don't want to detect a loop that\nway but we'll take the node itself\nand then add it to the hash set and i\nthink you can do that in most languages\nyou definitely can in python\nbecause the node itself is just an\nobject and you usually can hash an\nobject and so in that case we're going\nto take this\nvisit it take this visit it take this\nvisit it take this visit and then\neventually we'll get\nback to a node if we notice that a node\nhas\nalready been visited and now we're\nvisiting it twice\nthat obviously means that there must be\na cycle right\nwe can't visit the same node twice so\nthat means there's a cycle we detect\nthat and then we can return true a cycle\nexists\nnow in this case we're only having to\nvisit each node about once\nso the time complexity is going to be\nbig o of n the memory complexity is also\ngoing to be big o of n because every\nnode potentially is going to be stored\nin the hash set\nbut there's actually a way that we can\ndo this without using a hash set we can\ndo this in o of one memory and that's\nthe\nslightly complicated algorithm i'm going\nto show you that algorithm and i'm going\nto show you\nexactly why it works so the idea is\nsimple we're going to start at the\nbeginning of the linked list but we're\ngoing to have two pointers this time\nwe're going to have a slow pointer s and\nwe're going to have a fast pointer\nf and you may have seen this algorithm\nbefore it's a pretty simple algorithm\nonce you know it but i'm gonna again\nshow you why exactly it works so the\nslow pointer\neach time is just gonna be shifted by\none\nthe fast pointer is going to be shifted\nby\ntwo so it's going to be here and\nso originally they do start at the same\nposition but we're gonna look at every\nposition\nafter we've shifted it and so what's\neither going to happen\nobviously the fast pointer is faster\nthan the slow pointer so the if there is\nthe end of a linked list right like for\nexample\nthis points at null the fast pointer is\nof course gonna\ngonna reach the end of the linked list\nfirst so if we do that\nthen we can return false no link no\ncycle exists in the linked list but if\nthere\nis a cycle do you see that this fast\npointer and this slow pointer are\ngoing to meet again they're going to\nmeet at the exact\nsame position and if they meet at the\nexact same position that must mean that\na cycle\nexists so i'm just going to run the\nsimulation and then i'm going to show\nyou why it's always going to be the case\nthat these two are going to meet\nif they ever reach a cycle so we just\ntake one more step with s right we're\nonly shifting it by one\nf is gonna be shifted by two so first\nwe're gonna go to four\nand then we're gonna follow the link and\nreach back\nto this position right the two position\nso\nclearly f made a loop f has gone through\nthe cycle\nand so far we've shifted each of the\npointers twice\nand so we're going to do one last shift\ns is going to reach\nthe 4 and our f from over here is gonna\nbe shifted twice again\nand it's gonna reach the four as well so\nat this point\nwe're gonna just we're gonna see yes the\nslow pointer and the fast pointer have\nmet each other how could it be possible\nthat they met each other if the\nfast pointer was going twice as fast\nbecause\nthey were in a cycle and eventually the\nfast pointer no matter where they start\nslow is here fast as you're eventually\nthe fast pointer is going to catch\nup to the slow pointer let me show you\nwhy that's always going to be the case\nand why it's going to happen in linear\ntime\nso let's say this is our cycle and i'm\nnot drawing it as a linked list it's\nsome kind of circle right and it's a\ncycle\nand let's say we're moving clockwise in\nthis cycle\nfirst thing to notice is do you know\nthat every gap so let's say you know the\ndistance between slow and fast\nthat's going to be some integer value\nright it's not going to be a decimal\nit's going to be an integer value\nand this portion is also going to be an\ninteger value\nbecause the entire length of the cycle\nis going to be an integer value because\nyou know linked list\nlengths are integer values right this is\nan integer one this is an integer two\nuh also one so the entire list is length\ntwo right so we're dealing with\nintegers here not decimals so we're\nlooking at the case where at with a slow\nand fast pointer are at different\npositions because obviously if they were\nalready at the same position\nwe're inside the cycle they're at the\nsame position then of course we know\nwe're going to return true but it could\nbe possible that they're at different\npositions\nany arbitrary position is what i'm\nchoosing here\nand we know that the slope pointer on\none iteration is going to make\none jump right the distance it's gonna\ndo it's gonna move is one we know that\nthe fast pointer\nis gonna move a distance of two\nright so clearly in our simulation\neventually the fast pointer is going to\nreach and surpass the slow pointer\nbut why is it true that they are going\nto meet each other at the exact same\nspot\nwell let's just give this distance an\narbitrary\nvalue we know that the fast pointer will\ncatch up to the slow pointer and this is\nthe distance that it's going to have to\ntravel\nin order to do so this is our gap that\nwe have to close\nso let's say the the length of this gap\nis 10.\nif we move the slow pointer by one\nwe're taking the gap and increasing it\nby one right\nif the slow pointer gets shifted by one\nwe increased the gap\nbut then the fast pointer is not going\nto quit it's gonna move by two as well\nso when we move the fast pointer we're\ntaking the gap\nand closing it by two so we're saying\nplus\none minus two right do you see how\nthis evaluates to ten minus\none which is going to be nine so on a\nsingle\niteration of the loop the distance\nbetween the pointers\nis being closed by one so then\nhow many iterations is it going to take\nfor the fast pointer to reach the slope\npointer well of course whatever this\nlength happens to be right whatever that\nclosing distance happens to be whatever\nthat\ngap happens to be how big could this gap\npossibly be it could only be the entire\nlength of the list so you know let's say\nuh the fast pointer is over here where\nthis\ndistance is one so then the remaining\ndistance is gonna be\nthe entire length of the list let's call\nthat n\nminus one so then how many iterations is\nit gonna take to get this to equal to\nzero\nof course roughly n so that's why the\noverall time complexity is\nn where the length is the distance where\nn is the length of the cycle which could\nbe the entire linked list right\nso that's why it's always going to work\nand\nit's going to run in linear time and\nmaybe you didn't even care about why\nexactly it works but that's okay because\nonce you know the fast and slow pointer\ntechnique\nthe code is usually pretty easy to write\nlet's get into that now so like i said\nwe're going to start our slow and fast\npointer at the same position\nand the next time that they meet each\nother is how we know we've detected a\nloop so obviously they're at the same\nposition now so we don't want to\nsay that there already exists a loop\nbecause we don't know that for sure\nand we're going to be shifting our fast\nand slow pointers while\nfast and fast dot next is not\nnull because we need to make sure that\nfast dot next is not null\nbecause remember we're shifting fast by\ntwo on each\niteration and of course fast is going to\nreach the end of the linked list\nbefore slow does so if it does that then\noutside of the loop we can return false\nmeaning that there does\nnot exist a cycle but on the inside\nwe're gonna check if there is a cycle so\nwe're gonna take our slow pointer\nshift it by one slow dot next take our\nfast pointer shift it by two\nfast dot next dot next again\nand now if we if they meet each other\nwe can say if slow ever reaches fast\nthen we can return true there does exist\na cycle and you could pretty much write\nthis loop as a do while loop in a lot of\nother languages but i don't think python\nsupports that\nso the solution is really as simple as\nthat linear time\nconstant space you can see that the\nsolution works and is efficient so i\nhope this was helpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\n"
    },
    {
        "Name": "Find The Duplicate Number",
        "NcLink": "find-duplicate-integer/",
        "Pattern": "Linked List",
        "Description": "You are given an array of integers `nums` containing `n + 1` integers. Each integer in `nums` is in the range `[1, n]` inclusive.\n\nEvery integer appears **exactly once**, except for one integer which appears **two or more times**. Return the integer that appears more than once.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3,2,2]\n\nOutput: 2\n```\n\n**Example 2:**\n\n```java\nInput: nums = [1,2,3,4,4]\n\nOutput: 4\n```\n\nFollow-up: Can you solve the problem **without** modifying the array `nums` and using $O(1)$ extra space?\n\n**Constraints:**\n* `1 <= n <= 10000`\n* `nums.length == n + 1`\n* `1 <= nums[i] <= n`\n",
        "Difficulty": "Medium",
        "Video": "wjYnzkAhcNk",
        "PythonSolution": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        slow, fast = 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while True:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n            if slow == slow2:\n                return slow\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's all\nfind the duplicate number and you can\nsee that i'm not\nreally a big fan of this problem and\nmaybe i'm just salty but i really feel\nlike this type of problem\nis the ultimate test of whether you've\nseen the problem or not\nbut i'm still solving it nonetheless\nbecause it's an interesting problem\nand it does show up in interviews quite\na lot it seems i really don't know how\nanyone would be able to solve this\nproblem in a 30 minute interview without\nhaving seen even the person who came up\nwith\nthe algorithm floyd i i doubt even he\ncould solve this in 30 minutes in an\ninterview setting\nbut that's okay let's just learn the\nproblem today so we're given an\ninteger array of nums containing n\nplus one integers this is the length of\nthe array but\nevery single value in the array is going\nto be within the range\none through n so we have n different\nvalues that could be in the array like n\ndifferent\nchoices for the integers but we have n\nplus\none integers so that kind of implies\nthat at least\none of the numbers is going to be\nrepeated and they tell us that\nactually it's only one number is\nguaranteed to be repeated\nand the only thing we want to do is\nreturn the number that\nis repeated more than once now the easy\nway to solve this problem of course\nwould just be have a hash set right\niterate through every single value\nfind the one that occurs twice by using\nour hash set that's going to be o of n\ntime and o of n memory but they tell us\nthat we can only use constant extra\nspace\nand we can't even modify the input array\nso we can't even sort it or anything\nand i think those restrictions probably\nmake this a hard problem rather than a\nmedium problem but that's okay\nso there's two aspects to this problem\nand i'm going to explain both of them so\nwe're going to solve this in o of n time\nand o of 1 space the first thing to\nrecognize is this is a\nlinked list problem specifically a\nlinked list\ncycle problem and the second thing is\nto know floyd's algorithm which will\ntell you the beginning of a cycle in a\nlinked list so there's two problems one\nto even\nrecognize that this is a linked list\nproblem and two to know the algorithm to\nactually apply to it\nonce you know that so let me actually\nshow you how we can\nwe can figure out both of these things\nand yeah you're right it's probably not\nsuper intuitive and i i'm not really\nsure how you would be able to figure it\nout on your own if you've never done\nsomething like this before\nso remember that the length of our array\nis n plus 1\nbut every value in the array is going to\nbe between\none and n so there's n different values\nbut there's n plus one positions so in\nthis\narray we have five different elements\nright and we know that the elements are\ngoing to be in the range\none through four right so basically\ninstead of thinking of these as\nvalues let's think of them as pointers\nso we know for sure that every single\nvalue\nin the array is going to be in the range\none through four that means\nif we considered every value as a\npointer\neach value is going to point at some\nposition\nin this block of four you can see that\nthis one\npoints at position one this three\npoints at position three this\ntwo points at position two over here\nand this four points at position\nfour over here and then this two points\nback at position four so that's how you\ncan kind of see that\nyou know in that case there was a cycle\nand you can see i basically drew out the\nlinked list\nversion of that so it's not hard to see\nthat this portion is going to form\na cycle because no matter what value we\nlook at it's going to point at\nsome other value inside of this range\nthere's never going to be an\nexit condition none of these values are\ngoing to point outside of the range\neither you know over here or over here\nnone of them are going to point\noutside of the range so this portion is\ngoing to form a cycle\nlinked list somewhere right what about\nthis\nvalue is this going to be a part of the\ncycle\nnotice how none of these values nothing\nis\never going to point at index 0 because\nremember our\nrange is between 1 through 4 none of\nthem is going to be zero so\nnone of them is going to point here so\nwe can guarantee that this\nis not going to be a part of the cycle\nand when you see i\ntook this array drew it as a linked list\nyou can see\nthis is index zero right you can see\nthat this was our cycle portion\nbut this was not included in the cycle\nand that's going to be very important\nbecause we do when we start traversing\nthis linked list we're always going to\nstart here\nbecause we know this is not a part of\nthe cycle\nso in our input array you can see that 2\nis the duplicate right 2\nis the one that shows up multiple times\nso in the context of this problem\nthis position is going to point at index\n2\nand this position is going to also point\nat index two\nso what does that tell us about our\nlinked list\nthat means at the node that's labeled\ntwo\nthe each value of the node each label is\ngoing to map to the index so this\nis basically node two right what that\ntells us about\nnode two is that multiple nodes are\ngoing to be\npointing to node two right therefore\nwe know that this is the one that's\ngoing to be the start of the cycle\nwe know for sure there's going to be a\ncycle and we know for sure there's going\nto be a portion before the cycle\nthe portion before the cycle of course\nis eventually going to lead us to here\nwhich is the start\nof the cycle and of course there's going\nto be another node that completes the\ncycle right putting it back\npointing back to this node so if we can\nsomehow identify the beginning of a\ncycle\nin this linked list then we will know\nthat that beginning of the cycle\nis the return value that we're looking\nfor in the output you can see yes\n2 is the duplicate that's the one we\nwant to return therefore we want to\nreturn the start of the cycle\nso at this point it's all about applying\nfloyd's algorithm to find the beginning\nof a cycle\nso that's once you've determined that\nit's a linked list problem then you just\nneed to apply\nthis algorithm and this algorithm itself\nis actually also not very intuitive\nso let's look at a slightly different\nexample so i can illustrate the\nfloyd's algorithm so first i'm just\ngoing to tell you what the algorithm is\nand then i'm going to explain a little\nbit of the intuition of why it actually\nworks\nso the slow pointer and fast pointer are\nboth going to start at this position\nthe slow pointer of course is going to\nbe shifted by one\neach iteration so that's one jump that's\ntwo jumps that's three jumps so we just\nmade three jumps with our\nwith our slow pointer let's do the exact\nsame thing with our fast pointer\nso remember a jump with the fast pointer\nis going to be two positions so that's\none jump that's two jumps\nand let's make two more jumps from here\nso we're gonna go to two\nand then back to three so you can see\nthat it got a little bit\nmessy but we made three jumps with the\nfast pointer and we made three jumps\nwith a slow pointer and you can see\nthis is the first position that they\nintersected at\nso this was the intersection of\nthe us of the two pointers right this\nwas the first\nintersection so that's the first phase\nof this algorithm first we find the\nfirst position that they intersect at\nthen we take our slow pointer leave it\nhere\nso our slope pointer is going to be here\nright and then we're going to be done\nwith the fast pointer we're going to\ntake a\nsecond slow pointer and put it right at\nthe beginning of the array\nand each of these slow pointers we're\ngonna keep shifting them by\none until they intersect one more time\nso\nthis slow pointer is going to be shifted\nby one this slow pointer is also going\nto be shifted by one\nhey and we just found out that they\nintersected right\nand this second point of intersection is\nalways going to be the result it's not\nintuitive at all\nwhy this is the case yet but let me\nexplain that but now you know the\nalgorithm if all you wanted to do was\nmemorize it that's literally it now you\ncan code it up\nthat's why i don't like this problem\nbecause it's simple if you\nif you've solved it before so this\nalgorithm relies on the fact that the\nintersection point like the first\nintersection between the two pointers\nthe distance between this point and the\nbeginning of the cycle which in this\ncase\nis one right is always going to be the\nsame as the starting point\ndistance from the cycle from the start\nof the cycle that's also\none right since we know that's the case\nthat's how we can take two slow pointers\nstart one here start one here and then\nkeep shifting until they intersect\nthen we get the result but why is it the\ncase that the distance between this\nis the same as the distance between this\nlooking at this bigger example why is it\nthat\nthe distance between the start and to\nthe start of the cycle\nis always going to be the same between\nthe intersection and the start of the\ncycle why is that the case well let's\njust draw out a few\ndistances let's say the distance this\nis p right basically p is the number of\nprevious nodes we have before the actual\nstart of the cycle\nand let's just say you know arbitrarily\nthis is this the\nintersection point between the two\npoints right and we don't know that this\nis going to be the same so let's just\nlabel it\nx for noun let's not label it p so\nbecause we don't know for sure that it's\ngoing to be the same\nlet's label it x this is our unknown and\nthen\nthe remaining portion of the cycle\nis going to be c which is the length of\nthe cycle right in this case it's 5\nminus x right because the total cycle\nis is 5 which is c and this this x\nportion makes up the remaining portion\nof the cycle that's why the\nthis part is c minus x so we know that\nthe slow pointer is going to start at\nthe beginning it's going to traverse\nthis p\nportion and then it's going to traverse\nthe c minus x portion and it's going to\nland\nat the intersection point right now we\nknow\nthat the fast pointer is going to do\nmore than that it's going to of course\ndo this p portion\nonce then it's going to do a complete\nloop right because remember the fast\npointer is going to\nout loop the slow pointer and it's going\nto overlap the slow pointer so it's\ngoing to have to complete\na full at least one full loop\nand then once it does a full loop it's\ngoing to be back here\nand then it's going to traverse this c\nminus x\nportion to get to the intersection point\nright we don't know where the\nintersection is\nobviously i drew it over here but it\ncould be anywhere so let's\nwrite that mathematical equation out so\nwe know that\ntwo times the number of iterations the\nslow pointer does is\nequal to the number of iterations the\nfast pointer does right how many\nspaces it moves versus how many spaces\nthe slow pointer moves of course\nthe fast one is twice as fast that's why\nwe have to multiply the slow one by two\nto make it equal to this one and how\nmany\niterations did we say that the fast one\ndoes it's going to do p\nplus c x right to get to this position\nand then it's going to do another\ncomplete\ncycle starting from here to get back to\nthis position right\nso the fast pointer is going to be p\nplus c minus x\nplus c again so more simplified it's\ngoing to be\np plus 2c minus x\nthe the slope pointer is just going to\ndo p and then it's\njust going to do c minus x so we'll have\na 2 on the outside\np plus c minus\nx so i'm going to take this equation and\nsimplify it over here to the right\nso once we simplify it a little bit\nwe're going to get 2p\nplus 2c minus 2x which is\nequal to p plus 2c\nminus x and then this is the part where\nyou can start doing a little bit of\nalgebra so we can cross out the 2c from\nboth sides of the equation we can cross\nout one x\nfrom each side of the equation and we\ncan cross out one p\nfrom each side of the equation once we\ndo that algebra we're left with the\nequation and sorry that it's getting a\nlittle bit messy we're left with a\nsingle p\nand a single negative x so we get p\nminus x\nis equal to notice how we crossed out\neverything on the right side so we got p\nminus x is equal to zero when we\nrearrange that we get\np is equal to zero what did we just\nprove we just proved that the\npre-portion of the cycle is always equal\nto\nthis right so that's how we know\nonce we have a pointer over here then we\ncan set another slow pointer over here\nkeep iterating them by one and for sure\nwhen they\nmeet they're going to meet at the inner\nat the start\nof the cycle they're always going to\nmeet at this position so i hope this\nexplains a little bit of the intuition\nand a little bit of how you know this is\nvery rigorous this is a proof this is\nalways going to work\nand now you know why it's always going\nto work but the code is actually really\nsimple\nnow one last thing i didn't mention\nbefore we dive into the code is that\nnotice how this p\nthis pre-portion could be really long\nit could be even longer than the entire\nlength of the cycle so how would that\nupdate our math would our math still\nwork out in that case\nand i didn't include this in the math\nbecause i don't want to over complicate\nit too much\nbut yes the math would work instead of\nhaving\n2c over here we would have an n over\nhere\nand the math would end up still working\nout basically we would always start back\nat the beginning here\nwe traverse this many nodes and then\nfrom here\nbasically instead of just traveling this\nsmall distance it could be possible that\nwe would have to do multiple\nloops you know because if this distance\nwas really long\nlonger than the length of this loop we\nwould have to do multiple loops but\nafter all of that the remainder would\nstill be\nthis portion left so we would still end\nup getting to this position\nthe enter the start of the loop okay now\nwe can finally get into the code\nso remember we're gonna be starting at\nphase one of this algorithm we're gonna\nhave two pointers fast and slow they're\nalways gonna start at zero remember\nbecause we know\nzero is not a part of the cycle that's\nfor sure\nand we're gonna keep iterating through\nthese loops i think there's an easier\nway to write this code but i'm lazy so\njust while true\nwe're going to and we start out with\nwhile true because we want to keep going\nuntil they intersect but notice how they\nalready intersect at the beginning\nso we're going to update slow so\nbasically slow is going to be\nset to whatever it points at so nums of\nslow right and then fast is going to be\nthe opposite or the same thing numbs of\nfast but remember\nwe're advancing fast twice and so we can\njust do this and of course\nfast and slow are always going to be\ninbounds right they're never going to\npoint out of bounds we know that for\nsure based on the restrictions that\nwe're given\nand if slow is equal to fast that's when\nwe can break\nout of the loop if they're not equal\nthen we're not going to break this is\nbasically a do while loop\nbut i don't think you can do that in\npython so once we've done this\nthat's how we know okay fast and slow\nintersected here\nso now we're going to create a second\nslow pointer slow 2\nwe're going to set it to the beginning\nright back at index 0\nand now we're going to keep incrementing\nthis slow pointer and the first slow\npointer until they intersect so this is\nphase two of the algorithm while true\nadvance the slow pointer by one\nand advance the second slow pointer by\none as well notice how trivial this code\nis the hard part is just figuring it out\nso when we're going to keep going until\nthey intersect so\nif these were equal then we can break\nout\nof this loop and then return\nthe slow pointer right we can return\neither of them slow one or slow two\nindex that they're at right slow slow\none and slow two are always an index and\nthe index that they're at\nis the duplicate number because we have\nmultiple values pointing to the same\nvalue that's the duplicate we can\nactually take this and return it here\nso i'm just going to go ahead and do\nthat and this is the entire solution\nokay i don't know what i was thinking i\ndon't know why i put fast on the outside\nthis is nums\nnums of fast which is a number which is\na different index and then we're going\nto use that same index again\nin the nums array that's how we're\nbasically advancing fast by two we could\nobviously write it in different lines of\ncode but i'm just gonna leave it as it\nis just because it's a little bit neater\nand also i don't i don't really know\nwhat i'm thinking but the slow\nthe second slow pointer also needs to be\nadvanced i don't know why i called it\nslow one but that is the entire code\nand then once they finally meet we are\ngoing to be returning that index\nand as you can see the solution does\nwork it's in a linear time solution\nwe definitely didn't need to use any\nextra space we didn't need to modify the\ninput array\nthis is the floyd's algorithm with a\nfast and slow pointer\nbeginning of a cycle detection so i hope\nthat this was helpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully see you pretty soon\n"
    },
    {
        "Name": "LRU Cache",
        "NcLink": "lru-cache/",
        "Pattern": "Linked List",
        "Description": "Implement the [Least Recently Used (LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU) cache class `LRUCache`. The class should support the following operations\n\n* `LRUCache(int capacity)` Initialize the LRU cache of size `capacity`.\n* `int get(int key)` Return the value cooresponding to the `key` if the `key` exists, otherwise return `-1`.\n* `void put(int key, int value)` Update the `value` of the `key` if the `key` exists. Otherwise, add the `key`-`value` pair to the cache. If the introduction of the new pair causes the cache to exceed its capacity, remove the least recently used key.\n\nA key is considered used if a `get` or a `put` operation is called on it.\n\nEnsure that `get` and `put` each run in $O(1)$ average time complexity.\n\n**Example 1:**\n\n```java\nInput:\n[\"LRUCache\", [2], \"put\", [1, 10],  \"get\", [1], \"put\", [2, 20], \"put\", [3, 30], \"get\", [2], \"get\", [1]]\n\nOutput:\n[null, null, 10, null, null, 20, -1]\n\nExplanation:\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 10);  // cache: {1=10}\nlRUCache.get(1);      // return 10\nlRUCache.put(2, 20);  // cache: {1=10, 2=20}\nlRUCache.put(3, 30);  // cache: {2=20, 3=30}, key=1 was evicted\nlRUCache.get(2);      // returns 20 \nlRUCache.get(1);      // return -1 (not found)\n```\n\n**Constraints:**\n* `1 <= capacity <= 100`\n* `0 <= key <= 1000`\n* `0 <= value <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "7ABFKPK2hD4",
        "PythonSolution": "class Node:\n    def __init__(self, key, val):\n        self.key, self.val = key, val\n        self.prev = self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}  # map key to node\n\n        self.left, self.right = Node(0, 0), Node(0, 0)\n        self.left.next, self.right.prev = self.right, self.left\n\n    def remove(self, node):\n        prev, nxt = node.prev, node.next\n        prev.next, nxt.prev = nxt, prev\n\n    def insert(self, node):\n        prev, nxt = self.right.prev, self.right\n        prev.next = nxt.prev = node\n        node.next, node.prev = nxt, prev\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) > self.cap:\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today\nlet's take a look at a really popular\ninterview question lru cash\nit's even asked by twitch tv it's one of\ntheir most popular interview questions\nand also don't forget to like the video\nit supports the channel\na lot so this is definitely more of a\ndesign problem than an actual\nalgorithms problem so we have some kind\nof cache\nthat's going to store values it has a\ncapacity so it's fixed\nsize and we want to be able to get\nvalues from this cache based on a\nkey value if that key value exists\nthen we'll return the value that it\ncorresponds to if it doesn't exist the\ndefault value we want to return is\nnegative one\nand if we're getting values we also need\nto be able to put values into the\ncache we're putting them in based on key\nvalue pairs\nand there's a lot of edge cases and they\nexplain a bit of them to us\nif the key already exists in the cache\nthen\nwe just want to update the value if it\ndoesn't already exist then we're\ninserting it for the first time so we\ncan put that key value pair\ninto the cache and remember this does\nhave a fixed size capacity\nso if we ever exceed the capacity\nthen we have to evict the least recently\nused\nso that's why this is called the lru\ncash problem\nand it also makes sense right if there's\na key that we're not really using\nthen that's the one that we're going to\ntake out of the cache\nand this is actually pretty similar to\nhow browsers work\nso for example if you're using chrome\nand you know\nweb browsers have caches if there are\nvalues that we're not really using in\nthose\nin that cache then of course we can\nremove them let's also try to solve this\nthe most efficient way which is each of\nthese operations get\nand put are going to be constant time\noperations and it's going to be kind of\ntricky but\nit's definitely possible so let's just\nlook at the first example so\nthe input is two so that's something\nthat we need to\nkind of remember right the capacity is\ntwo in this case and the next operation\nis put so we're putting a\npair of one one key one value one\nand we're going to keep these kind of in\norder right because\nwe want to remove the least recently\nused so we got to kind of remember\nin what order are we adding these values\nin the next one\nis another put operation and we're\nputting 2 2.\nof course for these first three\noperations we're not really returning\nanything\nso next we're actually doing a get\noperation\nand we want to get the value that has a\nkey\nof one and remember we're trying to do\nthis as\nfast as possible we're trying to do each\noperation\nin constant time so how can we know\ninstantly what the value is\nwhen the key is one well the easiest way\nto do that would be with a hashmap right\nso we're going to use a hashmap to\ninstantly look up the value of every key\nwe can of course do this in constant\ntime and we know that\nwe the size of this hash map doesn't\nneed to exceed our capacity so\nwe can have only two values here right\nso for the key value we can use the same\nvalue\nthat we use for each of our nodes and we\ncould\nand for the value we could also do the\nsame thing we could use the same\nvalue that we use in our nodes but i'm\ngoing to show you why it's going to be a\nlittle bit\nbetter for us instead to have the value\nbe a\npointer to the node itself and we can do\nthe same thing with the second node\nthat we inserted as well so for key\nvalue 2\nwe're going to point at this node so now\nfinally when we call this get and we ask\nfor the key\n1 we're going to return the value 1\nthat's over here\nwhich is exactly what the output tells\nus is correct\nso since we just used the get operation\nto get this one we went to our key\nthen we found this value and then we\nreturned that value\nthat makes this the most recently used\nvalue and this is the least recently\nused value now\nso i'm going to keep track of the most\nrecent and least recent\nby having a left and right\npointers right so this left side is\ngoing to be\nthe least recently used and the right\nover here is going to be the most recent\nso therefore we're basically going to be\nswapping\nthese two nodes right and so this part\nthis portion of the problem\nis starting to to keep the ordering of\nthese\nit looks like we're going to need a\nlinked list and\nnot only a linked list but a double\nlinked list because remember we can\neasily look up where these values are\nbut if we want to also reorder them\nquickly\nby by for example every time we use a\nget operation we want to take this\nvalue and then move it over here because\nit was the most\nrecent and so now we're going to reorder\nthe two nodes so now this is the\nleast recently used and this is the most\nrecently used\nand since this is a doubly linked list\nwe need\nthe pointers to be connected of course\nthe the hashmap won't really need to be\nupdated because these are pointers\nthey're already going to be\npointing to the correct ones and i'm not\ngoing to show that and now we can get to\nthe most\ninteresting operation the third put so\nwe're putting a third value\nkey value 3 3 and since\n3 is greater than our capacity\nof 2 then we're going to have to remove\nthe least recently used value and\nconvenient for us\nwe know exactly what that value is so\nfirst we're going to end up updating\nthese pointers\nto make the least recently used 1 1\nand get rid of this and of course\nwe want to replace that too since we\nknow it's the least recently used\nwe want to replace it with the new key 3\nand now we also want to update that\npointer we want it to point at the new\nnode\nand since the new node 3 3 is the most\nrecent we're\ngoing to put it over here 3 3\nand the pointer is going to point here\nthis pointer is going to point here and\nthere's going to be a double\nlink between them so this is basically\nthe main idea we're going to keep track\nof a capacity\nwe're going to have a double linked list\nwe're going to have a hash map\nwhere the key of the hashmap is going to\nbe the same key that we get from the\ninput and the value is going to be a\npointer\nto the nodes and each node is going to\nlook something like this\nand it's going to have two pointers\nremember so it's going to have a\nprevious pointer\nand a next pointer and don't forget\nabout\nthis right and this left these\nare also going to be nodes because\nwe want to have pointers we want to be\nable to instantly know what's the least\nrecently used and what's the most\nrecently used so these are going to be\ndummy nodes pretty much\nso getting into the code remember we're\ngoing to need a\nnode so before we even write this lru\ncache class\nlet's make another class for that node\nthat we're going to use\nand remember each node is going to have\na key value pair\nso we're going to get those we're going\nand we're also going to have two\npointers one for the previous node and\none for the next node and they're both\ngoing to initially be set to null\nnow when we actually get into the lru\nclass we know that the capacity\nneeds to be stored because we want to\nknow if we ever go over that capacity\nwe also need a hashmap and i'm going to\ncall that our cache\nand remember this is going to map map\nthe key to nodes\nand before we even have any values in\nour cache we\nwant to have a couple dummy pointers a\ncouple dummy nodes\nwhich tell us what are the most recent\nand least recent\nuh values that we added so we can just\ninitialize these to zero\nfor the default values so zero zero\nand initially we want these nodes to be\nconnected to each other\nbecause if we're inserting a if we're\nputting a new node we want to put\nit in the middle between left and right\nand we can do that with some pointer\nstuff\nso left dot next is going to be right\nand right dot previous is going to be\nleft and remember left is going to help\nus\nfind the least recently used and\nright is going to be most recent\nso now let's start with our get function\nbecause it's mostly straightforward\nif the key exists so if the key is\nin our cache then we can return\nthat value right so we can return\nself dot cash of key\nnow this tells us the node remember\nbecause\neach key is mapped to a node so to get\nthe value\nwe can just do dot val and\nof course if it doesn't exist they\nwanted us to just return\nnegative one now the only thing we're\nforgetting with this\nget is that every time we get a\na value we want to update it to the most\nrecent so to help us with this part i'm\nactually going to write a couple helper\nfunctions\nso i'm going to write i'm going to write\na remove\nand insert helper function and these\nhelper functions are going to be applied\nto our linked list so we're going to\npass in\nthe node that we want to remove\nfrom our our doubly linked list and i'm\nalso\ngoing to write a function to insert\ninto our linked list and when we insert\nwe're going to insert at\nright and the remove is just going to\nremove\nfrom the list so\nthese are basically going to be pointer\nfunctions we're going to be manipulating\nsome pointers from our left from our\nright and doing some stuff so i'm not\neven going to worry about that\ni'd all i know is that we have a helper\nfunction that can remove\nany node from our list and a helper\nfunction that can\ninsert any node at the rightmost\nposition of our linked list\nso since we're getting what we want to\ndo to our list\nis take this node\nself dot cache of key and remove it from\nour list\nand after we remove it then we want to\nreinsert it\nat the right most position so we can\nand looking at this get isn't so bad as\nlong as we fill out\nthese two helper functions for us so now\nwhen we actually look at our put\nfunction\nlet's remember that if we have a\nkey that's already in our cache\nthat means that a node already exists\nin our list with that same key value\nso before we can insert this new key\nvalue pair\nwe want to remove from our\nlist so we can get that node by\ngetting our cache and using the key\nvalue\nso these helper functions are definitely\ncoming in handy for us\nso now we can create a new node with\nthis key value pair so node\nkey value and\nso now our hashmap has a pointer to this\nnode\nbut remember that's not enough we also\nhave a doubly linked list\nso we need to take this node and insert\nit into\nour list so insert\nand just pass in the node which is\ncache of the key value so the node is\nstored here and we pass that node into\nour insert function\nokay so we just inserted a new value but\nremember\nwe have a capacity to worry about so\nevery time we\ninsert a value we gotta check did does\nthe\nlength of our cache now exceed\nthe capacity if it does\nthis is the part where we're gonna we're\ngonna remove\nand delete or evict\nthe mo the least recently used\nso we're going to remove it from the\nlist\nthe linked list and delete the lru\nfrom the cache or\nthe hashmap so how do we actually find\nthe node for the lru well this is why\nwe have our left and right pointers\nremember the left pointer is all the way\nat the left and it's going to\ntell us what the least recently used was\nso left\nleft dot next is always going to be\nthe least recently used and so first\nwe're going to remove it from our linked\nlist\nby just passing in the node and we're\nalso going to delete it from\nour hashmap so self.cache\nand we want the key of this node which\nis actually stored in the node itself\nthis is why we didn't only store the the\nvalue we also store the key in our node\nclass\nso we don't have to return anything\ninput but we\ndo now have to fill out these two helper\nfunctions\nremove and insert so if you have\nthree nodes and you want to remove the\nmiddle node\nwhat do you do well you take this\npointer\nand move it over here and you take\nthis pointer and move it over here\nso this stuff is no longer relevant\nand we have removed the middle node\nthis is going to be referred to as our\nprevious node\nthis is referred to as our next node\nso when we're writing this function node\nis going to be the middle node so we\nwant to get the previous\nand next nodes of node so we can just\nget the pointer so node.previous\nnode.next\nall we want to do is say that previous\ndot\nnext should be updated and next\ndot previous should be updated these are\nthe two pointers\nof the next and previous nodes so\nprevious.next\nnext stop previous should be previous\nso now node is no longer in between\nprevious and next the last thing we need\nto do is\nfill out our insert function which what\nwe want it to do\nis insert a node at the rightmost\nposition\nright before our right pointer\nso let's say this is our right pointer\nwe want to insert right here and this\nis going to be our previous pointer so\nwhen we have our\nnew node that we're trying to insert\nwhat we want to do is take this pointer\nand reassign it to that\nthis pointer and reassign it\nover here and we also want this node to\nbe connected\nto its neighbors so we're going to have\nthe next pointer over here and the\nprevious pointer\nto be here so in this case\nour previous and next pointers we can\nget\nby using our rightmost pointer\nso self.write.previous\nand self.write now we want both\nprevious and next to point to node so we\ncan\ndo that like this previous dot next\nis going to be equal to next dot\nprevious\nwhich is going to be equal to node\nthey're both\npointing at node node has been inserted\nin the middle of them\nand node.next\nand node.previous also need to be\nassigned\nto next and\nprevious so this is quite a lot of code\nabout\n44 lines with some space and comments in\nbetween but\nthis is how you get the most optimal\nsolution\nfor this problem and of course i had a\nbug so\ni misspelled something i'm really hoping\nthat's the only bug here because i do\nnot want to search for a bug in these\nlines of code\nokay so we got it to pass so i hope this\nwas helpful\nif you enjoyed please like and subscribe\n"
    },
    {
        "Name": "Merge K Sorted Lists",
        "NcLink": "merge-k-sorted-linked-lists/",
        "Pattern": "Linked List",
        "Description": "You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.\n\nReturn the **sorted** linked list that is the result of merging all of the individual linked lists.\n\n**Example 1:**\n\n```java\nInput: lists = [[1,2,4],[1,3,5],[3,6]]\n\nOutput: [1,1,2,3,3,4,5,6]\n```\n\n**Example 2:**\n\n```java\nInput: lists = []\n\nOutput: []\n```\n\n**Example 3:**\n\n```java\nInput: lists = [[]]\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= lists.length <= 1000`\n* `0 <= lists[i].length <= 100`\n* `-1000 <= lists[i][j] <= 1000`\n",
        "Difficulty": "Hard",
        "Video": "q5a5OiGbT6Q",
        "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists or len(lists) == 0:\n            return None\n\n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if (i + 1) < len(lists) else None\n                mergedLists.append(self.mergeList(l1, l2))\n            lists = mergedLists\n        return lists[0]\n\n    def mergeList(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next\n",
        "Transcript": "hey guys it's me neat code again solving\nanother leak code problem this time\nwe're doing merge\nk sorted linked list before we've done\nmerging two sorted linked list\nwhich is i which is an easy problem i\nthink it was\nleak code 21 so if you haven't solved\nthat one yet i would recommend doing so\nbecause it's basically\nwe're basically extending that problem\nso\nthis problem is actually easier than you\nmight think for a leak code hard problem\nthere's some really basic ideas that we\ncan use\nto solve it efficiently so to illustrate\nthat i have\nfour single node linked lists right so\neach of these link lists only has one\nnode right so five for example\nso basically how can we merge them in an\nefficient way let me show you\nuh like the general idea so first we can\nmerge these two five and seven right so\nthe first two nodes\nwhen we merge them we know that the five\nis smaller than the seven so we put the\nfive\nfirst so now we have a partially so uh\na partial linked list so now we want to\nget the next value which is 3 and we\nwant to merge it\ninto this linked list again\nthe 3 is smaller than the beginning of\nthe linked list which is the 5 over here\nright\nso we can just put the three at the\nbeginning\nand next we only have one value left so\nwe want to merge\nthis eight into our linked list and so\nwhat's the general idea of how to do\nthat well we're gonna have to\ntake our eight right look at look at\nthis three right well it's bigger than\nthe three so we're not putting it\nthere is it bigger than the five yep is\nit bigger than the seven\nyep so we're going to put it at the end\nso notice how we had to iterate through\nevery single node to find where to put\n8 that's kind of a problem but we did\nfind the output\nthe output is going to be the 3 5 7 and\n8.\nso doing it this way is not the most\nefficient way to do it because\nnotice for each node or linked list\nwe're going to be merging it into our\ncurrent output or our current\nyou know result we're going to be\nmerging it that's not going to be super\nefficient we have k\nlists right and the total number of\nnodes we have is\nn so every time we're merging a list\nwe're gonna potentially have to iterate\nthrough every single node we have so far\nwhich could be big o of n\nso the overall time complexity is gonna\nbe k times\nn now i bet you already know where i'm\ngoing with the solution now because the\npicture\nreally makes it obvious why would we\nmerge it like\nthis when we're\nby doing that we're really repeating a\nlot of work that's really not the most\nefficient way to do it if you know\nthe algorithm merge sort you know that\nthere's a better way to do this\nso and it's a really basic idea right\nlike\nwhy merge it that way when we can merge\nthese two\nand merge these two eliminate a bit of\nthat repeated work\nright and then when we have that\nlike the five and the seven now\nusing this we're going to merge these\ntwo together\nas well and and assuming you know the\nalgorithm to merge two sorted linked\nlists\nyou we will get the standard we'll get\nthe same solution right\nbut let's analyze what exactly is going\non here when we did this\nfirst step right over here when we\nwent from four linked lists right one\ntwo three\nfour and then we went to just two of\nthem remaining right\nwe did have to iterate we did have to go\nthrough every single node so this was\na o of n operation right so it's still\nnot cheap it's o of n but the question\nis\nhow many times do we have to do this in\nthis case we only have to do it two\ntimes right\nso we did the same thing we took our two\nlinked lists down here\nand merged them into our result\nand again we had to potentially iterate\nthrough\nevery single one of our four nodes so it\nwas an o of\nn operation but basically what we're\ndoing is we're taking our lists\nand dividing them by two every time so\nhow many times can we take\nthe k lists and divide them by two well\nit's going to be\nlog k this is the part where we\nspeed up our algorithm it's log k it's\nthe log k\nis the number of times we're repeating\nthis o of\nn step so in this case with this\nalgorithm\nthe total time complexity is going to be\nn\nlog k\nand that's a lot better than the brute\nforce which was\nn times k right so this is a lot better\nokay so now let's actually get into the\ncode\nuh remember that we have to understand\nhow to merge\ntwo sorted linked lists so i'm just\ngonna put\nthat function here right now so we'll\nhave list one and list two as parameters\nand we'll return\nthe output list i'm not even going to do\nthis yet because we know\nthis is not the most important part of\nthe algorithm that's the leak code easy\nportion\nwe want to do the real part of the\nproblem which is merging\nk linked list so the first thing i'm\ngoing to handle is the annoying edge\ncases where\nmaybe the list is null or\nin that case we can just return an empty\nlinked list\nand now to get to the actual problem so\nwe're basically going to be taking\npairs of linked lists and merging them\neach time\nand we're going to keep doing this until\nthere's only one\nlinked list remaining and that's going\nto be our output so\nwhile the length of lists is greater\nthan one we're going to keep\nreducing it right we're going to keep\ncutting it in half\nso as we merge these lists i'm going to\nput them\nin a new list called merged list\nso now we want to iterate through each\nand each time we're going to we know we\nwant to do\npairs of linked lists so my incrementer\nis going to be 2.\nso list 1 is just going to be\nat index i now list 2\nmight be out of bounds right because if\nwe have an\nodd number of lists and we're\nincrementing by 2 each time\nlist 2 could be null so we have to check\nfor that we'll say it's lists of i\nplus 1 the adjacent list but we want to\nmake sure\nso if i plus 1 is in bounds so we'll\ncheck\ni plus 1 is less than the length\nof the list then we'll do that otherwise\nwe're going to say it's none if it's\nnone that's still\nokay right because merging one non-null\nlinked list and one null linked list is\nperfectly fine we can still do that\ni want to take these two lists merge\nthem together\nwith my helper function which i haven't\nand i want to take this and append it to\nour merged lists\nvariable over here where we are storing\nthe lists after we merge them\nthis is the way i like to do it but i've\nseen people do it a different way\nbut now so we want to update our lists\nvariable because that's where we're\nuh you know actually getting our lists\nfrom so i'm going to update it with\nmerged lists so merge list is basically\nlike a temporary variable\nand of course we're going to keep doing\nthat until there's only one list left\nand then we're going to return that list\nso list\nof zero so see that really wasn't\ntoo bad i mean you might uh kind of\nstruggle with a little bit of the edge\ncases that's perfectly fine but once you\nget the idea you see it's really not\nthat bad now we've reduced it to\nan easy problem we know how to merge two\nlinked lists i've done it before in a\nvideo but i'll\ntype it out again really quickly and\nmaybe if you're lucky your interviewer\nwon't even want you to\nmerge the list anyway but\nlet me go ahead and show off and try to\nspeedrun it and hopefully not have a bug\nand i'm speedrunning it i'm showing off\nbut i literally solved this problem\nright before i recorded this video so\ni'm br i'm basically typing basically\noff of memory so\nand i'm a super slow typer once you guys\nhonestly once you guys practice enough\nlead code you'll probably be 10 times\nokay so let's dummy.\nokay and once again let me prove to\nand i do so okay so it was pretty small\nuh merged lists dot append\nwe're appending to the output or\nappending to this list\nand hopefully that is good enough okay\nof course i get messed up with the typos\nmerged list i guess the confusing part\nwas that this variable name is\npretty similar to this function name\nprobably should have done it a little\ndifferently\nokay but it does work so hopefully\nyou get the general idea it's not too\nbad of a problem\nthere are actually a lot of ways to\nsolve it even a heap solution\nbut i think kind of sticking with this\nis fine\nbut thank you so much for watching\nhopefully this was helpful if you have\nany tips and tricks you can feel free to\nshare them with me and feel free to\nsuggest\nany other problems that you would like\nme to solve and i'll see you\n"
    },
    {
        "Name": "Reverse Nodes In K Group",
        "NcLink": "reverse-nodes-in-k-group/",
        "Pattern": "Linked List",
        "Description": "You are given the head of a singly linked list `head` and a positive integer `k`.\n\nYou must reverse the first `k` nodes in the linked list, and then reverse the next `k` nodes, and so on. If there are fewer than `k` nodes left, leave the nodes as they are.\n\nReturn the modified list after reversing the nodes in each group of `k`.\n\nYou are only allowed to modify the nodes' `next` pointers, not the values of the nodes.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/67cf2fff-f20a-4558-6091-c3e857f56e00/public)\n\n```java\nInput: head = [1,2,3,4,5,6], k = 3\n\nOutput: [3,2,1,6,5,4]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/af843e59-df12-4c55-652b-6ddab0a92900/public)\n\n```java\nInput: head = [1,2,3,4,5], k = 3\n\nOutput: [3,2,1,4,5]\n```\n\n**Constraints:**\n* The length of the linked list is `n`.\n* `1 <= k <= n <= 100`\n* `0 <= Node.val <= 100`\n",
        "Difficulty": "Hard",
        "Video": "1UOPsfP85V4",
        "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        groupPrev = dummy\n\n        while True:\n            kth = self.getKth(groupPrev, k)\n            if not kth:\n                break\n            groupNext = kth.next\n\n            prev, curr = kth.next, groupPrev.next\n            while curr != groupNext:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            tmp = groupPrev.next\n            groupPrev.next = kth\n            groupPrev = tmp\n        return dummy.next\n\n    def getKth(self, curr, k):\n        while curr and k > 0:\n            curr = curr.next\n            k -= 1\n        return curr\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today today\nlet's solve reverse nodes\nin a k group now this is a hard problem\nbut it's actually not as hard as you\nmight think\nso we're given one linked list and we\nwant to reverse\nthe nodes of that linked list a at a\ntime\nand then return the output so what do\nthey actually\nmean when they say k at a time so\nin the example that we're going to look\nat let's say k is 2.\nwe basically take this input right we\nsee there's\nfive nodes we want to look at each\ngroup of size k so each group\nof size two this is one group this is\none group\nand the last group doesn't even have k\nelements and what we want to do to each\ngroup\nso let's look at the first group we just\nwant to reverse it\nso now this has been reversed and we\nalso want it to still be a part of this\nentire linked list so what we have to do\nis for this\none we have to set its next pointer over\nhere\nand in the output you can see that\nthis group is reversed now we do the\nsame thing with the\nsecond group so four's next is actually\ngoing to be\nthree now we've reversed this and then\nthe output\nit's also reversed now they tell us if\nwe have a special group\nright like the last group doesn't even\nhave k elements\nso if it's not a multiple of k then it\nshould just remain\nas it is so we really don't have to make\nany changes to this\nit remains the exact same now\none thing to notice is reversing the\ngroups\nis pretty easy but we need to do a\nlittle more than just\nthat right see one's next pointer is\ninitially at two\nbut at the end it's pointing at four\nso really we have to make this jump\nso that's where the difficulty comes\nfrom and that's what i'm going to\nexplain once we've reversed these groups\nthen we actually have to put them\ntogether\nso like most linked list problems i'm\njust going to tell you from the start\nthis time that we\nare going to need a dummy node because\nwe're potentially\nmodifying the head of the list right\nlike\nfirst this is the head but at the end\nthis is going to be the head i don't\nwant to deal with edge cases and stuff\nso just having a dummy node here helps\nus a lot\nso we have k equals two\ni wanna reverse the first group how do i\ndo that\nlet's say we start here all i have to do\nis\ncount by k so one\ntwo so this is the k-th\nnode so now starting from here\nwe're gonna start reversing so the next\npointer\nof one is gonna be reversed but\nthis is the dummy node so i don't really\ncare about it\nso i'm actually gonna set this equal\nlet's say to null for now\nnext i'm gonna move to the next node\nwhich happens to be our kth\nnode i'm going to say its next pointer\nis also going to be reversed now it's\nset\nto 1 right the previous node\nnow we move to the next node but we\nknow we just passed our kth node so\nwe're not reversing this yet we're going\nto reverse it\nwith its own group right now we're only\nreversing\nthis group so we're finished so now if\nyou look at what we just did we\ntook this portion reversed that group\nright now we have this\nand we didn't really touch this so it\nstayed the same\nbut look what we just did we cut our\nlinked list\nin half it's not even connected anymore\nwe reversed the first group which is\nwhat we wanted\nbut we didn't want to split them so\ninstead of setting\nthis one to null we can set it\nto what the last what our cond where our\ncondition would\nstop right this is where our condition\nis going to stop so the node\nright after k is where we're going to\nset\nthe next pointer of this\nalso we don't want to forget that our\nour dummy node over here should point at\nthe\nfirst node so great we've done\nthe first group now we want to move to\nthe next group\nso don't forget k equals 2 so\nthis is our first node this is our\nsecond node\nso this happens to be the kth node so\nagain\nwe're going to take this pointer and\nreverse it\nand in the first example i showed you\nthat it's going to be set\nto null but really we know\nit's going to be set to k dot\nnext right k dot next we know that this\nis\nk so k dot next is over here\nso after i cross out the next pointer\ni'm going to move it\nover here next we want to reverse\nthe link of 4 so we can remove this\npointer and\nreverse it we know that this is the\nprevious\nnode and the last thing remember don't\nforget\nbefore we took our dummy pointer and\nthen set it\nto two instead of one but\nright now we're gonna take one's next\npointer\nand instead set it to four\nrather than three because we're\nreversing\nthis group so one dot next is gonna be\nat four so these pointers can get\ncomplicated and can definitely get\nmessy even when you're looking at a\npicture so let's redraw it\nso this is what our linked list looks\nlike\nnow we still have our dummy node over\nhere we reversed the first group\nwe reversed the second group let's look\nat the third group\nso we're starting here this is one let's\nget the kth node okay we want the second\nnode we try here\nthis is null right so the kth node\ndoesn't even exist\nso this group is too small so we're\nfinished\nwe don't have to do anything anymore and\nso notice we got\ntwo one four three five\nwhen you go back here that's exactly\nwhat we have in the output\ntwo one four three and five\nso now let's actually look at the code\nwe want a\ndummy node to be initialized\nat the beginning so we're gonna give it\na default value\nzero and the next pointer is gonna be\nset to our head\nof the linked list i'm also gonna have\na pointer i'm gonna call the group\nprevious\nwhich i'm gonna initially set to dummy\nbut the reason we have this\nis if we have a group so if our group\nwas 2 and 3 and we want to reverse it\nthe output would look like this right so\nwe took this group and reversed it to do\nthat we need to have a pointer of one\nnode\nright before the start of our group so\nwe can then say\none dot next is three so we're always\ngoing to save\none node right before our group now\nwe're just gonna start\nlooping i'm just gonna say while true\nbecause i'm lazy\nso we're going to need to get the kth\nnode so we know\nhow long or how big our group is how\nlike what exactly the group is we're\ntrying to reverse so i'm going to write\na helper function to do that\njust called get k and we're just going\nto pass\nin two parameters the current node and\nthe what the value k\nis so starting at cur we're gonna\nincrement\nwe're gonna uh we're gonna shift k times\nand then return that\nkth node so while cur is not at the end\nand\nk is greater than zero we're gonna\nupdate current\nand decrement k then at the end we can\nreturn\nthe kth node that we want to so now i'm\ngonna call that helper function\nget k and what's the start that we're\ngoing to pass in we're going to pass in\nthe group\nprevious because the group previous is\nand let's store this in case but\nwhat if the kth node doesn't even exist\nwhat does that\nmean that means we've gotten to the last\ngroup\nin our linked list and it's not big\nenough\nfor us to reverse it so we can stop then\nso we can say\nif not k if it's null then terminate so\nbreak out of the loop so that's why we\nhave a true here\nand that's going to be the condition\nthat breaks us out so\nsimilar to how we have we always keep\ntrack of one node before the start of\nour group\nlet's keep track of a node right after\nour group so if this is the kth\nnode let's just get kth dot\nnext and store that in group dot next\nso one node right after our group so now\nwe can start\nactually reversing right reversing\nthe group and we can use two pointers to\ndo that if you've solved\nthe delete code easy problem reversal\nlinked list you probably know how to do\nthis\ni'm going to set previous to null and\ncurrent\ngroup previous dot next\nbecause this is the first node in our\ngroup but there's just one problem with\nthis remember\nif we have previous initially set to\nnull\nwe're gonna end up splitting our linked\nlists and we don't want to have multiple\nlinked lists so\ninstead of this being null in reality\nit's going to be kth dot next\nso the rest of this is basically just\nreverse a linked list so\nwhile current does not reach the end in\nthis case the\nend is the end is group dot next and now\nwe're just reversing so i'm going to put\nit in a temporary variable\ncurrent.next we're going to update\ncurrent.next\nset it to previous previous is going to\nbe set to\ncurrent and then current is going to be\nshifted by 1 which is\nstored in our temporary variable so\nremember how\nkth was the last node in our group now\nwe want it to be the first node in our\ngroup\nand what we can do is say group\nprevious so one node before the start of\nour group\ndot next is now going to be\nkth so what we're doing is putting kth\nat the beginning of this group\nbut we also want to update group\nprevious for the next iteration of our\nloop right when we come back around\nwe want this node to be where it should\nbe we want this pointer to be where it\nshould be\nand to do that what we can do is\nactually have a and i have another\ntemporary variable so\nin that we're going to store group\nprevious\ndot next before we end up updating it\nand what this current what this\ninitially stores\nis the first node in our group remember\nkth was the last node in our group this\nis the first node in our group\nand so we want to set this equal to that\nbecause this started as the first node\nin our group\nbut now it's going to be the last node\nand that's\nwhat we want this to be set to so i\nthink probably this is the most\ncomplicated part of the problem and\npointers in general are really\nkind of annoying even drawing a picture\nis kind of annoying because you have to\ncross out a bunch of pointers\nbut right now all we need to do is\nreturn\nthe new head of the linked list which is\ngoing to be\ndummy.next so this is the final code so\nit does work\npretty well if this was helpful please\nlike and subscribe it supports the\nchannel a lot\n"
    },
    {
        "Name": "Invert Binary Tree",
        "NcLink": "invert-a-binary-tree/",
        "Pattern": "Trees",
        "Description": "You are given the root of a binary tree `root`. Invert the binary tree and return its root.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ac124ee6-207f-41f6-3aaa-dfb35815f200/public)\n\n```java\nInput: root = [1,2,3,4,5,6,7]\n\nOutput: [1,3,2,7,6,5,4]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e39e8d4f-9946-4f99-ee3d-0d4df08d4d00/public)\n\n```java\nInput: root = [3,2,1]\n\nOutput: [3,1,2]\n```\n\n**Example 3:**\n\n```java\nInput: root = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The number of nodes in the tree <= 100`.\n* `-100 <= Node.val <= 100`\n",
        "Difficulty": "Easy",
        "Video": "OnSn2XEQ4MY",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root: return None\n\n        root.left, root.right = root.right, root.left\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve a pretty easy and popular question\ninvert binary search tree so all they\ntell us to do\nis invert a binary tree and what exactly\ndoes that mean\nso let's say that this is our initial\ntree\nto invert it is basically what you can\ntell\nin the output right so the root stayed\nthe same but you can see it's two\nchildren which were left child two left\nor right child seven\nwere swapped right so seven is now on\nthe other side\ntwo has been moved right so basically we\ntook these\nand then we swapped them and when they\nsay invert the binary tree it's a\nrecursive definition so take a look at\nthis\nsubtree right you can see since we moved\nit to this side that's where it is\nright but notice how even these sub\ntrees\nare are different now right one was\ninitially on the left and three was\ninitially on the right\nbut now three is on the left and one is\non the right\nthe exact same thing happened with this\ntree right it was moved\nover here to the left side but then\nits children were also swapped right so\nnine\nwas moved to the left six to the right\nso when they say\ninvert the binary tree what we're saying\nis\nvisit every single node in the tree\nright\nand every time we visit a node take a\nlook at its\ntwo children and swap the positions\nof the children right so in other words\nif we're given a\ntree look at the root node and take its\nchildren and then swap the positions and\nthen\nrecursively run inver binaries\nor invert tree on the left subtree and\nrun invert on the right subtree so it's\na recursive definition\nso we can solve this problem with\nrecursion we can do\na depth first search whether it's\npre-order or post\norder it doesn't actually matter a depth\nfirst search will\nallow us to solve this problem\nrecursively so this problem would\nprobably be a lot more annoying\nif it were iterative but luckily we can\ndo it recursively so\nwe can first check the base case so if\nthe root is null\nthen we can return null we don't have to\ncontinue\notherwise what we're going to do is swap\nthe children\nso we're going to save the left value\nroot.left in a temporary variable then\nwe're going to\nreplace the root.left value with\nroot.right\nand then we're going to replace the\nroot.right value with the left value\nwhich we know is now\nstored in temp so after we swap the\nnodes\nall we have to do is now recursively\ninvert the\nsubtrees so we can invert the left\nsubtree\nand then we can invert the right subtree\nso by doing self.invert tree what we're\ndoing is making a recursive call to the\nfunction we're inside\nand once we have swapped the roots\nchildren once we have inverted the left\nsubtree and\ninverted the right subtree we know we're\nfinished so then we can return the root\nso there it is this problem is a\nrelatively short code it's a very good\nproblem to kind of understand the basics\nof\ndepth first search and tree problems in\ngeneral and it's actually a pretty\npopular problem\nand if you weren't able to solve this on\nyour first try don't feel too bad take a\nlook at this trivia\nthere was a very good engineer who\nactually failed this problem in their\ngoogle interview\nbut his career still turned out pretty\nfine so i hope this was helpful\nif it was please like and subscribe it\nsupports the channel\na lot and i'll hopefully see you pretty\nsoon\n"
    },
    {
        "Name": "Maximum Depth of Binary Tree",
        "NcLink": "depth-of-binary-tree/",
        "Pattern": "Trees",
        "Description": "Given the `root` of a binary tree, return its **depth**.\n\nThe **depth** of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5ea6da77-7e43-43e0-dd9d-e879ca0b1600/public)\n\n```java\nInput: root = [1,2,3,null,null,4]\n\nOutput: 3\n```\n\n**Example 2:**\n\n```java\nInput: root = []\n\nOutput: 0\n```\n\n**Constraints:**\n* `0 <= The number of nodes in the tree <= 100`.\n* `-100 <= Node.val <= 100`\n",
        "Difficulty": "Easy",
        "Video": "hTM3phVI6YQ",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n# RECURSIVE DFS\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n\n# ITERATIVE DFS\n# class Solution:\n#     def maxDepth(self, root: Optional[TreeNode]) -> int:\n#         stack = [[root, 1]]\n#         res = 0\n\n#         while stack:\n#             node, depth = stack.pop()\n\n#             if node:\n#                 res = max(res, depth)\n#                 stack.append([node.left, depth + 1])\n#                 stack.append([node.right, depth + 1])\n#         return res\n\n\n# BFS\n# class Solution:\n#     def maxDepth(self, root: Optional[TreeNode]) -> int:\n#         q = deque()\n#         if root:\n#             q.append(root)\n\n#         level = 0\n\n#         while q:\n\n#             for i in range(len(q)):\n#                 node = q.popleft()\n#                 if node.left:\n#                     q.append(node.left)\n#                 if node.right:\n#                     q.append(node.right)\n#             level += 1\n#         return level\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve maximum depth of a binary tree\nand the main reason i'm solving this\ntoday is just for the sake of completion\nwe have solved harder tree problems\nbefore\nbut this one is on the blind 75 list so\ni do want to solve this problem\ntoday and this problem actually has\nmultiple ways to solve it so i do think\nit's a good problem to understand of\nlike the fundamentals on uh tree\ntraversals we can do it three different\nways and i'm actually going to show\nthe three different ways there might\neven be more than three but i'm going to\nshow you the three main ways\nbasically recursive depth first search\niterative depth\nfirst search basically depth first\nsearch without using recursion\nand of course another way is going to be\nbreadth first search\nso i'm going to be showing all three\ntoday so the problem is pretty simple\nwe're given a root binary tree and we\nwant to return its maximum depth and the\nmaximum depth is defined as being\nthe longest path from the root\nto one of the no to one of the leaf\nnodes and basically along that path\nwe're counting the number of nodes so in\nthis case you can see we have two paths\nthat are of the same length so from the\nroot down to here\nwe have three nodes from the root down\nto here we have three nodes as well so\nthose are the two leaf nodes we have\nhere\nwe also have a leaf node on the left\nside but clearly we see\nthat there's only two nodes in this path\nso out of all those paths what's the max\nlength of course it's three so you can\nsee that that's what our output is going\nto be in this problem\nso the simplest way to solve this\nproblem is recursive depth first search\nnow\nwhat's the base case we're using\nrecursion so first let's think of the\nbase case obviously if we had just an\nempty tree right like what's what if\nthis was our tree what are we gonna\nreturn of course\nzero right the max depth of an empty\ntree is just zero\nwhat about if we just had one node and\nno\nchildren right okay we'd do this\nrecursively so we'd get to the first\nnode right we'd say okay we at least\nhave\none node then we'd say okay let's just\nfind the max of the left subtree and the\nmax of the\nthe right subtree both of those are\ngonna return zero right so\nonce we get back to the root what are we\ngonna say we're gonna say okay the left\nand right subtree were zero\nso the maximum of the left and right\nsubtree is also zero so what we're going\nto return from the perspective of this\nroot node is just going to be 1\nplus the max 1 plus the max\nof the left and right results basically\nthe max of\nthe left and right subtrees in which\ncase it was both\nzero so of course in this problem we're\ngoing to return one as the max step now\nlet's look at this more general example\nthat they gave us so obviously we're\ngoing to do the same thing we're going\nto get to the root say okay we found\nat least one node\nso the depth is at least one and then\nwe're going to return the max\nof we're going to return the max of\nthe left and right subtrees plus one and\nwhy are we doing it this way well you\ncan\nsee that we found this node but now we\nhave sub problems right we need to know\nwhat's the max path what's the max\ndepth and we'll have to search the left\nsubtree and we'll have to search the\nright subtree so we're not even\nconsidering this node anymore we're\ndoing recursion we're looking at the sub\nproblem what's the max depth of this\nleft subtree well of course it's just a\nnode a single node with no children so\nof course the max depth is going to be\n1.\nsimilarly let's do the right subtree and\nso again this is going to be our\nrecursive case right we have one node\nand from then this node's perspective\nwe're going to run recursion again we're\ngoing to look at the left subtree and\nthe right subtree both of which are\ngoing to return one\nso then of course from this node's\nperspective we're going to return to\nthe max depth of this subtree is 2 the\nmax depth of the left sub tree\nis 1. so now when we get back up here\nwe're saying okay from the perspective\nof this node we're going to return 1\nplus the max of left and right the max\nis clearly 2.\nso from this node's perspective we're\ngoing to return 3 the max depth is 3. so\nlet's code this up recursively\nit's literally just going to be this\nline that i just wrote and the base case\nand since we are traversing the entire\ntree the time complexity is going to be\nbig o\nof n the memory complexity is just going\nto be the height of the tree which also\ncould be worst case big of n if it's a\nnot\nif it's not a balanced binary tree so\nwith recursion we always want to take\ncare of the base case first so if the\nroot\nis null then of course we're just going\nto return 0 that's the max depth\notherwise we're going to return 1\nplus the max of what our dfs of left\nreturns or in this case it's not dfs\nit's actually called max\ndepth and since we're inside of the\nfunction in python you have to\nyou know say self.max depth and then run\nthat\non the left subtree and also run it on\nthe\nright subtree now to make this line\nshorter i could actually store the\nresult of both of these function calls\nin variables but i think this one liner\nis pretty much good enough so we're just\ntaking\nthe result of both of these function\ncalls figuring out what's the max of it\nso what's the max subtree's depth\nof both of the sub trees and then just\nadding one to it because we know that\nthe current node the current root node\nthat we're traversing\nis definitely not null so this\ncalculation will work out let's submit\nit\nand of course i'm showing that i can't\neven solve easy problems so it's not\ncalled\nnode it's actually called root hopefully\nyou were able to catch that\nbut yeah so this is the entire problem\nbut what if your\ninterviewer or what if you just want to\ndo this for learning purposes\nyou want to solve this problem without\nrecursion well there's two ways to do it\niterative depth first search or\niterative breadth first search and i'm\ngoing to show you both of those right\nnow\nnow there's not a lot of benefits to\nusing breadth first search on this\nproblem\ncompared to just doing dfs recursively\nmainly that you just don't have to do\nrecursion at all\nthe time complexity is still going to be\nthe same the memory complexity is still\ngoing to be the same\nbut let's still do this for learning\npurposes so breadth first search on a\ntree is basically\nlevel order traversal we're traversing\neach level\nby level until we get to the end or the\nlast\nlevel and then we can't continue anymore\nso you can kind of see how breath for\nsearch is a pretty intuitive way to find\nthe max\ndepth right we're basically counting the\nnumber of levels we have\nso here we see okay we have one level\nnext we see\nwe have two levels oh this is the third\nlevel and we can't go any lower so\nwhat's the number of levels that we had\nwe had three\nthat's the number of levels is basically\ngoing to be the same as the max\ndepth so now the only problem is how are\nwe actually going to code this\nup now typically bfs involves a queue or\na\ndeck a dq or however you call it and so\nthe way it's going to work is the queue\nis initially just going to have the root\nvalue\nso i'm going to kind of represent this\narray as the queue so initially we're\njust going to put the root\nin the queue right so now we're going to\nsay okay what's the length of our queue\nthis is these are the elements currently\nin our queue and this these are all at\nlevel one\nso now we're going to go through every\nnode in our queue we only have one and\nwe're going to take three\nnow we're going to remove it from our\nqueue and we're going to replace it with\nits children\n9 and 20. so let's add 9 and\n20 to the queue so now\nthis is our second level right these\nelements that we have here are our\nsecond\nlevel of the queue the second level of\nthe tree so we're going to do the exact\nsame thing\nwith these two nodes we're going to take\nthe first one 9\nget rid of it we see 9 is here now we're\ngoing to replace it with its children it\ndoesn't have any children so we don't\nhave to replace it with anything right\nbut we're going to keep going\nnow we're going to go to the second one\n20 remove that from\nour q and replace it with its children\nwhat are its children we have 15\nand 17 so let's add 15 i ran out of\nspace but that's okay\nand 17 to our q now this\nportion is the next level it's level\nthree\nso let's continue to go so 15 is the\nfirst one let's pop it let's get rid of\nit replace it with its children it\ndoesn't have any children\nso it's a base case next one seven okay\ni wrote 17 but it's actually seven sorry\nabout that i'm not paying attention\nbut okay we're gonna get rid of this\nseven and we're gonna see okay seven did\nnot have any children either\nso now when we when we continue to go\nwe're gonna see okay there's nothing\nleft in our queue so we have to stop\nright\nthat's how we know we're done traversing\nthe entire tree when we went through\nevery single node\nwhat's the max level that we actually\ngot to of course it was three so that's\nwhat we're going to end up returning the\nmax\ndepth of this this tree was three okay\nso now let's get rid of this and\nactually do\nthat solution so another base case or\nthe same basis i'm just going to say\nif not root we can still return zero so\nif there's no root then we're gonna\nreturn zero\nand we're also going to maintain the\ncurrent level that we're at and we're\ngonna have a queue which in this case\nis going to be a deck and initially\nwe're going to initialize this queue\nwith just a single value the\nroot i think most libraries do have a\nqueue structure so\nwe're going to initialize our queue like\nthat we're going to have our level\ninitially at one we're gonna keep going\nuntil the queue is empty right now so\nnow we want to go through the queue and\nremove\nevery element that's currently in it\nright so however many are in it so we're\ngonna say for i\nin range length of the queue at this\ncurrent time right so we're going to\ntake a snapshot of the length of the\nqueue maybe it has one element maybe it\nhas two\nwe're going to take a snapshot remove\nall of those and then add the children\nso basically traverse the entire level\nand then add the next level\nand then once we're done with that\nentire loop we're going to increase the\nnumber of levels\nso for every node in the queue we're\ngoing to go ahead and pop from the left\njust like we did in the picture we're\nalways going to be popping from the left\nof the queue and we're always going to\nbe adding to the right of the queue so\nwe're going to pop a node\nand then we're going to go ahead and add\nits children to\nthe queue only if the children are not\nnull so if node.left is non-null\nthen we're going to go ahead and say q\ndot append node\ndot left if node.right is non-null then\nwe're going to append that one\nas well so q dot append no dot\nright and actually if we're going to be\ndoing it this way we should probably\ninitialize our level to\nzero so you can see that we're never\ngoing to be adding\nnull nodes to our our queue so every\ntime\nour queue is non-empty we can be sure\nthat there's at least\na non-empty node in the queue right so\nwe're basically counting the number of\ntimes our q is not\nis going to be non-empty so each time it\nis we can basically increment the number\nof levels\nand then at the end once our q is\nfinally empty we know that we have\ntotaled up the number of levels and we\ncan go ahead and return that\nso you can see this solution also works\nand it's also pretty efficient so this\nis the breadth first search solution\nbut there's one more solution i want to\nshow you the iterative\ndepth first search solution basically\ndepth first search without using\nrecursion\nso now we're going to do iterative depth\nfirst search and we're going to be\nneeding a stack data structure because\nwe're basically going to be\nemulating the call stack the recursive\ncall stack right so\nyou know in a recursive dfs we go to\nthis node right and then we go to the\nleft sub tree right and when we're done\nwith the left sub tree\nthen we pop back up to the three\nand then we go down to you know the\nright subtree etc\nright that's like in in order dfs but\nwe're going to be implementing\npre-order dfs with a stack because\npre-order is actually by far the\neasiest one to do iteratively so what\nwe're going to do is we're going to say\nokay\ncome to this node process this node\nright then\nadd the children to the stack the left\nand right children right\nnow in now our normal pre-order\ntraversal we'll do the left subtree\nfirst so what we're going to do is now\nsay okay\nlet's do the left subtree well well\nwe're going to go to the left subtree\nit's pre-order so we're going to process\nthis then we're going to do its children\nwell it doesn't have any children right\nso now what are we going to do well this\none was added to the stack\nso then we can go ahead and process this\none and add its children to the stack\nand then we're going to process this one\nit doesn't have any children and then\nthis one's going to be at the top of the\nstack because we just popped this one\nand then we can process this one and\nthen we're done right so we're going to\ndo that\nand as we do it iteratively we're not\njust going to be adding the nodes\nthemselves to the stack but we're also\nfor each node going to be adding to\nthe depth of each node because we can\neasily do that right we know this is\ngoing to be depth one\nwhen we add the left and right children\nwe're gonna say okay these are at depth\ntwo\nwhen we add these two we're gonna say\nthese are at depth three\nso we're just gonna try to visit every\nsingle node find the node that had the\ngreatest depth and then we can return\nthat\nso initially we're gonna start with node\nthree at depth\n1 in our stack so now we're going to pop\nfrom our stack so let's\npop this node and we process it so so\nfar the max depth we found was\n1 and let's add its children to the\nstack so let's add 20 to the stack\nand let's add 9 to the stack and each of\nthese are going to have a depth of\n2. so now this is technically the top of\nthe stack even though it's the bottom so\nlet's pop from the top of the stack\npop this one that's node 9 so now we've\nfound a max depth of two that's better\nthan one\nand now let's also add the children of\nthis of course it doesn't have any\nchildren so we're done with\nthese so now what's at the top of our\nstack that's\nthat's well we popped this one we popped\nthis this is at the top of the stack now\nso let's pop this one\nwe pop 20. it also has a max depth of\ntwo so we don't update the result but\nnow we can add its children\nto the stack and the depth of course is\ngoing to be plus one so both of these\nare gonna have a depth of 20\nof three we're going to add 7 and 15 to\nthe stack so now let's pop the top of\nthe stack 15\npop this it has a max depth of 3 so\nwe've updated the result pop one more\ntime this\nalso had a max depth of three so we're\ndone with that we process this node\nand neither of these had any children so\nnow we're done with the dfs\nso that's basically how it's going to\nwork it's pretty straightforward at\nleast if you're doing it with pre-order\ndfs\nwith a stack okay so finally for the\nlast solution so this was bfs but now\nwe're going to be doing iterative dfs\nwe're going to leave this\ninitial case if the root is null we're\ngoing to return 0\nand our stack otherwise is just going to\nhave one single\nvalue on it the root but remember we're\nalso maintaining the depth so we're\ngonna add a pair of values we're gonna\nadd the root which is the node\nand we're gonna add it has a depth of\none and now we're gonna continue to go\nwhile our stack is non-empty so this is\npretty similar to bfs\nbut we don't actually need nested loops\nso\nnow we're going to pop from the stack\nstack dot pop we're popping two values\nremember we're getting the node and\nwe're getting its\ndepth and so what we're going to say now\nis we're going to say if the node is\nnon-null\nyou'll see why i'm going to do this in a\nmoment because it's possible the node\ncould be null so if it's non-null\nwhat we're going to do is we want to\nupdate our result now initially we're\ngoing to set our result\nequal to 1 because we know we do have at\nleast\na 1. and so if we pop this node and it's\nnon-null then we can potentially update\nour result so we'll set the result equal\nto the max of itself\nand the depth of the node that we just\npopped\nand then what we're going to do is to\nour stack we're going to add the\nchildren\nof of this node and we're gonna add both\nof them together so node.left\nnode.right but we're not even checking\nit could be possible that these children\nare null so we technically might add\nnull nodes to our stack which is\ndifferent than the drawing i showed but\nwe're showing that if we do add a null\nnode we're going to pop from we're going\nto pop it from the stack but we're not\nactually going to do anything with it\nright this\nif statement will prevent us from\nactually using that\nnull node so we're just going to ignore\nthe null nodes\nand actually we're we're adding both of\nthese nodes but we also want to add the\ndepth of each of them so that's what i'm\ngoing to\nmodify right now so we're going to\nappend the left node\nand we're going to append it with its\ndepth which is just going to be the\ndepth of the node that we just popped\nplus one and we're going to do the exact\nsame thing for node\ndot write so\ncopy paste and update this so we're\nadding both of the nodes even if they're\nnull we're adding them\nand then we're just going to continue\nthrough the stack until the stack\nbecomes\nempty and then once that is done we can\ngo ahead and return\nthe result and this is the entire code\nand i actually just realized\nthat we can actually simplify the code a\nlittle bit we can actually get rid of\nthese two first lines\nand set the result initially equal to\nzero\nso then if we do have a null root node\nthe loop will execute we'll pop this\nbut then the if statement won't execute\nso then the result will stay zero and\nthen we'll end up returning zero but of\ncourse if the root is non-null\nwe will end up updating the result so\nthis is the third and final solution\nthat i wanted to show you they all have\nbasically the same time and space\ncomplexity\nbut there's definitely variations with\neach of these solutions so i hope that\nthis was helpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully see you pretty soon\n"
    },
    {
        "Name": "Diameter of Binary Tree",
        "NcLink": "binary-tree-diameter/",
        "Pattern": "Trees",
        "Description": "The **diameter** of a binary tree is defined as the **length** of the longest path between *any two nodes within the tree*. The path does not necessarily have to pass through the root.\n    \nThe **length** of a path between two nodes in a binary tree is the number of edges between the nodes.\n\nGiven the root of a binary tree `root`, return the **diameter** of the tree.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/90e1d7a0-4322-4c5d-c59b-dde2bf92bb00/public)\n\n```java\nInput: root = [1,null,2,3,4,5]\n\nOutput: 3\n```\n\nExplanation: 3 is the length of the path `[1,2,3,5]` or `[5,3,2,4]`.\n\n**Example 2:**\n\n```java\nInput: root = [1,2,3]\n\nOutput: 2\n```\n\n**Constraints:**\n* `1 <= number of nodes in the tree <= 100`\n* `-100 <= Node.val <= 100`\n",
        "Difficulty": "Easy",
        "Video": "K81C31ytOZE",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        res = 0\n\n        def dfs(root):\n            nonlocal res\n\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            res = max(res, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code so today let's\nsolve diameter of binary tree we're\ngiven the root of a binary tree and we\nwant to return the length of the\ndiameter of the tree which is defined as\nbeing the longest path from a particular\nnode so in this case it would basically\nbe the longest path on the left side\nwhich could either be this part or this\npart both of those are of length two I'm\ngetting that calculation because two is\nthe number of edges on that side for the\nlongest path on the right side we just\nhave one Edge so that's one so the\ndiameter through the root would be 2 + 1\nwhich is 3 but keep in mind that the\nlongest path might not necessarily run\nthrough the route so let's look at a\ncounter example with this tree if we try\nto calculate the diameter through the\nroot on the left side we have nothing so\nthat's a zero on the right side we have\nthree that's the longest path you could\ntake multiple different paths but all of\nthem are going to be of length three so\nthe diameter from here is three but\nconsider the node over here length on\nthe left side is two and length on the\nright side is two so total is four\nthat's the diameter of this tree now I\nwant to mention to you that this problem\nis actually closer to a medium problem\nthan an easy problem why exactly is that\nbecause the solution initially seems\npretty obvious right to get the result\nwe can just try to calculate that\ndiameter through every single node in\nthe tree how do you do that well just\nlike I did get the longest path on the\nleft and the longest path on the right\nand add them together AKA sort of like\nthe height on the left side and the\nheight on the right side generally we do\nthis recursively with some kind of DFS\nalgorithm but the tricky part about this\nproblem is that the return value\nobviously of this DFS is going to be the\nheight so what we want to return from\nthis right subtree up to this node is of\ncourse the height but that's not the\nresult that we're ultimately trying to\ncompute what we're actually trying to\ncompute is the diameter now in terms of\nthe code there are multiple ways of\nhandling that the way I'll show you is\nsort of by using a member variable or\nyou can even think of it as sort of a\nglobal variable with respect to the\nrecursive function but the algorithm\nwill be exactly like this recursively\nrun DFS from the left sub tree we reach\nnull so the height of that of course is\ngoing to be zero that's what we return\nup here then do the same on the right\nside and then we'd continuously go down\nand so here we'd reach the case with\njust a node the height of that we will\nsay is going to be one that's going to\nbe returned up to the parent and that's\nbasically saying that the length of this\nis one same thing for this side we'll\nsay the length is one so now when we\nwant to compute the diameter from here\nwe're going to maintain a global\nvariable which I'll call it the result\nor this for sure and initially we'll set\nit to zero this is what we're trying to\nmaximize of course and from this node we\ncalculate a diameter of 1 + 1 which of\ncourse is going to be two now that's the\nbiggest result that we have now from\nthis node I want to return up to my\nparent the height of this tree so what\ndo I do well the height is different\nthan the diameter so we actually will\ntake the max of the left sub tree the\nmax of the right sub tree and add one to\nit well in this case they're the same so\nwe just get one and then add one to it\nwhich is this Edge so we'll say that the\nheight here is going to be two obviously\nit didn't have to be like that Suppose\nthere was a node over here and then\nmaybe the height of this right tree\nwould have been two and then we would\nhave returned 2 + 1 which would would\nhave been three so that's generally the\ncore idea we would do the same thing\nfrom here cuz it's kind of symmetrical\nto this side so this would be one and\none and then the height of this is two\nheight of this is two those are going to\nbe returned up to three add them\ntogether the diameter now is going to be\nfour it's going to be increased all the\nway up to four from here we want to take\nthe max of left Max of right it's two\nand we want to add one to it because of\nthis edge here so then we say the height\nof this part is three we return that up\nto the root I'll make it another color\nthree root is going to do the same thing\ntake left plus Right add them together\nwe get three this time it's not greater\nthan the result so our result will stay\nunchanged and it will be four four is\nultimately what we would return but it's\nnot going to be returned from the\nrecursive function keep that in mind\nwe're going to have a separate variable\nthat's sort of going to be Global which\ndoes that and since we were able to\naccomplish this by just visiting each\nnode once we will say that the time\ncomplexity is linear and the space\ncomplexity is going to be proportional\nto the height of the tree which could be\nlog in for a balance tree or n for a\nnon-balanced tree so we're going to\nsolve this recursively and I like to do\nit with nested functions so I'm going to\nhave my DFS here and I'm going to pass\nin a single variable Curr remember that\nthis DFS is not returning the diameter\nit's going to return the height that's\nthe most important thing about this\nproblem it's not a trivial recursive\nproblem the base case though is going to\nbe pretty easy if not Cur therefore we\nreached a null node the height of that\nis of course just going to be zero so\nthat's what we return otherwise let's do\nthe recursive case let's get the height\nof the left subtree let's call DFS on c.\nleft let's do the exact same thing for\nthe right subtree just like this now\nremember there's two things we want to\ndo we want to potentially update the\nresult and we want to return the height\nof the tree from cerr so let's start\nwith the result I'm going to create a\nvariable self. result is equal to zero\nthis is basically making it a member\nvariable of this class like an instance\nof this class so that it is accessible\ninside of this nested function so when I\nwant to maximize the result I'm going to\nset it equal to the max of itself self.\nresult and the current diameter how do\nwe get that we'll just take the left and\nright and add them together just as we\ndid in the drawing explanation now for\nreturning we're not returning this we're\nnot returning the diameter remember this\nReturns the height how do we calculate\nthe height though well it's either going\nto be the max of the left or the max of\nthe right and also don't forget to add\none for the current node that we are at\nthis just tells us the max of either of\nthe sub trees but Plus One will give us\nthe max of the height from cerr now\nthat's actually pretty much it it's not\neasy to come up with remember the\ncomplexity of this comes from the fact\nthat the return value is not the result\nso down here we're going to return self.\nresult but don't forget don't be like me\nand forget to actually call the\nrecursive function starting from the\nroot this is the entire solution you can\nsee that it works and it's very\nefficient I just want to show you a\ncouple different ways that you could\nhave handled This Global case though at\nleast in Python another way is just\nmaking it a local variable result and\nthen in here to update it let's get rid\nof all the self Dots here let's get rid\nof that and let's get rid of that to\nupdate result you have to kind of\ndeclare it nonlocal first you want to\nsay that this is not a local variable to\nthis function it's actually the same\nresult that was declared out there so\nthis will do the same thing so if we\nexecute this you'll see that once again\nit works it says it's more efficient but\nleak code run times are random so don't\nreally pay attention to that if you\nfound this helpful please like And\nsubscribe if you want to learn a bunch\nof more python tricks check out my\npython for coding interviews course and\n"
    },
    {
        "Name": "Balanced Binary Tree",
        "NcLink": "balanced-binary-tree/",
        "Pattern": "Trees",
        "Description": "Given a binary tree, return `true` if it is **height-balanced** and `false` otherwise.\n\nA **height-balanced** binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c19c3727-ea28-416c-3873-79ee75f2b400/public)\n\n```java\nInput: root = [1,2,3,null,null,4]\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/24fcc2da-e012-4f9e-856e-040f200f3c00/public)\n\n```java\nInput: root = [1,2,3,null,null,4,null,5]\n\nOutput: false\n```\n\n**Example 3:**\n\n```java\nInput: root = []\n\nOutput: true\n```\n\n**Constraints:**\n* The number of nodes in the tree is in the range `[0, 1000]`.\n* `-1000 <= Node.val <= 1000`\n",
        "Difficulty": "Easy",
        "Video": "QfJsau0ItOY",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if not root:\n                return [True, 0]\n\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1\n            return [balanced, 1 + max(left[1], right[1])]\n\n        return dfs(root)[0]\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem balanced binary tree\nwe're given a binary tree and we want to\ndetermine if it is height balanced what\nexactly do they mean by height balanced\nwell it's defined by saying that for\nevery single node in the tree if we take\nthe left and right subtrees of this node\nthe heights of these left and right sub\ntrees will differ by at most one so in\nhere you can see taking a look at the\nroot node uh it has a left sub tree\nwhat's the height of this left sub tree\nlet's call it one right because there's\none node in the left sub tree what about\nthe right subtree how m what's the\nheight of this right sub tree well it's\ntwo right we can determine that just by\nlooking at it so then the left sub tree\nhas a height of one the right subtree\nhas a height of two the difference is uh\nat most one right because if we take the\nabsolute value of the difference we get\none so we'll say the\ndifference is one so we just did that\nfor the root node but we have to do that\nfor every single node to make sure that\nthe left and right subtrees of every\nsingle node differ by at most one and\njust to show you a counter example so\nthis is kind of a badly drawn tree but\ntake a look at the root node right if we\ntake a look at the left tree over here\nthe height is three if we take a look at\nthe right subtree the height is three so\nthe difference is zero which fits into\nour criteria so from the root node the\nleft sub tree and the right subtree are\nbalanced but if we take a look at let's\nsay this node right we take a look at\nits left sub tree which is empty right\nso that's has a height of zero the right\nsubtree has a height of two so in that\ncase the difference is two minus zero\nwhich is two right positive two which is\ngreater than one so just because uh from\nhere taking a look at the root note the\nleft and right sub trees are balanced\ndoesn't mean that that's going to be\ntrue for every single node because we\njust looked at this node the left and\nright subtrees were not balanced how can\nwe solve this efficiently let me first\nshow you kind of a naive approach and\nthen we'll see how we can actually\noptimize that so if we were asking\nnaively right the first question we're\nasking is from the root node are the\nleft and right sub trees balanced how do\nwe even determine that well do you agree\nthat we could probably do a recursive\ndfs on the left sub tree to determine\nthe height of the left subtree do a\nrecursive dfs on the right subtree to\ndetermine the height of this subtree and\nthen we could compare those and make\nsure that the difference is less than or\nequal to one do you agree that we could\ndo that probably right i'll explain more\ndetails in the code but for now let's\njust assume we can do that we start from\nthe root we run a dfs on the left and on\nthe right that means we go through every\nsingle node in the tree so we just did\nan o of n operation right and we were\nable to determine okay from the root\nnode yes it is balanced but we're not\ndone yet right we now we have to\ncontinue to ask that question for every\nsingle node right so the next question\nwe're going to ask is suppose on the\nleft subtree right from the left subtree\nare the left and right subtrees from\nthis node also balanced and of course\nthey're both zero so we determine that\nthey are and then we'll have to\nrecursively go to the right subtree from\nhere we're going to ask are the left and\nright subtrees balanced yes they are but\nwe'll recursively have to continue we'll\nhave to do that from this node and then\nwe'll have to do that from this node\nsince we're running a recursive dfs on\nevery single subtree on this uh root\ntree we're going to have to do it\nbasically an o of n operation each time\nwe ask that question is it balanced from\nhere is it balanced from here is it\nbalanced from here and we could have a\nreally big tree and we'd have to do an\noven operation each time of n is the\nnumber of nodes in the tree and if we\nhave to do this n operation n times\nwe're going to get a time complexity of\no of n squared so now the question is\ncan we do better than that is there any\nrepeated work and i'll show you that yes\nthere is repeated work and it basically\ncan be eliminated by\nasking the question in a different order\nwhat i mean by that is instead of first\nasking if the entire tree is balanced\nfrom the root node right that's the\nfirst question we ask is it balance\nstarting from here instead of asking\nthat we uh\ndo this bottom up we start we\nrecursively instead of asking it from\nhere we're going to check okay is this\nentire right subtree balanced before we\ndo that we're going to ask is this\nentire subtree balance and we're going\nto keep going lower and lower until we\nget to the base case once we get to the\nbase case then we're going to go back up\nand i'll show you how that's actually\ngoing to end up eliminating the repeated\nwork if we do it in this order we'll\nonly have to visit each node at most one\ntime which will ensure the overall time\ncomplexity is going to be big o of n\nrather than n squared okay so when we\nget to the root before we check if it's\nbalanced from here we're going to check\nif it's bounced from this right subtree\nthat makes sense so far and then before\nwe ask from this position we're gonna\nask is it bounced from this leaf node\nright and now we can't really go any\nlower because this node doesn't actually\nhave any children so of course its\nsubtrees are going to be balanced but\nnow we're good right we we determine\nokay this\nfrom this node yes the left and right\nsubtrees are balanced right and then we\npop back up suppose and then uh we we\nalso want to make sure that this node is\nalso balanced it's the same thing right\nthe left and right childs don't exist so\nyeah it's balanced from here as well so\nwe determined that right now we know\nfrom at least these two nodes yes the\nleft and right sub trees are balanced\nfrom these two nodes okay now we want to\nknow is it balanced from this node how\ncan we determine that aren't we going to\nhave to go back down and revisit the\nentire right subtree in the entire left\nsub tree again no and i'll show you why\nas we are determining if this subtree is\nbalanced let's also at the same time\nsimultaneously let's make sure we get\nthe height of this tree the entire\nheight of this subtree and let's do the\nexact same thing for this node make sure\nwe get the entire height of this subtree\nbecause once we've done that then once\nwe go back up to the parent node from\nhere it will be easy we already have the\nheight of this tree we already have the\nheight of this tree we can take the\ndifference between those make sure it's\nless than or equal to one and then we're\ngood we we didn't even have to revisit\nthese trees right from this node now\nwe've already determined yes it's also\nbalanced from this position right so now\nwe've determined it's balanced from this\nnode bounced from here and balanced from\nhere and now we want to go back up to\nthe root node and make sure it's\nbalanced from here before we do that we\nhave to solve the sub problem on this\nleft subtree it's just a base case\nproblem right it's just a single node so\nwe know it's balanced from here as well\nso now we want to go back up to the root\nnode is it balanced from this root node\nwell as we are doing this right as we\nwere doing this right subtree we\ndetermined the height of this tree was\none the height of this tree was also one\nright so now we want to know before from\nfrom this node over here before we\nreturn back up to the parent we want to\nknow what's the entire height of this\nsubtree how can we easily determine that\nwell we know that this was one this was\nalso one so from here the height is just\ngonna be one meaning one this one comes\nfrom this node over here plus the max of\nits left and right subtrees which we\nknow are both one so we can take the max\nof one and one that's going to end up\nbeing one so the height of the overall\ntree is just gonna be one plus one which\nis two right so the height of this tree\nis going to be 2. we determine that\npretty easily and that's what we can\nreturn back up to this parent node which\nis good for us right and from this tree\non the left the height is 1 because it's\njust a single node so we return that up\nto the parent as well so now from here\nwe know that the height of the left sub\ntree is one the height of the right\nsubtree is two we can take that\ndifference two minus one it's one which\nis less than or equal to uh one so that\nwe do know that this is balanced from\nthis\nnode as well right and we can continue\nto recursively do that if we had another\nparent node up above us somewhere we\ncould return okay the height of this\noverall tree is going to be three right\nso that's the main logic we're gonna\nfollow yes we're going to do this\nrecursively and there's many ways to\ncode this up the main way i'm going to\ncode this up is actually by returning\ntwo values i'm going to return a boolean\nas the first value which will be either\ntrue or false basically for every single\nsubtree remember we are going to\ndetermine is that subtree balance we'll\nreturn a true or false for that and the\nsecond value will be the height of that\nsubtree so from this subtree what we\nwould return is true because it is\nbalanced and the height we would return\nis 2 right the height of the subtree is\n2 so this is kind of what we would\nreturn now if we ever from any single\nsubtree if we ever return false that\nmeans we found at least one subtree\nthat's not balanced if we find even one\nsubtree that's not balanced that means\nfrom the root we're going to end up\nhaving to return false which i'll show\nyou how we can implement that in the\ncode it's pretty straightforward okay so\nnow let's get into the code and\nmain thing is we're going to do this\nrecursively why can't i just use this\nouter function to do it because this\nouter function just returns a single\nvalue right the boolean but we actually\nwant to implement this by returning two\nvalues so i'm gonna write a nested\nrecursive function here and we're gonna\npass in a single parameter which is the\nroot and remember this function is going\nto return a pair of values a boolean and\nthe height of the tree so first things\nfirst the base case if the root is a\nnull right this means that we have an\nempty tree so is an empty tree\nconsidered balanced yeah let's say it is\nso for the first value we'll return true\nin this case and the second value which\nis the height of the tree an empty tree\nwe can assume just has a height of zero\nlet's say and now remember before we\ndetermine from this root node is this\ntree balanced first we want to determine\nif from the left sub tree it is balanced\nand from the right subtree is a balance\nso let's call dfs recursively on the\nright and left subtrees and then assign\nit to the result variables left and\nright so that's what we're doing with\nthe single line of code calling dfs on\nboth subtrees so now we want to know\nfrom the root node is it balanced right\nhow can we determine that well we're\ngonna have to take the absolute value of\nthe left and right heights right so how\ncan we do that we can take absolute\nvalue left of index one because remember\nthe second value is where the height\nhappens to be left of one minus right of\none so this will give us that so as long\nas this is less than or equal to one we\ncan say that the tree is balanced right\nnot not so fast because remember if\neither of these left or right subtrees\never returned false in the first\nparameter then we know for sure that the\nentire tree is not balanced right so\nbefore we say uh that this condition is\nenough we're gonna add two more\nconditions we're going to say okay as\nlong as this is true meaning that from\nthe root it's balanced and the left and\nright sub trees were also balanced so we\ncan determine that by just taking the uh\nfirst the zero index of left and the\nzero index of right\nand also this condition over here let me\njust reformat it slightly to make it a\nlittle bit more readable this balance is\nwhat we're going to be returning as the\nfirst\nas the zeroth index let me just show you\nthat so we're going to return a pair of\nvalues the first is going to be is this\ntree balanced and the second is going to\nbe the height of the tree how do we\ndetermine the height of the tree well\nit's going to be one\none comes from the root node that we're\ncurrently at plus the max of the left\nand right subtree so we can get that\npretty easily left at index one\nand right at index one so whatever the\nmax of those two is plus one gives us\nthe height hopefully this is pretty\nsimple but the balanced might not be\nthis balance doesn't only mean is the is\nthe tree balanced from the root position\nthis balanced means is the entire tree\nbalanced at all because remember if the\nleft subtree for example was not\nbalanced then this conditional is going\nto evaluate to false right because this\nbalance is only going to be true if the\nleft sub tree was balanced and the right\nsub tree was balanced and from the root\nsubtree are we balanced right so all\nthree of those have to be true for us to\nreturn true as the balanced variable\nhopefully that makes sense because that\nis the entire code once we're done with\nthat we can in the outer function we can\ngo ahead and call our dfs starting from\nthe root node and remember this dfs is\ngoing to return two variable or a pair\nof values right a boolean and the height\nso which of those do we want to return\nin the outer function we want to return\nthe boolean so we can return this at\nindex 0 and then that will be the entire\ncode so let me submit it to make sure\nthat it works as you can see on the left\nit does work and it's pretty efficient\nso i hope that this was helpful if it\nwas please like and subscribe it\nsupports channel a lot and i'll\nhopefully see you pretty soon thanks for\nwatching\n"
    },
    {
        "Name": "Same Tree",
        "NcLink": "same-binary-tree/",
        "Pattern": "Trees",
        "Description": "Given the roots of two binary trees `p` and `q`, return `true` if the trees are **equivalent**, otherwise return `false`.\n\nTwo binary trees are considered **equivalent** if they share the exact same structure and the nodes have the same values.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e78fc10c-4692-471f-5261-61e9be4f3a00/public)\n\n```java\nInput: p = [1,2,3], q = [1,2,3]\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0b0ee764-c643-46ff-cb3f-86ce8b58ab00/public)\n\n```java\nInput: p = [4,7], q = [4,null,7]\n\nOutput: false\n```\n\n**Example 3:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/4d811f95-0488-490b-1f4f-fc5489df0f00/public)\n\n```java\nInput: p = [1,2,3], q = [1,3,2]\n\nOutput: false\n```\n\n**Constraints:**\n* `0 <= The number of nodes in both trees <= 100`.\n* `-100 <= Node.val <= 100`\n",
        "Difficulty": "Easy",
        "Video": "vRbbcKXCxOw",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nsame tree so i'm going to upload this on\na friday so today we're going to be\ndoing an easy-ish problem\nso we're given the root of two binary\ntrees p\nand q we need to write a function to\ncheck if they\nare the exact same tree or not we can\ndetermine that by\none making sure that the structure is\nthe exact same\nso for example basically the number of\nnodes right like they both have a root\nnode\nthey both have a left child and they\nboth have a right child right the\nstructure is the same\nnot only that though they also have to\nhave the exact same\nvalues at every node position so in this\ncase we can see\nthey have the same value once again same\nvalue in the left side\nand lastly same value on the right side\nso these are the exact same tree right\nso\nwe can return true now if i got rid of\none of these nodes right\nlet's say i just got rid of this then\nit's definitely not the same tree right\nor\nif i took this value and changed it\nlet's say to a\nhunt a 10 or whatever then it's also not\nthe same tree because the values in this\ncase\nare different right the main thing to\nnotice with this problem is it\nlends itself very well to recursion and\nwe know that there's a\npretty convenient uh recurs recursive\nway to traverse\ntrees and that's depth first search\nwe're going to be using that recursive\nuh function to solve this problem so\nremember we're trying to check if these\nare the same\ntree right so that's a big problem we're\ncomparing\nthe big trees can we break that down\nrecursively well first thing to\nintuitively check is\nwe really just need to check the root\nnodes right are these the same that's\nthe first thing to check\nare the root nodes the same if they are\nwe're going to continue the function now\nif they were different for example maybe\nthis had a different value if it was\ntrue\nwe immediately return false right if\neven a single node\ndoesn't match we can return false\nnothing more is needed now if they do\nmatch right these are equal great now\nthis is the recursive part we don't have\nto consider this node anymore and we\ndon't have to consider this node anymore\nand now we have changed the problem now\nwe actually have\ntwo trees left we have one left sub tree\nright these are the left sub trees and\nwe also have two\nright sub trees so this is the right\nsubtree of the first\ntree and this is the second right\nsubtree so now\nthe problem is change now we're checking\nare these two trees\nthe exact same and are these two trees\nthe exact same right so we've changed\nthe problem\nit becomes recursive right we're now\ngoing to be looking at the sub trees\ncomparing them\nnow both of the sub trees need to be\nequal right these two need to be equal\nand these two need to be equal and then\nwe can return true\nand we're just going to continue to\nbreak this down obviously the tree\ncould be much larger than this in which\ncase we would continue to do that\nnow let's not consider this example\nanymore we know with recursive functions\nthe\nthe main thing to consider is the base\ncase so what are a couple base cases\nwell what if we had\ntwo null nodes right they're both empty\nwhat's what's what are we going to\nreturn then is this the same tree or is\nthis not the same tree well they're both\nempty right so that's technically the\nsame tree in this base case\nwe return true what if the left\ntree is null but maybe the right tree\nhas a single node in it\nnow this is obviously going to be false\nright these are not the same tree and\nthe exact same thing could be true we\ncould have\na null in the right tree and a real node\nin the left tree and that would also be\nfalse\nnow the case where both nodes are\nnon-null\nthen we're going to be looking at the\nvalues obviously if the values are the\nsame\nthat's true right that we're going to be\nreturning true they're the same tree\nif the values are different we're going\nto be returning false so\nthese are basically all of the base\ncases that i went over\nand the code is just basically going to\nbe implementing exactly what we just\nshowed right now so let's jump into that\noh and last but not least\nthe time complexity of this so the time\ncomplexity is overall going to be\nbasically the size of both trees added\ntogether so the size of p\nplus q because worst case we would have\nto iterate through every single node\nin both trees so that's basically the\noverall time complexity\nso like i said this is going to be a\nrecursive function since we already went\nthrough most of the base cases this is\ngoing to be pretty easy peasy so\nif you know debt first search already we\nknow the base case is important\nso if the first tree is empty and if the\nsecond tree is empty so\nif p and q are empty then what are we\ngonna do\nwe're gonna return true because they're\nboth empty trees empty trees are\ntechnically equal\nnow if they're both not empty but maybe\none of them\nis empty so if this this statement did\nnot execute\nthen we're going to go to the next one\nso if not p or\nnot q the only thing difference between\nthis and the one above is this one is\nand this one is or so if this one did\nnot\nexecute that means both of them are not\nnull but if\nthis executes that means only one of\nthem\nis null now what happens if one of them\nis null but the other one is\nnot null well then they're not the same\ntree right so we're going to have to\nreturn false in that case\nand we had one more base case right so\nlet's say if neither of these statements\nexecutes\nthat means that both of the trees are\nnon-empty so\nnow we can actually look at the values\nso if p dot\nval is not equal to q dot val\nwhat does that tell us that tells us\nthat the values are not the same so the\ntrees are not the same\nso we can return false in this case\none thing to notice here is that both of\nthese two\nare executing the exact same thing right\nthis is returning false\nand this is returning false so we can\nactually condense this i'm going to copy\nand paste this here so if\nif this is true or if\nthis last thing is true then we can also\nreturn false we don't actually need\nthis third condition so if this\nstatement does not execute\nthat means that both of the nodes p and\nq\nare not are are non-empty right and the\nvalues are actually the same\nbecause if this does not execute so then\nwhat are we going to do over here now\nwe're going to do the recursive step\nwe're going to call is same tree\non the left and right subtree so if p\nwe're going to call it on p left and q\nleft\nand we're going to call it on p right\nand q right and what do we\nwant to know from for the when we're\ncomparing the left tree\nand the right trees what do we want to\nknow we want to know that both\nof the the left sub trees and the right\nsub trees\nare equal so we want this to be true and\nwe want this to return true as well so\nwe're gonna take\nthese two uh the return values of these\ntwo function calls and we're gonna\nand them together and if the and is true\nwe're gonna return true if the and is\nfalse\nwe're gonna end up returning false and\nthis is the recursive step\nthis is the only thing that we have to\nreturn this is the entire\nfunction so this is a pretty good\nproblem to practice your tree traversals\nyour debt for search\npracticing so i think it's a pretty good\nproblem\nand i hope that this was helpful i hope\nyou do understand the edge cases and how\nwe simplified the code\nif it was please like and subscribe it\nsupports the channel\na lot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Subtree of Another Tree",
        "NcLink": "subtree-of-a-binary-tree/",
        "Pattern": "Trees",
        "Description": "Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2991a77a-9664-46ed-528d-019e392f7400/public)\n\n```java\nInput: root = [1,2,3,4,5], subRoot = [2,4,5]\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ae6114cb-23a0-457f-c441-0a82b7a58500/public)\n\n```java\nInput: root = [1,2,3,4,5,null,null,6], subRoot = [2,4,5]\n\nOutput: false\n```\n\n**Constraints:**\n* `0 <= The number of nodes in both trees <= 100`.\n* `-100 <= root.val, subRoot.val <= 100`\n",
        "Difficulty": "Easy",
        "Video": "E36O5SWp-LE",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    \n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not subRoot:\n            return True\n        if not root:\n            return False\n\n        if self.sameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def sameTree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root and not subRoot:\n            return True\n        if root and subRoot and root.val == subRoot.val:\n            return self.sameTree(root.left, subRoot.left) and self.sameTree(root.right, subRoot.right)\n        return False\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem subtree of\nanother tree and this problem is\nactually from the blind 75 list that we\nhaven't really visited in quite a while\nbecause we've solved most of the\nproblems on this list but you can see\none of the problems one of the few\nproblems that we missed was subtree of\nanother tree so let's solve that today\nby the way this is a spreadsheet we\ncreated a long time ago basically just\ntracking all 75 of the problems in the\nblind 75 list you can see i've taken\nsome of my notes on each of these\nproblems over here and each of the\nproblems or at least most of the\nproblems have a video solution that i\ncreated\nand you can see about 16 people are\nactually\nyou know looking at this sheet right now\ni assume most of them are viewers of\nmine and if you don't really care for\nspreadsheets i actually did make a video\nplaylist of each of the solutions uh we\nhave about 68 of them done so pretty\nmuch every problem has been solved\nexcept for just a few of them most of\nthe hard problems at least okay now\nlet's get back to the problem the\ndescription of the problem is pretty\nsimple we're given two binary trees one\nis called root so this is that entire\ntree and the second tree is called sub\nroot and this is that second tree and\nthe only thing we want to know is\nthis sub root this tree this entire tree\nis it a sub tree of\nthis tree on the left is this one a sub\ntree of this one now first question what\nis a subtree so for for this a root tree\nwhat's a sub tree basically you can\nstart at any node in the tree and then\ntake all of the nodes in that subtree\nright so for starting at four this is a\nsubtree of the tree uh starting at one\nthe node itself is a sub tree this\nitself is a subtree this itself is a sub\ntree even starting at the root node this\nentire tree is a sub tree of itself so\nnow the first thought that you probably\nhave is to check if this is a subtree of\nthis tree let's just brute force it\nright and how would that work well\nbasically we would check visit every\nsingle node in the root tree and then\ncheck starting from here does the tree\nmatch the sub root tree so let's start\nat the root right the root of both of\nthe trees three and four are are the\nroot values the same well they're not\nright so that kind of automatically\nmeans that this entire tree is not equal\nto this tree so then we continue right\nwe check okay starting from here\nstarting from the four are these two\ntrees the same well we check the root\nvalue you know they're both the same\nthey're both four so at this point we're\nbasically just comparing these trees to\ncheck if they are equal and we can do\nthat recursively there's actually\nanother leak code problem called same\ntree that i would recommend solving\nbefore this problem if you struggle with\nthis problem this one is also an easy\nproblem if you want to check it out but\nyeah we can recursively compare these\ntwo subtrees four and four are exactly\nthe same so now let's check the left\nchild of both trees one and one are both\nthe same now let's check the right child\ntwo and two are both the same so yeah\nthese sub trees\nyou know this this tree is a sub tree of\nthis tree because we did find a sub tree\nthat matches uh this tree so i think\nthis is one of the problems where the\nsolution is actually really simple right\nfor every single node in this tree let's\ncall it s for every single node in this\ntree we compared that sub tree to this\nentire tree let's call this tree t so\nthe way the worst case is going to work\nout basically for every position in the\ns tree we'd have to end up going through\nevery single\nnode in the t tree right so from here\nyou know let's say this was a four the\nworst case would be that we'd compare\nall three nodes with all three nodes\nhere but of course we didn't have to do\nthat because the root nodes weren't the\nsame but what i'm getting at is\nbasically the overall time complexity\nfor this solution the brute force is\ngoing to be s times t\nand yeah this works so basically the\nsize of both trees multiplied together\nso this will get us accepted on leak\ncode but just because understanding the\nsolution is simple it doesn't mean\nimplementing it is simple it's actually\nkind of tricky and my suggestion to you\nwould be since this is a tree problem\nmost tree problems are easiest to\nunderstand when you think of them\nrecursively so let's try to do that\ninitially the problem is we want to know\nis t this subtree is it a sub tree of\nthe entire tree here right is it a\nsubtree of this tree to determine that\nthe first thing we did was checked the\nfirst subtree right the root sub tree\nthat matches this tree right so just\nthree nodes in this case right and we\nfound that no this subtree is not the\nsame as this one right and by the way to\ncheck that comparison we could create a\nhelper function to do that for us we'll\ncall it same tree right that'll be a\nhelper function just to compare two\ntrees to let us know if they're equal\nbut in this case it didn't work right so\nnow we have to continue the problem and\nlike i said let's think of this\nrecursively initially we wanted to know\nis t a subtree of this entire tree we\nfound that it's definitely not if we\nstart at the root so now let's ask the\nsub problem is t\na subtree of the left sub tree of the\nroot node and when i say is it a sub\ntree of the left sub-tree over here i'm\nnot asking is it the same tree i'm\nasking is it a sub-tree so we're going\nto have two functions in this case one\nis the helper function same tree and\nanother is going to be\nanother function i don't know what it's\ngoing to be called i think it's just the\nthe generic function that they give us i\nthink it's called is subtree so\nbasically that's how it's going to work\nis subtree is initially going to be\ncalled with s and t is t a subtree of s\nwell we'll check is it the same tree\nfirst right okay it's not the same tree\nas s so then we want to know is it a\nsubtree of the left subtree so what are\nwe going to do in that case well we're\ngoing to call\nthe same tree function is it the same\ntree as the left sub tree so that's the\nmain idea but i think it won't make a\nhundred percent sense until we actually\njump into the code so let's do that in a\nmoment but as with most recursive\nproblems we definitely don't want to\nforget about the important edge cases\nwhen we are comparing the trees so first\nthing let's start with the helper\nfunction what would happen if both trees\nwere null in that case are they the same\ntree if they're both null and yeah if\nboth trees are null yes they are the\nsame what about if two trees like this\none and this one had the same initial\nvalues right like the first three values\nwe can see are the same but what if one\nof the trees had an extra node uh here\nright then is this tree the same as this\none of course not right so we'll have to\nkeep track of that when we do our is\nsame tree function now what about the is\nsubtree recursive function if both of\nthese trees are null is our is subtree\ngoing to return true is t a nulled\nsubtree a subtree of another null tree\nwell that's going to depend on our same\ntree helper function and it's going to\nreturn true so yes a null sub tree is a\nsub tree of another null sub tree but\nthe more interesting edge case is what\nif s was null right s is empty but t is\nnon-empty in that case is t a sub tree\nof this one nope it's not right because\nthis tree cannot be found anywhere in\nthe s tree but what if the opposite was\ntrue what if t was an empty tree then is\nan empty tree a null tree is it a\nsub-tree of a non-empty tree and in this\ncase the answer is yes and the main\nintuition i use is basically you know if\nwe had a null tree here we could just go\nto one of the children of you know one\nof the leaf children of the other tree\nand technically these have a null sub\ntree because they do have a null child\nso that's kind of the intuition i use\nbut that might be a good clarification\nquestion to ask in a real interview but\nin leak code's case i think they do want\nthat to be\ntrue so those are the main topics that i\nwanted to go over so now let's actually\njump into the code and see how we can\nimplement the solution okay so now let's\nget into the code and like i said we are\ngoing to define one more function a\nhelper function same tree which is just\ngoing to pass\nin the same parameters right two trees s\nand t and then let us know if they are\nthe same tree so well\nlet's actually start with this function\nbecause i think it will help us finish\nthe rest of it so the first base cases\nif we are given empty trees right if s\nis empty and\nt is empty they're both null in that\ncase what do we want to return well if\nthey're both empty then they are the\nsame tree technically so we can go ahead\nand return true now if they're not both\nempty then we have to actually compare\nthem so we have to compare them but\ntechnically one of them could still be\nempty so let's make sure both of them\nare not empty first right so if s and t\nare both non-empty and\nthe values of both of these are the same\nright because that's of course how we\ndetermine if two trees are the same if\nthe values are the same so if s eval is\nthe same as t val then what are we going\nto do are we going to return something\nwell we know that these two nodes are\nthe same but we still have to compare\nthe rest of the sub trees right so we\nhave to compare the s the left subtree\nof s and t and we have to compare the\nright subtree of s and t\nright so this is a recursive definition\nso what we're going to do is call same\ntree passing in the sub trees right so s\ndot left and t dot left we want to know\nthe left sub trees are the same but we\nalso want to know if the right subtrees\nare the same so we'll do the same\ncalculation with both of these and\nwhat's the return value going to be\nbasically if both of these are uh true\nif both of these return true meaning the\nleft subtree and the right subtree were\nthe same then we can return that value\nso what i'm just going to do is take the\nand the conditional and of both of these\nand then return that itself so we have\ntwo cases so far if both of the trees\nare empty we return true if they're both\nnon-empty then we actually compare the\ntrees and the third case uh is basically\nif one of the you know if both of these\nconditions don't execute and they both\nreturn something so the if statements\nwill never exit but if neither of them\nexecutes that means at least one of the\ntrees is empty and one of the trees is\nnon-empty in that case of course we want\nto return false they can't possibly be\nthe same tree if one of them is empty\nand the other is non-empty so basically\nwe just solved one leak code easy\nproblem this is its own problem but now\nwe can use this\nfunction and use it in our real is\nsubtree function but remember this is\nalso going to be a recursive function so\nlet's start with the base cases remember\none of the things we determined is that\nthe tea tree the one that's the actual a\nsub tree if it's empty then of course it\nwill be a sub tree of the other tree\nregardless of whether the other tree is\nempty or not so what we can say is if\nnot t if t is null then we can return\ntrue no matter what right so that's\nreally simple now what if the opposite\nwas true do you remember what we said if\ns is empty but t is non-empty in that\ncase we have to return false t cannot be\na subtree of s so in that case we return\nfalse and just so you know the order of\nthese conditions is very important\nbecause if we did not return with the\nfirst if statement then we pretty much\nknow that t is non-empty so then here in\nthis condition i could hear right and t\nto indicate that t is non-empty but it's\nnot necessary i hope you can see why\nbecause we pretty much checked that with\nthe first condition if t was empty we\nwould have returned so here we know for\nsure it's not empty we don't have to\ninclude this second condition so now at\nthis point we basically know both of the\ntrees are not empty so what are we going\nto do well we of course want to compare\nboth of the trees right so let's call\nsame tree on both of them if they are\nequal if both of the trees are the same\nthen we can return true so let's check\nthat so is the return value true if it\nis then we can go ahead and return true\nso pretty straightforward but what if\nthey are not the same sub tree and this\nis kind of the tricky part but it's\nsimple once you actually see it okay\nthey're not the same tree but remember\nthe is sub tree function is recursive so\nwe can instead compare t to the subtree\nof of s right we can compare t to the\nleft subtree of s and we can also do the\nsame we can compare t with the right\nsubtree of s and i don't mean calling\nthe same tree function i mean\ncalling the is subtree function so is\nsubtree\nis t a subtree of the left subtree of s\nor we could check the opposite case is t\na subtree of the right subtree of s\nright so if either of these returns true\nthen we can return true right because we\nonly want to know if t is a subtree of\nat least one of the trees in s so we can\ninstead of taking the logic and of both\nof these we can take the logic or of\nboth of these so logic or uh you know\ntake that condition and then return\nwhatever it evaluates to so that is the\nentire code let's just run it to make\nsure that it works so as you can see yes\nit does work and it is relatively\nefficient even though the time\ncomplexity is the size of both trees\nmultiplied together so i really hope\nthis was helpful if it was please like\nand subscribe it really supports the\nchannel a lot consider checking out my\npatreon where you can further support\nthe channel if you would like and\nhopefully i'll see you pretty soon\n"
    },
    {
        "Name": "Lowest Common Ancestor of a Binary Search Tree",
        "NcLink": "lowest-common-ancestor-in-binary-search-tree/",
        "Pattern": "Trees",
        "Description": "Given a binary search tree (BST) where all node values are *unique*, and two nodes from the tree `p` and `q`, return the lowest common ancestor (LCA) of the two nodes.\n\nThe lowest common ancestor between two nodes `p` and `q` is the lowest node in a tree `T` such that both `p` and `q` as descendants. The ancestor is allowed to be a descendant of itself.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2080ee6a-3d27-4cd5-0db2-07672ead8200/public)\n\n```java\nInput: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 8\n\nOutput: 5\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2080ee6a-3d27-4cd5-0db2-07672ead8200/public)\n\n```java\nInput: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 4\n\nOutput: 3\n```\n\nExplanation: The LCA of nodes 3 and 4 is 3, since a node can be a descendant of itself.\n\n\n**Constraints:**\n* `2 <= The number of nodes in the tree <= 100`.\n* `-100 <= Node.val <= 100`\n* `p != q`\n* `p` and `q` will both exist in the BST.\n",
        "Difficulty": "Medium",
        "Video": "gs2LMfuOR9k",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        while True:\n            if root.val < p.val and root.val < q.val:\n                root = root.right\n            elif root.val > p.val and root.val > q.val:\n                root = root.left\n            else:\n                return root\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so\ntoday we're gonna solve lowest common\nancestor of a binary search tree\nand if you recall a while ago in a video\ni showed you guys this\nsheet of the 75 blind problems that have\nbecome pretty popular and so this is\nbasically a spreadsheet that i showed\nwith an entire list of those problems\nand i've actually ended up making videos\nfor most of these problems so far\nthe video that we're doing today is\nactually going to be lowest common\nancestor one of the few problems that i\nhaven't done yet so\ni will be linking this sheet in the\ndescription if you do want to take a\nlook and i'll probably be trying to wrap\nup most of the problems in this list i\nthink one of the\nnext ones that i'm going to be doing is\nalien dictionary because i really like\nthat problem\nand once i've gotten this entire sheet\nof problems done i'll probably be making\na playlist for it\nbut for now you can watch the videos\nthat are currently available for this\nlist of problems\nso in this problem we're given a binary\nsearch tree and we're and we're supposed\nto find the lowest common ancestor of\ntwo\ngiven input nodes in the binary search\ntree\nand so the lowest common ancestor is\nbasically defined as being the lowest\nnode in the tree such that p\nand q are descendants of this\nnode or p or q happens to be equal to\nthis node\nso basically what we're saying is six\ncan technically be a descendant of\nitself\nso for example in this problem in this\nexample we're given p equals two q\nequals eight so we're going to start at\nthe root\nbecause the root is always going to be a\ncommon ancestor of\nevery single node in the tree right\nthat's just\nkind of basic right for you know this\nnode in this node of course\nthis is going to be a common ancestor\nit's not necessarily the lowest common\nancestor\nbut it is a common ancestor so\nwhat we're gonna see is p is less than\nsix therefore it's going to be in the\nleft subtree and it actually happens to\nbe a direct\nchild of six eight happens to be greater\nthan six so it's gonna go in the right\nsubtree\nso basically if we went in the left sub\ntree two is two\ngoing to be a ancestor of\ntwo and eight of course not right two\ncan't be an ancestor of the node eight\nif it's in a different subtree\nsimilarly eight is not going to be a\ncommon ancestor of two\nso basically if we look at this level or\nif we keep going down\nwe're never gonna find a common ancestor\nbetween two and eight so the lowest one\nthat we found\nended up being six so we notice if\nthere's a split\nbetween the nodes that p and q\nare going at if they're going in\nseparate sub trees where that split\noccurs is going to be the lowest common\nancestor\nso if i change this problem slightly and\ni gave\np as 7 and q as 9 we would once again\nstart at the root because we know this\nis going to be a common ancestor of\nthese two nodes\nand so now we're going to check okay 7\nis greater\nthan 6 right and 9 is\nalso greater than 6. so therefore we\ndon't need to search in separate\nsubtrees we can just go to the right\nsubtree to look for both of these values\nwe know that this is not going to be the\nlowest common ancestor this could\npotentially though\nbe the lowest common ancestor so now\nonce again we're going to repeat that\nwe're going to say 7\nthat's going to be less than eight so\nfor a seven we're gonna have to look in\nthe left subtree\nnine is greater than eight so for that\nwe're gonna have to look in the right\nsubtree so\nsince this is where the split occurred\nthat means this is going to be the\nlowest common ancestor for this\ninput so we would return this node as\nthe lowest common ancestor\nso one last case is if we changed q\nto be a six so once again we would start\nat the root right before we were\nchecking if p\nand q were both greater than six then we\nlook in the right subtree\nif they're both less than six then we\nlook in the left sub tree\nif they're if one of them is in the\nright sub tree and one of them is\nin the left sub tree that's how we know\nthis is the lowest common ancestor but\nwhat about the last edge case\nwhere one of these nodes happens to be\nequal to the root node\nin that case this is potentially the\nlowest common ancestor\nit's definitely a common ancestor of\nboth of these but now if we go\nlower for sure none of the descendants\nof this\nnode nothing in the left subtree or in\nthe right subtree is going to be a\nancestor of this node itself right so\nbasically\nif we ever reach the node itself for\nexample six\nthen that's going to be the lowest\ncommon ancestor so it's\nan ancestor of itself and it's also an\nancestor of\nseven which can be found down here right\nso this problem isn't too difficult once\nyou can kind of understand that if\nthere's\na split between these two nodes then\nthat's going to be the lca the\nlowest common ancestor and since we're\ndoing it this way we don't have to visit\nevery single node in the entire tree so\nthe time complexity is not going to be\nbig o of n it's going to be\nlog n because we're only going to have\nto visit one\nnode for every single level in the tree\nso basically the time complexity is the\nheight of the tree which is usually\ngoing to be log n\nand the memory complexity is just going\nto be big o of 1 because we're not\nreally needing any data structures or\nanything like\nthat that being said let's jump into the\ncode now so as i mentioned we are going\nto start\nourselves at the root node and we're\nbasically going to continue until we\nfind our result\nso we're guaranteed to find a result p\nand q are guaranteed to exist\nin the input tree so what we're just\ngoing to say is while current is not\nnull now it's never going to be null\nbecause we are going to find a result\nbut this is just a way to get it to\nexecute forever until we find that\nresult\nso one case would be if the p-value and\nthe q\nvalue were both greater than the root\nvalue or the current value that we're\nvisiting\nand in that case we would have to go\ndown the right subtree\nso since we're going down the right\nsubtree we can update our current\npointer to current dot\nright now the else case is basically\ngoing to be the opposite of this\nso i'm just going to copy and paste that\nbasically if both of the values happen\nto be\nless than the current node that we're\nvisiting in that case we would want to\ngo down the left subtree\nso in that case we can update current\nand set it equal to current dot\nleft now the last case is basically if\nour split occurs or if we end up\nactually\nfinding basically finding one of the\nvalues p or\nq and in that case it basically means we\nhave found our result either way so we\nwould just be able to return\ncurrent itself now we don't have to put\nany return statement outside of the loop\nbecause we're guaranteed that this is\ngoing to execute at some point\nso as you can see this is a pretty\nefficient solution\nso i hope that this was helpful if it\nwas please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Binary Tree Level Order Traversal",
        "NcLink": "level-order-traversal-of-binary-tree/",
        "Pattern": "Trees",
        "Description": "Given a binary tree `root`, return the level order traversal of it as a nested list, where each sublist contains the values of nodes at a particular level in the tree, from left to right.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a4639809-0754-4eda-221f-a4cd58bd9c00/public)\n\n```java\nInput: root = [1,2,3,4,5,6,7]\n\nOutput: [[1],[2,3],[4,5,6,7]]\n```\n\n**Example 2:**\n\n```java\nInput: root = [1]\n\nOutput: [[1]]\n```\n\n**Example 3:**\n\n```java\nInput: root = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The number of nodes in both trees <= 1000`.\n* `-1000 <= Node.val <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "6ZnyEApgFYg",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        res = []\n        q = deque()\n        if root:\n            q.append(root)\n\n        while q:\n            val = []\n\n            for i in range(len(q)):\n                node = q.popleft()\n                val.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(val)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nbinary tree level order traversal it's\nbasically just like it sounds so we're\ngiven a binary tree\nand we want to return the level order\ntraversal\nof its nodes so basically going through\nevery single\nlevel of the tree and going from left to\nright\nso for example for this tree we have\nthis level\nso that's going to be one list we have\nthe second level\n9 and 20 and then we have the third\nlevel 15\nand seven so we have one two three lists\nand these lists are going to be put\ntogether and that's going to be\nour result the three lists in that order\nso to understand what we want to do is\npretty straightforward right so\nbasically we have the first level right\ngo from left to right\nwe see that there's only a single node\nin this level three\nthat's going to be one list we see the\nsecond level right that's what we want\nto do we want to traverse this\ntree every single level right one level\nat a time\ngoing from left to right so the second\nlevel\nwe'll see 9 and 20 right we want to add\nthat to a\nseparate list and lastly we'll get to\nthe third level\ngoing from left to right we have a 15\nand then\na seven we're going to add that to the\nthird list\nand so we've traversed the list in level\norder traversal and each of these sub\nlists are going to be\nput together into a single list and then\nthat's going to be our results so that's\nwhat we want to do we\nknow that that's pretty straightforward\nso\nthe only question now is do you know an\nalgorithm that can do that\nthat can traverse it level order and if\nyou don't\nthe algorithm is breadth first search so\nwe want to run\nbreadth first search on our tree\nand then add the values into lists\nand the second thing to notice is do you\nknow\nhow to implement this breadth first\nsearch so we need to know\nthis is the algorithm to use and now we\nneed to know how to implement it and let\nme show you how to do that\nso we have a tree and we want to run a\npretty standard algorithm\non that tree called breadth first search\nand you might know how to\nalready implement this algorithm you\nneed a q\ndata structure because we're going to be\ninserting elements\nto the right meaning we're gonna you\nknow insert an element here here\nhere right we're gonna be adding\nelements to the right portion\nand we're gonna be popping elements from\nthe left portion so as soon as an\nso basically we're following first in\nfirst out right the first element that\ngets inserted\nover here is going to be the first\nelement that gets removed right so\nthat's the order\nwe're going to be doing things in so the\nfirst thing we're going to do is take\nthe first element\n3 and add it to our queue this is based\nbasically to initialize the queue right\nand we know we're creating\nsub lists right so what we're gonna do\nnow\nis see that okay how count how many\nelements are in our queue initially\nright there's\none element in our queue so we're going\nto basically\nremove one element from our queue we're\ngoing to see okay the 3 is in the queue\nnow let's get rid of the 3 and add it to\na sub list\nright now the queue is empty so we know\nthat this\nsub list is complete and what that tells\nus is basically we\nwe went through the entire first level\nright\nthat's what we're trying to do we're\ngoing through every level we know that\nthe first level only had one element in\nit\nso now we're done but when we pop that\nthree we need to add its children\nright it has two children it has a child\nnine\nand a child twenty so we're gonna add\nthose children\nto our cue and we're to do it from left\nto right because that's important right\nwe're doing this from left to right so\nwe're going to add a 9\nthen we're going to add a 20. okay so\nnow we want to go through the second\nlevel of the tree right so we're going\nto have a sub list for the second\nlevel clearly we have two elements\nin our queue so we're gonna basically\npop these two\nelements from our queue from left to\nright\nso the left is nine we're gonna pop nine\nfrom the queue add it to the sub list\nso nine is added to the sub list and\nnotice how\nnine did not have any children right so\nwe don't have to add any children\nfor nine into our queue so next we still\nremember we had two elements we were\ntrying to remove we have two elements in\nthis level so let's\nnow pop 20 so we can add 20 to our sub\nlist right so now\nclearly this level is complete we added\nboth nodes in the order 9 and 20\nto a sub list but notice 20 had a couple\nchildren had 15 and seven so as we\nremove\n20 from our q we're adding its children\nto the queue\nfor the next level right because we know\nwe want to keep\ngoing down a level so when we get here\nthe values will already be added to our\nqueue so\n15 and 7 are added to our queue we're\ndone with the second level now time to\ngo to the third level\nwe see that there's two nodes two values\nin our queue\nso we're gonna pop both of these values\nfirst we pop 15\nadd it to the sub list for the third\nlevel\nand then we pop seven add it to the sub\nlist for the third level\nneither of these nodes had any children\nso now we're done we know we're done\nbecause our queue is now\nempty right there's nothing left in our\nqueue\nso we created a sub list for every\nsingle\nlevel and as the question wanted us to\ndo we're going to package\nall three of these sub-lists into one\nlist and then return\nthat as our result so we're really just\ndoing a breadth first search algorithm\nwith a queue on this binary search tree\nand since we're doing it like that\nthe time complexity is going to be o of\nn we're only visiting every single node\na single time\nthe memory complexity is also o\nof n because our q at any given point in\ntime\nour q could have up to n divided by two\nelements in it because the biggest level\nof a tree\ncould be n divided by two that's how\ntrees work\nbinary trees at least and so we know\nthat n\ndivided by 2 can be rounded to big o of\nn so the memory complexity\nis big o of n with breadth with breadth\nfirst search\nso with that being said let's jump into\nthe code\nso first let's initialize an array for\nthe result\nand we also remember want to have a q so\nin python\nwe can do that with collections dot deck\nthis will give us a q and the first\nvalue we want to initialize this q\nwith is the root node that we're given\nso with that we can start running the\nbreadth first search and we're going to\nrun breadth first search\nwhile our queue is non-empty remember\nand since the queue is not\nempty we're going to get the length of\nthe cube right so we're going to get the\nnumber of\nnodes or values that are in this queue\ncurrently and we're going to go we're\ngoing to loop through\nevery single one of those values this q\nlength is basically ensuring that we we\niterate through\none level at a time we're going through\none\nlevel at a time and with those nodes\nfrom that level we're going to be adding\nthem to its own\nlist right and then we're going to add\nthat list to the result\nlist so i'm going to loop through every\nvalue in this queue currently so for\nq length i'm going to pop nodes from the\nleft\nof the queue right first in first out\nand it's technically possible that the\nnode could be null\nso i'm going to have a check to make\nsure it's not null\nthen we're going to take the node value\nand\nappend it to the list level\nand and don't forget this is also\nimportant that to our queue\nwe make sure to add the children of this\nnode so node.left\nand node.right technically these could\nbe\nnull but that's why we have this if\nstatement\nso then when the next loop comes around\nright we come around to the next\niteration\nof the while loop it'll make sure to\ncheck that these nodes are non-null\nbefore adding them to its own\nlevel list okay so now we have the loop\nin place that's going to iterate through\nevery node of a single\nlevel after we've done that entire level\nwhat we're going to do\nis take our result and make sure we add\nevery single level\nto that result right and then we're\ngoing to keep running\nthis outside while loop the outer while\nloop\nuntil there are no nodes left\nin our queue that's how we know we've\ngone through every single level\nadded it to the result and then at the\nend we can finally return the result\nand one last thing we want to do is make\nsure that\nif we're adding a level to the result we\nwant to make sure that level is\nnon-empty because we know technically\nour queue could have\nnull nodes we're not adding null nodes\nto the level list so\nwe want to make sure that level is\nnon-empty if we're adding it to the\nresult\nwe can run the code and see that it does\nwork and it is pretty efficient this is\na breadth-first search\nlevel order traversal of a binary tree\nand we did it in linear time and i hope\nthat this was helpful\nif it was please like and subscribe it\nsupports the channel a lot\n"
    },
    {
        "Name": "Binary Tree Right Side View",
        "NcLink": "binary-tree-right-side-view/",
        "Pattern": "Trees",
        "Description": "You are given the `root` of a binary tree. Return only the values of the nodes that are visible from the right side of the tree, ordered from top to bottom.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d348893a-8917-456c-9599-c405cfc4e000/public)\n\n```java\nInput: root = [1,2,3]\n\nOutput: [1,3]\n```\n\n**Example 2:**\n\n```java\nInput: root = [1,2,3,4,5,6,7]\n\nOutput: [1,3,7]\n```\n\n**Constraints:**\n* `0 <= number of nodes in the tree <= 100`\n* `-100 <= Node.val <= 100`\n",
        "Difficulty": "Medium",
        "Video": "d4zLyf32e3I",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        q = deque([root])\n\n        while q:\n            rightSide = None\n            qLen = len(q)\n\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    rightSide = node\n                    q.append(node.left)\n                    q.append(node.right)\n            if rightSide:\n                res.append(rightSide.val)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today\nso today let's solve binary tree right\nside\nview the problem is pretty\nself-explanatory we're given a binary\ntree\nand basically imagine you're standing on\nthe right side of it so this is the tree\nimagine we have a person standing over\nhere right you can see\nfrom the right side you can see\neverything on the right side\nand so what nodes can this person see\nwell they can see\nthe root node right there's nothing\nblocking that they can see\nthis node can they see two well you\ncan't really see two because it's behind\nthis node right it's basically blocking\nit's blocking this node right\nand the same thing with these two nodes\nright we can see four because it's the\nright most right like\nimagine the person sees this but you\ncan't really see that\nbecause it's being blocked by the four\nso\nthat so when you just look at this\nexample this problem seems really easy\nright so your first thought might just\nbe okay start at the root\nand keep going to the right\nright just keep going down and we'll get\nthe right side view right every node on\nthe right side\nbut we can make a counter example pretty\neasily to show that that actually won't\nalways work imagine this node 5\nhad a left child right like let's let's\nsay it has 7\nover here now now you can see that our\nresult is going to be\none three four we can't include these\nnodes because they're being blocked\nbut there's nothing over here right the\nseven is not being blocked so if this\nwas our input tree then\nour output would be one three four and\nwe'd have to add a seven to that because\nlook at our person\nthey can technically see down here so\nbasically what this means is we can't\nonly look at the right children right\nso you can actually solve this problem\nwith a breadth first search i know most\ntree problems you can just do depth\nfirst search but this problem can\nactually be solved with breadth first\nsearch there actually\nis a depth first search solution but i'm\ngoing to explain the breadth first\nsearch solution\nto you because in some ways it's easier\nand you might know brett's first search\nin a tree is also known as level\norder traversal so it's also known as\nlevel order traversal which\nyou're gonna see why it's called that\njust about now\nso instead of saying that there's a\nperson over here that can see\nonly the right side of the tree another\nway of framing this problem is saying\nokay for each\nlevel right each level of the tree we\nwant the\nright most node so the first level it's\npretty easy because there's only one\nnode\nso we'll just take the one from that\nwhat about this\nlevel right we look at the nodes\ntogether for this level we want the\nright most so we get the three\nnext we want the third level\nand what's the right most value it's\ngonna be the four right\nand lastly we take the last\nlevel and there's only one node it's\nseven\nso we're going to get d7 so with a\npicture this is pretty\nobvious right it's really easy to know\nwhat we're doing with a picture but\nactually\nwriting the code for level order\ntraversal is a little bit tricky\nand i'm gonna show you how to do that\nbasically how we're gonna implement this\nis with a q data structure so initially\nwhat we're gonna do\nis add the root node to our queue so\nwe're gonna add\none to our queue and we're also going to\nhave a result\narray so now what we're going to do is\ntake a look\nat our rightmost value in the queue it's\n1\nso we're going to add 1 to our result\nnext now we're no longer looking at this\nnode we are looking at\nits children basically the next level so\nwe can get that by taking the left and\nright child\nand adding them to our q and removing\nthe leftmost value from our q so we add\nthe two\nand the three to the q and it's\nimportant that we do it\nin order right the left and right the\nleft has to be added\nfirst and then the right because we\nalways want to get the right most value\nwhen we you know add to our result so\nnow\nthis is the second level of our\nuh tree right so what are we going to do\nagain we're just going to take the\nrightmost value in this case it's 3\nadd it to our result and next what we're\ngoing to do is we're going to look at\nthe\nleftmost value pop it right but before\nwe pop it we want to take its children\nnotice it doesn't have a left child\nright that's null and the right child is\n5. so we're going to take its children\nand add them to the queue so now we're\nadding\n5 to the q so we're done with 2. next we\nhave to remove\n3 from our cube because we're done with\nthis level we want to look at the next\nlevel\nso we remove three but before we remove\nthree we have to add its left and right\nchild\nnotice it doesn't have a left child but\nit has a right child four so we're going\nto add four to our q\nso now look at our cube we have two\nelements and these two elements\nrepresent the third level so what we're\ngoing to do\nnow is take the rightmost value once\nagain\nin our queue and add it to our result\nbecause that's\nthe rightmost value in this level\nof the tree and now we're going to\nrepeat that process so for five we're\ndone looking at five but we have to look\nat its left and right child it has one\nchild\nseven so we remove five and we add\nseven to our q and we also look at four\nso\nwe're done looking at 4 right so we pop\nit but before we pop it we want to look\nat its children notice\nboth of the children are null so\nbasically we've reached our base case\nwe don't end up adding more elements to\nthe q\nin this case and now there's only a\nsingle\nelement remaining in our queue and that\nelement represents the fourth\nlevel of our tree and the rightmost node\nin that level is seven so we can add\nseven to our result\nand we know we still have to remove\nseven now right so remove seven from our\nq\nnotice it didn't have any children right\nboth of the children were\nnull so we've reached our base case we\ncannot add\nany more elements to the queue therefore\nthe queue is now\nempty so now we can stop running our\nalgorithm we know that our result\nis complete we have no more nodes left\nto traverse\nso now let's translate this into code so\ni'm going to initialize a\nempty result i'm also going to have a\nq so in python we can do that like this\nit's called a dec and i'm going to\ninitialize it just like i did in the\npicture with a single element\nand that's going to be root now it's\npossible that root\ncould be null so technically it's\npossible that our q\ncould have null values and i'm going to\nshow you how i'm going to handle that\nso while the queue is non-empty that\nmeans we can\npop elements from the queue so i'm going\nto get\nthe right side element from this current\nlevel i'm initially going to set it to\nnull\nand i'm going to get the current queue\nlength\nright the current length of the queue so\nright now imagine\nit's just a single level right our q at\nany given point contains\none level at a time so for this level\ni'm gonna get the length\nand then what i'm gonna do is go through\nevery element\nin this level so for only q length right\nthe initial\nlength because we know this q is going\nto continuously be\nupdated so i'm going to go through every\nelement\nand i'm going to pop it so q pop\nleft right we know we're popping\nelements from the left and we're adding\nelements to the right\nnow we know the node actually could be\nnull so what i'm going to check is\nif node is not null if it is null then\nwe can just go to the next\niteration of the loop so if it's not\nnull what i'm going to do is update our\nright side\nto that node so you can see that after\nthis entire\nloop is done executing what right side\nis going to have\nis the last node that was in\nthis current level of the queue and\nsince this node is not\nnull i'm just going to take its children\nso\nso node.left and i'm going to append\nthat to our queue\nand also i'm going to take node.right\nand append it to the queue\nnow it's technically possible that these\nchildren could be null\nbut we know that if they are in the next\niteration of the while loop\nwe'll come back here and we'll verify\nthat the nodes are non-null\nbefore we you know update our right side\nand it's also important that you add the\nleft node\nbefore you add the right node and after\nthis\nafter this for loop is done executing\nwhat we have done is taken every node in\nthe current level\npopped it right that's what the pop is\ndoing and taking\nall the children of that level and added\nthem to the queue so basically what\nwe've done is removed\nthe elements from the previous level and\nadded the elements from the next\nlevel so that's good and the other thing\nthat we did is we took the right side\nthe right\nmost node in that level and had it\nstored\nin the right side variable so now we can\ntake\nto our result we can take that right\nside variable and append it to the\nresult\nbut not just uh right side we actually\nwant right side dot\nvalue because we're trying to append the\nvalues and it's actually technically\npossible\ninitially right side was null in one of\nthe base cases\nyou know the right side could actually\nbe null\nonce we've reached the last level so\nwe're going to verify that\nright side is non-null so once we've\ndone that\nand once this cue is empty meaning we've\ngone through every single\nlevel of the tree then all we have to do\nis return our result\nso there it is it's a pretty efficient\nsolution even though this percentage\ndoesn't indicate that\nso i hope this was helpful if you\nenjoyed like and subscribe it supports\nthe channel a lot\n"
    },
    {
        "Name": "Count Good Nodes In Binary Tree",
        "NcLink": "count-good-nodes-in-binary-tree/",
        "Pattern": "Trees",
        "Description": "Within a binary tree, a node `x` is considered **good** if the path from the root of the tree to the node `x` contains no nodes with a value greater than the value of node `x`\n\nGiven the root of a binary tree `root`, return the number of **good** nodes within the tree.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9bf374f1-71fe-469e-2840-5d223d9d1b00/public)\n\n```java\nInput: root = [2,1,1,3,null,1,5]\n\nOutput: 3\n```\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/8df65da7-abac-4948-9a92-0bc7a8dda100/public)\n\n**Example 2:**\n\n```java\nInput: root = [1,2,-1,3,4]\n\nOutput: 4\n```\n\n\n**Constraints:**\n* `1 <= number of nodes in the tree <= 100`\n* `-100 <= Node.val <= 100`\n",
        "Difficulty": "Medium",
        "Video": "7cp5imvDzl4",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def dfs(node, maxVal):\n            if not node:\n                return 0\n\n            res = 1 if node.val >= maxVal else 0\n            maxVal = max(maxVal, node.val)\n            res += dfs(node.left, maxVal)\n            res += dfs(node.right, maxVal)\n            return res\n\n        return dfs(root, root.val)\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve count good nodes in a binary\ntree this is according to leak code this\nis microsoft's most asked question of\n2021 so far and in my opinion it's\nactually a pretty good problem to\nunderstand a lot of good fundamental\nknowledge can be gained from this\nproblem so we're given the root of a\nbinary tree that is going to always be\nnon-empty we want to count the number of\ngood nodes in the tree and a good node\nis defined so for example take node x it\nis defined as a good node if for example\nlet's take this node 4 if from the path\nfrom the root node all the way down to\nthis node this path in particular if\nthere are no nodes in this path that\nhave a greater value than this\nparticular node so basically along this\npath if there isn't any value larger\nthan 4 then this node 4 counts as a good\nnode what about 1 let's take the path\nfrom the root to 1.\nare there nodes greater than the value 1\nalong this path yes because this node 3\nis greater than this node 1 so then 1 is\nnot a good node so we can solve this\nproblem in linear time big o of n time\nwhere n is the number of nodes and\nmemory complexity is going to be log n\nor in other words the height of the tree\nwhich technically could be greater than\nlog n it could be as big as n\nand we can accomplish this with a simple\ntree traversal in particular we're going\nto be using pre-order traversal meaning\nwhen we recursively run dfs on this\nwe're going to process each node before\nwe do recursively the left subtree and\nrecursively the right subtree so the\nfirst question is is the root node\ntechnically a good node well\nthis is basically the entire path are\nthere any nodes greater than three no so\ntechnically yes the root node does count\nas a good note so what we're going to do\nnow we've counted one as\nwe found one good note and now we want\nto know how many good nodes are there in\nthe left subtree and how many good nodes\nare there in the right subtree well\nfirst let's do the left subtree even\nthough we could do it in the opposite\norder but i'm just going to do the left\nfirst so\nto count how many good nodes are in this\nleft subtree first we have to we have to\nrun the dfs on the left child but before\nwe do that we have to pass to this left\nchild we have to pass what's the\ngreatest value we have seen so far we\ndon't have to pass all the values we've\nseen so far we just have to pass the\ngreatest because then we're going to\ncheck for every node is this\nis the greatest node that we've seen so\nfar somehow greater than this node if it\nis then this is not a good node so to\nthis node we're gonna pass the value\nthree we're gonna now process this the\ngreatest we've seen so far is three one\nis smaller than that this is not a good\nnode so this does not count but we still\nhave to recursively run dfs on the left\nand right now when we do run dfs on the\nleft obviously it doesn't have a right\nsubtree but on the left subtree what\nvalue are we going to pass here well we\nwould want to take the max of 3 which\nwas the parents max and the value here\nof course one is smaller than three so\nwe're going to pass three to this uh\nnode as well so so far the max we've\nseen is three\nis is the max greater than this node\nit's not so even though they're the\nexact same value this still counts as a\ngood node so that's what we learned and\nso\nnow we have seen two good nodes so far\nnow the same thing we're going to do on\nthe right subtree literally the exact\nsame thing just recursively doing the\nsame thing we're going to pass 3 to this\nnode because 3 is the max value we've\nseen so far from the root right if there\nwas a really big value here we wouldn't\nwant to transfer it to the right subtree\nbut we're counting from the root\ndownwards so let's look at four is this\nmax value greater than four it's not so\nthen four does count as a good node\nnow let's do the same thing for the left\nsubtree but when we go to the left\nsubtree we're not passing three we're\npassing four because so far now along\nthis path the max value we've\nencountered is four so we're going to\npass four to this child node one now\nobviously four is greater than one so\nthis does not count as a good node same\nthing on the right node we're going to\npass 4 down to this node the max we've\nseen so far is 4 but this value 5 is\ngreater than it 4 is not greater than 5\nso this counts as another good node so\nall together you can look we have one\ntwo three four good nodes and\nwe would you know from the root what\nwould we actually do we'd say okay we so\nfar we found one uh good node at this\nroot in the left right plus left this is\nbasically the equation we're going to\nuse one plus left plus right of course\nleft is actually going to be one because\nthere's one good node in the left\nsubtree right is actually going to be\ntwo there's two good nodes in the right\nsubtree so one plus one plus two that's\ngoing to be four so from the root we're\ngoing to return four good nodes in this\nentire tree so with that being said we\ncan finally jump into the code okay so\nwe know this is going to be a recursive\nfunction but in our recursive function\nwe're going to have to pass in more than\njust the root so which is why i'm going\nto define a separate function inside of\nthis function dfs obviously we're going\nto pass in the node or the root or\nwhatever you want to call it but we're\nalso going to pass in what the max value\nis so far from the path from the root\nall the way down to every particular\nnode and i didn't mention this but our\nbase case of course is going to be if\nthe node we reach is null right so if\nnot node now what are we going to return\nthen does an empty tree have any good\nnodes of course it doesn't so we're\ngoing to return 0 right ok so now we got\nto a node that is non empty we want to\nknow is this particular node a good node\nor not well let's\nlet's compute that into our result so\nwe're going to say okay result is going\nto be 1 if this node is a good note how\ndo we know if it's a good note if the\nnode value is greater than or equal to\nthe max value encountered so far\notherwise the result so far is going to\nbe 0 meaning this node is not a good\nnode next we want to do is update our\nmax value so far right we're just going\nto take the max of itself and the max of\nthe current node's value so we've\nupdated our max value so far why did we\ndo this because of course we're going to\nneed to pass this along to our dfs\nrecursive call of course we're going to\nrun dfs on the node's left child passing\nin the max value and of course we're\ngoing to do the exact same thing on the\nright child the right subtree passing in\nthe max value so far now what are we\ngoing to do with the results of these\ntwo recursive calls well this function\nitself is just counting the number of\ngood nodes so we're going to take the\nresult of it and add it to our result\nfor both of these function calls we're\ngoing to count the number of good nodes\nin the left and right subtree adding it\nto the result once that's been computed\nthen we can go ahead and actually return\nthat result value\nso you can see that this dfs is\nbasically computing the result that we\nwant of course we want to compute it for\nthe entire tree so when we actually call\nour dfs we're going to call it on the\nroot node now what default value can we\npass in for the max value so far well we\ncould pass in some kind of negative\ninfinity right or whatever but it\nactually works out as well if we just\npass in the root value because as long\nas this root is greater than or equal to\nthe max value so far it does count as a\ngood note and we know that the root node\nalways counts as a good node so this is\ngoing to work out for us now what we\nactually want to do is return the result\nof this function call and then we're\ngood to go\nas you can see it's pretty dang\nefficient so this is a good fundamental\nbinary tree question to understand your\npre-order traversal and it also happens\nto be the most common asked question by\nmicrosoft of 2021 so i hope that this\nwas helpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Validate Binary Search Tree",
        "NcLink": "valid-binary-search-tree/",
        "Pattern": "Trees",
        "Description": "Given the `root` of a binary tree, return `true` if it is a **valid binary search tree**, otherwise return `false`.\n\nA **valid binary search tree** satisfies the following constraints:    \n* The left subtree of every node contains only nodes with keys **less than** the node's key.\n* The right subtree of every node contains only nodes with keys **greater than** the node's key.\n* Both the left and right subtrees are also binary search trees.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/18f9a316-8dc2-4e11-d304-51204454ac00/public)\n\n```java\nInput: root = [2,1,3]\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6f14cb8d-efad-4221-2beb-fba2b19c8a00/public)\n\n```java\nInput: root = [1,2,3]\n\nOutput: false\n```\n\nExplanation: The root node's value is 1 but its left child's value is 2 which is greater than 1.\n\n**Constraints:**\n* `1 <= The number of nodes in the tree <= 1000`.\n* `-1000 <= Node.val <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "s6ATEkipzow",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def valid(node, left, right):\n            if not node:\n                return True\n            if not (left < node.val < right):\n                return False\n\n            return valid(node.left, left, node.val) and valid(\n                node.right, node.val, right\n            )\n\n        return valid(root, float(\"-inf\"), float(\"inf\"))\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today\nsolving validate binary search a very\ngood question for practicing binary\nsearch tree questions we're just given a\nroot of a binary search tree and we just\nwant to determine\nis it a valid binary search tree or not\nand from learning data structures and\nalgorithms you might know that a valid\nbinary search tree\nis such that we have a node\nlike two and every every\nsingle node in the left subtree one\nand if it possibly had other children is\ngoing to be\nless than two right so one is going to\nbe\nless than two and similarly every single\nvalue in the right subtree three\nincluding three's potential children's\nif it had any\nare going to be greater than\ntwo not greater or equal strictly\ngreater and we know this is a recursive\ndefinition so if\nwe had three and it had some children\nlike\nfive and maybe four over here we see\nthat it's not\na binary search tree because four\nshould be less than three four should be\nless than three but it's not\nso this is not a binary search tree so\nwe need to do\na recursive depth first search to solve\nthis problem\nbut let me show you what you might try\nyou might just try\na simple solution like hey five we have\nfive is the root\nlet's check its child okay three is less\nthan five that's good\nokay let's check the right child okay\nseven is greater than five that's good\nright\nokay let's now let's check seven because\nwe see three\nit doesn't have any children that's good\nfor us we don't have to check anything\nbut\nseven has a left child it has four as a\nleft child well\nthat's good four is less than seven\nand it has a right child eight that's\ngood\neight is greater than seven so is this a\nbinary search tree\nthe answer is no because\nit's really easy to miss we have a 5 as\nthe root\nwe have a right subtree over here and we\nhave a\n4 in the right subtree\nbut we know 5 is not less than 4\nthat's not true so we need a better\nalgorithm\nand it requires depth first search we\ncan't\njust check the neighbors so our brute\nforce approach would be\nfor five check every value in its left\nsubtree make sure that it's\nevery value is less than five and then\ncheck every value\nin the right subtree make sure five is\nless than every value in the right\nsubtree\nand so we would need n comparisons to do\nthat right\no of n and then we'd have to repeat that\nprocess for\nevery sub tree so seven we got to repeat\nthat compare it to\nevery potential descendant of itself\nwhich is going to be o of n and the time\ncomplexity of that\noverall is going to be o n squared so\ncan we do\nbetter than o of n squared so one\nthing to notice is the root value can be\nany value right there's no restrictions\non what the value can be\nbecause it doesn't have any parents so\nwe can say that\nit can be any value between negative\ninfinity\nand positive infinity and as long as\nthat's the case five is okay we don't\nhave to make\nany other comparisons five is between\nnegative infinity and positive infinity\nokay and then\nwhen we go down to the left subtree we\nknow five is good we don't even have to\ncheck it anymore\nbut when we go down to the left subtree\nwhat do we have to\ncheck all we have to check is that 3\nis less than 5 so in other words\nwe just want to make sure three is\ngreater than a negative infinity which\nof course it is\nand we're adding one more condition we\nwant to make sure\nit's less than five so\nour left boundary stayed the same but we\nhad to update\nour right boundary from up here\nright and so we're done with that and of\ncourse we don't have any children\nfor three and five of course we don't\nhave any children for three so\nwe are done checking three next\nwe want to also determine that the right\nsubtree\nis a binary search tree so we want to\nmake sure seven\nis greater than five but is there an\nupper boundary for seven like this could\nhave been a hundred\nor could have been anything so there's\nno upper boundary yet\nso we just need to check that seven is\nless than infinity\nmeaning that this is the right boundary\nand it's greater than\n5 so we had to update the left boundary\nover here when we went\nhere we only had to update the right\nboundary\nand this condition is true so\nwe are done checking 7 it is satisfied\nand when we go to the right child 8\nwe're going to do the same thing we only\nhave to\nupdate the left boundary so we have to\nmake sure that 8 is at least\ngreater than 7 but it could be\nanything so it's less than infinity so\nthat's good\n8 is a binary search tree\nbut now we get to the value that\nactually\nbreaks our binary search tree and let's\nsee what our algorithm\ndoes so we know since set four is the\nleft child of seven\nit should be less than seven\nfour is less than seven\nwe have to update the right boundary for\nfour\nbut the left boundary stays the same\nso we're getting the left boundary from\nover here we're borrowing it from its\nparent\nbecause if seven is greater than 5\nthen it's left child and 4 is a part of\nthe sub tree 4 must\nalso be greater than 5 so the left\nboundary is 5. now\ndoes this condition hold it does\nnot 4 is not between\n7 and 5 so this value breaks\nour binary search tree so therefore this\nis not a binary search tree\nit's false we're returning false and\nwith this algorithm since for each\nnode all we're really doing is making a\ncomparison\nwe're making a single or rather two\ncomparisons this is going to be\nbig o of n or uh 2n\nwhich we know is still linear so we can\njust call it big\no of n so now it's actually time to\nwrite the algorithm and the best way to\ndo this\nis recursively so that's what i'm going\nto do i'm going to write a helper\nfunction\nnested inside of this helper or inside\nof our original\nfunction we'll call it valid we know we\nneed to pass\nin the node since we are going to do\nthis recursively and we're going to have\ntwo boundaries\nleft and right boundaries like any\nbinary search recursive function\nif we reach a null node we can just\nreturn what are we going to return\nwe're going to return true because\ntechnically an empty binary search tree\nis still a binary search tree and then\nwe want to check\nwe want to make sure that node value is\nless than the right boundary\nand node value is greater than the left\nboundary\nbut we know if this is not true if\nthese conditions do not satisfy then\nwe have to return false because we found\na node that\nbroke our binary search tree and now\nit's time to make\nour recursive call so we want to make\nsure that the left subtree of node\nis valid so we can pass node.left and\nwhat's going to be the boundary\nfor these well since we are going left\nwe can leave the left boundary the same\nbut we're going to\nupdate the right boundary to the node's\nvalue because we know\nthat a left sub tree has to be less than\nevery value we know every value in the\nleft sub tree has to be\nless than the parent and so the parent\nis going to be set\nto the right boundary because we need we\nneed to make sure that this is going to\nbe\nless than that so we want to make sure\nthat the left sub tree is valid we\nalso want to make sure that the right\nsubtree\nis valid and in this case we're going to\ndo the opposite of what we just did\nso the left boundary is going to be\nupdated\nand the right boundary is going to stay\nthe same because we know\nevery value in a right subtree has to be\ngreater than the root or the parent node\nwhich is the left boundary and if both\nof these return true\nthen we can return true if they both\nreturn false\nthen we can return false so what we can\ndo is just\nreturn the result of this so whatever\nthis evaluates to\nis going to be our result we don't\nreally need any variables\nand now we just need to call the\nfunction that we just defined\nvalid we'll pass in the root we want to\nmake sure that this is a binary search\ntree\ninitially the left boundary can be set\nto negative infinity\nand the right boundary can be set to\npositive infinity because\nthe root value could be anything there's\nno restrictions on what the root value\ncan be\nand as you can see this is a super\nefficient solution\nbeats 97 percent and it doesn't take\nvery much code either so i hope this was\nhelpful\nif you enjoyed please like and subscribe\nand support the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Kth Smallest Element In a Bst",
        "NcLink": "kth-smallest-integer-in-bst/",
        "Pattern": "Trees",
        "Description": "Given the `root` of a binary search tree, and an integer `k`, return the `kth` smallest value (**1-indexed**) in the tree.\n\nA **binary search tree** satisfies the following constraints:    \n* The left subtree of every node contains only nodes with keys **less than** the node's key.\n* The right subtree of every node contains only nodes with keys **greater than** the node's key.\n* Both the left and right subtrees are also binary search trees.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/02eca3db-f72f-4277-7134-faec4f02e500/public)\n\n```java\nInput: root = [2,1,3], k = 1\n\nOutput: 1\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/dca6c42d-2327-4036-f7f2-3e99d8203100/public)\n\n```java\nInput: root = [4,3,5,2,null], k = 4\n\nOutput: 5\n```\n\n**Constraints:**\n* `1 <= k <= The number of nodes in the tree <= 1000`.\n* `0 <= Node.val <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "5LUXSvjmGCw",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        curr = root\n\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            k -= 1\n            if k == 0:\n                return curr.val\n            curr = curr.right\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nkth smallest element in a binary search\ntree\nso we're given the root of a binary\nsearch tree and an integer\nk and we want to return the kth smallest\nelement in the binary search tree right\nand so remember a binary search tree by\ndefinition means that it's in\norder meaning that for let's say 3\neverything in its left subtree is going\nto be\nless than 3. everything that's right sub\ntree is going to be\ngreater than three and so let's say k\nequals\none that means we want the one smallest\nelement\nin the binary search tree so if you put\nall four of these elements in order we\nget a one\ntwo three and four the smallest element\nis\none so then we can return one and now so\nyour first\nthought with this problem might be that\nokay so\nin order like you saw what i just did\nright i just took every element and put\nit in\norder and then took the kth element\nright and if k was 2 we would get the\nsecond element if k was 3\nwe'd get the third element right so is\nthere a way i can take this binary\nsearch tree\nand then put it into a sorted array or\nsomething\nand the answer is yes right because\nbinary search\ntree means that if we traverse this tree\nin order and then take each element and\nthen put it into an array\nthen we've basically solved this problem\nso for example we start at the root but\nwe don't\nvisit the value yet right we go to the\nleft child right and then we see okay it\ndoesn't have\na left subtree right doesn't have any\nleft child so then we visit one\nby that i mean we basically put it\ninside of our array\nthen we go to its right subtree we see\nokay two\nwe add two to the array and of course\nsince we know\nk is one we could actually stop here\nonce we visited the one\nbut we could also continue to add\nelements so then we'd pop back\nup to the three add the three and then\nwe go to the right child and then\nsee the four and add the four and so you\nknow\nthat writing an in-order traversal for a\nbinary search tree recursively is pretty\neasy right but\ni'm going to show you how to do it\niteratively which you might not\nknow yet but it's actually pretty\nsimilar to doing\nthe recursive solution so you saw how\nthe recursive solution works right let's\nsay we visit one\nthen we go to its right child right we\nvisit one and then we visit two and then\nwe end up having to\npop back up to the three right\nso to pop back up here we know the\nrecursive call will eventually\ncome back like with the call stack right\nthat's how function calls or method\ncalls\nwork but if we're doing it iteratively\nnot recursively right\nthen we need a stack to contain\nthe previous nodes that we need to pop\nback up to\nso i'm going to show you how to do this\nproblem with a stack iteratively\nso let's say that this is our stack\nso iteratively we start at the root\nright\nand we we're not going to visit this\nnode yet right\nso we're not going to count it as a k\nvalue yet because we want to go through\neverything in the left sub tree first so\nnext i'm just going to keep going as far\nleft as i can so i'm going to go to this\nnode right\nit's left child but before i go here i'm\ngoing to add the 3 to the stack\nbecause we know we want to pop back up\nto this 3 when we're done\ntraversing the left subtree so now i'm\nat the one i'm going to go to\nits left child right but we see it's\nnull\nright but before i go to null i'm going\nto add one\nto the stack but once we reach a null\ncase\nthat means it's time for us to pop back\nup and go back up to the previous node\nand we know that because we just look at\nthe top of our stack so we take this one\nwe remove the 1 and so basically when we\nremove an element from the stack that\nmeans we're processing it or\nvisiting it and we see k is equal to\n1 this is the first value that we just\nvisited right\nso then it must be the result so the one\nthat we just popped\nis going to be the output right but\nlet's say\nthat it wasn't let's just continue the\niterative solution just so you can kind\nof understand how it\nworks so now i'm at the one right\nwe just process the one we don't have to\never consider it again so i'm just going\nto cross it out\nbut now once we pop up right we visit a\nnode\nthen we want to go to its right child\nonly after we\nvisit the node after that do we want to\ngo to its right subtree right because\nremember we're trying to do this\nin order so\nwith three still remaining in the stack\nwe're gonna go to two right so now we're\ngonna\nadd two to the stack and now i'm gonna\ngo to the left child of two right we\nknow it's\nnull so so then we're allowed to pop\nback\nup right so we're gonna go to the two\nit's because it's at the top of our\nstack\nright so the 2 is at the top of our\nstack so now we're going to pop the two\noff\nso meaning we're processing the node 2\nor visiting it so we can cross it out\nnow\nand now i'm going to go to its right\nsubtree which is\nalso now null right because now that we\nprocess two we're allowed to go to its\nright subtree but we see that it's\nnull so since it's null that means we\npop\nagain from our stack right so we're done\nwith this null but\nconveniently for us we have a three at\nthe top of our stack we crossed these\ntwo values out\nso now we're going to automatically go\nback up here\nso we pop the three so now it's time to\nprocess the three right we process it we\nlook at it we visit it whatever you want\nto call it\nand after we visit it then we were\nallowed to go to the right\nsubtree so now we we're at four so we\nadd\nfour to our stack and you basically know\nwhat's gonna happen now we're gonna try\nto go to the left sub tree but it's\ngoing to be null\nso we pop from the from the stack so we\nprocess\nfour but then we try going to the right\nsubtree it's also\nnull so now that so now we look at our\nstack right we're going to pop again\nfrom our stack but our stack is\nempty right so that's how you know the\nalgorithm is done we visited\nevery node that we needed to and if you\nwere actually keeping track\nand you noticed the order that we popped\nthe elements in\nso basically the first element we popped\nfrom our stack was a one if you were\npaying attention\nafter that we did a two right we popped\nthe two\nand then we went back up to the three we\npopped the three\nand then finally we visited the four\nright so even though we did it\niteratively we visited the elements\nexactly\nin order so it's surprisingly the\niterative solution\nis not quite as hard as you might expect\nlet me show you the code for it now\nso i'm going to declare a variable n\nto basically tell us the number of\nelements that we visited from our tree\nonce\nn equals k that's how you know we\nvisited\nthe element that we wanted to and then\nwe can return that value\nand remember i'm also going to have a\nstack which is going to help us\nbecause we we need it because we're\ndoing this iteratively\nso i'm also going to have actually a\npointer cur\nit's going to initially point at the\nroot it's basically going to tell us\nwhat node that we're currently visiting\nor at the node that we're currently at\nand so i'm going to have a while loop\nbasically while current is not null and\nthe stack is non-empty we're going to\ncontinue\ntraversing our binary tree right that\nmakes sense so far\nand remember the first thing we want to\ndo is let's say we're at ker what are we\ngoing to do\nwhile current is not null we're just\ngoing to keep\ngoing left right remember we want to go\nthrough every node in the left sub tree\nbefore we visit the current node so\nwhile current is not null we're going to\nset current equal to current dot left\nbut remember before we do that we have\nto go back\nup to current after we're done\nprocessing current dot\nleft so before i do that i'm going to\ntake\nthe stack and add current\nto it and so when this loop is done\nexecuting that means current is at\nnull so that means we went too far and\nthat means we have to pop\nthe last element that we added to our\nstack so actually stack\npop we're popping the most recently\nadded value from our stack\nand we're going to set it to cur so now\nthat we popped this element\ncurve that means we're processing it so\nwhat we can do is actually\nupdate our n value that means n\nthat means we just visited another node\nso we can increment n\nby 1. and if n happens to be equal\nto k that means the current node that we\njust\nprocessed is the value we're looking for\nbecause remember we are\nlooking for the kth smallest element\nso if that's true then we can just\nreturn\ncurrent.value and we're done we don't\nhave to visit any extra elements\nbut what happens if this is not the case\nwell\nwe just processed current right that\nmeans\nthat we're allowed to now go to its\nright subtree so we can actually\nupdate current now and set it to current\ndot\nright and so what's gonna happen now\nwell the loop is gonna actually go back\nup if current dot write is non-null or\nthe stack is not null then we're gonna\nstart our loop and for that node we're\ngonna keep going left as much as we can\nmaybe it doesn't have a left\nsub tree so then this part isn't is not\ngonna execute and then we'll end up\nwe're gonna end up just popping again\nfrom our stack\nand conveniently for us in this problem\nwe're guaranteed to have at least k\nnodes in our tree so this\nis actually always going to execute\nwe're not going to end up\nexiting this while loop so we actually\ndon't even need a return statement over\nhere\nand this actually is the entire code let\nme just run it for you to prove that it\nworks\nand as you can see it's according to\nthis not pretty efficient but i'm pretty\nsure if i ran it again i would get a\nmuch more efficient time but you can see\nthis is the\niterative solution it's roughly this the\nsame time complexity as\nthe uh recursive solution and\nsurprisingly\nuh it's not that much code right like\nyou might expect the iterative solution\nto be more complex\nbut we're actually not doing anything\nfancy we're just going as far\nleft as we possibly can adding the\nvalues to the stack\nand then popping from the right when we\nneed to\nso i hope this was helpful if it was\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Construct Binary Tree From Preorder And Inorder Traversal",
        "NcLink": "binary-tree-from-preorder-and-inorder-traversal/",
        "Pattern": "Trees",
        "Description": "You are given two integer arrays `preorder` and `inorder`.\n        \n* `preorder` is the preorder traversal of a binary tree\n* `inorder` is the inorder traversal of the same tree\n* Both arrays are of the same size and consist of unique values.\n\nRebuild the binary tree from the preorder and inorder traversals and return its root.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/938c14d3-6669-47ab-924b-a1a08640f200/public)\n\n```java\nInput: preorder = [1,2,3,4], inorder = [2,1,3,4]\n\nOutput: [1,2,3,null,null,null,4]\n```\n\n**Example 2:**\n\n```java\nInput: preorder = [1], inorder = [1]\n\nOutput: [1]\n```\n\n**Constraints:**\n* `1 <= inorder.length <= 1000`.\n* `inorder.length == preorder.length`\n* `-1000 <= preorder[i], inorder[i] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "ihj4IQGZ2zc",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])\n        return root\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve a pretty fun problem\nconstruct a binary tree from a pre-order\nand in order traversal so we're actually\ngiven\ntwo integer arrays representing one\nthe pre-order traversal and two the\nin-order traversal\nof a binary tree and our\ngoal is to take these two traversals\nand the orderings of those nodes and\nthen can\nreconstruct basically the original\nbinary tree\nthat the traversals are from and it is\ntechnically possible\nthese two traversals have all the\ninformation we need\nwe just need to take that information\nand then deconstruct it\nand then reconstruct this binary tree\nfrom those so just to verify it let's go\nthrough this\ntree and actually do the pre-order\ntraversal first of all so\nfirst we know pre-order traversal is you\nstart at the root and then you process\nthe current node\nthen you do the left subtree then you do\nthe right subtree right\nso let's just let's just do the\npre-order traversal so we're starting at\nthe root we\ndo the root node first that's how\npre-order works so then we get a three\nnext we're going to go to the left sub\ntree and then\nand then do pre-order traversal on that\nleft subtree\nwe see nine right so we're going to add\nnine to our\npre-order traversal and it doesn't have\nany children so we're actually done with\nnine we're done with three now it's time\nto do the right subtree\nin pre-order traversal so we start at 20\nadd\n20 to our pre-order\ngo left we see 15 add 15 to the\npre-order\n15 doesn't have any children now we go\nto the right\nsubtree seven so add seven it's our last\nnode\nto the pre-order traversal right and\nthis actually take a look at this take a\nlook at all the values it matches\nexactly\nwith the input so this is the uh\npre-order traversal now let's just\nvalidate the in-order traversal\nas well inorder traversal is we start at\nthe\nroot right we take care of the entire\nleft subtree first then we take care of\nthe root node\nand then we take care of the right\nsubtree with\nin order traversal that's the general\norder so let's validate\nthe inorder traversal of this tree so\nwe're starting\nat one we're we're starting at the root\nthree but we're not going to add three\nyet first we're gonna do the left\nsubtree\nwe see we have a nine the nine does not\nhave any left or right children so now\nwe can add that nine\nto our inorder traversal remember we're\ndoing this in order\nleft to right we go back up to the root\nnow we can process the root we can take\nthree and add it to the inorder\ntraversal\nand now we're going to do the entire\nright subtree\nso we get to 20 but we're not we're\ngoing to wait for 20. we're going to\nfirst do the left\nsubtree 15 15 is the only value here so\nit doesn't have any children add 15 to\nthe inorder traversal\nnow we can add 20 because we've done the\nleft subtree\n20 is added and then last we go to the\nright subtree\nonly one value seven let's add that\nseven to\nour in order now let's take a look at\nthese\nfive values notice how they are the\nexact same\nfive values in the exact same order as\nthat in-order traversal that we were\ngiven\nso we can see that the\nthat what they gave us was correct but\nnow the question remains how can we\nactually take\nthese two uh arrays these two\ntraversals and construct this tree well\nit's definitely possible\nlet me show you how to do that right now\nso i just want to let you know that\nthere's actually\ntwo things two main facts that we're\ngoing to be using to construct this tree\nso the first\nfact is that the first value\nin pre-order traversal is always going\nto be the\nroot right we remember when we do\npre-order traversal right\nwe're always processing the root first\nso if i was taking\nthe pre-order traversal that we're given\nright we we\nremember this is the pre-order traversal\nthat we're given the\nfirst value in pre-order traversal is\nalways going to be the root so\nthis is the first value three it's\nguaranteed\nto be the root because that's how\npre-order traversal works the first\nvalue\nin pre-order traversal is always the\nroot node now we don't know about the\nrest of these\nright but we can recursively\nconstruct now the left subtree and the\nright subtree right we can\nwe can we're done with this three right\nnow our goal is to reconstruct the left\nsubtree\nhey lucky for us the first value here\nis always going to be the root of\nthe of the left subtree right because\nthat's how pre-order traversal works\nright\nso that's one thing that we're going to\nuse the first value is\nalways going to be the root and then we\ncan take the sub\nlist right we can remove the three we\ndon't need to look at it anymore then we\ntake the sub list and then\nbasically we're going to do this\nrecursively that's what i'm telling you\nokay we can construct the root but we\nneed more information than that right\nand then we're let's say we're done\nlooking at this three now i want to take\nthis uh array right and i want to know\nwhich values are going to go in the left\nsubtree and which are going to go on the\nright subtree\nfrom looking at the actual tree itself\nwe know the answer right we know that\nthis is where we're going to cut our\nlist right\nthe 9 is going in the left subtree\nright these three values are going in\nthe right subtree but how can we\ndetermine that\nwell that's what we need our inorder\ntraversal array for\nokay so now let's take a look at the\ninput array we're given for the inorder\ntraversal and by the way let me just\nmention that\nevery value in the traversal is\nguaranteed to be unique\nthat's true for both of the traversals\nthe inorder and the pre-order every\nvalue is going to be unique because\nevery value in the tree\nis going to be unique but okay so far we\nknow that this first\nvalue three is gonna be the root right\nso now let's\nfind three right we we know three is the\nroot right\nso we removed it from our first list\nbasically right\nbut now let's find it in our in\norder list we find it's right over here\n3 is in this index right so we know we\ndon't need this 3 anymore right we\nalready created that\nnode but so now what does\nthis in order array tell us\nnotice how this is convenient for us\nevery\nvalue to the left of the 3 that we just\ncreated the root from\nevery value over here which is only 9 is\ngoing to\ngo in the left subtree and every value\nto the\nright of 3 is going to go in the right\nsubtree that's\nreally convenient for us why is this the\ncase because that's\nbasically the purpose of in-order\ntraversal right\nit guarantees that we're going to go\nthrough the tree in order right from\nleft to right basically right so if we\nsee the three here\nand that's and this is the position in\nthe array we know everything\nhere is going to be in the left sub tree\neverything here is going to be in the\nright subtree that's what it tells us\nthis is really convenient for us because\nwe can count it right we can see there's\nexactly\none value that's going to go in the\nleft subtree and there's exactly three\nvalues that are going to go in the right\nsubtree so what we can do\nis we can take we can take the remainder\nof the pre-order\narray and then partition it right\npartition it over here because we know\none value is going to go in the left\nsubtree and three\nvalues are going to go in the right\nsubtree so that's what we're doing and\nwe're going to continue this right\nso now let's recur and by the way in the\ncode we're going to do this recursively\nlet's create the left subtree\nwe know that okay this is the in\norder portion right and this is how\nwe're gonna partition\nit from pre-order right we see this is\nthe array to create the left subtree the\nthing here is\nnotice how this is size one right\nthere's only one value here and there's\nonly one value here right that tells us\nthat the sub tree we're creating is only\ngonna have one node in it right so\nnine is the only node in the left\nsubtree so we're going to create that\nnode put the value there and now we're\nbasically\ndone with this left sub tree obviously\nbecause there's no more\nuh you know there's no more nodes left\nin this general area right this these\nvalues are reserved\nfor the right subtree this is reserved\nfor the right subtree\nokay so now we're looking at the\npre-order portion right there's three\nvalues just like in the in order portion\nand remember how are we gonna create the\nroot node of this subtree now we always\ntake the first value in pre-order\ntraversal it's\n20 right the value is 20 so we're going\nto take this\nvalue 20. we don't need it anymore\nbecause we're going to create a\na node from that value and so now we\nneed to know which values are going to\ngo in the left sub tree and which are\ngoing to go\nin the right subtree we know by finding\n20 right 20 is the value let's find 20\nin our in order traversal it's over here\nby the way in the code i'm going to be\ncalling the index of this\nmid so m for mid we find the\nindex of 20 right we know we don't need\n20 anymore so we can get rid of it right\nwe see that there's one value on the\nleft of 20\nand there's one value on the right of\n20.\nthis tells us that one value is going to\ngo in the left subtree and one value is\ngoing to go in the right subtree right\njust like we have over here\nso now let's construct that left subtree\nwe know it's going to be exactly size 1\nfrom looking over here so we take this\n15\nright where can we now our job is to\nrecursively create the left subtree\nwe're going to take this 15 since it's\nthe first value in the subarray for\npre-order right we know that it's going\nto be the root of\nthe current subtree we're at so let's\nget rid of this this 15.\nlet's create that node right 15 over\nhere is going to be a node\nand there's no more values left in this\nsubtree because we know it's only going\nto be size\n1. okay now we're creating the right\nsubtree\nwe know that there's only one value in\nthe right subtree from looking over here\nwith and since there's only one value\nleft in general it's a seven\nwe can make a node from it and then\nwe're done\nwe know we're done because we've\nbasically gotten rid of every single\nvalue\nin our arrays pre-order and in order\nso using these two arrays we were able\nto create our\ntree correctly and just let me just\nsummarize what we're actually doing\nwe're not doing a lot\nwe don't need a ton of information\nremember\nthe first value in pre-order\nthe pre-order array is always going to\nbe the root right that's just how it\nworks and then once we\ntake that value create a node from it\nand then when we try to\nlook that value up in in order traversal\nright\nthen we can get some subarrays\nright we can take we can take the length\nof the left\nand right sub array so the right sub\narray is three\nand the left sub array is one note\nnow these counts one and three they tell\nus\nhow to partition the pre-order traversal\nso take a look at the pre-order\ntraversal\none tells us that we're gonna cut over\nhere because this needs to be size\none this needs to be size three\nand then from this subarray this\nsubarray with only one value\nwe are going to recursively run the\nalgorithm\nto create this left subtree and with\nthis sub array we're going to\nrecursively run the algorithm\nto create this subtree and we're just\ngoing to continuously repeat that\nprocess until we get to our base cases\nand until we're finished with every\nsingle node that we need to create\nso now let me actually show you the code\nit's actually very short\nless than 10 lines okay so as i\nmentioned this is a recursive algorithm\nso we always want to start with the base\ncase and the base case is going to be\nwhat if we don't have any nodes\nto traverse through the two arrays that\nwe're given\nthat means we can return null or\nbasically we don't have to create\na tree so if pre-order is empty or\nin order is empty then we can return\nnull we have no values so we don't need\nto create a tree we can return null\notherwise we're going to create a tree\nnode right\nand what's the value of that tree node\ngoing to be well it's going to be\nthe first value that happens to be in\nthe pre-order\narray just like i showed you right\nalways going to be the first value so\nit's always going to be\nindex of zero and then whatever that\nvalue was\nwe want to find the position of it in\nthe in order array so inorder dot\nindex so we want the index of that value\npre-order of zero\nand we're going to get it in mid now\nthis is the part\nwhere we're going to build the subtree\nso root.left let's create the left\nsubtree and we're going to do this\nrecursively as i mentioned\nso self.build tree we're calling the\nfunction that we're\ninside of and the convenient part about\npython is we can do\nsublist so that's going to cut down our\ncode quite a bit so we need to pass in\nthe new\npre-order and in order arrays or the\nsub-arrays more likely so pre-order\nwhat are we going to pass in for the\nleft subtree of\npre-order well mid tells us\nmid tells us how many nodes we want the\nindex\nof basically the value of mid tells us\nhow many nodes we want in the left\nsubtree so what i'm going to do is for\npre-order\nwe're going to start at index one we're\nbasically skipping the zero index\nbecause we already just created a node\nfor the zero index we're starting at\nindex one going all the way\nup until mid plus one in python\nthis mid plus one is non-inclusive so\nthis sub array is really just\na pre-order from index one to mid so\nthat's what we're doing and we're going\nto pass in the in\norder portion that we need as well and\nthat's just going to be\nfrom the beginning up until mid but not\nincluding mid right\nthis probably makes more sense if you go\nback and look at the picture but\nbasically we're just creating the\nappropriate sub-lists\nthat we need to create the left subtree\nwe're going to do basically the exact\nsame thing with the\nright subtree and i would encourage you\nto draw this out\nyourself to basically reinforce what\nyou're learning or\nwatching me do right now so to build the\nright subtree\nwe need every value after this sub list\nright so we can just say starting at\nindex\nmid plus one going until the end\nof the list that's how you do it in\npython we're starting at mid plus one\nand going until the end of that\nsub list just like i showed in the\npicture and\nfor in order we can actually do the\nexact same thing\nwe want every node to the right of\nmid in in order right from our inorder\narray we want every value to the right\nof this\nindex mid so we can do that with mid\nplus one start starting at mid plus one\nand then going until the end of the\narray so now let me close this function\nand so this is literally all you have to\ndo the reason it's so easy\nis mainly because i'm using python but\nyou could you could\nread you could do this code without\npython it would probably just be a\ncouple extra lines\nyou might need to pass in a couple extra\nparameters into this build tree function\nbasically just these indices that i'm\ndoing you might not be able to create\nsub lists\nbut you can at least create you can at\nleast pass these indices into your\nfunctions\nin java and other languages so with that\nwe have actually created our\nuh tree so the only thing left for us to\ndo is return that tree\nso with that being said this is the\nfinal solution it's probably\nless code than you would have predicted\nbut the problem is a little tricky\nbut it's kind of enjoyable at least in\nmy opinion\nso i hope that this was helpful if you\nenjoyed please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Binary Tree Maximum Path Sum",
        "NcLink": "binary-tree-maximum-path-sum/",
        "Pattern": "Trees",
        "Description": "Given the `root` of a *non-empty* binary tree, return the maximum **path sum** of any *non-empty* path.\n\nA **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge connecting them. A node can *not* appear in the sequence more than once. The path does *not* necessarily need to include the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9896b041-9021-44c2-ab3e-5cff76adf100/public)\n\n```java\nInput: root = [1,2,3]\n\nOutput: 6\n```\n\nExplanation: The path is 2 -> 1 -> 3 with a sum of 2 + 1 + 3 = 6.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/19ce1187-387e-4323-f2c9-1a317ab36200/public)\n\n```java\nInput: root = [-15,10,20,null,null,15,5,-5]\n\nOutput: 40\n```\n\nExplanation: The path is 15 -> 20 -> 5 with a sum of 15 + 20 + 5 = 40.\n\n**Constraints:**\n* `1 <= The number of nodes in the tree <= 1000`.\n* `-1000 <= Node.val <= 1000`\n",
        "Difficulty": "Hard",
        "Video": "Hr5cWUld4vU",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        res = [root.val]\n\n        def dfs(root):\n            if not root:\n                return 0\n\n            leftMax = dfs(root.left)\n            rightMax = dfs(root.right)\n            leftMax = max(leftMax, 0)\n            rightMax = max(rightMax, 0)\n\n            res[0] = max(res[0], root.val + leftMax + rightMax)\n            return root.val + max(leftMax, rightMax)\n\n        dfs(root)\n        return res[0]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve binary tree\nmaximum path sum and yes this is another\nproblem from the blind 75 leak code list\nso this is a list of 75 common leak code\nquestions and today we're going to be\nsolving this tree question\nbinary tree maximum pathsome the link to\nthis spreadsheet will be in the\ndescription if you do want to take a\nlook\nand i think i've almost done all the\nproblems that i wanted to do from this\nlist nearly all of them so far\nso a path is defined in a binary tree as\nbeing a sequence of nodes where\neach pair of adjacent nodes in the\nsequence\nhas a can as a edge connecting them and\na node can only appear in the sequence\nat most once and the path sum of that\npath is defined as being the sum of all\nthe nodes values in that path\nso for example in this example we're\ngiven a tree\nand the path is basically going like\nthis right you see how you know we have\na node we go here\nand then we go here right it's it this\nis this counts as a path\nright even though it's even though from\nhere we're technically\nsplitting we're going left and right\nthis is still a you know a sequence of\nnodes right it could be read like\nin any direction but it's it's still\nlike a sequence and then when you take\nthat path you basically get one plus two\nplus three so that's going to be the\noutput\nnow of course in this problem we can\nactually have negative values so for\nexample this\n2 could be negative 2. so then what\nwould be the maximum path sum then well\nwe don't want to add negative values\nthat won't increase our total so\nin this case we're going to go from here\nto here right this is going to be our\npath 1 plus\n3 and then we would return 4. now what\nhappens if this negative\n1 this value was a negative 1 instead\nright\nnow we could just take 3 by itself that\ncounts as a path\nor we could take 2 by itself that counts\nas a path or we could\nstill take that same path which would\ngive us 2 minus 1 plus 3 which gives us\n4 and that is actually the max once\nagain\nso it's possible that negative values\ncould still be included\nin the output so you might think well\nwhat if we have a tree of\nall positive values like this one can we\njust take\nevery single node like basically like\nthis\nand call it a path and just add every\nvalue together well\nno and the reason is because some if\nwe had this structure right this isn't\nreally a path\nbecause how would you traverse it right\nwe could start here then\nyou know go go this way then go down\nbut then here we have to make a split we\ncan't go in two directions at once that\ndoesn't count as a path\nso basically what we realize is as we\nlook at this example is that\nif we're starting at a node we can only\nsplit once right like if we're here we\ncan split\nin two directions right we can include a\npath from here from the left side and\nthen we can also go here right\nand if we get to this portion right we\nalready had a split up above\nso we can't split twice right because\nthen it's no longer a path so\nwe can only choose one of these nodes we\nwould obviously choose the bigger one\nthat's a five\nright so take a look what would the sum\nbe if we ended up splitting from here\nthis is obviously the max we could\ncreate what is the total it's\nit's 1 plus 2 plus 3 plus 5 which is\ngoing to be 11.\nnow we can we're going to try it\nmultiple ways right\nit's possible maybe there could be a\nsplit over here of course this doesn't\nhave any children so the most we could\nget\ndoing that would just be a two but what\nabout over here what if we ended up\nsplitting from here so we\ntook the left and the right from here\nwe'd get a four\nand we'd get a five now if we did do\nthat notice how this is going to be the\ntop most node so whenever we\nsplit from a node we can't really get\nany of its parents or anything like that\nso in this case what is the sum of this\npath well\nit's going to be 4 plus 3 plus 5 which\nis going to give us 12.\n12 is greater than the 11 that we had\npreviously so this\nis going to be the max path sum so you\ncan tell that a brute force approach\nwould be for every single node\nevery single node consider it being the\ntopmost node and then from the left\nsubtree basically find what's the\nmaximum\npath we could create in the left subtree\nif we never split so we can't include\nboth\nleft and right and then do the same for\nthe right side right\nand if we sort of do it recursively we\ncan eliminate repeated work\nso suppose we're given that same tree we\nwant to we're going to start at the root\nnot like normal right so from here we\nwant to know what's the max path sum we\ncould do from here if we split\nfrom this position right going left and\nright now why start at the root when we\ncould solve the\nsub problem first and possibly use that\nsub problem in the result at the root\nposition\nso we're going to leverage that idea a\ndepth first search\nidea just like usual with tree problems\nand using that we're going to end up\ngetting a linear time solution\nand it's just going to depend on the\nreturn value of\nour recursive function so we're going to\nstart at the root\nand now we're going to go left right we\nwant to know what's the maximum\npath we can get from the left subtree if\nwe never\nend up splitting so in this case it's\npretty\nsimple because it doesn't have a left\nchild or a right child right so we don't\neven end up having to split and we get a\nsum of\ntwo from this spot right and even\neven if we were splitting from here we\nwould get a total of two so far so what\nwe'll say\nis so far the max path we've gotten so\nfar is two right\nnow we still want to know what's the max\nwe can get from this position so what\nwe're gonna do\nis now go to the right tree so\nrecursively now we're gonna ask the\nquestion down here what's the max path\nsum we can get if we ran\nit through this position and we ended up\nsplitting left and right\nand by the way our result so far is\ngoing to be two that's the maximum path\nso far that we've gotten\nso from here we're gonna since we're\ntrying to again find what's the max we\ncan get\nsplitting from here we're gonna go\nrecursive and we're gonna do that for\nthe left sub tree and the right subtree\nso\nwe're getting that same base case here\nright with this left sub tree if we\ntried to split from\nhere the max path we'd get is four\nbecause it doesn't even have any\nchildren right so let's keep track of\nthat the max\npath we could get from here is four now\nif we didn't split here we'd also get\nthat same value of four and that's what\ni'm marking here next to each note i'm\nmarking what's the max we could have\ngotten\nif we did not split i know it's a little\nconfusing and it'll make more sense when\nonce i actually finish the rest of this\nexample and so\nfrom over here now we do have what's the\nmax we'd get from the left path\nwithout splitting it's four but now we\njust want to do that for the right side\nonce again it's that same base case\nright so what's the max we could get\nrunning through here if we never split\nit would be five\nit doesn't have any children so we\ncouldn't split even if we wanted to\nso now we're at this node once again we\nhave computed the left\nand right sub problems now from this\nnode we're going to be computing two\ndifferent\nvalues by the way our result right now\nwould actually be 5 because that's what\nwe've gotten so far so\nfrom this position i'm computing two\nvalues i want to know\nwhat's the maximum sum we could get with\na path\nrunning from here if we are allowed to\nsplit so we are allowed to go\nright and we are allowed to go left so\nwhat would the total of that be well of\ncourse we would just take okay what's\nthe\nmax we could get from the left subtree\nwithout splitting right because we can't\nsplit again if we already split up here\nwe don't want to split again\nhere so what's the max we could get from\nhere if we never split well\nit would be four right and once again\nwhat's the max we would get from here if\nwe never split it would be five\nso up here i'm going to take three\nplus four plus 5 and say this is the max\npath\nrunning through here if we are allowed\nto split\nnow this isn't the value that i'm going\nto return to the parent\nthe reason i computed this value is so i\ncan potentially update the result right\nand we\nare going to update the result because\nthis is 12 so far our result is five\nso we can say that our new result now is\ngoing to be\n12. now what's the value i want to\nreturn\nup to my parent remember what this guy\nwanted to compute was what's the max\nit could have if it was allowed to split\nto the left and it was allowed to split\nto the right\nso from here on we don't want to split\ntwice\nso the question of i have for this node\nwhen we're returning up to our parent\nis what's the max i could get running\nthrough here if we are\nnot allowed to split so how am i going\nto get that well\ni can take this 3 and add it but then i\nhave to look at my left subtree\nand my right subtree and take the max of\nboth of these right i have to take the\nmax of them i can't choose\nboth so i have to choose one of them i'm\ngoing to take the maximum which is going\nto be\n5 so i'm going to say 3 plus 8\nthat's going to be the value that we\nreturn so notice how for each node i'm\nmarking what's the return value from\nthat node going to be\nso it's going to be 8 in this case so\nthen when i return back up to the root\ni'm going to say okay from here what's\nthe max path we could get well i'm going\nto take the note itself\n1 take the left which is 2 and take the\nright which is this path right notice\nhow we don't split\nit's going to be an 8 which is going to\ngive us 11. now that's not bigger than\nour result right so we actually\ndon't update the result in this case and\nof course this is the root node so it's\nnot going to end up returning to its\nparent but what if it did have a parent\nwhat would it return well we could only\nwe would take one and then add it to the\nmax of the left or the right\nof course the right is an eight this is\nthe path so we'd say one plus\na is going to be nine nine is what we\nwould return to our parent that's the\nmax path we can get from here without\nsplitting\nwhat would that path look like well of\ncourse it would just be this right\nnotice how this is a path\nit never splits so that is the main\nidea for this problem there's one last\nquick thing i want to go over\nso the return value of course is going\nto be for every node what's the max path\nwithout splitting and\nwe are going to still calculate what's\nthe max path with splitting and use that\nto actually update our result we're\ngoing to keep this as a global variable\nbecause it just makes the code easier\nbut it's actually it is possible to\nsolve this problem without using this\nglobal variable and by the way if you've\nbeen noticing we're only going to be\nlooking at each node once so that's\ngoing to be a time complexity of big o\nof\nn the memory complexity of course is\ngoing to be the height of the tree which\nis usually\nlog n if it's a balanced tree but one\nlast case\nremember this tree could have negative\nnumbers so for example let's say this\nwas a negative four\nand this was a negative five so then\nfrom this left subtree we would return a\nnegative four and from this we return a\nnegative five so then\nyou know when we're actually computing\nokay what's the max path that could run\nthrough here\nand let's say we're doing it for the one\nthat we can't split\nright where we don't split so we either\nchoose the left or the right\nand as i mentioned how we're doing it is\nwe're just taking the max of the two\nright so in this case we would take the\nmax of negative four\nand the max of negative five right and\nof course we'd say the max is negative\nfour so then\nwhen we're up here what we would end up\ncomputing is three plus negative four\nwhich is going to give us\nnegative one right negative one so what\nwe would say is okay the max we could\nget\nhere without splitting is going to be\nnegative 1 but that's not actually the\ncase right\nbecause th to get the maximum pat some\nfrom here where we're not allowed to\nsplit\nit doesn't necessarily mean we have to\ninclude the children right they're\noptional we could actually choose to not\ninclude either of these\nand that's what we would want to do\nbecause they're both negative\nanyway why would we want to include some\nnegative numbers so when we're actually\ntaking the max of the two\nwe're actually going to take the max of\nthree values we're going to take the max\nof the left right\nand potentially zero because if we just\nadd zero to it\nthis will stay the same so those are the\nkey ideas i wanted to go over\ni think that is enough for us to dive\ninto the code to solve this optimally\nso like i said we're going to have a\nglobal variable for the result\nand initially we're just going to set\nthat to the val whatever value happens\nto be at the root so the reason i'm\nmaking it a list is because that'll make\nit for\nthat'll make it so that we can modify it\nwithin the recursive function\na little bit easier so we're going to\nhave a recursive dfs\nwe're going to pass in whatever root\nnode we're traversing and that's really\nall we have to pass\nin so now the base case is that if we\ndon't have\na root like if the node is null in that\ncase what we're going to return is just\n0 that means we're not going to be\nadding anything\nand so we're going to be returning i\njust added a comment we're going to\nreturn from this function the max path\nsum without splitting\nso we want to get the max path sum so of\ncourse we have to do this recursively so\nlet's get the left max\nand we can do that recursively just pass\nin root.left if it's\nnull of course that's just going to\nreturn zero we're also going to get the\nright max\npassing in root.right so the first thing\ni'm going to do is compute\nthe max path sum with a split\nfrom this root node so basically what\ni'm going to do is i'm going to take the\nroot dot value\nand add it with the left max\nand the right max right because we are\nsplitting from this root node now of\ncourse these left and right maxes could\nbe\nnegative so what i'm actually going to\ndo before that is update them so\nwe're going to set left max equal to the\nmax of itself\nand 0 and do the exact same thing with\nthe right max so it's going to be set to\nthe max of itself\nplus 0. so here we're going to be\ncomputing the max path\nrunning through here so we're going to\ntake the root value the left max and\nthe right max add them together now this\ncould potentially be our new result so\nlet's see if it actually\nis so result at position 0 is going to\nbe set to the max\nof itself or this value that we just\ncomputed\nso this is the part where we're actually\ncomputing what could actually be the\nupdated result now what the return value\nremember of this function is not going\nto be the same as this the return value\nis going to be\nwhat we compute without splitting so the\nreturn value is going to be\nreturn root dot val plus whatever the\nmax\nof the left max and right max is right\nbecause we can't choose\nboth because if we choose both that\nmeans that we're splitting\nand so that's actually the entire\nfunction right you can see\nwhen we handle the recursive case well\nand we take the max of it\nand zero then we really just have two\nmain computations we're doing right\nthe max path sum with a split and the\nmax path sum without a split\nof course this one is going to be the\nreturn value and after we're done with\nthat all we do is call our dfs\npassing in the root and then that will\nupdate our global variable up above\nwhich is the\nwhich is the result then we can go ahead\nand return that result and that is the\nentire function\ni'll run it and you can see that it does\nwork now you might think it's a little\nbit cheating to even have a global\nvariable like this and it's actually\npossible to solve this problem pretty\neasily without a global variable 2. i\njust didn't show it\nthe main way you would do it is instead\nof you know computing this and updating\na global variable what we could do\nis take we could basically return two\nvalues from this function so we would\nreturn the max path sum with the split\nand the max path sum without a split so\ni hope that this was helpful\nif it was please like and subscribe it\nsupports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Serialize And Deserialize Binary Tree",
        "NcLink": "serialize-and-deserialize-binary-tree/",
        "Pattern": "Trees",
        "Description": "Implement an algorithm to serialize and deserialize a binary tree.\n\nSerialization is the process of converting an in-memory structure into a sequence of bits so that it can be stored or sent across a network to be reconstructed later in another computer environment.\n\nYou just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. There is no additional restriction on how your serialization/deserialization algorithm should work.\n\n**Note:** The input/output format in the examples is the same as how NeetCode serializes a binary tree. You do not necessarily need to follow this format.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a9dfb17f-70e9-42a3-ba97-33cfd82f6100/public)\n\n```java\nInput: root = [1,2,3,null,null,4,5]\n\nOutput: [1,2,3,null,null,4,5]\n```\n\n**Example 2:**\n\n```java\nInput: root = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The number of nodes in the tree <= 1000`.\n* `-1000 <= Node.val <= 1000`\n",
        "Difficulty": "Hard",
        "Video": "u4JAi2JJhI8",
        "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Codec:\n    \n    # Encodes a tree to a single string.\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        res = []\n\n        def dfs(node):\n            if not node:\n                res.append(\"N\")\n                return\n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return \",\".join(res)\n        \n    # Decodes your encoded data to tree.\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        vals = data.split(\",\")\n        self.i = 0\n\n        def dfs():\n            if vals[self.i] == \"N\":\n                self.i += 1\n                return None\n            node = TreeNode(int(vals[self.i]))\n            self.i += 1\n            node.left = dfs()\n            node.right = dfs()\n            return node\n\n        return dfs()\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nserialize and deserialize a binary tree\nbasically what we're trying to do is\nwe're given a binary tree right and we\nwant to write two functions for it\nserializing it and then deserializing it\nwhen we serialize we're taking an object\nright and this object\nin memory it could be anything right\nlike you don't know where this node\ncould be\nin memory you don't know where this node\ncould be we know that there's some links\nand stuff connecting them all together\nbut\nwhat we want to do is take this and put\nit into a very easy to read\nstring that could be passed around\neasily right so basically\nfor example we could convert basically\nwe could convert\nthis entire tree into a string something\nlike this right\none is the root node then there's a two\nthen there's a three then there's a\ncouple nulls because two doesn't have\nany children\nand then there's the other nodes four\nand five right basically\nthis is something that's easy to use and\npass around right\nand we also wanna be able to take a\nstring like this and then turn it\nback into a tree so we have to keep that\nin mind it's something that could be\nyou know taken back and forth easily\nreversed so there's a lot of different\nways to solve this problem\ni'm gonna show you a pretty easy and\nstraightforward way to do it\nyou could use breadth first search\nbasically taking the tree and then\nserializing it level by level\nand then you know reading through the\ninput level by level\netc but there's also a way to do it with\ndepth first search using\npre-order traversal and i'll show you\nthis way because it requires a little\nbit less code\nso like i mentioned we're going to be\ndoing this with pre-order traversal so\nlet's just see\nwhat would a tree like this if we\nconverted it into pre-order traversal\ninto the form of a string what would it\nlook like well obviously the first\nvalue is one so we're gonna say okay the\nroot note is one right that's what\npre-order means we're gonna do the first\nnode\nthen we're gonna recursively do the left\nsubtree with pre-order\ntraversal and then similarly after that\nwe're going to do the right subtree in\npre-order traversal\nnow obviously we want to be able to\nseparate values\nso we're going to use a comma as a\ndelimiter but you could use a space if\nyou really wanted to\nor use something else but i'll just use\na comma so now let's recursively do the\nsame thing for the left subtree so\nobviously we have a two\nlet's add that too because we're doing\npre-order and now let's do the left and\nright subtree of two so first let's go\nto the left subtree\nnow we're gonna see null right this is\nnull it's empty there's nothing there\nbut we are gonna add that to our string\njust to indicate to us that this\nleft portion of the subtree cannot be\ncontinued right and\nyou could add the word null but i'm just\ngoing to use a capital letter n to\nindicate that so that's going to be our\nspecial value that indicates an\nempty no node or empty tree since we\nfinished the entire left subtree and we\nknow that it was a null right so that's\nbasically our base case that tells us we\ncan't go any farther here so now what's\nour right subtree for two it's also\nnull so we're going to add another null\nand see how we've done the entire left\nsubtree here\nso now we can start going down the right\nsubtree\nso of course the first value is a three\nso let's go ahead and add that\nand similarly we're going to do\npre-order traversal on the left subtree\nnow you can basically see\nthis is the exact same thing that we did\nup here right\n2 was a node and two had no children so\nleft and right child of two were null\nthat's the same that's true for this\nfour node so we're gonna add\nfour and then we're gonna add the two\nnull nodes basically indicating that\nfour\ndoes not have any children n\nn so now let's go do the right subtree\nbasically you\ncan probably tell what i'm going to do\nhere so i'm running out of space so\nlet's put the five down here\ncomma and then a couple empty null nodes\nand now we're done right that was the\nentire string\nso now i'm going to get rid of this tree\nand we're going to see\nis it even possible for us to be able to\ntake a string like this\nand know exactly which one is going to\nbe the left node and which is going to\nbe the right etc etc right well we're\nobviously going to use\npre-order traversal on this string\nbasically\nto create a new tree and i'm going to\nshow you that it is\npossible that this string is actually\nnot ambiguous\nbecause clearly you can see okay one is\ngoing to be the root note then the next\nvalue must be the left if this were a\nnull\nthat would mean that one has no left\nsubtree right so we could just put\nnull for its left subtree but clearly\nthis is not null\nso that means two is the left child of\none\nnext we see okay let's create the\nsubtree for\ntwo right well it's left child is null\nand next it's right child is also\nnull so therefore two is not going to\nhave anything right so\nthat's basically the idea so now let's\nactually do it okay since we know we\ncreated the string with pre-order\ntraversal that's basically the idea\nwe're going to use so we're going to\nhave a pointer\nwe'll call it i that's going to\nbasically tell us what index\nof this string that we're at well in\nreality what we're going to do we're\nactually going to take this string\nand then split it based on the delimiter\ncomma so then it's actually going to be\nan array but i'm not going to redraw\nthat just because\nit's pretty straightforward what we're\ngoing to be doing with this string\nso first one is non-null so it's a one\nright so we\nare going to create a root node with the\nvalue one\nnow let's create the left sub tree\nsimilar to pre-order traversal right\nwe're creating the node now then we're\ngonna do the left subtree then we're\ngonna do the right subtree the question\nyou might have is\nhow do we know when the left sub tree\nstops\nand when the right sub sub tree starts\ni'm going to show you it's actually\nsimpler than you might think\nso we know that the first value here is\ngoing to be the left\nchild if this were null we would put a\nnull here but it's not null it's two so\nwe are creating a\ntwo node over here and once again\nrecursively creating\nthis subtree so start with the left so\nthis first value is going to be the left\nsubtree it's a\nnull right so since it's a null that\nmeans we can't continue\nthis subtree anymore right so that means\nwhatever value\nso we're done with this first null now\nwhatever value comes\nnext here is going to be the value in\nthe right subtree\nof this two node it happens to also be\nnull but maybe if it wasn't unknown\nmaybe it could have been a three right\nthat's when we would put three over here\nbut clearly it's not it's a null so that\nmeans\nwe can actually stop this subtree\nas well so since both of the children\nwere null\nthat means we're actually done creating\nthis entire subtree\nwe reached our base case basically so\nwe're done with this\nnow the next value that comes in our\nstring is clearly going to be the right\nchild of one so the three is gonna be\nthe right child\nhere and now of course pre-order\ntraversal we're gonna fill in the left\nsubtree of three so what's the next\nvalue\nin our string it's a four so this does\nhave a left subtree\nfour continuously we're going to be\ndoing the left subtree of four\nwe see it's a null that's our base case\nso we're done with the left sub tree of\nfour\nnext we're looking for the right subtree\nof four so what's the next value in our\nstring it's again\nnull so we reach the base case we can be\ndone\nwith this entire subtree so we're gonna\npop back up recursively over here to\nthree\nand now we know we need to fill in the\nright subtree it could be null or it\ncould be a real value let's find out\nwell the next value in our string is a\nfive so therefore\nthis is going to be five so next we see\nthat okay left child of five is going to\nbe null and\nright child of 5 is going to be null\nright so clearly what you can see here\nis that for every single leaf node we\nhave\nin our tree we we specified what their\nchildren were going to be we specified\nthe leaf node two has two null children\nleaf node four has two nulls and leaf\nnode five has two nulls\nthat's how you know we're done with the\nentire string we're\nwe're gonna stop here we know that\nthere's nothing left to do\nright every single leaf had null\nchildren therefore we can't possibly\ncontinue this tree right so we're done\nso that's why it's not ambiguous and by\nthe way what do you think the time\ncomplexity of this was well we know that\npre-order traversal is pretty linear\nright so\nbasically o of n for serializing and for\nd\nserializing this problem is actually a\nlittle simpler than you might think\nfor a hard problem at least so now with\nthat being said let's jump into the code\nso good thing for us we only have to\nfill in two functions so let's start out\nwith the serialize so we're going to be\ngiven a root node for a tree and we want\nto convert it into a string and then\nreturn that string so let's start\nwith a empty string initially right\nand actually just to make things a\nlittle bit easier i'm going to\nset our result to an array i'm basically\ngoing to be adding\nstrings together like for example if we\nhad a node 1 i'm going to add it like\nthis if we add a node 2 i'm going to add\nit\nlike this and then at the end i'm\nbasically going to be joining all the\nstrings together with a comma\ndelimiter so i'm going to define a\nfunction inside a function just because\nit's easier once again right so this is\ngoing to be our pre-order depth first\nsearch we are going to be passing in the\ncurrent root or the current node that\nwe're visiting\nand of course we know that the base case\nis if the node is\nnull and in that case what are we going\nto do our special character that we're\ngoing to define\nis going to basically be a n character\nso to result i'm going to append\nand end character and then we're going\nto return\nif it's not null then we know we can\nappend we can we're since we're doing\npre-order we're going to be appending\nbefore we recursively do depth for\nsearch we're going to append\nnode.val but we know it's going to be an\ninteger so we're going to we're going to\nconvert it into a string so node.val\nconverted into a string\nappended to result after that of course\nwe just call our recursive different\nsearch\non the left and right subtree so uh debt\nfor search on node.left\nand depth for search on node.right and\nwe don't even have to call our return\nfunction because once this is done\nexecuting it's going to basically return\nby default\nso once that is done we know that our\nresult is going to contain\nall the strings that we want it to so\nbasically what i'm going to do is return\nthe result joined by a\ncomma delimiter so comma dot join\neverything in result oh but i almost\nforgot we actually have to\nremember to call our debt for search\nfunction so i'm going to call it passing\nin the root value\nso our serialized function is actually\njust as simple as that so\nnext we're going to be moving on to our\ndeserialize function so we're going to\nbe given the data right\nwe know that the data is going to be\ncomma delimited so we're basically going\nto split it\nbased on that comma into an array a list\nof\nthe data that we're going to be needing\nso i'm just going to call that vals\nand i'm also going to create a pointer\ni'm going to call it self.i\nself because it's going to be a member\nvariable of this class\nbasically because we want it to be\nglobal because i'm about to define\nanother\nrecursive function inside of this\nfunction and i don't even need to pass\nany variables into it because\nthe self.i is global so i'm going to\ninitialize this to 0 indicating we're\ngoing to start at the first\nvalue in our list of values and so once\nagain we're going to start with the base\ncase now what's the base case going to\nbe well if our\npointer is pointing at a value in the\nvowels\nand if that value happens to be null now\nhow do we know if it's null\nwell that's pretty easy right we can say\nvals at index\nself dot i and if it happens to be equal\nto the character n\nwe know that's null so what are we going\nto do we're just going to return the\nbase case we're going to return\na null node if it's not null that means\nwe have some work to do right we have to\ncreate a tree node\nwith that particular value but we know\nthis valves\nat self.i we know this is going to be a\nstring right so\nand we know that tree nodes have integer\nvalues so we're going to convert this\ninto an\ninteger before we pass it in and so this\nnode is going to be referred to\nas node one thing i actually almost\nforgot\nif we're create if we're saying that the\nvalue at this vowels\nis null so we're basically saying we're\ndone visiting this right we're returning\nnull for this n in our values array so\nbefore we return we want to make sure\nthat we increment i so self.i\nplus one so that next time we go we call\na function\nthat we're at the appropriate value in\nour list of values\nand that's exactly what we're going to\nbe doing down here too right so since\nwe're already using\nthe value at self.i once we create this\ntree node we know we have to increment\nour pointer i so that we can be moving\non to the next\nvalue that we need to create a node for\nso i'm going to call depth first search\nremember we don't actually have to pass\nany parameters into this and the return\nvalue for this is going to be the sub\ntree i created\nfor node dot left it could be null\nor it could be something else now after\ncalling the step for a search function\nwe don't have to increment self.i\nbecause that's going to be happening\nrecursively so\nonce this is done we're going to do the\nexact same thing for the right subtree\nso\nuh node.write is also going to be\nbasically whatever debt for search\nreturns for us\nand once all of that is done we know\nthat we can simply return the node the\nroot node that we ended up creating\nand then once that's done we've\nbasically defined our debt for search\nfunction so what are we going to do\nwe're just going to call that debt for\nsearch function\nand return the result because for this\nfunction we're taking in a string of\ndata and then converting it into a tree\nand then returning that tree\nthis problem is not too bad if you do\nhave a pretty good understanding of\ndepth first search or pre-order\ntraversal or you know just\ngeneral binary tree traversals you could\ndo this with breadth-first search if you\nreally wanted to it just takes a little\nbit more code but you can see that this\nis a pretty efficient enough solution\nthis is about as good as it gets so i\nhope that this was helpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Kth Largest Element In a Stream",
        "NcLink": "kth-largest-integer-in-a-stream/",
        "Pattern": "Heap / Priority Queue",
        "Description": "Design a class to find the `kth` largest integer in a stream of values, including duplicates. E.g. the `2nd` largest from [1, 2, 3, 3] is `3`. The stream is not necessarily sorted.\n\nImplement the following methods:\n* `constructor(int k, int[] nums)` Initializes the object given an integer `k` and the stream of integers `nums`.\n* `int add(int val)` Adds the integer `val` to the stream and returns the `kth` largest integer in the stream.\n\n**Example 1:**\n\n```java\nInput:\n[\"KthLargest\", [3, [1, 2, 3, 3]], \"add\", [3], \"add\", [5], \"add\", [6], \"add\", [7], \"add\", [8]]\n\nOutput:\n[null, 3, 3, 3, 5, 6]\n\nExplanation:\nKthLargest kthLargest = new KthLargest(3, [1, 2, 3, 3]);\nkthLargest.add(3);   // return 3\nkthLargest.add(5);   // return 3\nkthLargest.add(6);   // return 3\nkthLargest.add(7);   // return 5\nkthLargest.add(8);   // return 6\n```\n\n**Constraints:**\n* `1 <= k <= 1000`\n* `0 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n* `-1000 <= val <= 1000`\n* There will always be at least `k` integers in the stream when you search for the `kth` integer.\n",
        "Difficulty": "Easy",
        "Video": "hOjcdrqMoQ8",
        "PythonSolution": "class KthLargest:\n    \n    def __init__(self, k: int, nums: List[int]):\n        self.minHeap, self.k = nums, k\n        heapq.heapify(self.minHeap)\n        while len(self.minHeap) > k:\n            heapq.heappop(self.minHeap)\n\n    def add(self, val: int) -> int:\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem k the largest element\nin a stream and it's marked as an easy\nquestion but i definitely feel that it's\nmore of a medium and maybe that's why\nmany people disliked it but we are told\nto design a class to find the kth\nlargest element in a stream of numbers\nso stream basically means that we could\ncontinue to add numbers to the list of\nnumbers after we do that we still have\nto find the kth largest element now that\nwe've added more numbers to it and they\nsay that the kth largest element is the\ncase largest in the sorted order not\ndistinct and what they mean by that is\nbasically that if we had you know this\nuh list of numbers and k equals three\nmeaning we want the third largest number\nif we look at the distinct values we'd\nsay okay three is the largest two is the\nsecond largest and one is the third\nlargest but they say we want to return\nthe case largest in sorted order meaning\nthis is the first largest this is the\nsecond largest and this is the third\nlargest so we return two we're not just\nlooking at distinct elements if we have\nmultiple copies we include those as well\nthe good thing is we only need to\nimplement two functions one is the\nconstructor where we'll be given the\nparameter k that we can store and an\ninitial list of numbers and this list of\nnumbers it could be at least k elements\nor it could be less than k elements or\nit could be more than k elements so\nthat's something we're gonna have to\ntake care of when we do write out the\ncode uh but the second function is the\nadd function where we can actually add a\nnumber to the stream of data and this\nfunction is also going to return the new\nkth largest element every time we call\nit so\nthey do tell us that whenever we call\nthis function we are guaranteed to have\nat least k elements in the stream of\ndata so that's good even though we might\nnot have k elements when we initialize\nit we will have k elements when we call\nthe add function so now the question is\nhow can we efficiently solve this\nproblem well suppose we were given this\ninput right in our constructor this\narray and k equals three of course the\nintuitive approach is to sort the input\nso that we can uh you know look through\nand find the kth largest element a\nlittle bit faster right in the original\narray we could just scan through the\nentire input and that'd be o of n to\nfind the kth largest but when the array\nis sorted though we can of course use\nbinary search which will run in log n\ntime but the problem is if we want to\ninsert a new value for example we want\nto run add on the value three well yeah\nwe can run binary search to add the\nnumber as well we can find where to\ninsert it but when you insert in the\nmiddle of an array it's a linear time\noperation big o of n so the question is\nis there a better approach is there a\ndifferent data structure we can use and\nyes there actually is and the data\nstructure that's going to help us the\nmost in this case is a min heap and we\nare going to require it to be of size k\nand let me tell you why well first of\nall a heap is a data structure if you\nhaven't heard of it that has a somewhat\nsorted property we can add and pop\nelements from the min heap in log n time\nwe can also get the minimum value of the\nmin heap in big o of one time obviously\nthis is a little bit better than an\narray especially an unsorted array like\nwe are given in the input but the\nquestion is why are we going to require\nit to be of size k and why are we using\na min heap rather than a max heap well\none thing we are going to use to our\nadvantage is that we're only going to be\nadding elements to our stream of data\nwe're never really going to be removing\nanything so in this example we're given\nfour numbers but we only need a min heap\nof size k because we only need the k\nlargest values from the array in this\ncase it's four five and three why is\nthat why do we never need the two\nbecause we want the third largest value\nthis is the largest this is the second\nlargest this is the third largest so we\nhave three numbers that are bigger than\ntwo is two ever going to be the third\nlargest value in our stream of data it's\nnever going to be because we're never\ngoing to remove any of these elements\nright we might add elements we might add\na value like six if we add this six\nvalue then we don't want to include this\nf this four anymore then we only want to\nkeep track of these three numbers six\nfive and eight and now this is going to\nbe the third largest number five is\ngoing to be the third largest number two\nis never going to be included in this\ngroup two is never going to be in our\nmin heap of size k if we added a small\nelement to our stream like a 1 well we\ndon't care about a 1. now in terms of\nthe code and how we're going to\nimplement this we're going to have a min\nheap of size k first of all what we're\ngoing to do to get this heap is we're\ngoing to take this entire input and add\nit to the min heap right so suppose we\nhave four five and eight in our min heap\nnow we're going to do a while loop while\nthe size of the heap is greater than k\nwe're gonna pop the minimum\nvalue in this case the minimum is 2\nwe're going to pop it thankfully now our\nheap is size k exactly so we don't need\nto continue to pop elements and remember\nour min heap we can get the minimum\nvalue and since we have these are the\nthree largest values we want the third\nlargest which is going to be the minimum\namong all of these i hope now you can\nsee why we're using a min heap because\nwe can get the minimum in o of one time\nbut the add function over here requires\nus to add a value to our stream of data\nso for example suppose we want to run\nadd 3\nwell how do we know if 3 is included\namong our k largest values well the\neasiest way to do it there's multiple\nways but the easiest is just to take\nthat 3 and add it to our min heap so now\nwe have 4 values in our min heap and we\nwe added it in log n time now we want to\npop the minimum value from this min heat\nbecause we want the third largest value\nwe have four values in the heap let's\npop the smallest one which is three we\ncan do that again in login time and now\nwe want to know okay among the remaining\nwhat's the smallest value again it's\nfour so as you can see we can do the add\nfunction in log n time how many times\nare we going to run the law in the add\nfunction who knows let's call it m and\nthen this is going to be the overall\ntime complexity of add if we count all\nthe function calls that are made to it\nnow in terms of our\nconstructor function actually generating\nthis entire heap it's potentially going\nto be n log n in the worst case reason\nbeing is we can actually initialize the\nheap like this is our input data we can\nturn it into a heap in o of n time\nthat's not too bad but then remember\nwhen we started with the array we had\nthis two right we have to keep popping\nelements until we only have k elements\nremaining so\na pop function is gonna be log n time\nhow many times are we gonna have to pop\npotentially n minus k times so this is\nthe overall time complexity k could be\nreally small it could be one so you know\nworst case we could have n log n for our\nconstructor but the add function is just\ngoing to be log n that's a big\nimprovement over the first solution we\ncame up with which was uh end time when\nwe were just using a array structure so\nheaps definitely help us out a lot now\nwe can go ahead and code this up now\nlet's code it up first thing we're going\nto do is the constructor you can see i\nhave one comment that hopefully will\nhelp guide us\nin the code so we can create a member\nvariable with the self keyword in python\nso first we want to create our min heap\nand we also want to have another member\nvariable for k which is you know going\nto be the size of that heap or at least\nthe desired size of it so min heap\ninitially can just be assigned to nums\nand our k is just going to be assigned\nto the input parameter k we want to turn\nthis into a heap right now it's just a\narray we can turn it into a heap in\npython like this heap q dot heapify\nkeepifying this array into a min heap\nthat will create the sorted property it\nwill run in big o of n time but it could\nbe that it has more than k element so\nwhile the length of self.min he is\ngreater than k we can go ahead and pop\nfrom the min heap we can do that with\nheap q dot heap pop\non the min heap data structure and don't\nforget the keyword self since it's a\nmember variable so the constructor isn't\ntoo bad now let's do our add function\nthere's multiple ways you could write it\nbut the easiest way is just to go ahead\nand add this value to our min heap\nregardless of what it is if it's too big\nor if it's too small who cares we can go\nthis value\nand then we're gonna pop the smallest\nvalue which might end up being this\nvalue or it might end up being a\ndifferent value who knows let's go ahead\nand just pop it and our heap data\nstructure will actually take care of\nthat for us anyway\nbut there's actually just one edge case\nthat you might miss remember our heap\nmight be initialized with less than k\nelements this loop will execute if it\nhas more than k elements which is good\nbut what if it has less than k elements\nthen if we add a value to the heap we\ndon't want to pop from the heap if it\nhas less than k elements or even equal\nto k elements we only want to pop if the\nlength of the min heap is greater than k\nelements so if it's greater than k\nthat's when we want to pop from the min\nheap but once we've done that we make\nsure our heap is valid it does have k\nelements we're guaranteed that when the\nadd function runs so now we just want to\nreturn the minimum from our min heap and\nthe way heaps are implemented the\nminimum value will always be stored in\nthe zeroth index so we can just go ahead\nand return\nthis\nand don't be dumb like me we forgot to\nwhen we're referencing min heap and the\nk value we want to make sure we\nreference it as a member variable so\nlet's use the keyword self\nself.min heap okay it looks good to me\nlet's run it to make sure that it works\nand as you can see on the left yes it\ndoes work and it's about as efficient as\nwe can get so i really hope that this\nwas helpful if it was please like and\nsubscribe it really supports the channel\na lot consider checking out my patreon\nwhere you can further support the\nchannel and hopefully i'll see you\n"
    },
    {
        "Name": "Last Stone Weight",
        "NcLink": "last-stone-weight/",
        "Pattern": "Heap / Priority Queue",
        "Description": "You are given an array of integers `stones` where `stones[i]` represents the weight of the `ith` stone.\n\nWe want to run a simulation on the stones as follows:\n\n* At each step we choose the **two heaviest stones**, with weight `x` and `y` and smash them togethers\n* If `x == y`, both stones are destroyed\n* If `x < y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nContinue the simulation until there is no more than one stone remaining.\n\nReturn the weight of the last remaining stone or return `0` if none remain.\n\n**Example 1:**\n\n```java\nInput: stones = [2,3,6,2,4]\n\nOutput: 1\n```\nExplanation: \nWe smash 6 and 4 and are left with a 2, so the array becomes [2,3,2,2].\nWe smash 3 and 2 and are left with a 1, so the array becomes [1,2,2].\nWe smash 2 and 2, so the array becomes [1].\n\n**Example 2:**\n\n```java\nInput: stones = [1,2]\n\nOutput: 1\n```\n\n**Constraints:**\n* `1 <= stones.length <= 20`\n* `1 <= stones[i] <= 100`\n",
        "Difficulty": "Easy",
        "Video": "B-QCq79-Vfw",
        "PythonSolution": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n\n        while len(stones) > 1:\n            first = heapq.heappop(stones)\n            second = heapq.heappop(stones)\n            if second > first:\n                heapq.heappush(stones, first - second)\n\n        stones.append(0)\n        return abs(stones[0])\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem\nlast stone way so this is an easy-ish\nproblem i would say\nbut we're also going to be solving the\nsecond version of this problem last\nstone weight 2\nprobably tomorrow or the next video that\ni upload\nso the context is that we're given a\ncollection of stones\neach stone has a positive integer weight\nso greater than zero weight\nand each turn we can choose\nthe two heaviest stones and then smash\nthem together now what happens when we\ntake the two heaviest stones\nand mash them together well in one case\nif they are the exact same weight both\nof the stones are going to be destroyed\nif they are not the exact same weight\nthen\nthe smaller stone is going to be totally\ndestroyed\nbut the larger stone is going to\nbasically be\nthe difference between the weights so\nfor example let's say we had two stones\nfive\nand four this is the weight of the\nstones they're not equal so\nwhen we smash them together the smaller\nstone four is going to be destroyed\nand the larger stone is going to be\nbasically\na five minus four that's what its\nremaining weight is going to be so\nyou know we take the we start with two\nstones and then we get reduced to a\nsingle stone the smaller stone gets\ndestroyed\nthe larger stone is going to be five\nminus four that's a one\nso that's kind of what happens when we\nsmash two stones together\nat the end there is going to be at most\none stone left and it could technically\neven be\nzero stones if there aren't any left so\nwhat do we want to return we want to\nreturn the weight of whatever stone\nhappens to be left\nover if we don't have any stones left\nover\nthen we can just return a 0 as the\ndefault value\nso i will say that this problem is\nsomewhat straightforward let's take a\nlook at one of the\nexamples and the reason this problem is\nstraightforward is\nthey gave us basically all the\ninstructions and the information that we\nneed and all we really have to do is\nkind of\nsimulate these instructions we don't\nactually have to find a clever way to\nsolve this problem we just have to\nsimulate what they told us that's pretty\nmuch the best we can do\nwhat did they tell us to do they told us\nto always take the two\nheaviest stones and then smash them\ntogether how are we gonna\nget suppose we had a bunch of stones\nlike this\nhow are we gonna get the two heaviest\nstones\nof course we could sort the array that's\none solution\nbut even if we did sort the array you'll\nfind that\nit's a valid solution but you know when\nwe're taking the two heaviest\nseven and one we're smashing them\ntogether and then we're gonna basically\nbe introducing a new stone right so\neight minus seven is going to be the new\nstone one and then we're gonna\nto maintain the sorted property of this\nlist we're gonna have to insert this in\norder which\nmight be a little bit annoying but i\nthink it is a valid solution but another\nsolution\nis going to be using a heap not a min\nheap in this case but we're actually\ngoing to be using a max heap\nbecause we're going to be taking the max\nstones each iteration in order to take\nthis\ninput array and transform it into a max\nheap is actually an\no of n time operation uh with the\nheapify function\nbut every time that we want to actually\nget the maximum from here\nthat's going to be a log n operation and\nhow many times potentially are we\nactually going to need to get the\nmaximum\nfrom here n times so n multiplied by log\nn\nthat's what's going to be the overall\ntime complexity\nof this solution now how is it actually\ngoing to work\nwell basically as i mentioned we're\ngonna simulate so\nwe're gonna assume we have a max heap\nhere we're gonna get the largest stone\nit's gonna be an eight we're gonna get\nthe second largest stone it's gonna be\na seven we're gonna smash them together\nwe have eight\nand seven smashing them together seven\nis smaller so this is going to be\ndestroyed\neight is gonna be transformed into a one\nnow so we can let's just introduce\nanother one\nto this list and we're gonna continue\nthe simulation right we're gonna get the\nnow two biggest stones it's gonna be a\nfour\nand a two what's going to happen with\nfour and\ntwo well two is smaller so that's gonna\nbe destroyed\nfour is going to basically be four minus\ntwo which is gonna be two\nso we can insert that into our max heap\nso now we're gonna insert a two\nnow we are left with it's a little bit\nmessy but we're left with\na two a one and a couple ones\nso when we smash these two together\nwe're actually gonna be left with a\nsingle one i won't\ndraw that because i think at this point\nyou probably get the idea then we're\nleft with three ones\nwhat's going to happen with these three\nones well two of them are going to be\nsmashed together\nand then we're left with a single one\nleft and we have nothing left\nwe have no other stones to smash this\none with\nso when everything is said and done we\nwill be remaining\nwith a single stone so we can go ahead\nand return uh\none as the return value and you know it\ncould have been a little bit different\nit could have been\nsomething like okay we're left with two\nones then they get smashed together and\nthen we have\nnothing left so then if we had nothing\nleft we could return a zero but that's\nnot the case in\nin this example we do end up returning a\none as you can see\ndown here this problem is pretty\nstraightforward if you have a decent\nunderstanding of\nheaps and their time complexities in\nthis case the only tricky part for us in\nthe code\nis going to be python does not actually\nhave max heaps\nso we're going to have to use a min heap\nto basically simulate a max heap and you\ncan do that\nby basically you know assume we had some\nkind of heap we would want eight to be\nthe maximum value and then suppose we\nhad some other values three and five\nbut this is how a mac a real max heap\nwould work\nbut if we are actually implementing this\nwith a min\nheap it's going to be the opposite of\nthis but we still want 8 to be\nthe the value that we get from the root\nso what we're going to do is actually\nhave negatives\nwe're basically gonna multiply every\nvalue in the heap\nby negative one so that the minimum\nwhich is\neight negative eight in this case is\ngoing to be popped when we want the\nmaximum and then when we pop this we're\ngonna get negative eight but we can just\nconvert it we can get the absolute value\nof this\nand then just convert it back into an\neight that's kind of how\nunfortunately we're gonna have to do\nthis in python in other languages i\nthink you can just get a regular max\nheap\nbut i think that's all the information\nwe need now we can hop on into the code\nbut before i do let me just give you a\nvery quick word from our sponsor for\ntoday\ninterviewing dot io if you want to get\nhired\nat top tech companies like google\nfacebook and\namazon then you need to check out\ninterviewing dot io\nyou'll practice realistic coding\ninterviews\nwith senior engineers who will give you\ndetailed feedback\non exactly what you need to work on they\nhave the\nlargest network of vetted and\nexperienced\ntech interviewers in the world so you\ncan book an interview\nwith as little as 24 hours notice\nand the best part you don't even have to\npay\nuntil you get hired please check out the\nlink in the description below\nfor more details okay so now let's get\ninto the code like i said we're going to\nbe writing the simulation\nfor this problem and so the first thing\nwe want to do is put all of these stones\ninto a max heap\nnow python does not have max heap so\nwe're gonna put these in a min heap but\nwe're gonna multiply every one of these\nvalues by negative one we're gonna make\nthem negative\nso in python what i'm doing right now is\nbasically just going through every\nsingle stone\nand putting it into a list uh and\nmultiplying each zone by negative one\ni'm putting the negative of that stone\nin\nthis list and now i want to turn this\nlist into a\nheap so what i'm going to do is heap q\ndot heapify\nthis stones this is a linear time\noperation\nso now we're good to go now we can start\nrunning the simulation\nand remember we want to continue this\nwhile the number of stones is greater\nthan one if we have one stone or if we\nhave zero stones\nthat's when we can stop the simulation\nbut until\nthen we are going to take the two\nlargest stones\nhow can we get them well we're gonna pop\nfrom\nthe min heap we can do that like this\nheap q dot heap\npop from the max heap not min heap\nso pop from stones and we can that'll\ngive us the largest\nand this will give us the second largest\nuh stone\nand remember if the stones are equal\nthat's basically we wouldn't have to do\nanything right we just remove\nthese two stones from the heap and if\nthey are equal\nweights then we don't really have to do\nanything we're not going to add them\nback to the heap we don't have to we\ndon't have to do anything\nbut in the other case if the second\nstone that we popped was less than\nthe first stone that we popped and why\nam i saying second stone well because\nthe second stone is going to have a\nsmaller weight than the first stone or\nequal weight right because it because\nwe're popping the first one that one is\nsupposed to be the heaviest stone\nbut we you know we're doing it this way\nbut\nremember we made all the weights\nnegative so\nwhat we actually have to do is the\nopposite of this case if second\nis greater than first suppose we popped\nyou know this is kind of an example\nsuppose the first stone had a weight of\neight in that case it would have a value\nof negative eight\nand the second one had a weight of seven\nuh\nand the value would be negative seven in\nthat case then of course\nnegative seven is a greater value than\nthe first stone right\nso that means basically this second is\nthe smaller stone and we have to destroy\nsecond and how are we gonna do that well\nbasically we already popped it from the\nheap so we don't actually have to\ndestroy it all we have to do is take\nthe difference between these two and\nthen add that back into the heap now how\nare we going to take the difference\nfirst of all a heap q dot heap push is\nhow we can actually\nadd to the heap so we're going to add to\nstones whatever that value is how are we\ngoing to get the value\nwell obviously the value in this case\nwould be a 1 right if we took it 8\nsubtracted 7 from it we'd be left with a\n1. how can we do that computation\nwell basically you can just take second\nsubtracted by first\nif that kind of confuses you if these\nnegatives and kind of that math confuses\nyou\nyou can convert these into absolute\nvalues if you want so you know you can\ntake the first\nand second and convert them into the\nabsolute value then the math will be\nstraightforward\ni don't really want to waste you know\ntoo much time writing that code out and\nthis kind of does make sense to me so\ni'm just going to keep it\nshort and concise i'm just going to take\nsecond subtracted by first\nwhich will give us the which will give\nus the weight that we want to add right\nwe want to add\na stone of weight one but remember in\nour heap we are keeping track of\nnegative values\nso i would have to i would have to\nmultiply this by negative one uh\nthe easier way to do this is just to\ntake first subtracted\nby second which will give us the exact\nsame thing it'll give us the negative\nthat value that we're looking for it'll\ntake the difference between these and\nthat difference will be negative right\nwe'll have\nfirst which is negative eight plus seven\nwhich is going to be a negative one\nwhich is you know what we want in this\ncase so i hope that makes sense it's a\nlittle bit confusing\nbut basically this is our case and that\nis the entire simulation code once we're\ndone with that\nwe can go ahead and return whatever the\nvalue of the stone happens to be the\nremaining stone so stone at index\nzero but don't forget we actually do\nhave negative values right so when we\nreturn\nthe value of that stone we want to\nreturn the positive value so we're going\nto take the absolute value\nof this stone and also don't forget\none last edge case what if stones was\nempty\nright what if we didn't have any stone\nleft in here\nwell one way to handle that edge case is\njust to take\nbefore we return just say stones dot\nappend a\nzero so in that case if there's already\na stone in\nthis list we'll we'll end up returning\nthat stone because it'll be at index\nzero\nif there's not a stone then we'll add\nthis\nzero stone and then we'll end up\nreturning that zero\ninstead so this basically works out in\nall cases which is what i'm getting at\nso i hope\nthis was helpful as you can see this\nsolution does run and it is pretty\nefficient sometimes it's more efficient\nthan other times so i hope that this was\nhelpful if it was\nplease like and subscribe it supports\nthe channel a lot\nand i'll hopefully see you pretty soon\nwhen we solve the second version of this\nproblem last stone weight 2 which is a\n"
    },
    {
        "Name": "K Closest Points to Origin",
        "NcLink": "k-closest-points-to-origin/",
        "Pattern": "Heap / Priority Queue",
        "Description": "You are given an 2-D array `points` where `points[i] = [xi, yi]` represents the coordinates of a point on an X-Y axis plane. You are also given an integer `k`.\n    \nReturn the `k` closest points to the origin `(0, 0)`. \n\nThe distance between two points is defined as the Euclidean distance (`sqrt((x1 - x2)^2 + (y1 - y2)^2))`.\n\nYou may return the answer in **any order**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ffe90895-5c8e-47f1-6719-d5c0f656d700/public)\n\n```java\nInput: points = [[0,2],[2,2]], k = 1\n\nOutput: [[0,2]]\n```\n\nExplanation : The distance between `(0, 2)` and the origin `(0, 0)` is `2`. The distance between `(2, 2)` and the origin is `sqrt(2^2 + 2^2) = 2.82842`. So the closest point to the origin is `(0, 2)`.\n\n**Example 2:**\n\n```java\nInput: points = [[0,2],[2,0],[2,2]], k = 2\n\nOutput: [[0,2],[2,0]]\n```\n\nExplanation: The output `[2,0],[0,2]` would also be accepted.\n\n**Constraints:**\n* `1 <= k <= points.length <= 1000`\n* `-100 <= points[i][0], points[i][1] <= 100`\n",
        "Difficulty": "Medium",
        "Video": "rI2EBUEMfTk",
        "PythonSolution": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        minHeap = []\n        for x, y in points:\n            dist = (x ** 2) + (y ** 2)\n            minHeap.append((dist, x, y))\n        \n        heapq.heapify(minHeap)\n        res = []\n        for _ in range(k):\n            _, x, y = heapq.heappop(minHeap)\n            res.append((x, y))\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem k closest points\nto the origin so let's take a look at\nthis example and you can't really see it\nwell but they have a couple points so\nthere's one point over here and there's\none point over here so we have a list of\npoints right we could have a bunch more\npoints right anywhere on this\ntwo-dimensional grid we have an x-axis\nand a y-axis so each point is\nrepresented by a pair of values this\npoint is 1\n3 this point is negative 2\n2\nright and so we can have a bunch more\npoints and we want to return from the\nentire list of points we want to return\nthe k closest points to the origin now\nthe origin is the\ncenter which is zero zero right so which\nof these points is the closest to the\norigin and in this case we have k equals\none so from these two points we just\nwant to return the single point that is\nthe closest to the origin and we're\nguaranteed that the solution is going to\nbe unique so there's never going to be a\ntie or anything like that but it could\nbe you know\nin this case we have k is 1 it could be\nk is 2 k is 3 or something if we had a\nbunch more points so we just want to\nfigure out efficiently what are the k\nclosest points to the origin now the\nfirst thing is how do we know how far\nany given point actually is from the\norigin you know you might remember from\nyour you know high school math class or\nin this case they actually tell us the\nactual formula which does make things a\nlittle bit easy so it's basically taking\nthe x difference right so in this case\nfor this point the x difference is going\nto be 1 minus 0 plus the y difference in\nthis case the y difference is going to\nbe three minus zero and each of these is\ngoing to be squared because you know\nthat's kind of how it works a squared\nplus b squared equals c squared this is\nthe formula we're using so if we want to\nfind c which is going to be the actual\ndistance we'll take a squared plus b\nsquared and then take the square root of\nthe entire thing to actually find c so\nyou know finding the distance we can do\nthat a squared plus b squared taking the\nsquare root but in this case we actually\naren't required to find the square root\nbecause we're not actually trying to\nreturn the distance we're just trying to\ndetermine which point is the closest so\nyou know for example let's say we had\nsomething like this that totaled up to\nfive right and we had another one that\ntotaled up to 4. if we take the square\nroot of 2 or 4 that's going to give us 2\nif we take the square root of 5 is going\nto give us 2 point you know something\nsomething so we're not required to take\nthe square root because we just want to\nbe able to compare which one is greater\nright obviously if 5 is greater than 4\nwe know that that the square root of 5\nis also going to be greater than 4 so\nwe're not technically required to\nactually take that square root and i\ndon't know why i'm making this such a\nbig point it's just that it's kind of\neasier to code it up then if we don't\nactually have to take the square root we\njust take the absolute difference\nbetween the x\nsquare it the difference between the y\nsquare it and then add them together\nthat will be enough for us to compare\ntwo points and to figure out which one\nof them is actually closer to the origin\nso once you have that down how can we\nactually find the k closest points we're\nnot just finding the single closest\npoint that would be easy but we're\ntrying to find k of the closest points\nwell the the easiest and simplest idea\nthat you might think of is just sorting\nright so if we have a list of size n and\nfor each one of these points we you know\ncompute this\ntake the x difference y difference\nsquare it right and use that value to\nsort the entire list of points the time\ncomplexity of that is going to be n\nlog n because we're sorting the entire\nlist and then once we have that right\nlike let's say we had\nwhat you know three values or something\nwe just wanted the first two which is k\nand then we can just iterate through the\nlist and find k so the k is not really\ngoing to change the time complexity the\ntime complexity is going to depend on\nthe n log n sorting but since we're only\nlooking for k points right we don't\nactually need to sort the entire thing\nwe just need the k closest points so\nactually this problem can be\nreduced or slightly simplified if you\nuse a min heap and that's going to be\nthe solution i'm showing you if you\nyou know if you already know how to use\na min heap you can probably skip to the\ncoding portion or you know solve this\nproblem yourself a min heap is a good\nway to solve this problem but i'm going\nto analyze it for you right now so let's\nstill take the simplified example so\nlike i said the first thing we're going\nto do for every point so we have the\npoint 1\n3 and we want to know the distance\nbetween it so we can say okay 1 squared\nplus 3 squared which is going to give us\n10 so this is you know the distance\nactually isn't 10 but that's going to be\nthe value we use to compare we're not\ngoing to take the square root because we\nactually don't need to the other one\nnegative 2\npositive 2 is going to be 2 squared plus\n2 plus negative 2 squared which is you\nknow just going to be 2 squared as well\nso\ntaking both of these together is going\nto be\na distance of 8 so\nthe next thing we're going to do is\ntake these right notice how we put the\ndistance as the first value because when\nwe put this in a min heap we want this\nto be the value that we order it by so\nwe're going to take this and we're going\nto run the function heapify which is not\nn log n heapify is actually a linear\ntime algorithm so it'll basically take\nall of these put them into a heap in o\nof end time so now\nyou know let's say that all of these are\nin our min heap what are we going to do\nwe want to pop from this heap k times\nbecause we want every time we pop we\nwant to pop the closest one which is in\nthis case going to be this point right\nand of course k in our example is only\none but obviously this solution could be\ngeneralized to if k was two three or\nbigger right so in this case how many\ntimes are we gonna pop from the min heap\nobviously k times we only need to find\nthe k closest points and what's the\noperation for for popping from a heap\nit's going to be log the size of the\nheap which is worst case going to be n\nso this time complexity is actually\ngoing to be a little bit better it's\ngoing to be k log n that's why a min\nheap solution is slightly more efficient\nbecause if k is relatively small it's\ngoing to be a lot better than something\nlike n log n right this is much smaller\nthis is much faster so that's kind of\nthe idea at this point you probably know\nhow to code it up but you know just to\nfinish the example k is one we pop from\nthis one time are we gonna pop this one\nor this one obviously this one has a\nsmaller distance so we pop this one and\nthen we take it append it to our result\nand we we only append the coordinates\nthe coordinates were negative two\npositive two right we don't actually\nhave to append the distance or anything\nso this will be added to our result and\nthen we're going to return that result\nright we only need to pop once\nand we can return that you can see up in\nthe result over here at the top that's\nexactly what they did they just returned\na list of one point\nso that is the main solution now we can\ngo ahead and code it up so now let's\nactually code it up and like i said\nwe're going to be using a min heap so\ninitially a min heap is just an array or\na list in python so what we want to do\nis we actually want to go through every\npair of points every x y in the input\nlist points and we want to go ahead and\nactually compute the distance so how can\nwe compute the distance for every point\nwell it's pretty much just going to be x\nsquared plus y squared right so we can\ntake x in python you can take x to the\npower of 2 like this plus y to the power\nof 2 like this and add those together we\njust won't take the square root because\nwe're lazy and we know that we don't\nactually need to take the square root so\nthen to our points or rather to our min\nheap we can append to it this uh point\nthat we just calculated right so we'll\nappend the three values we talked about\nthe distance is gonna go first because\nthat's the key value for our min heap\npython will use that the first value by\ndefault and we're going to also append\nthe coordinates of this point as well\nand now that we have all those points in\na list obviously that this operation was\na linear time operation now we're also\ngoing to do a linear time operation in\npython we can turn that list into a heap\nlike this\nheapq.heapify that list so it'll reorder\nthe list to make sure that it is in the\nstructure of a heap and we also want to\nhave a list for the result right we're\ngoing to pop k times so while k is\ngreater than zero we're going to keep\npopping from our min heap we're gonna\nsay heap q dot heap\npop from the min heap and whatever value\nis popped we're gonna append it to the\nresult just like this but actually i\njust realized we're actually popping\nthree values from it so before we append\nit let's get the three values we're\npopping the distance the the\nx-coordinate and the y-coordinate from\nthe min heap and once we pop those three\nvalues to our result itself we're only\nappending two values the coordinates the\nx and y coordinates and we're gonna do\nthat k time so let's make sure to\ndecrement our k value and so once we've\npopped from it k times we can go ahead\nand return the result that we just\ncreated and as you can see the solution\nworks and it is pretty efficient i think\na sorting approach would be about as\nefficient but this is slightly better in\nsome cases so i hope that this was\nhelpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Kth Largest Element In An Array",
        "NcLink": "kth-largest-element-in-an-array/",
        "Pattern": "Heap / Priority Queue",
        "Description": "Given an unsorted array of integers `nums` and an integer `k`, return the `kth` largest element in the array.\n\nBy `kth` largest element, we mean the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nFollow-up: Can you solve it without sorting?\n\n**Example 1:**\n\n```java\nInput: nums = [2,3,1,5,4], k = 2\n\nOutput: 4\n```\n\n**Example 2:**\n\n```java\nInput: nums = [2,3,1,1,5,5,4], k = 3\n\nOutput: 4\n```\n\n**Constraints:**\n* `1 <= k <= nums.length <= 10000`\n* `-1000 <= nums[i] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "XEmy13g1Qxc",
        "PythonSolution": "# Quick Select\n# Time complexity: O(n) in average, O(n^2) in worst case\nclass Solution:\n\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        k = len(nums) - k\n        left, right = 0, len(nums) - 1\n\n        while left < right:\n            pivot = self.partition(nums, left, right)\n\n            if pivot < k:\n                left = pivot + 1\n            elif pivot > k:\n                right = pivot - 1\n            else:\n                break\n\n        return nums[k]\n\n    def partition(self, nums: List[int], left: int, right: int) -> int:\n        pivot, fill = nums[right], left\n\n        for i in range(left, right):\n            if nums[i] <= pivot:\n                nums[fill], nums[i] = nums[i], nums[fill]\n                fill += 1\n\n        nums[fill], nums[right] = nums[right], nums[fill]\n\n        return fill\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem kth largest element in\nan array so we're given an integer array\nnumsend and integer k we want to return\nthe kth largest element in the array by\nlargest they mean largest in sorted\norder not the largest distinct element\nso we could have duplicates in this\narray and so when they say let's say a k\nequals one ray if k was one and let's\nsay this array was sorted then that\nwould mean we want the right most\nelement because we want the first\nlargest element if k is two we want the\nsecond largest element so not the\nlargest element but the second largest\nelement so that's how it works now the\nmost obvious solution you probably could\nalready come up with by yourself is just\ntake the input array it's not\nnecessarily gonna be sorted but we could\nsort it ourselves what would be the time\ncomplexity well it would be uh n\nlog n right that's the time complexity\nto sort and since this is an array once\nwe sort it we can instantly check the\nindex that we want what index are we\ngoing to want let's say k is 2 what\nindex would we want in nums we'd want\nthe second largest right so instead of\nthe largest we'd want the second largest\nso how would we do that we'd just take\nthe length of the array minus k that\nwould give us the index that we want to\nget to but this is a medium problem so\nyou can assume that there are going to\nbe different solutions can we do better\nthan n log n well it turns out we can\nand one solution is using a max heap\nusing a heap will be slightly better\nbecause we won't have to sort the entire\ninput array what we can do with the heap\nis you can take an entire input array\nlike this one and you can heapify it you\ncan turn it into a heap and you can do\nthat in o of n time but just because we\nhave a heap doesn't mean we've\nnecessarily solved the problem because\nwe don't necessarily want the largest\nelement in the array we might want the\nkth largest element so from that heap\nafter we've already done an n operation\nto turn this array into a heap then\nwe're going to have to pop from that\nheap k times because it's a max heap so\nwe're going to pop k times so we can get\nthe kth largest element every time you\npop from a heap it takes a log n\noperation where n is the size of the\nheap how many times are we going to pop\nwe're going to pop k times because we\nwant the kth largest so this is the time\ncomplexity of\nthe heap solution you can see it's\nslightly better than n log n depending\non whatever k happens to be so in some\ncases it will be better than the sorting\napproach if k is\nrelatively small and that's about as\ngood as you can do in terms of worst\ncase time complexity but there is a\nsolution that's better actually if you\nwant to know the average case time\ncomplexity and that's what i'm going to\nbe focusing on because that's i think\nthe more difficult of the three\nsolutions that i've talked about so this\nthird solution actually can be achieved\nwith o of n average time complexity not\nworst case the worst case actually\nhappens to be n squared so in the worst\ncase it's not that efficient but in the\naverage case it is pretty efficient what\nalgorithm am i talking about well i'm\ntalking about the algorithm quick select\nit's pretty similar to a standard\nalgorithm that you may know called quick\nsort and if you haven't heard of this\nalgorithm i'm going to be teaching it to\nyou today if you have then you can\nprobably implement this yourself let me\nshow you how to do that now so let's\ntake a look at this first example and\nlike i said this algorithm is going to\nbe really similar to quick sort and the\nmain part about quicksort is the\npartition so that's what we're going to\ndo first we're going to take this entire\narray and partition it into two halves\nright we're gonna somewhat cut it in\nhalf one half of the array is gonna be\nevery value in let's say this half of\nthe array is less than or equal to every\nvalue in the right half of the array\nthat's how we're gonna partition it so\nhow can we make sure that it's always\ngoing to be half well it turns out we\ncan't that's why the worst case time\ncomplexity is going to be n squared and\nthe average case time complexity is\ngoing to be o of n because what we're\ngoing to do is we're going to randomly\npick a pivot let's just pick the\nrightmost element each time as the pivot\nvalue when i say pivot i mean this value\nis going to decide what goes in the left\nhalf and what goes in the right half so\nwhat we're going to do now we selected\nthis as our pivot we're going to start\nat the beginning of the array and we're\ngoing to go through each element and\nwe're going to compare each element to\nthis pivot value so for example 3 is\nless than or equal to 4 right so what\nare we going to do we're going to make\nsure to place it in the left half of the\narray it's already in this spot so what\nwe're going to do is basically just swap\nit with itself and then we're going to\nshift our\npivot pointer\nover here this pointer is basically\ngoing to indicate every time we find a\nvalue such as this one\nor this one that's less than or equal to\n4 then we can put it in this spot\nwherever this pointer happens to be and\nthen once we've done that we're going to\ntake this pointer and shift it again to\nindicate that okay next time we find a\nvalue like this one that's less than or\nequal to four then we're going to put\nthe value in this uh position so in the\nactual code we're going to be doing this\nin place but i just drew an extra piece\nof memory just to kind of help you\nvisualize it so we're going to take our\nthree keep it in this spot three is\ngoing to go here our our p pointer is\nnow going to be shifted here originally\nit was over here but now we shifted it\nover here so now we're done visiting\nthis element we're going to go to the\nnext element 2 is 2 less than or equal\nto 4 yes it is so we're going to go\nahead and put this value 2 in the\nposition where p points at so we're\ngoing to put our 2 over here p is going\nto be shifted\nby 1. so let's put p over here we find a\nwe go to the next element right one\nagain it's less than or equal to four we\nput one over here and then shift our p\nvalue so one goes here p is going to be\nover here now now we get to our first\nelement that's not less than or equal to\n4 so what do we do in that case we're\ngoing to leave this exactly where it is\nand and again we're going to get to the\nnext element 6 is again not less than or\nequal to 4 we're going to leave it\nexactly where it is and before we\nactually get to the last element we're\ngoing to stop so at this point we've\nwe're basically done going through the\nentire array right and now our array\nlooks something like this right we have\na 4 over here and at this point what\nthis p pointer tells us is that every\nelement before the p pointer everything\nover here is less than or equal to this\nvalue four and then every value\nover here right p\nand you know all these remaining\nelements except for the last one of\ncourse all of these elements are going\nto be greater than 4 right because all\nof these are less than or equal to 4 so\nthese must be greater than 4. that's\nwhat we mean by partitioning the array\nnow notice just because we partitioned\nthe array this is not in sorted order\nright it's not necessary the halves of\nthe array the partitions are not\nnecessarily going to be in sorted order\nbut they are going to be partitioned so\nthat everything here is less than\neverything here and one last swap that\nwe're going to do now is we're going to\ntake our pivot value over here which we\nselected as the rightmost element and\nwe're going to swap it with whatever\nhappens to be at this pointer right now\nso let's do that last swap we're going\ngonna put we're gonna replace this value\nwith a five and we're gonna replace this\nvalue with a four so this might be a\nlittle hard to read but so the reason\nwhy we did that you're probably\nwondering why did we even do the\npartition in the first place so now we\nknow all we know at this point is we\nhave some value\nat this point our p this is the value we\nuse to do the partition right now it's\nover here and we know that everything\nover here is greater than it and\neverything over here is going to be less\nthan or equal to this partition value\nright that's good so now what we're\ngoing to check is where is that k value\nthat we're looking for where is the\nsecond largest value in the array\nremember what we determined earlier that\nwe can find that target value at the\nindex length minus k right so what the\nlength of this entire thing is six\nminus k which is two so we're going to\ngo to index four this is zero one two\nthree four this is index four so all we\nhave determined at this point so far is\nthere are two elements on this half of\nthe array right so we know for sure that\nthe the second largest element must be\nsomewhere here we don't know for sure\nthat this is the second largest element\nor that this is the second largest\nelement because remember these are not\nnecessarily going to be sorted in this\ncase they're not so so we don't know\nit's over here but we know it's\nsomewhere in this half of the partition\nright it's definitely not here and it's\ndefinitely not here right if the the k\nvalue is different right maybe k was a\nreally big number then we'd get length\nwhich is six minus let's say k was four\nuh then we'd get two right that would\ntell us that okay the target value is\ngoing to be in the left half of the\narray or it could even be such that\nlet's say k was equal to three then we'd\nget length which is six minus k which is\nthree then we'd get the value three so\nthen we'd go to index equals three and\nthen we'd we'd see that this is that\nindex right and then if if it's ever\nthis case right where that value that\ntarget value is exactly at p wherever\nthat partition happened to be then we've\nactually found our result do you know\nwhy that's the case it's because we know\nfor sure that this is the kth largest\nvalue in this case we know for sure\nright now that this value is the third\nlargest value because we know for sure\nthat everything in the left half is less\nthan or equal to this value and we know\nfor sure that there are two values that\nare greater than this value\nso that must mean that this is the third\nlargest value right so we found the\nthird largest value but we're looking\nfor the second largest value so\nbasically what i'm getting at is we're\ngoing to do this recursively so instead\nof\nbasically we've eliminated that these\ncannot possibly be the result so now\nwe're going to run the exact same\nalgorithm i just showed you the quick\nsort partition on this part of the array\nuntil we find that result until we find\nk equals to the second largest element\nand when we actually do that partition\non this we're gonna use 5 as the pivot\nwe're going to say 6 is greater than 5.\nour p pointer is going to be here and\nthen at the end we're going to take this\nswap it with whatever is with p so then\nwe're going to have an array like\nlooking like this 5 and 6 where this is\nour partition\nvalue this is where p is at and like i\nsaid all of this is actually going to be\ndone in place so we will have the\nultimate array and then we're gonna look\nat k you know the length minus two which\nis gonna find put us at this index then\nwe're gonna have found our result five\nis the second largest element because we\nknow for sure there's at least there's\nexactly one element that's greater than\nfive right there's one element that's\ngreater than five that must mean five is\nthe second largest element so that's\nmainly how the code is going to work so\nif you recall how quick sort works it's\na little bit different right let's just\nanalyze the time complexity right now so\nwith quick sort when you do the\npartition then you have to recursively\nrun uh you know quicksort on the left\nhalf and on the right half which ends up\ngiving us a average case time complexity\nof n log n but in this case uh the\naverage case is actually going to be big\no of n because we're not going to be\nlooking at both halfs of the partition\nwe're only going to be looking at at\nmost one half of the partition wherever\nwe know that the target value happens to\nbe and assuming in the average case\nevery time we choose a pivot that pivot\nis going to be somewhere in the middle\nof the array it's going to be middle of\nthe pack where half the elements are\nless than half of them are greater than\nit that's going to give us you can\nprobably skip over this part you\nprobably don't care but just to analyze\nthe time complexity we're gonna have to\niterate through the entire array once\nright so let's say that's an n operation\nthen we're gonna have to let's say\niterate through half of the array which\nis gonna be n over two operation then\nwe're gonna have to iterate through half\nof that array which is gonna be n over\n4. this is an infinite series that you\nmight remember from calculus this\ninfinite series evaluates to 2 times n\nwhich we know is linear so that means\nthe average taste\naverage case time complexity is big o of\nn that's the average case but we know\nthat actually in some cases\nwe could have a pivot value let's say\nsix was our pivot value right six was\nhere then when we partitioned the array\nour p pointer is actually going to be\nover here so\nand let's say we didn't find the result\nthen we're gonna have to look through\npretty much the entire array except one\nelement and let's and it could be uh the\narray could be organized in such a way\nthat every time we choose a pivot that\npivot is always the greatest value so\nbasically each time we iterate through\nthe entire array we eliminate one value\nwe iterate through the entire array\nagain we eliminate one value we iterate\nthrough the entire array again eliminate\none value so that's an n squared time\ncomplexity in the worst case but like i\nsaid the average case is actually big o\nof n okay that was definitely a mouthful\nso now we are ready to get into the code\nit's not too difficult the code and like\ni mentioned earlier the easiest way to\nsolve this problem is just two lines of\ncode sort it and then return\nthe length minus k you know that index\nand that actually happens to be faster\non leak code than the quick select\nthe quick select algorithm but i'm still\ngoing to code the quick select anyway\nbecause the average case happens to be\nmore efficient and it's definitely a\nmore interesting solution so like i said\nthe index that we're going to be looking\nfor the target index that we're looking\nfor is going to be the length of the\narray minus k so what i'm going to do is\njust\ntake k and reassign it to this just to\nmake it easier for us because this is\nthe index right k i'm going to use k as\nthe index that we're looking for the kth\nlargest element if the array was sorted\nso now\nwe're going to do that recursive quick\nselect algorithm and since every time\nthe subarray that we're looking at and\nrunning quick select changes we're going\nto pass in two variables we're going to\npass in the left and right pointer this\ntells us on which portion of the array\nare we currently running quick select on\nthen when you actually implement quick\nselect you choose the pivot we're going\nto choose the right most value because\nit's easy\nand we're going to have our p pointer\ninitially being at the leftmost value so\npivot is going to be set to nums of\nright p the pointer is going to be set\nto the leftmost position just like i\nshowed in the drawing and then uh\npretty much like the drawing we're just\ngoing to go ahead and iterate through\nthe entire array except the last element\nso we're going to go from index left all\nthe way to right\nright is non-inclusive in python so it's\nnot actually going to reach the right\nindex and we'll go through each element\nif this element nums of i happens to be\nless than or equal to the pivot value\nthen we're going to swap it with\nthe left index or not the left index\nactually the p index right wherever\nwe're putting uh the partition values so\nif this is the case we're gonna set nums\nof p equal to nums of i and we're gonna\nset nums of i equal to nums of p you can\ndo that in one line in python you don't\nneed a swap helper function we can do it\njust like this\nso we're just swapping these two values\nit's pretty straight forward\nremember every time we do do a swap\nthough then we want to increment the p\npointer because next time we do a swap\nwe want to put it in the next position\nokay so that's the partition and the\nlast part of the partition is to swap\nthe pivot value with the p index so\nwe're going to set nums of p\nequal to the pivot value and we're going\nto set nums of right the you know what\nthis pivot value is currently in the\nrightmost position we're going to swap\nthat with whatever happens to be in nums\nof p so nums of right is going to be set\nto\nnums of p\nthis might be confusing maybe because i\nuse pivot so you can actually rewrite it\nso instead of using pivot i could\nactually just go ahead and write nums of\nr we're just swapping the rightmost\nvalue with whatever happens to be at\nnums of p right at our p index okay and\nonce that is done then we potentially\nmay have found a solution or we may not\nhave found a solution so so let's check\nis our k value less than p\nthe k is the target index we're looking\nfor if it's less than p that means we\nhave to run quick select now on the left\nportion of the array because we have to\nlook for a smaller index so we're going\nto call quick select and for the indices\nwe're going to pass in left remains the\nsame but the right pointer is now going\nto be shifted towards the left right is\nnow going to be set to p\nminus 1 because we can look at the left\nportion of this\narray now this partitioned array that's\nif k is less than p we could have\nanother case and we're actually going to\nbe returning this value whatever happens\nto be\nand the else case is if uh k is greater\nthan p if k is greater than p that means\nwe have to look in the right portion of\nthe array so in that case we can return\nquick select\nlooking at the right portion of the\narray which means our left pointer is\ngoing to be\nchanged to be p\nplus 1 now and our right pointer is\ngoing to stay the same that's the other\ncase the last case else is if p is\nexactly equal to k in that case we can\njust go ahead and return nums of p\nbecause we know for sure p is the kth\nlargest element and yes since all of\nthese\nend up returning something that is the\nentire code that's the entire quick\nselect algorithm now all we have to do\nis actually call it so we can call quick\nselect for the pointers of course we'll\njust pass in zero for the left boundary\nand for the right boundary we'll pass in\nlength\nminus one so that we can run quick\nselect on the entire input array and\nthen return whatever the result is so\ni'm going to run it to prove to you that\nit works even though since the worst\ncase is n squared and some of the uh\ntest cases on leak code actually happen\nto be you know poor cases for quick\nselect it doesn't run very efficiently\non some of those test cases so this\nactually isn't very efficient on leak\ncode but you know this is definitely a\ngood algorithm to know in the average\ncase it does beat the sorting approach\nso i hope this was helpful if it was\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully see\n"
    },
    {
        "Name": "Task Scheduler",
        "NcLink": "task-scheduling/",
        "Pattern": "Heap / Priority Queue",
        "Description": "You are given an array of CPU  tasks `tasks`, where `tasks[i]` is an uppercase english character from `A` to `Z`. You are also given an integer `n`. \n    \nEach CPU cycle allows the completion of a single task, and tasks may be completed in any order.\n\nThe only constraint is that **identical** tasks must be separated by at least `n` CPU cycles, to cooldown the CPU.\n\nReturn the *minimum number* of CPU cycles required to complete all tasks.\n\n**Example 1:**\n\n```java\nInput: tasks = [\"X\",\"X\",\"Y\",\"Y\"], n = 2\n\nOutput: 5\n```\n\nExplanation: A possible sequence is: X -> Y -> idle -> X -> Y.\n\n**Example 2:**\n\n```java\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"C\"], n = 3\n\nOutput: 9\n```\n\nExplanation: A possible sequence is: A -> B -> C -> Idle -> A -> Idle -> Idle -> Idle -> A.\n\n**Constraints:**\n* `1 <= tasks.length <= 1000`\n* `0 <= n <= 100`\n",
        "Difficulty": "Medium",
        "Video": "s8p8ukTyA2I",
        "PythonSolution": "class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        count = Counter(tasks)\n        maxHeap = [-cnt for cnt in count.values()]\n        heapq.heapify(maxHeap)\n\n        time = 0\n        q = deque()  # pairs of [-cnt, idleTime]\n        while maxHeap or q:\n            time += 1\n\n            if not maxHeap:\n                time = q[0][1]\n            else:\n                cnt = 1 + heapq.heappop(maxHeap)\n                if cnt:\n                    q.append([cnt, time + n])\n            if q and q[0][1] == time:\n                heapq.heappush(maxHeap, q.popleft()[0])\n        return time\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem task scheduler one of\nyou suggested this problem and i think\nit's a pretty good one so we're given an\narray of tasks it's a character array\nand it's going to be limited to the\ncharacters from uppercase a to uppercase\nz so 26 characters each of the\ncharacters represents a task and the\ntask is something that the cpu needs to\nprocess and the tasks could be processed\nin any order each task takes exactly one\nunit of time to process so that's good\nbecause it makes things simple for us\nand for each unit of time the cpu could\neither process an entire task or it\ncould be idle and the reason it would be\nidle is because we're also given\nnon-negative integer input n that\nrepresents the cooldown period between\nthe two same tasks and the same task is\nrepresented by the same letter the same\ncharacter in the array and to understand\nthis let's take a look at an example and\nby the way what we actually want to\nreturn is the minimum number of units of\ntime that the cpu will take to finish\nall of the tasks let's take a look at\nthis example we're given these tasks\nright three a tasks and three b tasks\nand the idle time we're given is two\nunits of time so basically let's say we\nprocessed an a task right that takes us\none unit of time to process now we\nprocess a b task and now we know that\nbefore we process another a task we have\nto wait two units of time so you know\nlet's say we process an a we can't\nprocess another a we have to wait two\nunits of time before we can process\nanother a so what are we gonna do in the\nmeantime well there's a b as well so\nlet's process one of the b's and now for\nthis b we know we actually have to wait\ntwo units of time before we can process\nanother b\nso the next time we can process another\nb will be at this point in time after we\nhave processed our second a so now the\nquestion is can we fill this spot with\nanything or are we gonna have to be idle\nat this point in time and there aren't\nany other characters right we had one a\nand one b now we have two a's and two\nb's remaining so we can't do anything\nthis has to be idle we process an a a\nsecond a and a second b uh that means\nthat before we can process another a is\ngonna be two units of time so this b and\nthen another uh unit of time and then\nanother a and we also process the b the\nnext time we can process a b will be at\nthis point in time so at this point\nagain we are going to have to be idle\nbut the good thing is that this is the\nentire um like all the tasks we were\nlooking for three a's and three b's so\nas you can see it took us one two three\nfour five six seven eight units of time\nto do this so our output is going to be\na so now let's think about a general\napproach that we could come up with to\nsolve this problem so let's say we had\nthis as our input first thing to notice\nis we're going to be given characters a\nthrough z doesn't really make sense to\nworry about which character we're\nlooking at right there's not really not\na big difference between a b and a c but\nwe should keep track of how many of each\ncharacter there is so we know there's\nthree a's two b's and two c's right we\ndon't even have to worry about the\ncharacters anymore we can just focus on\nthe numbers we know that there's three\nof one character there's two of a\ndifferent character and then two of\nanother character we know that the idol\ntime in this case is one what order\nshould we uh process the characters in\nit's probably better to process the more\nfrequent character first the more\nfrequent task first because we know\nthere's going to be some idle time and\nprocessing the more frequent one first\nbasically gives us more time to not be\nidle and i'll show you the intuition\nbehind that let's say we did a c first\nright we do c uh we know that idle time\nis just one right so then let's say we\ndo b and we're allowed to do another c\nright away let's say we do that right we\ndo another c and uh then we do another b\nbecause we the idle times only one right\nso now we've already processed all the\nthe c's and the b's and all we're left\nwith is three a's okay let's process one\nof the a's okay great but now we have an\nidle time we have no other characters\navailable for us so we have to wait\nand then we can process another a and\nthen we wait and then process another a\nso in this case this was one way but did\nthis minimize the total time that it\ntook us to process all the tasks a\ndifferent way would have been to start\nwith the most frequent character right a\nand now there's only two a's left so now\nwhat's the most frequent well you could\nsay a again but we know that there is an\nidle time of at least one so at this\npoint in time a is not available to us\nso we have to process a different\ncharacter let's say a b then a is\nactually going to be available for us\nagain so we could process the a or we\ncould process the c in this case it\ndoesn't really make any difference\nbecause there's two of each of these so\nwe could do either one let's just do c\nso then there will be two a's one b and\none c then we'll of course want to do\nthe more frequent character the a and\nthen there's gonna be one a remaining we\ncan't process another a without at least\none unit of idle time so let's do b and\nthen do c and then we can do a right\nthis\nalso is a valid way and this one\nactually minimizes the idle time rather\nthan\nthis one and what is the idle time in\nthis case it's about uh not the idle\ntime the total time in this case is\nabout seven as opposed to nine in the\nother case so that's kind of the\nintuition why we're going to\ntry to do the more frequent task first\nand then the less frequent task how\nwe're going to be doing this is by using\na data structure called a max heap which\nwill allow us to continuously figure out\nwhich task is the most frequent one and\nthe max heap can actually allow us to\ndetermine that in log n time right if we\nhave a bunch of these we could figure\nout which is the most frequent in log in\ntime which is good but in this case\nactually it's even better than that it's\nabout log 26 since we only have 26\ndifferent characters this is kind of a\nconstant time operation anyway but i\nwill say that the overall time\ncomplexity is still going to be big o of\nn one because we are gonna have to you\nknow count the occurrences of each task\nso we're gonna have to go through the\nentire uh input and we're going to be\nyou know popping every value from our\nmax heap and adding every value to our\nmax heap so the time complexity is going\nto be big o of n that's also going to be\nthe memory complexity but now to the\nactual algorithm itself we're actually\ngoing to use one other data structure aq\nit's not required but i think it makes\nthe problem a little bit more organized\nso let's start off with the max heap\nright we have three integers we're going\nto be adding integers to our max heap\nnot the characters we're going to be\ntaking the counts of each task and\nadding that to the max heap so we're\ngoing to have a three and a two and a\nanother two and by the way when i\nactually code this up in python we don't\nhave a native max heap so the way to we\nonly have a min heap so the way i get\naround that is basically by taking each\nof these values and making it negative\nyou know in a max heap we want to pop\nthe maximum and we can do that in log n\ntime so in this case we'd pop the 3\nwhich is the maximum but in python we're\nactually going to do it the opposite way\nall of these are going to be negative so\nwe're going to end up popping the\nminimum which is going to be negative 3\nbut we're going to you know assume that\nit's a positive 3. but yeah so that's\nthe idea first we're going to pop the 3\nor the negative 3. you can think about\nit however you want that's the most\nfrequent but now we want to change the\ncount from being a three to now being a\ntwo right because we just processed one\nof the tasks so you know if you have a\nnegative you'll have to add one if you\nhave a positive you can decrement it to\none in my case when i write the code i'm\ngoing to be adding one to this but now\nwe're actually going to be taking this\nand adding it to our queue data\nstructure because we know that there's\nsome amount of idle time for this task\nat the current point in time we are at\ninitially we were at time equals zero\nbut we just processed the task so now\nwe're at time equals one and we're going\nto add this integer 2 or negative 2 to\nour q\nbut we're also going to be adding\nanother value to the queue and that's at\nwhat time is this task going to be\navailable for us to process once again\nbasically at what point can we take this\nand add it back to our max heap right\nwhat's the idle time that is going to be\nremaining well right now we're at time\nequals one and our idle time for each\ntask is n equals one so basically we're\ngonna take n\nand add it to our current time so it's\ngonna be two basically at time equals\ntwo this task is gonna be available for\nus to add to the heap again so that's\nwhat the second value in this case means\nand once again we're going to pop from\nour max heap we're going to pop the\nnegative 2 and that means we have\nprocessed the task so now our time is\nactually going to be time equals 2.\nwe're going to take that task it was a\nnegative 2. we're going to add 1 to it\nwhich is going to make it a negative 1.\nso then we're going to take that\nnegative 1 and add it to our q\nand at what time is that task going to\nbe available to add back to our max heap\nwell it's going to be 2 plus 1 because n\nis 1 in our case so at time equals 3\nthis task can be added back to our max\nheap but now that we're at time equals 2\nwe see that this task actually is\navailable now to add back to our heap so\nlet's pop it from our q and take the\nnegative 2 and add it back to our max\nheap and at this point you're probably\nstarting to get the idea so i'll just\nkind of fast forward through this we're\ngoing to pop this again set our time now\nequal to 3. we're going to take that\nnegative 2 add 1 to it so it'll be a\nnegative 1. we'll add that to our heap\nat time equals 4 it's going to be\navailable for us to add back to the heap\nthis value can be popped from our queue\nwe can add a negative 1 here and then\nstart the cycle over so let's pop this\nvalue over here uh add it to our q we're\nrunning out of space so let's add a\nlittle bit more space uh that negative\ntwo will become a negative one the time\nnow will actually be four so the time\nthat this can be popped it's going to be\nat time five we see it's time for so\nthis can now be popped so we add that\nback to our uh heap negative one and now\nit's time equals four so i'm really\ngoing to fast forward through this it'll\ntake one more unit of time to process\nthis task but now this task as you can\nsee we're going to pop it it's a\nnegative 1 we're going to add 1 to it so\nnow it's going to be 0 right 0 once a\ntask becomes 0 we know that we don't\nhave to process it anymore right so when\nit's 0 we're not going to add it to our\nq because it doesn't have to be idle\nit's never going to be added back to the\nmax heap once it's zero we're not going\nto do anything with it so uh you know we\npop it from our max heap and there's\nnothing left but we see that this value\nover here and right now it's going to be\ntime equals five actually so time is\nfive this can be added back to our max\nheap\nlet's add that negative one sorry if\nit's getting a little bit messy but next\nwe're gonna pop this from our max heap\nit's gonna become zero so we don't add\nit to our queue now it's gonna be time\nequals six after we process that task\nand lastly we have one task remaining we\npop it we process it it becomes zero we\ndon't add it to the queue so now after\nprocessing that task our time is seven\nso we can return seven in this case and\nthat's pretty much the entire algorithm\nso that's what i'm going to be following\neven though popping and pushing to a max\nheap is usually a login operation in\nthis case it's really going to be a log\n26 operation so the overall time\ncomplexity in this case is really just\nbig o of n because we have to just go\nthrough every single task okay now let's\nwrite the code okay so now let's code it\nup and you can see i have a couple\ncomments just to kind of help simplify\nthings for us and i usually don't do\nthis but we want to count the\noccurrences of each character in the\ninput it's a list of strings we could\njust you know run through that loop\nthrough that and add it to a hash map\nbut you can actually do that with a\nbuilt-in way in python just using a\ncounter which is literally a hash map\nit'll just do that for us so we don't\nhave to write the code but now we\nactually want to create our max heap\nusing those counts themselves uh we can\ndo that in python with one line of code\nwe're just going to iterate through each\ncount in\nthe\nhashmap that we just created but we want\nto only iterate through the values so\ncount.values and we want to add that to\nour hashmap but in python's case we\ncan't have a max heap this is actually a\nmin heap after we heapify it so i'm\nactually going to take the negative of\nthe count and add it so this is just\ncreating an array with every negative\ncount that we computed but to actually\nturn it into a heap\nwe can do\nheapq.heapify in python and to that max\nheap and it'll basically order it it'll\ntake this array and order it in such a\nway that it is a max heap basically for\nus to efficiently get the maximum value\nfrom\nthe heap whenever we want it we're also\ngoing to declare a variable to keep\ntrack of what time it is initially we'll\nset that to zero and we'll also have a q\nin this case a double ended queue and\nthe double ended queue is gonna actually\ncontain a pair of values and the pair of\nvalues are gonna be that negative count\nthat we had up above and for that uh you\nknow task that count\nthe corresponding idle time at what time\nis it going to be available for us to\nadd back to the\nmax heap okay so with that said we're\ngonna continue uh our loop we're gonna\ncontinue processing these tasks while\nthe max heap is non-empty but end or not\nand but or the\ncue is not empty right as long as one of\nthese is not empty that means we have\nmore tasks that we need to process\nso as we process\neach iteration of the loop is just going\nto increment the time by exactly one and\nactually before i even forget i\nmentioned that the time complexity of\nthis whole algorithm is going to be big\no of n but that's not entirely correct\nlet's say n is the size of our tasks we\ncan add one more variable let's call it\nm where m actually represents what the\nidle time is because in the worst case\nyou know we have to go through that idle\ntime for each task that we have write\nsuppose that the tasks was just an array\nof all a's\nin that case we'd have to you know go\nthrough the idle time for each task but\nthe idle time is actually a pretty small\nconstant i think it's less than 100 in\nour case but just wanted to mention that\nin case but okay now let's continue with\nthe algorithm so at each iteration of\nloop we're going to increment the time\nby one if the max heap is non-empty we\nare going to pop from it and we can do\nthat with heap q dot heap pop from the\nmax heap and from it we're gonna get the\ncount and as we uh pop from the heap\nthat means we're processing this task so\nto the count itself we can actually add\none to it because remember we're\nactually using negative values for the\ncounts if you were using positive values\nyou'd probably subtract one from it but\nin our case we're going to be adding one\nto it and if this count is non-zero we\ncan check that uh like this if count is\nnon-zero then we want to go ahead and\nappend it to our queue and we can do\nthat like this we're gonna append a pair\nof values the count itself and the time\nthat it's going to be available again\nand we can get that by taking our time\nour current time adding to it the idle\ntime n so at this time we can once again\nadd it to our maxi okay that's great we\nprocess a task we remove it from the max\nheap but remember we also have to take\ncare of our queue if our queue is\nnon-empty and the first value in our\nqueue at index 0\nthe idle time for it which is also\nit was actually going to be at index one\nbecause it's the second value in the\npair so if this time has just been\nreached so if this is equal to the\ncurrent time that means you know we can\nactually pop this from our queue so\nwe're going to say q dot popped left and\nso this is actually going to pop that\npair of values and from that pair of\nvalues we care about the first one which\nis the count so we're going to get an\nindex of zero but actually that value\nitself what do we want to do we just\nwant to add it back to our max heap so\nwe can do that with heap cue.heat push\nwe're going to take it add it to our max\nheap so let's just copy and paste this\nand uh move it up above so the only\nthing left for us to do is once\neverything has been processed for our\nmax heap and our queue we can just go\nahead and return the time that it took\nus to do all that work let's just clean\nthis up a little bit that's the entire\ncode so now let's just run it to make\nsure that it actually works and as you\ncan see on the left yes it does work and\nit's pretty efficient i do want to\nmention there actually is a different\nsolution for this that's actually a\nlittle bit more of a true linear time\nsolution but i think it's a lot less\nintuitive and i think this solution is\nperfectly fine for interviews and\nbecause it's more of an intuitive\nsolution i think this is\nmore or less what interviewers would\nexpect you to come up with so i really\nhope that this was helpful if it was\nplease like and subscribe it really\nsupports the channel a lot consider\nchecking out my patreon where you can\nfurther support the channel and\nhopefully i'll see you pretty soon\n"
    },
    {
        "Name": "Design Twitter",
        "NcLink": "design-twitter-feed/",
        "Pattern": "Heap / Priority Queue",
        "Description": "Implement a simplified version of Twitter which allows users to post tweets, follow/unfollow each other, and view the `10` most recent tweets within their own news feed.\n\nUsers and tweets are uniquely identified by their IDs (integers).\n\nImplement the following methods:\n\n* `Twitter()` Initializes the twitter object.\n* `void postTweet(int userId, int tweetId)` Publish a new tweet with ID `tweetId` by the user `userId`. You may assume that each `tweetId` is unique.\n* `List<Integer> getNewsFeed(int userId)` Fetches at most the `10` most recent tweet IDs in the user's news feed. Each item must be posted by users who the user is following or by the user themself. Tweets IDs should be **ordered from most recent to least recent**.\n* `void follow(int followerId, int followeeId)` The user with ID `followerId` follows the user with ID `followeeId`.\n* `void unfollow(int followerId, int followeeId)` The user with ID `followerId` unfollows the user with ID `followeeId`.\n\n**Example 1:**\n\n```java\nInput:\n[\"Twitter\", \"postTweet\", [1, 10], \"postTweet\", [2, 20], \"getNewsFeed\", [1], \"getNewsFeed\", [2], \"follow\", [1, 2], \"getNewsFeed\", [1], \"getNewsFeed\", [2], \"unfollow\", [1, 2], \"getNewsFeed\", [1]]\n\nOutput:\n[null, null, null, [10], [20], null, [20, 10], [20], null, [10]]\n\nExplanation:\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 10); // User 1 posts a new tweet with id = 10.\ntwitter.postTweet(2, 20); // User 2 posts a new tweet with id = 20.\ntwitter.getNewsFeed(1);   // User 1's news feed should only contain their own tweets -> [10].\ntwitter.getNewsFeed(2);   // User 2's news feed should only contain their own tweets -> [20].\ntwitter.follow(1, 2);     // User 1 follows user 2.\ntwitter.getNewsFeed(1);   // User 1's news feed should contain both tweets from user 1 and user 2 -> [20, 10].\ntwitter.getNewsFeed(2);   // User 2's news feed should still only contain their own tweets -> [20].\ntwitter.unfollow(1, 2);   // User 1 follows user 2.\ntwitter.getNewsFeed(1);   // User 1's news feed should only contain their own tweets -> [10].\n```\n\n**Constraints:**\n* `1 <= userId, followerId, followeeId <= 100`\n* `0 <= tweetId <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "pNichitDD2E",
        "PythonSolution": "class Twitter:\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = defaultdict(list)  # userId -> list of [count, tweetIds]\n        self.followMap = defaultdict(set)  # userId -> set of followeeId\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweetMap[userId].append([self.count, tweetId])\n        self.count -= 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        res = []\n        minHeap = []\n\n        self.followMap[userId].add(userId)\n        for followeeId in self.followMap[userId]:\n            if followeeId in self.tweetMap:\n                index = len(self.tweetMap[followeeId]) - 1\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n\n        while minHeap and len(res) < 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index >= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.followMap[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem design twitter\nthis is a somewhat challenging problem\nfor a medium and spoiler alert this is\nactually really similar to another leak\ncode problem which is called merge k\nsorted lists and that problem is\nactually a hard problem so it's kind of\nweird that they make this a medium\nproblem because this problem is actually\neven harder than the merge case sorted\nlist problem but that's okay so we are\ntold to design a simplified version of\ntwitter and this problem is really about\nwhich data structures are we going to\nuse for each of these functions so you\nreally need to have an understanding of\ntrade-offs to make sure that we\nimplement each of these functions in the\nmost efficient way so there's in total\nfive functions we wanna do one is the\nconstructor so that's where we're really\njust gonna handle what data structures\nwe wanna use like initializing them and\nall that and i'm actually gonna start\nwith the implementation for these two\nfunctions the follow function and the\nunfollow function\nso any user in this case the follower id\nis the user can follow another user and\nthat's called the follow e id followee a\nlittle bit confusing for me but so\nclearly with this function we need to\nkeep track that this user is following\nthis user right we need a data structure\nto do that now there's a bunch that we\ncould do the easiest one that you might\nconsider is a map right we want to map\nthis user to another user\nbut of course a user\ncan actually not just follow one person\nbut they could follow multiple people so\nthe simplest idea that you might think\nof is first okay create a hash map right\nuh where we're gonna map the user id\nright just some generic user to whoever\nthey're following right we'll call that\nthe follow eid but it's not just going\nto be one so let's actually call it list\nof followee ids right that's just our\nnaive approach that's just the first\nthing that came to our mind so if each\ntime we get a user and we are told that\nthey follow somebody else we can just\nkeep adding that you know user that they\nfollow to the end of that list that we\nhave right in our hash map this is going\nto be the key this is going to be\nthe key is going to map to a list and we\ncan add a new value to that list and of\none time so that's easy but now we're\nintroducing a second operation called\nunfollow so if a user now wants to\nunfollow another user how can we\nimplement it with our current data\nstructure well removing from a list is\nnot as easy as adding to the end of that\nlist because we might actually have to\nsearch through the entire list to even\nfind that a follower id that we're\ntrying to remove and then removing it is\ngoing to be a big-o of end time\noperation is there a more efficient way\nthat we can do this well there is a data\nstructure we know that can add and\nremove in o of one time do you know what\nit is well hashmap is one of them but in\nthis case we don't really need a map we\njust need a set of values right a list\nor a set but in this case we can use a\nhash set and that can insert and remove\nin big o of one time so instead of using\na list which was our naive approach\nwe're actually going to map each user id\nto a hash set of follow eids okay so\nthat's actually pretty easy right so\nwe've already figured out a follow and\nwe've already figured out unfollow and\nof course we're going to be initializing\nthis data structure inside of our\nconstructor but now for the somewhat\ndifficult part the post tweet and the\nget news feed function so let's start\nwith post tweet each user can post a\ntweet and obviously they can post more\nthan one tweet so we need to be able to\nmap a user to their list of tweets right\nlet's just start with a list again and\nsee if it works out for us so again\nwe're gonna have a hash map okay so\nwe're gonna have another hash map\nmapping each user id to the list of\ntheir tweets and each time we post a\ntweet for a given user we're just going\nto take that tweet and add it to the end\nof that list so let's just see if that\nworks for now that's like the most naive\napproach and in this case i'll just tell\nyou it is going to work for us and\nyou're going to see why so by the way\nthis post tweet if we're just adding to\nthe end of the list each time we can do\nthat in big o of one time so we've\nbasically got all three of these\nfunctions running in big o of one time\nbut this get news feed is going to be by\nfar the most complex function so\nbasically for any given user we want to\nretrieve the 10\nmost recent tweet ids for that user and\nthe way we're going to get the 10 most\nrecent tweets is from the list of uh\nfollowees of the list of people that\nthat user follows right and from that\nlist of people that they follow we want\nthe 10 most recent tweets now how do we\neven get most recent well one anytime a\nuser posts a tweet we're already adding\nit to the end of the list right so if we\ncreate a list of tweets right let's say\nthis is the first tweet then we have the\nsecond tweet then we have the third\ntweet of course the most recent tweet is\ngoing to be at the end of the list right\nfor any given user but we don't just\nhave one user right it's possible that\nwe were told okay this user uh you know\nwe're given some user but they maybe\nfollow two people right maybe the second\nperson that they follow has these tweets\nfour five six and let's say these are\nthe actual tweet ids right so we know\nthat this is the most recent tweet from\nthe first person that they follow and\nthis is the most recent tweet from the\nsecond person that they follow but these\nvalues we can't just compare the tweet\nids right because that's what we have\nright now a list of tweet ids so instead\nof just having a list of tweet ids how\nabout we also keep track of the time\nthat that tweet was posted so in that\ncase we won't just have a list of tweet\nids we'll have a list of pairs a list of\ni'm going to call it count because\nthat's what we're going to be keeping\ntrack of for time right we don't\nactually have a time we have a count of\nhow many total tweets we have and we're\nactually going to start our count at 0\nand then we're going to decrement it to\nnegative 1 then to negative 2 then a\nnegative three and you're gonna see why\nit basically has to do with us using a\nheap uh and in python at least there's\nnot really a max heap so we're gonna be\nusing a min heap if you're if you're\ndoing this in java by the way you can\njust take the count and start at zero\nand then increment it to one then to two\nthen the three but in this case i'm\ngoing to be decrementing it from one to\nnegative one to negative two and it'll\nwork out for us this count isn't the\nmost important part of this function\nokay so once again let's say we're\ntrying to run get newsfeed for some\nparticular user now first thing we want\nfor that user is who do they follow how\ncan we get that well remember we have a\nhash map for that we can take this user\nid and get a hash set of all the people\nthat they follow and a hash set in this\ncase is basically equivalent to a list\nfor us because we're just going to\niterate through all the people that they\nfollow and then get the tweets of those\npeople right so for each followee id\nthat's a person right that's a user how\ndo we get their list of tweets well\nconveniently we have a second hash map\nfor that we can take that uh followee id\nand then convert it into a list of their\naccount and tweets right and that count\nis really just going to be used to\nfigure out what tweet\noccurred most recently so suppose we did\nall that work right we took some user\nand then got a list of all the people\nthat they follow and their particular\ntweets let me just draw some example for\nthat let's say we have one three five uh\nand let's say these are the counts right\nbecause we know that that list is\nactually going to have a pair of values\ncount and tweet id uh we do care about\nthe tweet id as well because that's what\nwe're gonna be returning remember we're\nreturning a list of the tweet ids that\noccurred most recently the 10 tweets\nthat occurred most recently and if there\naren't 10 let's say there's only eight\ntweets from all the people that they\nfollow then we occur however many we\nhave right we don't go over 10 but if\nthere's less than 10 then we'll return\nhowever many we have but in this case uh\nlet's say there are less than 10 let's\nsay we have two four and then for the\nother one let's say we have a six\nseven so not only do we want at most ten\ntweets but they need to actually be\nordered from most recent to least recent\nso how do we do that that's really the\nmain portion of this algorithm and it's\nbasically exactly like merge k sorted\nlists the naive way to do this would run\nin big o of 10\ntimes k where k is basically the number\nof people that that user follows and let\nme tell you why because of course for\neach in this case we have three right\nbasically i'm saying k is equal to three\nbecause we have three different lists uh\nif we're trying to get the most recent\ntweets and order them in that way of\ncourse we're gonna start at the end of\neach list right so we're gonna have a\npointer for each list you can call it an\nindex or whatever you want and we're\ngoing to compare all of these right\nwhich one occurred most recently which\none has the smallest value in this case\nfour is the smallest value so what are\nwe going to do well we're gonna take 4\nand add it to our list i'm kind of\nrunning out of space so let me just\ncreate a variable up here sorry if it's\nmessy so result is going to be our list\nso we found the first value it's 4 so\nwe're going to add 4 to that list and\nthen we're going to take that pointer\nwhich was here and then decrement it\nwe're going to shift it to the left so\nnow it's going to be over here and then\nwe're basically going to keep repeating\nthis right we're going to take the\nminimum of all of these and the reason\nthe time complexity is 10 times k is\nobviously we have k lists to find the\nminimum between k values it's a big o of\nk operation so that's the naive way to\ndo it but if you've solved merge k\nsorted lists before you know that we\ndon't have to do it in the naive way the\nslightly more optimal way to do this is\nactually to take our frontier of all\nthese lists basically frontiers all of\nthe pointers right wherever the pointers\nare take this this and this and add it\nto a data structure called the heap in\nour case we want the min heap because we\nwant the minimum value right we want to\nknow which one of these occurred most uh\nrecently uh and actually that reminds me\nwe remember we were actually going to\nmake these values negative so sorry if\nthis was confusing or remember we were\ngoing to start at 0 and then make all\nthese negatives so\nthat doesn't really change the problem\nat all but it's just how we're going to\nimplement it in the code if you're using\njava by the way you don't need to make\nthem negative because java has a max\nheap which you can use but we will be\nusing a min heap and python but the idea\nis the same right we're going to take\nthese values add them to a heap in our\ncase we're going to be using a min heap\nand then from this value this value and\nthis value we're going to find the\nminimum we're going to do that in log k\ntime\nand how many times are we going to do\nthat log k operation well of course only\nat most 10 times right so the time\ncomplexity is 10 times log k so that's\nbetter than 10 times k which we\npreviously had right well not quite\nactually\nand that's kind of the dumb part about\nthis\neven if you do use them in heap it\ndoesn't really change the overall time\ncomplexity let me tell you why because\nlet's say we take each of these k values\nand we add them to the heap we can add\nthese values in two different ways we\ncan push each of these values which\nwould result in k times log k just to\npush these values these k values to the\nmin heap or we could run heapify which\nwould be a big o of k time operation so\nthat in addition to our 10 times log k\nit makes the overall time complexity\nstill big o of k which is what we\nalready originally had so it actually\ndoesn't change the overall time\ncomplexity uh but the benefit is if you\nknow if we were running this algorithm\nin a generic case where we didn't have\nto actually receive uh 10 uh different\ntweets maybe we had to receive\nup to n tweets our algorithm using a\nheap would be more efficient so i think\ni've talked enough about the complexity\nand how we're actually gonna design this\nnow it's actually time to implement the\nsolution and code it up just to save a\nbit of time i'm just gonna copy and\npaste a few lines of code so remember\nwe're gonna have three main variables in\nour constructor we're gonna keep track\nof the count initially it's gonna be\nzero uh we're gonna use the count to\nbasically uh it would be better to call\nthis time but it really is just counting\nour number of tweets so basically we can\nmaintain which tweet was created earlier\nthan another tweet we're also gonna have\na tweet map where we map each user to a\nlist of uh that user's tweets as well as\nthe count which is uh gonna be used to\nfigure out which tweet was created uh\nearlier and of course we want to be able\nto have a follow map to\nmaintain a user and a set of all the\npeople that they follow so i'm actually\ngoing to implement the follow and\nunfollow first because they're a lot\neasier so for follow we take our follow\nmap and\nfor a follower id we want to say okay\nthis uh person is now following another\nperson uh with the uh followee id so\nwith the hash set we're gonna add to\nthat hash set this followee id so that's\npretty easy now in the unfollow it's\nbasically the reverse of this right a\nuser is now unfollowing someone so\ninstead of adding we're gonna remove but\nwhat if this person is actually not even\nfollowing a different person well let's\njust add a conditional to make sure that\nthey are following before we actually\ncall the remove function because at\nleast in python i think it will throw\nlike an exception or something so let's\njust\nmake sure if follow e id is in\nthe set for that follower id so if that\nis the case only then are we actually\ngoing to remove it okay so that was the\neasy part now let's do post tweet it's\nthe second easiest so for any user uh\nthey just created a tweet so we want to\nbe able to record that so in our tweet\nmap we're gonna say oh and by the way i\ndidn't mention we're using default dicks\nin this case default dictionaries or\nhash maps in this case of course we have\na list right that's going to be what\nwe're recording and in this one we have\na set main reason i'm doing it like this\nis just to save a couple lines of code\nif we didn't have default dicks we could\nhave just initialized it to a regular\nhashmap but in that case each time i'm\nadding values like see here i'm adding\nvalues i would have to initialize it\nbefore so i'd have to say\nfollower id\nis going to equal a list and or in this\ncase a set and then i can add it right\nfirst we'd have to create an empty set\nand then add the\nvalues to that set doing it this way\njust saves a few lines of code i think\nin most cases your interviewer would\nprobably be fine with it but if they're\nnot you can always just write it out\nit's pretty easy to do it just saves us\na few lines of code in this case so in\nthe tweet map for this user id we want\nto append to the end of the list the\ntweet id but actually not just the tweet\nid remember because we determined that\nwe need to record a pair of values we\nneed to record the count uh that this\ntweet was created at so that we know\nwhich tweet was created before another\ntweet\nactually i think we're trying to figure\nout which tweet was created most\nrecently uh but either way our account\nwill help us for that and then after\nwe've done that we want the next tweet\nto be uh created at a different count so\nwe're gonna actually decrement this so\nthat we can use this in our min heap in\nour this function that's i think pretty\nmuch it for post tweet so now basically\nto the main part of this algorithm to\nget news feed so like i said we're gonna\nhave a result right that's gonna be the\nlist of tweets so it's gonna be ordered\nstarting from the most recent tweets uh\nfor all the people that this person\nfollows and we're also going to be\nneeding a min heap to figure out what\nthe most recent were so initially the\nmin heap is going to be empty we are now\ngoing to go through\nevery person that this user follows how\ncan we get that how can we get the\nfollowee id of each person that this\nuser follows well remember we have a\nfollower map for that so follower map\ndon't forget to use self in python\nfor this user id so we want to go\nthrough each followee id and what do we\nwant to do with that followee id we want\nthe most recent tweet that this person\ncreated right our frontier basically\nfirst we're going to get the index and\nthat index is basically just going to be\nthe last value of the list so first to\neven get the list we need the tweet map\nof this followe id so this will give us\na list we want the length of this list\nminus 1 because that will give us the\nlast index and using that last index we\ncan take that list\nso this is the list we're going to index\nit so basically look at this position of\nthe list which will give us the last\nvalue and remember this itself is a pair\nof values the count and the tweet id so\ncount tweet id and this is what's going\nto be added to our min heap so i'm\ninitially just going to append this to\nthe min heap we don't need to heap push\nit or anything and then we can heapify\nthis after we've added every value that\nwe want to it so i'm appending to the\nmin heap the first value so it's going\nto be not just a pair of values but it's\nactually going to be 4 values and you're\ngoing to see why but the first value is\nwhat's used as the key as long as\nthere's not a tie and there won't be a\ntie in this case because count is always\ngoing to be unique for every single\ntweet in this case i'm gonna add that\ncount as the first value because that's\nwhat we want to use as the key that's\nwhat we want to order our min heap and\nthen the remaining i'm gonna of course\nneed to add the tweet id because that's\nwe're gonna we're gonna end up adding to\nthe result and i'm also going to be\nadding the followee id of this person\nbecause after we pop this tweet we also\nwant to get the next tweet from this\nfollowee id right so we using this\nfollowee id we're going to go back to\nthe list and then get the next position\nat the next index not really the next\nindex but the previous index so really\ni'm going to decrement this index by one\nso let's make sure to store that index\nalso in our min heap just so we have it\nso we can take that index decrement it\nby one but we're basically saying that\nthis is the next position we're going to\nlook at in our list over here as long as\nit's greater than or equal to zero\nbasically as long as there are still\nelements in that list for that followee\nid okay that's definitely a lot going on\nhere which is why this problem is pretty\ndifficult for a medium and actually one\nthing i forgot to do is\nwe're not 100 sure that this followee id\nthis person even has any tweets that\nthey created so before we even try to uh\nyou know look at it inside of the tree\nmap before we try to look at some index\nlet's make sure that at least has one\ntweet so basically if followee id is in\nself.tweet map if that is the case then\nthey have at least one tweet so that's\nwhen we're gonna be actually running\nthis portion okay so we go through every\nuh person that they follow after we do\nthat let's make sure to actually turn\nthis list because right now it's just a\nlist we want to turn it into a heap a\nmin heap so in python we can do that\nlike this heapq.heapify\nto that key okay now we actually get\ninto the main portion of the algorithm\nremember we want to pop\nat most 10 values we can run a while\nloop basically saying while the min heap\nis non-empty and the result or or the\nlength of the result is less than 10. so\nbasically if we run out of values this\nis going to stop even if we don't have\n10 but right if our min heap is empty\nit'll stop if we reach 10 values it'll\nalso stop each time though we're going\nto pop from the min heap we want the\nmost recent tweet that occurred we can\ndo that in python like this heap q dot\nheap pop from the min heap it's going to\npop four values that we defined up here\nright so i'm just gonna copy and paste\nthat\nfour values we don't need the minus one\nso\nthese are the values it's gonna give us\nand of course we want the tweet id\nthat's the most important because that's\nwhat we're going to end up adding to the\nresult this is the most recent tweet\nthat happened so we can go ahead and add\nit to the result now if this followee id\nthis person had any more tweets we want\nto get that tweet and we can get it at\nthis index let me just actually copy and\npaste this because we're using the same\nvariable names which makes it convenient\nfor us so let me uh so from the tweet\nmap we're going to get that person and\nthis index which will tell us the next\ntweet that we can add to our min heap\nthis remember returns a pair of values\nwhich we defined up here count and tweet\nid so let's re-define count and redefine\ntweet id which we you know used up here\nthat's okay we'll redefine them because\nthis is these two values are what we're\nnow going to be uh pushing to the heap\nwe can do that like this heap q dot heap\npush to the min heap and we're always\nadding four values to it the first one\nis going to be the count next is going\nto be the tweet id next is going to be\nthe followee id which we have up above\nand last is going to be the index but\nremember we always add the index minus 1\nbecause we're adding the next index uh\nbut don't forget we just ran these two\nlines of code right but we're assuming\nthat the index is going to be valid\nwe're assuming that the index is going\nto be greater than or equal to zero that\nthat person has some more tweets left\nthat we haven't already added to the min\nheap so let's make sure to have that\nconditional up above okay and quite a\nbit of code but luckily that is all of\nit so after all that is done we have 10\ntweets we can go ahead and return the\nresult and of course i do i miss the\nname so this is follower map but we\ndon't need the er okay and i had one\nlast bug and actually had to do with how\nwe read the problem they actually define\nthe news feed like a user is actually\ntechnically following themself basically\nwe want the 10 most recent posts from\nthe people that they follow including\nthemself so before we even run this\nfunction what we're actually going to do\nis to the follow map of that person\nwe're just going to add themselves to it\ni think that's one of the easiest ways\nto do this so for that user user id\nwe're going to add themselves to it so i\nthink that's kind of dumb if i was doing\nthis in a real interview i think i'd\nprobably miss this detail but it's just\none thing you need to do to pass this\nproblem so now let's run it i really\nhope i don't have any more bugs and\nluckily it actually does work so you can\nsee on the left yes it works and it's\npretty efficient so i really hope that\nthis was helpful if it was please like\nand subscribe it really supports the\nchannel a lot consider checking out my\npatreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Find Median From Data Stream",
        "NcLink": "find-median-in-a-data-stream/",
        "Pattern": "Heap / Priority Queue",
        "Description": "The **[median](https://en.wikipedia.org/wiki/Median)** is the middle value in a sorted list of integers. For lists of *even* length, there is no middle value, so the median is the [mean](https://en.wikipedia.org/wiki/Mean) of the two middle values.\n\nFor example:\n* For `arr = [1,2,3]`, the median is `2`.\n* For `arr = [1,2]`, the median is `(1 + 2) / 2 = 1.5`\n\nImplement the MedianFinder class:\n\n* `MedianFinder()` initializes the `MedianFinder` object.\n* `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n* `double findMedian()` returns the median of all elements so far.\n\n**Example 1:**\n\n```java\nInput:\n[\"MedianFinder\", \"addNum\", \"1\", \"findMedian\", \"addNum\", \"3\" \"findMedian\", \"addNum\", \"2\", \"findMedian\"]\n\nOutput:\n[null, null, 1.0, null, 2.0, null, 2.0]\n\nExplanation:\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.findMedian(); // return 1.0\nmedianFinder.addNum(3);    // arr = [1, 3]\nmedianFinder.findMedian(); // return 2.0\nmedianFinder.addNum(2);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n```\n\n**Constraints:**\n* `-100,000 <= num <= 100,000`\n* `findMedian` will only be called after adding at least one integer to the data structure.\n",
        "Difficulty": "Hard",
        "Video": "itmhHWaHupI",
        "PythonSolution": "class MedianFinder:\n    def __init__(self):\n        # two heaps, large, small, minheap, maxheap\n        # heaps should be equal size\n        self.small, self.large = [], []  # maxHeap, minHeap (python default)\n\n    def addNum(self, num: int) -> None:\n        if self.large and num > self.large[0]:\n            heapq.heappush(self.large, num)\n        else:\n            heapq.heappush(self.small, -1 * num)\n\n        if len(self.small) > len(self.large) + 1:\n            val = -1 * heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -1 * val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -1 * self.small[0]\n        elif len(self.large) > len(self.small):\n            return self.large[0]\n        return (-1 * self.small[0] + self.large[0]) / 2.0\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nfind median from a data stream so this\nis another\nhard problem but it's not super\ndifficult if you know the data structure\nbehind it\nso they basically tell us we know the\nmedian is defined as the middle value\nin a sorted integer list if the list is\neven there is no middle value so you\ntake the average of the two middle\nvalues right\nso with this sorted array the middle\nvalue is three so the median is three\nwith this there is no middle value so\nyou take the two middle values\nadd them together divide by two and then\nyou get a median of 2.5\nand so we're actually designing a data\nstructure that's going to have two\noperations\none operation is going to be adding a\nnumber to our data stream so we had\nwe actually have to store the list of\nnumbers and that list of numbers is not\nconstant it's going to be changing every\ntime\nadd number is called and then from that\nlist of numbers that we're going to be\nmaintaining ourselves\nwe are going to need to constantly be\nfinding the median\nof that list so every time this function\nfind\nmedian is called we have to return what\nthe median is\nfrom the elements so far so this is just\nan example\nif we add num1 then our list is going to\nhave one in it\nif we add another number two then our\nlist is going to have two numbers\nthen if we want to find the median we\nwill take the average of these two and\nit's going to be\n1.5 after that we'll add another number\nthree\nand then we'll find the median again in\nthis case the median is different\nbecause our list got updated the middle\nvalue is now\ntwo so what's the most obvious way to\nsolve this problem well i\nbasically just hinted at it right so\nwhere\nthe way the obvious way to solve this is\ninsert elements\nin order so let's say these are the\nfunction calls that are gonna be made so\nwe're gonna add\nfour numbers and then we're gonna try to\nget the median so we're gonna maintain\na list or an array right and\nevery time we get a function call add\nthree\nwe're gonna insert in order just like it\nsays up here\nand basically if our array is always\nsorted\nthen it's going to be easy to identify\nthe middle number right which is going\nto be the median\nright so the median is always going to\nbe in the middle position and if our\narray is sorted we'll always know where\nthat\nis so the first one we have is add three\nso just add it to the first spot\nnext we want to add two so how do we do\nthat in order well\nwe have to traverse our array so far so\nwe get\nwe see that there's a three over here\nright so then we gotta replace that\nthree we shift the three to the next\nposition and then we put a\ntwo in the position that the three was\ninitially at\nright so now our array is in sorted\norder we had to\nuh shift some elements and we had to\nsearch for the spot that we put the two\nin right so you can tell that every time\nwe add a number\nit's going to be an o of n operation\nwhere\nn is the number of elements we have\nadded so far\nso we added two next let's add one\nwell we're gonna traverse the array\nright we're gonna see okay the first\nelement is two we know that\none is less than two so really what\nwe're gonna do is\ncross out the two cross out the three\nright shift the two over here\nshift the three over here and then put a\none here but\ni'll just to keep the picture simple i'm\njust gonna put the one over here but we\nknow that\nin the worst case every time we insert\nan element it's gonna be o of\nn lastly we're gonna take the four and\nadd the four so we're gonna see\none nope four is bigger than that two\nnope four is bigger than that three\nnope four is bigger than that so we add\nthe four at the end\nso now we finally have a get median call\nwell good thing for us since our\narray is in sorted order we know getting\nthe median is super easy in this case we\nhave an\neven length list right we have four\nelements so we are going to take\nthe two middle elements two and three\nadd them together\ndivide by two we're going to get 2.5 so\nwe know that\nthe get median operation is always going\nto be o of 1\nbut adding a number is always going to\nbe o of n\nso how can we speed this o of n\noperation up and let me just tell you\nbasically what we're going to do\nis instead of having just a single list\nof\nelements we're gonna break this up into\ntwo and\nthe we're gonna have basically two\nsubsets right\nand one is always gonna be less so this\nhas one\nand two and this has three and four\nand all elements from the left are\nalways going to be\nless than or equal to all elements in\nthe right\nso this will also make it easy for us to\nget the median\nbut i'm not just gonna have arrays i'm\ngoing to use a\nheap or a priority queue so we're going\nto use a heap data structure\nso i'm going to have two heaps in this\ncase a small heap and a large heap\nsmall heap all elements in the small\nheap are always going to be less than or\nequal to\nall elements in the large heap also\nthe size of these heaps is always going\nto be approximately equal so\nif there were two elements in this heap\nthen there's there has to be two\nelements in this heap what if we had an\nodd number of elements so what if there\nwere three elements in this heap\nthat's allowed because we know that we\ncan't actually\nhave these be equal if there's a two and\na three right\nor in the opposite case there could be\ntwo elements here and there could\nactually be\nthree elements here that's also allowed\nbecause we know that's approximately\nequal\nif the difference though is ever greater\nthan one so if there were\nfour here and two here we know then we\nhave to balance them right make this\nequal\nthree and make this equal three right we\nalways have to keep it as balanced as\npossible\nand if you're not familiar with what\nexactly a heap is\nit's basically like a list it's pretty\nsimilar to a list it's implemented\nusing arrays or lists the only\ndifference is though\nadding a number we don't add at the\nbeginning or at the end we just\nadd elements to the heap and adding an\nelement to this\nheap is always going to be a log n\noperation\nand removing an element is also going to\nbe\na log n operation right so add\nor remove is log n and there happen to\nbe\ntwo kinds of heaps a max heap or\na min heap and the thing about these\nis so for a max heap finding the max\nin this list so find max in a max heap\nis always going to be\no of one so that's the advantage\nwe know that finding the max in a\nregular list\nis o of n because you have to search the\nentire list\nbut with a heap we can find the max in\nconstant time\nsimilarly with a min heap if you want to\nfind the min\nthat's also an o of one operation\nso with that being said the small heap\nis going to be implemented as a\nmax heap and the reason we have a max\nheap and not a min heap it's kind of\ncounterintuitive right if this is the\nsmall heap why are we using a\nmax heap and that for this one we're\nactually going to have a\nmin heap instead of a max heap\nand the reason is what if we had\nelements to\nthese heaps such as right what if we had\nthese elements in each of the heaps\nright we see that all elements here are\nless than or equal to the elements in\nthe\nright heap but if you actually want to\nfind the median\nof these we know we need to get the max\nvalue in the small heap right two and we\nneed to get the\nmin value in the large heap three\nadd them together and then divide by two\nright that's how we're going to get the\nmedian so that's why we need the min\nheap right\nwe always want the minimum value from\nour large heap and we always want the\nmax value from our small heap and of\ncourse\nfinding the median like this way right\ngetting the\nvalue getting the value from each of the\nheaps it only works\nif the size of the heaps is\napproximately the same right if\nin this case they're equal but what if\nwe had a\nthird element in this heap what if we\nhad a three well they're approximately\nequal right but you can see the length\nof this one\nis greater right but the difference in\nlength is one so they're approximately\nequal\nin that case how are we going to find\nthe median well since we know that the\nlength of this heap is bigger than the\nlength of this heap\nwe know that we have an odd number of\nelements in that case right if one heap\nis bigger than the other there's\nalways going to be an odd number and in\nthat case we're going to want to get the\nvalue\nfrom this heap so if the length of this\nheap\nis bigger we're going to want to get the\nmax from\nhere we're going to want to get the max\nvalue from this heap and that's going to\nbe\n3 and we know in this case 3 happens to\nbe the median right if you\nbecause look at them these values are in\nsorted order we get rid of these two we\nget rid of these through\ntwo the middle value is three and i'm\nnot going to walk you through this case\nbut\nlet's just say imagine we had a two over\nhere the exact same thing would happen\nright we would get the min value from\nhere we get the two\nand notice that look the max value from\nhere and the min value from here are\nequal right that's why i say\nevery value in here has to be less than\nor equal it's possible that they are\nequal\nokay so now let me just go through a\nquick walkthrough of this code again\nso what we're gonna do add the first\nelement which is a three\nwhich heap are we gonna add it to in\nthis case it doesn't really matter so\nwhat i'm gonna do is just by default add\nit to the small heap\nso let's add three to the small heap and\nwe know that that was roughly a log\nn operation right next let's add\ntwo so by default i'm always gonna take\nwhatever element we add and i'm gonna\ntake it and add it to the small heap now\ni added\ntwo to the small heap but wait a minute\nnow the heaps are not approximately\nequal\nthis has a length of two this has a\nlength of zero it was okay when this had\na length of one because that's still\napproximately equal\nbut 2 is that's too big of a difference\nso now what we're going to do is find\nthe max\nvalue in this heap and add it to\nthis heap the large heap which is always\ngoing to have elements greater than or\nequal to the small heap\nso we need to get the max value from\nthis heap and since this is a max heap\nactually finding the maximum is an o of\none\noperation now the downside is we have to\nremove\nthat value which is a log n operation\nand we're going to take that element\nthat we removed and add it\nto the min heap and that's also going to\nbe a\nlog n operation we know adding and\nremoving\nfrom heaps is always login finding the\nmaximum in a max heap\nis o of one finding the minimum in a min\nheap is also o of one\nokay so now we did add three add two now\nlet's add\none i'm gonna change this add one to a\nadd\nseven just to illustrate one last thing\nabout this\nalgorithm that we're gonna do and let me\njust cross this out we're not doing\ninsert order anymore we're doing the\nheap solution\nso we're gonna add seven right by\ndefault\ni know that i'm adding it to the small\nheap so what am i gonna do i'm gonna\ntake\nseven and add it to the small heap now\nthe size of this heap is two the size of\nthis heap is one so they are\napproximately equal the last condition\nthough\nis every element in the small heap less\nthan or equal\nto every element in the min heap now how\nare we going to check that well\nwe can find the minimum of the min heap\nin o of one time\nright it happens to be three we can find\nthe max of the small heap in o of one\ntime\nit happens to be seven is that\nis seven less than or equal to three no\nit's not so\nwhat are we gonna do well we're actually\ngonna do the exact same\nthing we did before so i'm gonna find\nthe max\nfrom the small heap in o of one time i'm\ngonna remove that max so\nseven is removed to remove we know it\ntakes login time\nand then i'm going to add it to the min\nheap\nwhich also takes log n time so now\ni'm adding seven and the lengths are\napproximately equal still right this has\none element this has\ntwo elements and now if we get the\nmaximum from here\ntwo and we get the min from here three\nwe see that the condition actually now\nis true every element in the left\nis less than or equal to every element\nin the right\nnow we added seven now let's do add four\nso by default i'm always going to add it\nto the small heap\nso i'm adding four to the small heap the\nsmall heap has two\nthe large g has two also but we know\nthat\nthis condition doesn't hold right the\nless than or equal condition if we get\nthe max\nfrom here that's going to be four if we\nget the min from here that's going to be\nthree\nthis is just not true right four is not\nless than or equal to three\nso we have to pop this and we have to\nmove it\nto this heap so now everything is good\nright it's\nevery value is less than or equal write\nthis as two this has three that's less\nthan or equal gray\nonly problem now is the lengths are not\napproximately equal\nthis has one element this has three\nelements\nso since the length of this one is\ngreater what are we gonna do we're gonna\nget we're gonna find the min\no of one time remove that min and\nthen move it to this heap so we know\nthat the min\nis three we can do that in o of one time\nbut removing it is gonna be\nlog n and adding it to the left heap is\nalso gonna be log n\nso now the lengths are approximately\nequal this has two elements\nthis has two elements and the other\ncondition find the max from here find\nthe min here\nwe'll end up with three and four and\nless than or equal is definitely true\nso it looks like a lot of work and it\ndefinitely is\nit's a lot harder than just having one\narray right\nit's definitely more code but it's also\na lot more efficient now\nthe only thing we have to do is get the\nmedian and\nthe time complexity for get median is\nactually still\no of one which is exactly what we wanted\nlet me show you why\nwell we need in this case we have an\neven number of elements right\ntwo plus two is even so we wanna find\nthe maximum from our left heap which is\nthree right we know we can do that in\no of one time because this is a max heap\nwe want to find the minimum value from\nour right heap and we know we can do\nthat in o of one time because this is a\nmin heap and we know that four happens\nto be the min value\nso we get these two values three plus\nfour\nadd them together divide by two and\nthat's going to be our median so we can\nstill\nfind the median in o of one time which\nis great\nnow with all that being said let me\nfinally show you the code\nand show you that it's not as long as\nyou might expect okay so now let's look\nat the code\nso here's a couple comments we're gonna\nhave two heaps large and small\nlarge is gonna be a min heap mac or\nsmall is gonna be a max heap\nand the heaps should be roughly equal to\nroughly\nthe same size so in python you can\nactually have a heap\nbe just a list and i'll show you the\nother things we'll need to do later so\nactually in python since these are\nmembers\nof this object large and small we need\nto\nhave a self as the prefix and so\nnow we have two functions to implement\nfind median and add num let's start with\nadd num\nso just like i showed you what i'm going\nto do is\ni'm always going to take num and add it\nto the small heap so\nheap q dot heap push this is how you do\nit in python\nother languages might be different\nobviously so to the small heap we're\ngoing to push num\nnow python is kind of annoying in that\nit only\nimplements min heaps we know small is\nactually a\nmax heap so to get around that what i'm\ngoing to\nhave to do is take every number and\nactually multiply it by negative one\nthis allows us to actually implement a\nmax heap which\nisn't implemented by default in python\nfor some reason\nbut what i'm doing here is taking num\nand adding it to\nthe small heap the max heap right but\nnow we want to make sure\nevery element in small\nis less is less than or equal to\nevery element in large right so every\nelement in the small heap has to be less\nthan or equal to every element in the\nlarge heap so i'm going to make sure\nthat that's true so\nif if small and large are non-null\nand so from from small from our\nsmall heap our max heap what i'm going\nto do is get the max value from it so\nhow can i do that i can just take the\nindex of 0 because it's\nimplemented as a list heaps are\nimplemented as lists\nso if you get the 0th index you're\ngetting the max value\nwe know that every time we add a value\nto the small heap we're multiplying it\nby negative one\nso to reverse that i'm going to take\nthis value\nand multiply it by negative one and get\nthe true value that we actually added to\nthe heap\nand so i wanna know is this value\nsomehow\ngreater than the smallest value in our\nlarge heap how can i get the smallest\nvalue in our large heap i can do the\nexact same thing\nindex of zero but i didn't have to\nmultiply this by negative one\nbecause this is a min heap and that's\nwhat python does by default\nso if this condition is true let me make\nit look a little nicer so\nso that mainly this condition is true\nmeaning that some value\nin our our small heap is greater than\nour large heap then we have to\npop from our small heap and then add to\nour large heap\nso i'm going to heap q dot\nheap pop so i'm going to pop from our\nsmall heap i'm going to get the largest\nvalue from our small heap stored in val\nand then i'm going to i'm going to push\nthat value\nto our large heap so to our large heap\ni'm going to push that value\nbasically exactly what i did in the\npicture but maybe the\ncode is a little confusing oh and\nactually since we know\nevery value pushed to the small heap is\nbeing multiplied by negative one\nto reverse that we have to also multiply\nit by negative one when we pop from it\nbecause look when we pushed to it we\nmultiplied that number by negative one\nbut to our large heap we can actually\ngive the correct values we don't have to\nmultiply by negative one\nthat is actually probably one of the\nmore confusing parts about this\nwhich is annoying because there's no way\nto really get around it in python\nso now we check this condition the only\nother condition that we have to check\nis what if the size is uneven\nand so by uneven size we actually mean a\ndifference\ngreater than one so if the length of\nsmall\nis greater than the length of large plus\none that means the difference is two or\ngreater\nin that case in that case what are we\ngoing to do this is too big so what\nwe're going to do is\npop from the small and then up and then\npush to the large which is actually\nexactly what we did\nup here so i'm just going to copy and\npaste that\nand the other case is if the length\nof the large heap is greater than the\nlength of the small heap\nplus one meaning the difference is two\nor greater\nand in that case i'm basically going to\ndo the opposite of what we just did up\nhere so let me copy and paste that so\nwe don't need this negative one because\nwe are going to be popping from\nthe large heap which has the correct\nvalues not the negative one multiplied\nvalues\nand with that value though i'm going to\ntake that value and add it to the\nsmall heap and actually we are going to\nneed to take this value and then\nmultiply it by negative 1\nbecause we have to do that whenever we\nadd to this\nsmall heap so now we are making sure we\ntake every element add it to one of the\nheaps and if there happens to be\na size difference we're handling that if\nthere happens to be\nan order difference right like the\nvalues are in the wrong order we're\nhandling that as well\nand remember all of these heap\noperations are\nlog n operations log n\nand now the last thing we have to handle\nis finding the median\nso one case is that there's an odd\nlength how do we know if there's an odd\nlength well\nif the length of small was ever\ngreater than the length of large we know\nthat then we have an\nodd length right because maybe one of\nthem has three elements the other has\ntwo elements\nwe know with this function we're always\nmaking sure that they're\nabout roughly equal so if this evaluated\ntrue that means we have an odd number of\nelements\nand small happens to have an extra\nelement so what we can do\nis return the largest value in small\nwhich is stored in index 0 of small\nif the opposite is true if the length of\nlarge\nis somehow greater than the length of\nsmall\nwe know that the opposite happens to be\ntrue so we can return\nthe smallest value in large now if\nneither of these\nevaluates that means we have an even\nnumber of elements so\neach each of these heaps has the exact\nsame size so what we can do in that case\nis return the largest value\nin the small heap plus the smallest\nvalue in the large heap add them\ntogether\nand then divide by two and then return\nthe result of that\nso here is the final code it's 34 lines\nbut you can see we have some comments\nand some\nyou know boilerplate type uh code\nbut the code that itself that we had to\nwrite was relatively short right because\nwe did this with a heap\nand we did it pretty efficiently let me\njust run it to prove that it works\nokay uh just one time i forgot to\nsay that this small is a member object\nso self.small\nand i actually forgot to do that in a\ncouple places so let me just fix that so\nself.small self.large self.small\nself.large self.small self.large\nand a couple more places okay so we\ncorrected\nthe self errors one last thing i forgot\nis remember\nsmall as negative we multiplied the\nnumbers by negative so when we're\ngetting the number and actually trying\nto calculate the median we have to take\nthat number and multiply it by negative\none\nbefore we add it to this number and then\ndivide by two\nand let me not forget to do the exact\nsame calculation when we're returning\nthe value here right so i somehow had\ntoo many bugs in here but okay so now\nfinally\nthis should be the final code the big\nthing in python at least is to remember\nthese negative ones if you're doing this\nin c\nplus plus or java i'm pretty sure you\nwill not have to worry about that\nthis should be the final code finally\nand you can see\nyes it is pretty efficient and in python\nat least it's not\na lot of code i think even in java and c\nplus it shouldn't be that much code\neither so i hope this was helpful\nif you enjoyed please like and subscribe\nit supports the channel\na lot and i'll hopefully see you pretty\nsoon\n"
    },
    {
        "Name": "Subsets",
        "NcLink": "subsets/",
        "Pattern": "Backtracking",
        "Description": "Given an array `nums` of **unique** integers, return all possible subsets of `nums`.\n\nThe solution set must **not** contain duplicate subsets. You may return the solution in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3]\n\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7]\n\nOutput: [[],[7]]\n```\n\n**Constraints:**\n* `1 <= nums.length <= 10`\n* `-10 <= nums[i] <= 10`\n",
        "Difficulty": "Medium",
        "Video": "REOH22Xwdkk",
        "PythonSolution": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n\n        subset = []\n\n        def dfs(i):\n            if i >= len(nums):\n                res.append(subset.copy())\n                return\n            subset.append(nums[i])\n            dfs(i + 1)\n            subset.pop()\n            dfs(i + 1)\n\n        dfs(0)\n        return res\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem\nsubsets so we are given an integer array\nnums and all we need to do is return\nevery single possible subset that we\ncould create\nfrom the input nums and we do not want\nto\ninclude any duplicate subsets so what is\na subset well let's say we have\none two three as our input one subset of\ncourse would be\none right by itself another subset would\nbe two by itself\nwe could do one two together now what\nhappens if we do\ntwo one right we just swap the order\ndoes that\ncount as a different subset or is that\nthe same\nas this subset well they're the exact\nsame we don't care about the order this\nis not a permutation\nthis is a subset so it's not a\npermutation\nit's a subset so we do not want to\ninclude\nduplicates and this counts as a\nduplicate we're not going to include it\nand 3 is another subset 1 3 2\n3 1 2 3 the original input\nis technically also a subset and we also\ndon't want to forget the empty subset so\nno matter\nwhat we're given an empty subset is\ntechnically a subset of this\nas well so if we want to create all the\nsubsets from this input we have a choice\nfor\nevery single element so for this one\nwe have a choice of include the one in\nour subset\nor not include the one so we get an\nempty subset right so we have that\nchoice\nand we have that choice for every single\ninput element so in total we have two\nchoices here\ntwo choices here and two choices here so\nthis is going to be\n8 or in other words 2 to the power of n\nwhere n is the size of our\ninput right so this is the number of\nsubsets\nand we don't want the number of subsets\nwe actually want the subsets themselves\nso how long could a subset be right well\nwe could have a subset one two three\nright the size of our input\nwe could also have subsets that are\nsmaller right like one two\nmaybe two three so as you can tell\nthis is not going to be an efficient\nproblem to solve we have this many\nsubsets\nand each subset could be up to length n\nso the worst case time complexity of\nthis problem is going to be\nn times 2 to the n regardless of\nhow efficient we make it because given\nthe constraints of this problem we don't\nwant the number of subsets we want the\nsubsets themselves\nwe have to make it inefficient so with\nthis in mind we can just\njump straight into backtracking which is\nthe brute force way of solving this\nproblem but it's also\npretty much the most efficient way so\nlike i said\nfor each of these elements we have a\nchoice so i'm going to draw the decision\ntree\nso first we can choose to add one or\nnot add one and that will give us two\nsubsets one subset with just one\nand one empty subset so along\nthis path we can decide now do we want\nto add two or\nnot add two so with one decision we will\nadd two and the other decision we won't\nadd to\nso we'll get one two as one subset and\nthe other subset will just be\none by itself and we can actually repeat\nthat\non the right subtree for two so we can\ndecide to add\ntwo to this empty subset or we can\ndecide\nto not add two to the empty subset in\nwhich case we'll get\na subset with two by itself or we'll get\nthe empty subset again right\nthis is where we're just not adding\nanything and lastly\nwe can decide whether we want to add\nthis 3 or not\nso if we add the 3 to this subset we'll\nget\n1 2 3. if we don't add the 3\nthen we will remain as 1\n2 and we can repeat that decision over\nhere\nand that's basically what i'm gonna do\nnow right repeat that decision for every\nsingle one of our like you can call them\nnodes or you can call them leaf nodes\nthat's just what we're doing\nso if i add the three here we'll have a\none three\nif i do not add the three here we'll\nhave the\none by itself so you can kind of see\nthese are\nfour unique subsets right now let's\nbuild the rest of the four from over\nhere\nso i have the choice do i add three or\ndo i\nnot add three to this subset if i do i\nwill get\ntwo three if i don't i will have\ntwo by itself and you can see these two\nsubsets are\ndifferent from the subsets over here\nthese are still unique\nand lastly we can choose to add three\nto the sub to the empty subset or we can\nchoose\nnot to add three to the empty subset in\nwhich case\nwe'll get a single empty subset now you\ncan see\nwe keep multiplying by two right so here\nwe had a one we had one\nwe we multiply by two now we have two\nsubsets over here right we go down again\nwe multiply by two now we have\nfour subsets over here right then we go\ndown one more time multiply by two we\nhave\neight subsets and they're all unique\nthis is our result this is what we're\nbuilding with this problem\nthis is backtracking now if you want to\nknow how to do this backtracking\nsolution in code\nlet me show you right now so let's do\nthis with backtracking so we're going to\nhave\na result list which we're going to add\nthese subsets to\nand i'm gonna do this with uh\nbacktracking depth first search\nand i'm going to write this function\ninside of this function\nso that we don't have to pass in this\nvariable or this variable into it\nwe'll just have access to it by default\nbut i'm going to pass an i which is the\nindex\nof the value that we are making the\ndecision on so\nyou know we had one two three so\ninitially i'm going to pass an\nindex zero for this one and you know\nthis will be index one this will be\nindex 2 that's going to tell us\nwhether we decide to add 3 or not add 3.\nso this i will tell us which element\nwe're currently\nvisiting and so we know that the base\ncase for this will be if\ni happens to be out of bounds so if it's\ngreater than or equal\nto the length of our input we know we're\nout of bounds\nand in that case we can just return now\nwhat\nwhat like data structure am i going to\nuse to build each subset i'm going to\nhave an array and i'm going to allocate\nit\noutside of the function so that we have\nglobal access to it inside of\nthis function right so let's say cur\nlet's actually call it subset\nlet's say that it has the subset that we\ncurrently have if we ever reach the base\ncase we know we've gotten\npast our leaf node so what we can do is\nadd that to our result\nand i'm also going to add a copy of the\nsubset because\nit because the way it works in python\nand in most most languages\nthis subset is going to be modified\nright so we know we have two decisions\nso this is the decision\nto include nums of i so this is like our\nleft decision that i showed you in the\npicture right so what i'm going to do is\nto the subset i'm going to append\nnums of i and then i'm going to\nrecursively run\ndepth first search on the next element\nso i plus\n1. so this is going to be like the left\nbranch of our\ndecision tree and this is going to be\nthe decision\nnot to include nums of i so basically\nwe're skipping numbers of i so how am i\ngoing to do that i'm going to take the\nsubset\nand just pop the element that we just\nappended and then i'm going to\nrecursively run depth first search\nuh i'm basically going to do the same\nthing so these\ntwo function calls while they look the\nexact same they're going to behave\nslightly differently because for this\nrecursive call\nit's going to have a different subset\ngiven to it\nand this recursive call is going to have\nan empty subset given to it so now the\nonly thing left for us to do\nis call our function of course we're\ngoing to pass\nan index 0 that's the first value and\nthen we can return\nour result so as you can see it is of an\nefficient solution\nluckily for us the order that we have\nour subsets in the result doesn't matter\nso for example if we had an empty\nsubset and we had one that's the same as\nif we returned\none and the empty subset right like the\norder that we put the subsets in\ndoesn't actually matter but again i hope\nthis was helpful if you enjoyed\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Combination Sum",
        "NcLink": "combination-target-sum/",
        "Pattern": "Backtracking",
        "Description": "You are given an array of **distinct** integers `nums` and a target integer `target`. Your task is to return a list of all **unique combinations** of `nums` where the chosen numbers sum to `target`.\n\nThe **same** number may be chosen from `nums` an **unlimited number of times**. Two combinations are the same if the frequency of each of the chosen numbers is the same, otherwise they are different.\n\nYou may return the combinations in **any order** and the order of the numbers in each combination can be in **any order**.\n\n**Example 1:**\n\n```java\nInput: \nnums = [2,5,6,9] \ntarget = 9\n\nOutput: [[2,2,5],[9]]\n```\n\nExplanation:\n2 + 2 + 5 = 9. We use 2 twice, and 5 once.\n9 = 9. We use 9 once.\n\n**Example 2:**\n\n```java\nInput: \nnums = [3,4,5]\ntarget = 16\n\nOutput: [[3,3,3,3,4],[3,3,5,5],[4,4,4,4],[3,4,4,5]]\n```\n\n**Example 3:**\n\n```java\nInput: \nnums = [3]\ntarget = 5\n\nOutput: []\n```\n\n**Constraints:**\n* All elements of `nums` are **distinct**.\n* `1 <= nums.length <= 20`\n* `2 <= nums[i] <= 30`\n* `2 <= target <= 30`\n",
        "Difficulty": "Medium",
        "Video": "GBKI9VSKdGg",
        "PythonSolution": "class Solution:\n    def combinationSum(self, nums: List[int], target: int) -> List[List[int]]:\n        res = []\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if i >= len(nums) or total > target:\n                return\n\n            cur.append(nums[i])\n            dfs(i, cur, total + nums[i])\n            cur.pop()\n            dfs(i + 1, cur, total)\n\n        dfs(0, [], 0)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve combination sum\nand this is another problem from that\nblind 75 list the link will be in the\ndescription so we are doing one more\nproblem\nand have very few problems from this\nlist remaining\nso we're given an array of distinct\nintegers called\ncandidates and we're given a target\ninteger called\ntarget and we just want to return a\nlist of all the unique combinations of\ncandidates where all those numbers end\nup summing to the\ntarget value and we're allowed to return\nthose combinations in any order\nand we're also allowed to use the same\nnumber from candidates\nmultiple times but we don't want to have\nduplicate\ncombinations for example if 2 2\n3 sums up to 7 right that means\n3 2 2 these are the exact same values\nright\njust in a different order these sum to\nseven as well so we don't want to add\nboth of these combinations to the result\nbecause they're the exact same\nso what we're saying is we want\ncombinations we don't want permutations\nthat end up summing\nto the target value so in this example\nyou can see\nthat we are given these candidates and a\ntarget of seven and we have two\ndifferent ways that we can sum up to\nseven of course seven by itself\ndoes sum up to the target and two\noccurrences of the two value and one\noccurrence of the three value added\ntogether\nare gonna lead to seven as well so then\nwe return these two combinations\nas our result so i would say the\ndifficult part about this problem is\ntrying to figure out how to\neliminate duplicate combinations right\nfor example if we just brute force it\nlike a decision tree so we have four\ndifferent values we can choose we can\nchoose each of them\nan unlimited number of times what we can\ndo is have four decisions in our\ndecision tree right like that might be\nthe naive thing that you start with\nso we would get two three\nsix and seven and then we'd basically\ncontinue that right\non one path over here we would find okay\nwe found the seven\nso we found the target right so we found\none way that we can reach the target\nso therefore we don't need to continue\ndown here because as we add more numbers\nall of these values are going to be\npositive so as we add more numbers\nwe're only going to get a sum larger\nthan the target so you know\ni think it's kind of obvious why we\ndon't continue down this path right\nbut down here from the six let's try to\ncontinue right we can add a two so we'd\nget\nsix two we could add a three so we get a\nsix three\nwe could add another six so we'd get six\nsix and we could add a seven where we'd\nget six seven\nso notice how all of these are gonna sum\nto a value\ngreater than the target so down this\npath we\nnever ended up reaching the target we\nonly went over the target so we don't\ncontinue down any of these paths\nright but now let's continue down this\npath so here\nwe'll get we can get another 2 we can\nget\na 3 we could get a 2 6 but in that case\nwe would get 8 which goes over our\ntarget we could also get a 727\nbut that also goes over our target now\nhere's the part where we're going to end\nup getting duplicates so i'm going to\nshow you why\nthis type of decision tree does not work\nso here we could get\na 3 for example right so we'd get two\ntwo\nthree now that sums to the target down\nthis path we could choose a two so we'd\nget two\nthree two notice how both of these\nend up summing to seven but they're the\nexact same they're just in a different\norder we have two twos and a three\nhere we also have two twos and a three\nso we ended up getting the same\none twice so this works in finding the\ncombinations but we end up getting\nduplicate combinations so what kind of\ndecision tree can we try\nthat gets us the result that we want but\ndoes not have these duplicates let me\nshow you how we're gonna do that\nlet's logically think about this we know\nthat we have one value in our\ncandidates two right so we can try to\nget\nall combinations that include this\n2 value right and see if any of those\ncombinations leads us to the target\nvalue\n7. now we could also so then\nif we make a second decision over here\nright in this decision we're definitely\nincluding at least\none two now if we go down this path we\nwant to make sure that\nnone of the combinations down this path\never match the combinations down this\npath\nhow can we guarantee that well in this\nside we said we're definitely including\nat least one two\nhow about in this side we don't include\neven a\nsingle two so basically we skip\ntwo so here we're gonna have an empty\narray because we skipped the two right\nall we said is we were able to start\nfrom here but we said no we're just not\nincluding a two we're just gonna do\ncombinations with these three values\nthat's gonna guarantee that none of the\ncombinations on both sides are gonna be\nmatching\nand that's basically the logic that\nwe're gonna follow\nso from here remember we can include\nmultiple twos if we want to right so one\ndecision here could be including a\nsecond two so we get two two now\nthis is this path is going to include\nall combinations that include\nat least two twos right and but remember\nour definition for this decision tree\nneeds to be recursive right because we\ndon't\nwant any of the combinations down this\npath to be the same as any of the\ncombinations down this path so what we\nsaid here is\nwe're going to include two twos how\nabout down this path\nwe say that we're we're not including\nany more\ntwos now what we're saying is we had one\ntwo but now we're done we're skipping\ntwos now we're only going to use values\nfrom here\nso that's the recursive thing right\nwe're basically doing the same decision\ndown here as we did up here so here\nwe're going to say we ended up\nskipping the two and we're we still only\nhave one single two\nand so let's just continue to repeat\nthat so over here we're gonna add\nanother two so we'll have\ntwo two two and over here we'll say okay\nwe're\nnow we're done with twos right where\nwe're gonna keep ourselves at a limit of\ntwo occurrences of two and we're\nbasically going to continue this logic\nuntil we get to our base case so over\nhere we're gonna see if we ended up\nhaving four\ntwos we'll get a target of eight so\ntherefore we went over\nour target value so we're going to stop\nbut down here right this was up our path\nwhere we said okay we're not going to\ninclude\nany more twos in this path so here we\ncan make a decision we can add a three\nso then we'd get two two three so we're\ncontinuing that recursive definition\nand so notice how we have two two three\nthat's seven so we did find at least\none combination but remember down now\nfor if we make our decision to the right\nwe wanna make sure we don't have any\nduplicates from here so in this\nside we decided to add one three how\nabout down this path we say we're done\nadding threes we're not even going to\nadd a single extra three so\nthis is going to remain as two two\nnow i think it's pretty obvious that\ndown here since we're only allowed to\nadd values six and seven neither of\nthese is gonna end up leading to the\ntarget if we add a six\nwe'll get a total of of ten if we add a\nseven we'll get a total of eleven\nneither of these\nyou know both of these go over our\ntarget so let's quickly run through the\nrest of the decision tree so over here\nover here we said we added a second two\nso over here we're not going to be\nadding any more to so here we can add a\nthree so we'd get\ntwo three and over here we would skip\nadding threes right so we're gonna we're\nnot gonna add any more threes this is\ngonna remain\nas two now down this path at this point\nwe have a total of five so we're only\nallowed to add values three\nsix or seven all of those are going to\nend up leading to\na total of greater than seven so we\ncan't we won't be able to find any\nsolutions down this path\ni'm just skipping and drawing it out\nbecause we're kind of running out of\nroom\nnow over here what we said is we skipped\ntwo\nand we and since this path includes the\none where we added a three so here we're\nnot going to add any threes\nand so we're only allowed to choose six\nand seven that's going to end up leading\nto\nuh totals of greater than it's going to\nlead to either eight\nor nine those are both greater than our\ntarget value\nso here we're not allowed to add any\ntwos because that's what this path was\nso we can add a three\nor we can choose to skip three\nand have add nothing so here since we're\nwe're not see we're we're skipping three\nso we're only allowed to add sixes or\nseven so here we can say okay get a six\nthis path we skip six so we're not\nallowed to add any sixes over here\nand from over here we'll say okay we can\nadd a\nseven which will give us the total seven\nright\nthat's the target that we're looking for\nso we did end up finding that\nso that's our second solution that we\nfound now since this\nthis path is going to lead to\ncombinations that do include a seven\nthis path\ncannot include a seven but you notice\nhow as\nwe are continuing to go down right paths\nwhat we're saying is okay\nwe're we're basically removing the\nnumber of elements we can choose from\nright we're popping two initially over\nhere then when we go down here\nwe're we're not allowing ourselves to\nchoose three over here we can't choose\nsix\nthen when we finally go down all the way\nover here we're not even allowed to\nchoose seven so therefore we have no\nchoices left so this is also going to be\na base case\nbecause we ran out of elements and the\nway we're going to be tracking\nwhich elements we can choose from is\nwe're going to have a pointer let's call\nit i\nand so initially it's going to be here\nwhich means we can choose any of these\nelements\nas we pop an element like this one we'd\nend up taking our i pointer and shifting\nit over\nhere which tells us okay we can only\nchoose these elements now\nso that's the main idea this is going to\nbe a recursion tree each\nrecursion step we can make two decisions\nand it's pretty easy to code up once you\ncan kind of understand this logic let me\nshow you how to do that\nby the way the time complexity of this\nyou can see that our decision tree\nwe're making two decisions each time so\nit's going to be 2 to the power\nwhat's the height of our decision tree\ngoing to be well each value in\nthis is going to be positive it's going\nto be at least one so the height of this\ndecision tree can be at most whatever\nthe target\nvalue we're trying to make it so t so\ntwo to the power of t\nwhere t is the target value that's going\nto be the big o\nand uh big o time complexity of this\nproblem so we are going to do this\nrecursively but let's have our result\nvariable which is basically going to be\nglobal for the scope of this problems\nbecause i'm going to define\na depth for search function inside of\nour outer function\nso a few variables we're going to pass\ninto here we do want to maintain\nwhich of the candidates we're still\nallowed to choose so like i said we're\ngoing to have a pointer i that's going\nto determine that\nwe're also going to have a current\nvariable we're only going to have a\nsingle occurrence of this it's just\ngoing to be a list that tells us\nwhat values we have added so far to the\ncurrent combination for example like we\ncould have two\nwe could have two two right two two\nthree etcetera etcetera\nand for the values in our current\ncombination we do wanna have a total so\nwe want to be maintaining what's the\ntotal sum of those because if it ever\nreaches\nour target sum then we know we have\nfound a solution if we ever go\nover our target sum that means we've\nreached the base case and we can't\ncontinue anymore\nso in our dfs function let's go ahead\nand define those base cases we know the\nbase cases if total ever ends up\nreaching target that means we found the\nresult so what we're going to do is\nresult dot\nappend we want to append the actual\ncombination so we're going to append\ncurrent\nand we're since we're only maintaining a\nsingle uh\nvariable list for current we don't want\nto actually append current itself we\nwant to create a copy of it because\nwe're going to continue to use this\ncurrent variable\nwhen we're doing the other combinations\nrecursively so we don't\nbecause then we're going to be modifying\nit so we just want to create a single\ncopy\nbefore we actually add it to the result\nand after we're done with that we don't\nwant to continue the rest of this\nfunction so we're just going to go ahead\nand break out of it by returning\nso that's the base case where we succeed\nwhat's the base cases\nif we end up uh being impossible to find\na combination well one is going to be if\ni is out of bounds meaning we can't\nchoose any more candidates so if i\nis greater than or equal to candidates\nor our total ended up going over the\ntarget that we're trying to reach\nthat's a base case where we have to\nreturn immediately because we cannot\nfind a combination done\nnow for the actual recursive step\nremember we have two decisions to make\nwe can choose to include\nthe value at candidates of i right we\ncan choose to include this value\nwhat so what are we going to do if we're\nincluding this value well first of all\nwe're going to take our current\nuh values that are in our combination\nwe're going to take\nthat candidate and go ahead and append\nit to our current\ncombination right we're going to do that\nbefore we end up actually calling our\ndfs function so we're going to call dfs\nand what are we going to pass in well\nwe're including this candidate so we can\npotentially\ncontinue to include it right so what\nwe're going to say for our index i that\nwe're passing is i stays the same right\nwe're not restricting which candidates\nwe're allowed to choose from just yet\nso i stays the same we pass in current\nbecause we just updated it right now so\nwe can go ahead and pass it in\nand the total did end up changing so we\ntook our current total and\nadded this candidate to it right\nso we can go ahead and pass in total\nplus candidates of i\nso let me delete this line because we're\nnot doing anything with it\nbut yeah so this is going to be that\nfirst decision where we do include the\ncandidate\nnow the next decision is going to be\nwhere we can't include it\nbut but after we call this function we\nwant to clean up a little bit we ended\nup adding\nuh this value to our current candidates\nour current combination so we want to go\nahead and pop that before we go down the\nother decision\nand bef so once we pop that we can go\ndown the other decision that's if we're\nnot\never going to include this candidate so\nfor the index we're going to pass an i\nplus 1\nindicating that we can't include any any\noccurrences of i and for current we can\njust go ahead and pass in\nour current combination and total is\ngoing to stay the same because we didn't\nend up adding any value to it right we\nwe\nleft our current uh combination as the\nsame as it was before when we actually\ncalled this function\nand once that's done we've we basically\nmade our two decisions right can you see\nwhat's going on can you see that we\ncalled that for search\nonce and then we called it a second time\nso we did create that two branch\ndecision\nand after we're done with that we can go\nahead and return and in this case we\nactually don't need to return\nso that is the entire dfs function last\nbut not least\nwhat we want to do is actually call it\nout here so we're going to call it\npassing in 0 as the beginning index\npassing in an empty array as the current\ncombination\nand passing in 0 as the current total\nand then once that is done\nwe will have updated our result which we\ndeclared up here\nand then we can simply go ahead and\nreturn that result it should contain\nall the combinations that end up\ntotaling to the target\nso you can see this problem isn't too\nbad to code this backtracking approach\nisn't too bad once you kind of\nunderstand the two decisions that we're\nactually making\nso i hope that this was helpful if it\nwas please like and subscribe it\nsupports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Permutations",
        "NcLink": "permutations/",
        "Pattern": "Backtracking",
        "Description": "Given an array `nums` of **unique** integers, return all the possible permutations. You may return the answer in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3]\n\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7]\n\nOutput: [[7]]\n```\n\n**Constraints:**\n* `1 <= nums.length <= 6`\n* `-10 <= nums[i] <= 10`\n",
        "Difficulty": "Medium",
        "Video": "FZe0UqISmUw",
        "PythonSolution": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        res = []\n\n        if len(nums) == 1:\n            return [nums[:]]\n\n        for i in range(len(nums)):\n            n = nums.pop(0)\n            perms = self.permute(nums)\n\n            for perm in perms:\n                perm.append(n)\n            res.extend(perms)\n            nums.append(n)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem permutations\nI've actually already solved this\nproblem before but I think I could\nexplain it a bit better so I wanted to\ndo it again we're given an array of\ndistinct integers and we want to return\nall possible permutations of those\nintegers so for the record a permutation\nof a set of numbers like this would look\nsomething like this we have three\nnumbers so we're going to have three\npositions to fill for the first position\nwe have three choices we can pick any of\nthese three elements so let's put a\nthree over here for the second position\nwe don't know which element we already\npicked we could have picked this one or\nthis one or this one for the first spot\nbut either way we know we're going to\nhave only two elements remaining to\nchoose from to place over here so\nthere's going to be two different\nelements that go here and then after\nwe've picked the first two elements this\none is already decided so we'll put a\none here so 3 * 2 * 1 we'll have six\ndifferent permutations of this set of\nnumbers and in order to visualize it\nlet's kind of draw a decision tree so\nlet's say that for the first choice we\ncan choose among three elements we can\nhave one two or three so regardless of\nwhich path we take we're going to have\ntwo choices here we could have either a\ntwo or a three we can't have a one cuz\nwe already picked it here we can have a\none or a three because we can't have two\nwe already picked it here we can have a\none or a two but not a three so now it's\ngoing to get a bit more simple we'll\nonly have one choice for each of these\nand it must be the element we haven't\nchosen so here it's going to be three\nhere it's going to be two here it's\ngoing to be three here it's going to be\none here we haven't chosen two and here\nwe haven't chosen one so now if you go\nthrough each path we have a permutation\nwe have exactly six of them and you can\nsee every single one of these is\ndifferent so if we could have each of\nthese in an array this is the result\nlike we've calculated the entire result\nnow the only problem with the way we're\nthinking about it here is it's pretty\neasy on like pen and paper to draw this\nout but how would we actually calculate\nthis in terms of code obviously it looks\nlike we're using recursion and it's\ndefinitely possible to do it that way\nbut the way we're doing it right now\ninvolves a decent amount of bookkeeping\nbecause what exactly is the sub problem\nlike here we chose one right so we got\nrid of one and these are the elements\nremaining so now we're trying to create\npermutations with those elements but\nhere the sub problem is different here\nwe use two so now we have the these\nelements remaining and we're trying to\ncreate permutations with those elements\nagain we could do it this way but it\nwould involve like removing this element\nand doing some other stuff so I think a\nslightly easier way to think about this\nproblem is to really use the idea of sub\nproblems cuz it makes recursion very\nvery easy so let me kind of redo this in\na very simple way now we're still going\nto use recursion but we're actually not\neven going to Branch anywhere so you're\ngoing to see something interesting here\nwe have three numbers to choose from so\nwhat we're trying to do is give me all\npermutations from 1 2 and three but next\nthe sub problem we're going to ask is\nthis give me all permutations with just\nthese two numbers so we're going to have\nsomething like this 2 three and then\nfinally we're going to ask just give me\nall permutations with just a single\nnumber notice how it's getting more\nsimple as we go down so watch what the\nreturn value is going to be well first\nlet's go to the base case if I don't\nhave any elements from here I'm going to\nreturn up an array with an empty list\nlike that's our permutation we can only\ncreate one permutation with an empty set\nof numbers and it's an empty permutation\nso that's the base case just to keep it\nsimple and now it's going to stay pretty\nsimple with just three how many\npermutations could we have well it would\nlook like this we're going to return up\nto the parent just a single array with\nthe value three cuz a single number can\nonly be permutated like that\nnow it's going to get more interesting\nfrom here now from this sub problem two\nand three how do we solve it well you\nprobably know what the return value is\ngoing to look like it's going to look\npretty simple just like this so it's\ngoing to have two in the front and it's\ngoing to have two in the back so 32 like\nthis so these are the two permutations\nwe can create now the reason I'm showing\nyou this way is this way is so easy to\ncalculate just watch this from the base\ncase all we do is just add three to that\nlist okay now from here this was the\nnumbers were given we already got all\npermutations from three so now the only\nthing to do is to add two so what we do\nnow with this array it's a very simple\narray it just has one element so we know\nwe have two choices actually with two we\ncan put it at the front or we can put it\nat the back so that's exactly what we do\nwe create a permutation with two at the\nfront and then we create a permutation\nwith two at the back and then from here\nwe're going to do the same thing we have\nthese two permutations two and three\nwhat we're going to do is try to put one\nin every position we're going to try to\nput one at the beginning we're going to\ntry to put one in the middle and we're\ngoing to try to put one at the end so\nwe're going to end up with three\ndifferent permutations we're going to do\nthe same thing with this one we also\nhave 32 it's obviously different from 2\nthree so we're going to put one at the\nbeginning in the middle and at the end\nand if we do this we're going to end up\nwith three more permutations which is\nsix total permutations and that's\nobviously going to be the result and if\nyou're curious I'll quickly draw out\nthose permutations here one goes at the\nend here one goes in the middle oh when\nI said end I meant beginning sorry here\none goes at the end and from this\npermutation 32 we're going to put one at\nthe beginning so 1 3 2 we're going to\nput one in the middle 3 1 2 and we're\ngoing to put one at the end end 3 2 1\nthese are the six permutations now let's\ncode it up and I'll also explain the\ntime complexity in the coding solution\nso we're going to start with the base\ncase which is pretty simple in our case\nwe're going to have the length of the\ninput and when it's equal to zero we're\ngoing to return a list with a single\nempty list inside of it and so the\nreason we're using that is because we're\nonly going to have a single parameter\nthe input list the idea is that we're\ngoing to keep calling the recursive\nfunction with the input nums without the\nfirst element so that's the sub problem\njust get rid of the first element from\nnums just create a subarray starting at\nindex one and that'll give us all the\nvalues from nums except the first one so\nthese are our permutations like our sub\nproblem and then we want to from these\nadd the current element which is the\nnumber at index zero to all of these in\nevery possible position and we're going\nto store those in another variable which\nI'm going to call result that's what\nwe're going to end up returning from\nthis function now to actually do what I\nsaid earlier let's just go through every\nsingle permutation that we have and for\neach permutation let's go through every\npossible index that we could insert the\ncurrent value into that permutation so\nI'm going to get the length of P I'm\nalso going to have plus one because we\ntechnically could add to the end of the\npermutation as well so now for that\npermutation P I'm actually going to\ncreate a copy of it because we're going\nto use this one multiple times we're\ngoing to possibly add a value to it in\nmultiple different places we don't want\nto modify the original permutation we\njust want to create a copy of it so I'm\ngoing to store that in a variable called\nP copy then for p copy we want to insert\nat index I the value nums at index zero\nwe're taking this value inserting it at\nthis index we're going to do that for\nevery index and then we're going to take\nP copy and append it to the result we're\ngoing to do that for every permutation\nand then the result is going to be here\nand then we're just going to go ahead\nand return now as you can see on the\nleft this solution works and it is very\nefficient well it's about as efficient\nas we can get for this problem and let\nme just kind of show you how to analyze\nthe time complexity the idea here is\nit's going to be easier for us to do it\nwithout kind of focusing too much on the\ncode remember that how many permutations\nare we going to have well if we have\nthree elements we had something like 3 *\n2 * 1 that is a math equation called n\nfactorial so if we have n elements in\nthe input we're going to have this many\ndifferent permutations how do we build\neach individual permutation well to add\na single element to a permutation we're\nlike inserting in the middle that's how\nwe're coding this up so it's an N\noperation and that's just inserting one\nelement into a existing permutation if\nwe're inserting n elements into each\npermutation we're going to have like an\nN squ over here so the overall time\ncomplexity is going to be n factorial\ntime n^ 2 but this is really the\ndominating factor in the time complexity\nn factorial space complexity wise if\nyou're not counting the output which is\njust going to be n * n factorial CU each\npermutation is going to be of length n\nand we're going to have this many of\nthem if you're not counting the output\nand you're just counting like extra\nspace here the space is still actually\ngoing to be in\nfactorial time n because we have\nmultiple copies of it here so this is\nspace this is time now you might think\nsince we don't even branch in this\nrecursion isn't it possible to solve\nthis problem without recursion and\nyou're exactly right the logic is going\nto actually be very very similar like\nwe're going to start kind of with this\nas the base case I think the time and\nspace complexity is going to be the\nexact same so I guess I'll leave this\nhere um but this we're going to call\nthis our permutations and we're going to\nget rid of this cuz we're not going to\nhave any recursion I want to leave this\ncode here cuz I want to show you how\nsimilar the solution is going to be\nremember this is the base case we want\nto compute like the sub problem so for\nevery number I could use like an index I\nto make it more clear but we don't need\nto I'm just going to go for n in nums\nfor every number we want to now add this\nnumber to all the existing permutations\nthat's what we're trying to do that's\nthe logic behind this so I'm going to\ncall the new permutations we create with\nthis number the new perms it's going to\nbe just an empty list for now we're\ngoing to go through every existing\npermutation kind of like we did down\nhere right going through every\npermutation and now I want to insert\nthis element into every permutation and\nI need to do that for every position so\nI'm going to say for I in range length\nof p + 1 exactly the same as we did down\nhere and now to that permutation I want\nto create a copy of it just like we did\nbefore and then I want to insert into\nthat copy the current element at index I\nwe want to add n so this is slightly\ndifferent I guess it's not nums of zero\nit's n and also I want to say let's take\nthis now and add it to New perms so new\npermutations append P copy the only\ndifference here is going to be at the\nend we want to update perms to be this\nnow so we're going to set permutations\nequal to the new permutations and then\nat the end we're going to turn the\npermutations so you can see that the\ncode above is very similar to the code\nbelow and I kind of got rid of the base\ncase here so this is not like the\ncomplete code but you can see that this\nportion of the code is pretty much\nexactly like this portion so I'm going\nto get rid of this down here and I'm\ngoing to run this code for you now and\nshow you here that it also works and\nit's also just as efficient pretty much\nin terms of Big O at least if you found\nthis helpful check out NE code. thanks\n"
    },
    {
        "Name": "Subsets II",
        "NcLink": "subsets-ii/",
        "Pattern": "Backtracking",
        "Description": "You are given an array `nums` of integers, which may contain duplicates. Return all possible subsets.\n\nThe solution must **not** contain duplicate subsets. You may return the solution in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,1]\n\nOutput: [[],[1],[1,2],[1,1],[1,2,1],[2]]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7,7]\n\nOutput: [[],[7], [7,7]]\n```\n\n**Constraints:**\n* `1 <= nums.length <= 11`\n* `-20 <= nums[i] <= 20`\n",
        "Difficulty": "Medium",
        "Video": "Vn2v6ajA7U0",
        "PythonSolution": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        def backtrack(i, subset):\n            if i == len(nums):\n                res.append(subset[::])\n                return\n\n            subset.append(nums[i])\n            backtrack(i + 1, subset)\n            subset.pop()\n\n            while i + 1 < len(nums) and nums[i] == nums[i + 1]:\n                i += 1\n            backtrack(i + 1, subset)\n\n        backtrack(0, [])\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem subsets 2. we\ndid solve the first one of this and that\nwas actually a long time ago and people\nhave been requesting i solved this one\nas well so let's do it today the first\none is actually very similar to this one\nthe only difference is that in this case\nthe input array that we're given can\ncontain some duplicate values now our\njob is still the same we want to return\nall possible subsets we can from this\ninput array nums but since we do have\nduplicate values it's going to be tricky\nfor us to not have any duplicate subsets\nin our result the good thing is we can\nreturn the solution in any order so\nthat's good but let's take a look at an\nexample we have one two two now a subset\nof one two two is basically uh some\nvalues from here where the order is\npreserved for the most part so you know\nwe could just take the value one that's\na subset we could take the second value\ntwo\nthat's a subset as well we could take\nthe third value by itself which is also\ntwo but here you can see we have a\nduplicate right these are both the same\nwe can't include both of them so you\nknow we don't include the second one and\nby the way even if we don't choose any\nof these for example if we just have an\nempty list\nthat is still a valid subset as you can\nsee in the output over here we could\nalso take the first one and take the\nfirst two which would give us one two we\ncould take the first one and then take\nthe second two but that would be the\nexact same that would be one two as well\nso we're not going to keep both of them\nso you're starting to get the idea of\nyou know subsets in general and what the\nproblem here is going to be for us to\nnot include any duplicates in our\nresults when we don't include any\nduplicates we have six different subsets\nthat we can create and before we\nactually get into the assertion you\nmight be thinking okay maybe dynamic\nprogramming is something we can do and\nthat would be possible but i know\nimmediately by looking at this problem\nthat we can't do dynamic programming and\nthe reason is because we're not really\ncounting subsets or anything like that\nwe're actually creating the subsets so\neven if we found some kind of shortcut\nit wouldn't really make this any more\nefficient because we still have to\ncreate all of these subsets and how many\npossible subsets could we have well to\ngenerate a subset for each value we can\neither choose to include this value or\nnot include that value so for each value\nwe have two choices now how many values\ndo we have in our input let's just call\nit n so let's say 2 to the power of n is\nhow many subsets we're going to have now\nhow long is each subset going to be well\nat most it could be of length n so we're\ngoing to take the number of subsets\nmultiplied by the length of the subset\nso this is going to be the overall time\ncomplexity to actually generate all of\nthese subsets notice how we can figure\nthis out even though we haven't even\nsolved the problem yet and this kind of\nhints to you how we are going to solve\nthis problem this is basically a brute\nforce solution right so we're going to\nbe using backtracking okay so let's get\ninto it so let's take a look at an\nexample and let's just start with the\nfirst subset solution which is actually\npretty trivial for a backtracking\nproblem remember we want to create every\nsingle possible subset so for each one\nof these input values we have a choice\nare we going to include this one or are\nwe not going to include this one so\nputting it more simply with a decision\ntree you know for the first decision we\nhave we're at this one right and we know\nthat because we're going to keep track\nof an index a pointer whatever you want\nto call it and it's initially going to\nstart at zero once we make our decision\nhere then we're going to shift it to the\nright and then make our decision over\nhere and then keep doing that for every\nsingle value in the input but so let's\nstart with our first decision which is\nthe one so let's say we do include that\none then we are going to have a array of\none this is our subset so far if we\ndon't include the one we're going to\nhave an empty list which is still a\nvalid subset but we're not done yet we\nstill have to iterate through the rest\nof the array so next we're at the second\ndecision which is two values so for here\nwe could either add the two and if we\nadd the two we'd have one two or we\ncould not add the two so we're basically\nskipping the two which would leave us\nhaving a one same over here we could add\na two which would be just 2 by itself in\nan array\nor we could skip the 2 which would leave\nthis being an empty list still ok so we\njust finished this value now we're at\nthe second two and we're going to\ncontinue this kind of naive approach but\nnow you're gonna see what the problem is\nso for here suppose we add this to which\nwould leave us having one two two if we\ndon't add the two we stay as a one two\nand over here you're gonna see where the\nproblem is so here we could add a 2\nwhich would give us a 1 2. you see that\nwe have two subsets that are the exact\nsame now even though we're not finished\nwith the array yet uh both of these\npaths are clearly going to lead to the\nsame subsets because they are the exact\nsame and they the remainder of the array\nis going to be the same for both of\nthese so we're going to end up with\nduplicate subsets but the important\nquestion is how did this happen and how\ncan we prevent this from happening let's\ntake a look so as we make this decision\ntree for example when we're over here\nand we're at the two value we know that\nall subsets that follow this one like as\nwe go down the decision tree all subsets\nare going to include at least one one\nvalue right and the decision we're\nmaking is okay we're including this two\nso if we do include the two then we're\nsaying all subsets that we create using\nthis one are going to include at least\none two value so this path is supposed\nto be the path with all subsets that\ninclude at least one two and we don't\nwant duplicates so when we make the\ndecision on the right side where we skip\nthis two value we don't include the two\nvalue on this right side so what this\nright side should represent is all\npossible subsets that don't include at\nleast a single two basically all subsets\nthat do not include any two values why\nbecause this left side over here already\nincludes all subsets that have at least\none two value so if we include any two\nvalues on the right side we're going to\nend up with duplicates so what we have\nto do is not include any two values on\nthis right side how can we do that well\nbasically when we were over here that's\nwhat two we were deciding at right when\nwe choose to skip this two we should\nchoose to skip all two so instead of\ntaking our i pointer and just shifting\nit by one to be over here we should\nactually shift it by two to be over here\nbecause that's how we know we're not\ngoing to get any more two values but\nthis input representation might make it\nlook simple but we're actually not\nguaranteed that the input array is going\nto be sorted so we have to sort it\nourselves which is going to be n log n\ntime but that's not a big deal because\nwe already know that the time complexity\nof this solution is going to be about n\ntimes 2 to the power of n so this is\npretty insignificant so now let's\nre-draw this decision tree keeping what\ni just mentioned in mind and then we\nwill eliminate all the duplicates okay\nso this can actually stay the same\nbecause this is the side where we do\ninclude a 2 but this is the side where\nwe're skipping all the two values so our\npointer when we're making a decision now\nis not actually going to be over here\nour pointer is actually going to be over\nhere at this 3. so are we gonna include\na three or not that's our choice so if\nwe do include a three we get one three\nif we don't include a three we just get\none okay and what about this two well we\nchose one two so now the next decision\nis going to be are we including the\nsecond two or are we not including the\nsecond two so we can draw that so if we\ndo include the second two we get a two\ntwo and if we don't include the second\ntwo we just stay as a single two and\nlastly on the right side over here are\nwe actually going to be choosing from\nthe second two well no because we\nalready skipped the first two and that\nmeans we're gonna end up skipping the\nsecond two as well so the decision we're\nmaking over here is actually going to be\nare we including the three or are we not\nincluding the 3 so that's going to be 3\nby itself or just an empty\narray and so now you can see that this\nis actually\nthe last value that we were looking at\nso we're not going to go any further\ndown in this case so just to kind of\nillustrate that i'm going to put a box\naround here this is the base case we're\nnot going to go any further same over\nhere this was also the base case because\nwe were choosing from the three value\nhere we included it here we did not\ninclude it okay at this point you\nprobably get the idea so i'm going to\nfast forward so over here we either\ninclude the three or we don't include\nthe three which will leave us with a one\ntwo two three the other one would be\njust one two two and the other decision\nis just one two two over here if we\ninclude the 3 we get 1 2 3. if we don't\ninclude the 3 we just get a 1 2 and then\nlet's finish these two as well so this\nwould be 2 2 3 or just a 2 2 if we don't\ninclude the 3 and then this one is going\nto be 2 3 or just 2 by itself so these\nare all of our\nsubsets that are going to be added to\nthe result output you can see that it's\nactually not quite 2 to the power of n 2\nto the power of n in this case would be\n2 to the power of 4 which is 16. in this\ncase i think we actually have about 12\nof them and the reason is because we're\neliminating duplicates right if we\nincluded the duplicates it would have\nbeen 16 but that's why uh the time\ncomplexity still is the same we can\nstill say the time complexity is n times\ntwo to the power of n because remember\nthis is the worst case we don't actually\nknow if there are gonna be any\nduplicates in the input or not if\nthere's not any duplicates this is gonna\nbe the upper bound you know if there are\nsome duplicates the actual time\ncomplexity might be a little bit smaller\nthan this but i think that's enough for\nus with this explanation now let's\nactually get into writing the code\nluckily it's pretty straightforward okay\nso now let's code it up and we're going\nto declare our result it's initially\njust going to be an empty array this is\nwhat we're going to be adding all our\nsubsets to and remember before we\nactually get into the backtracking\nportion we want to make sure that our\ninput array is in sorted order okay so\nnow let's write the backtracking portion\nwe are given uh two main inputs that\nwe're gonna keep track of one is the\nindex that we're at in our nums array\nand the second is what's the current\nsubset looking like so far uh we're\ngonna have a single base case\nand that's when we reach the end of the\ninput array so basically if i is equal\nto the length of the input array nums\nthat's basically how we know we have\ngone through the entire array that means\nwe can take this subset that we have\nbuilt and go ahead and append it to our\nresult but we want to make a copy of\nthis subset because this subset is just\ngoing to be an array and we're going to\nbe using this as we do our backtracking\nso what we want to do is actually create\na copy of this subset so that when we\nhave a future backtracking call that we\ndon't end up overwriting this subset\nbecause we're taking a reference to this\nsubset and appending it to this array\nwhat we want to do is create a copy and\nwe can do that in python like this or\nyou can use like a built-in copy\nfunction in java or whatever language\nyou want and after that we just want to\nreturn because we don't want to continue\nbacktracking when we reach the end of\nthe array okay that's the base case but\nwhat is the recursive case well remember\nwe have exactly two decisions to make\none is all subsets that include nums of\ni that include the number that we're at\nthe other case is all subsets that do\nnot include nums of i so we do not\nchoose to include nums of i in our\nsubset let's start with the first\ndecision what we're going to do is we're\ngoing to include nums of i right so\nwe're going to take our subset and\nappend to it this number nums of i and\nthen simply enough we're going to go\nahead and do our backtracking call by\npassing in the next index so we're going\nto pass in i plus 1. and we're going to\npass in the subset that we have so far\nand you know that's going to take care\nof all subsets that include this number\nso very easy but before we start\ngenerating all subsets that do not\ninclude that number we should probably\nremove from the subset the value that we\njust added to it we can do that just by\nsaying subset pop that'll pop this value\nthat we just added so now we're going to\ngenerate all subsets that don't include\nnumbers of eye but this is the slightly\ntricky part because remember if there\nare duplicates the duplicates will be\nright next to each other because\nremember we sorted the input array so\nwhat we want to say is\ni plus 1 as long as i plus 1 is inbound\nso it's less than the length of the\ninput array and you'll see why we're\ndoing this and if nums of i\nis equal to nums of i plus one so what\nam i doing here and why am i doing it\nwell remember if we have an input array\nlike one two two and we're at this value\nand we're choosing to skip this two then\nwe should probably skip the second two\nas well because we don't want duplicates\nright we should skip the second two and\nthen our index i is gonna be over here\nright and we're gonna compare this value\nto this value are they equal yes they\nare so then we're going to increment our\npointer to be over here now then we're\ngoing to compare this value with the\nnext value 3. it's not equal so\nthat's when we're going to stop this\nloop right and what this loop is going\nto be doing is just going to be\nincrementing the i pointer like i kind\nof talked about right now but what if we\ndidn't actually have this 3 value here\nin that case our i pointer would be\nincremented to be this position and we'd\nsee that i plus 1 is out of bounds so\nthen our loop would terminate as well\nokay and after the loop does terminate\nwe still want to run our back tracking\nbecause even if we don't add any values\neven if we skipped the entire array you\nknow this is this case over here is\ngoing to be the case that ends up adding\nthe empty array to the result so we\ndefinitely don't want to skip calling\nbacktrack onto this regardless of what\nthe while loop ends up doing so let's\ncall our backtracking uh pass in i plus\n1 same as we did up above and let's pass\nin the current subset\nafter we have popped the value from it\nremember that is actually the entire\ncode as long as i don't have any bugs\nlet's run it to make sure that i don't\nso first we want to actually call our\nbacktracking function let's pass in 0 as\nthe starting index and just pass in an\nempty array as the initial subset and\nthen after that we can just return the\nresult so now let's run it to make sure\nthat it works and as you can see on the\nleft yes it does work and it's pretty\nefficient so i really hope that this was\nhelpful if it was please like and\nsubscribe it really supports the channel\na lot consider checking out my patreon\nif you'd like to further support the\nchannel and hopefully i'll see you\n"
    },
    {
        "Name": "Combination Sum II",
        "NcLink": "combination-target-sum-ii/",
        "Pattern": "Backtracking",
        "Description": "You are given an array of integers `candidates`, which may contain duplicates, and a target integer `target`. Your task is to return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`.\n\nEach element from `candidates` may be chosen **at most once** within a combination. The solution set must not contain duplicate combinations.\n\nYou may return the combinations in **any order** and the order of the numbers in each combination can be in **any order**.\n\n**Example 1:**\n\n```java\nInput: candidates = [9,2,2,4,6,1,5], target = 8\n\nOutput: [\n  [1,2,5],\n  [2,2,4],\n  [2,6]\n]\n```\n\n**Example 2:**\n\n```java\nInput: candidates = [1,2,3,4,5], target = 7\n\nOutput: [\n  [1,2,4],\n  [2,5],\n  [3,4]\n]\n```\n\n**Constraints:**\n* `1 <= candidates.length <= 100`\n* `1 <= candidates[i] <= 50`\n* `1 <= target <= 30`\n",
        "Difficulty": "Medium",
        "Video": "FOyRpNUSFeA",
        "PythonSolution": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        candidates.sort()\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if total > target or i == len(candidates):\n                return\n            # include candidates[i]\n            cur.append(candidates[i])\n            dfs(i + 1, cur, total + candidates[i])\n            cur.pop()\n\n            # skip candidates[i]\n            while i + 1 < len(candidates) and candidates[i] == candidates[i+1]:\n                i += 1\n            dfs(i + 1, cur, total)\n            \n        dfs(0, [], 0)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem combination sum\n2 this is actually my second time making\na solution for this one cuz I think I\ncould do a little bit better than the\nfirst time I explained this one so\nbefore we start I want to mention that\nthis is part two of the combination some\nseries I would definitely watch part one\nof this I have a very good video on this\nyou can also check it on N code iio if\nyou want to search for it this problem\nand combination someone are a part of\nthe neat code 150 list which is a very\ngood list of problems to understand and\nactually there's another problem that\nwill help you understand the trick\nbehind this problem it's actually an\narray problem it's called threesome\nthat's also a part of the N code 150\nlist and it's beneficial to know for\nthis problem because we kind of\neliminate duplicate Solutions pretty\nmuch the same way except we do so\nrecursively in this problem so let's get\ninto it the idea is we're given a list\nof numbers and we want to find all\ncombinations from this set of numbers\nthat sum up to so similar to the first\nquestion so one way would be 116 we get\nthis one we get this six and we get this\none they sum up to eight another one\nwould be 17 you could choose this one\nand this one but couldn't we make up 17\nmultiple ways couldn't we also have\nchosen the second one over here and the\nSeven well technically they count as the\nsame combination so we don't want\nduplicate combinations in the solution\nset and another difference between this\nproblem and the first combination sum is\nthat we cannot use the same number in\nunlimited amount of time so we can't\njust take the one and reuse it eight\ntimes to sum up to the Target we could\nthough use the same element multiple\ntimes if it shows up multiple times in\nthe input we have two occurrences of one\nso that's the max number of times that\nwe can use the number one in a solution\nso that's what makes this a little bit\ntricky in the first combination sum we\nwere given a distinct set of numbers and\nwe could reuse the same number an\nunlimited amount of times so in the\nfirst problem we had the input and we\nwere able to solve it very simply with\nrecursion for a given element either you\ninclude it or you skip it so we would\nhave had 10 or we would have skipped 10\nand then from here we would have chosen\nfrom the next element we can either\ninclude one or we can skip one from this\nside though we're not quite at one yet\nwe can actually choose to continue\nincluding 10 we can have multiple\noccurrences of 10 or we could have\nskipped it and in that case from here we\nwould have started choosing from one so\nhere we could have chosen uh one or we\ncould have skipped one and so that was a\nvery simple two Branch recursion but we\ncan't apply the same here and the reason\nfor that is at some point with this\nexample we might include one and then\neventually we might get to seven and\nthen we might include seven as well if\nwe were to have skipped this one we\ncould have gone down this path we could\nhave included the seven and then we\ncould have included the one that came\nafter it and we would have ended up with\nduplicate combinations so we want to\navoid this case and we can believe it or\nnot still do so with two Branch\nrecursion it's going to be similar to\nhow we eliminate duplicates in threesome\nso this is the trick behind eliminating\nduplicates the issue here is that when\nwe choose to include one or choose to\nskip one we don't want to end up with\nanother one on the same path where we\ndecided to skip one so how can we make\nit so that we never see another one\nagain if we decided to skip it well this\nis the trick first you take the input\narray and you sort it so I'm going to\nredraw this in sorted order now it's\nsorted why did I put it in sorted order\nbecause I want all duplicate elements to\nbe adjacent it's not necessarily\nimportant that we go through the\nelements in sorted order that's actually\nnot important because all of these are\ngoing to be positive anyway so they're\nalways going to contribute to the Target\nwe're never going to deal with negative\nnumbers so it doesn't matter so much the\norder that we go through them but it\ndoes matter that we group similar\nelements together so now I'm actually\nable to make the choice I'm going to say\nokay either I include one in my solution\nset so this brand brch is going to\ninclude all possible combinations that\ninclude one or have multiple occurrences\nof one up to two in this example or I'm\ngoing to decide to skip one on this side\nbut when we are choosing from an element\nwe're going to obviously have some kind\nof pointer that tells us the current\nposition that we're at let's call that I\nso here I'm choosing between this\nelement I can include it and if I\ninclude it here I definitely need to\nshift my pointer because I'm not allowed\nto reuse that same element multiple\ntimes so I do have to shift the pointer\nhere so it's going to be shifted but\nwhat about this case where I decided I\nwant to skip one well if I shift it by\none and it lands over here I'm still\nable to choose from one but I wanted to\nskip it all together so this is where\nwe're going to use something called a\nloop I'm going to use a while loop and\nwhat we're going to say is don't just\nshift I by 1 keep shifting it while the\nelement at I is equal to its neighbor so\nwhile these two are equal shift I so\nright now I is going to be shifted over\nhere and right now this value is not\nequal to its next neighbor so now this\nis where I is going to land and when we\nactually make the recursive call we're\nalways going to be passing in I + 1 into\nthe recursive call so we don't really\nhave to shift it again here so it's\nalready going to be passed in uh when we\ndo it recursively so that'll probably\nmake more sense when we get to the code\nbut keep in mind that just because we\nhave a loop in the recursive solution\ndoesn't mean we're going to be\nrecursively calling the function\nmultiple times we're still only doing\ntwo Branch recursion so with this I'll\nkind of run through the quick simulation\nhere and then we'll get into the code\nthe code is going to be very similar to\ncombination some one just the fact that\nwe're sorting the input this time and\nthat we're going to have a loop inside\nof our recursive function so here we can\ncontinue to include one we're at the\nsecond one so here we could have\nincluded it we would have gotten that\none one or we could have skipped it in\nwhich case we're over here so we would\nhave you know still have been here but\njust keep in mind that I'm not drawing\nexactly where the pointer happens to be\num here we could like go through all\ncombinations obviously that's going to\nbe a very large tree but just trust me\nwhen I say that eventually we could have\nskipped two we could have skipped five\nand we could have gotten to six and in\nthat case this would have been one valid\ncombination where we get 11 six so\nthat's going to be valid now another\nbase case could have been where we have\ngotten to like 1 1 7 clearly in this\ncase we went over the target the target\nshould be eight but when you sum all of\nthese together we're going to get nine\nso at that point we can actually stop\nour recursion cuz we know all elements\nin the input are positive so we're never\ngoing to get a lower sum if our sum is\nnine now but we're looking for a sum of\neight well we're never going to get\nthere at this point that's another base\ncase now from here you could imagine\nthat we would have skipped everything in\nbetween here and we would have gotten to\nseven in that case we would have gotten\n1 7 that's another a valid combination\nand I won't draw all of them out but\nhere we could have gotten to 1 2 five\nthat's another valid one in the case\nwhere we skip one we could have chosen\ntwo and then eventually chosen six so\nthat would have been another valid one\nthese are all the valid ones I didn't\ndraw out the entire recursion tree I\nwould encourage you to do that as an\nexercise though I do think it'll help\nyou understand it and it might be easier\nto kind of do the drawing after after\nyou look at the code so maybe that'll\nhelp you out keep in mind the overall\ntime complexity of this is going to be\nsimilar to combination some one even\nthough we're doing sorting and log in\nthat's not going to be the bottleneck\nthe bottleneck is going to be the fact\nthat we have up to two branches at every\nsingle step assuming that every number\nwould be distinct in the input we'll\nhave two branches so the overall time\ncomplexity is going to be something like\n2 the^ of n that's how many different\ncombinations we could have ended up with\nwhen we add these to the result we are\ngoing to create a copy of every single\narray so I think in the worst case the\ntime complexity would be n * 2 ^ of n so\nnot very efficient but given that this\nis a combination problem there's no way\naround that like the size of the\nsolution in the worst case is going to\nbe n 2 the Power of n so there's no like\nshortcut in terms of time for us to\nachieve the correct solution in this\ncase so you can't really apply dynamic\nprogramming to this it's not going to\nhelp you out in terms of the space if\nyou don't count the output as extra\nspace the over all memory is going to be\nBig O of n for an individual combination\nor for like the size of the recursive\ncall stack so I'm going to declare the\nresult it's going to be an array of the\ncombinations we know that that's what\nwe're ultimately going to return down\nhere so I'm just going to put that there\nnow we are going to have a recursive\nfunction you could call it DFS or\nbacktrack I guess I'll call it DFS it\ndoesn't really matter we know that\nthere's a few things we're going to have\nto keep track of one the current\nposition that we're at in the candidates\narray two is the current combination\nI'll just call that curve for short so\nthose are the elements in our current\ncombination and the third variable is\ngoing to be the sum or the total of\nthose current elements so that we can\ncompare once the total has reached the\ntarget amount or the total has exceeded\nthe target amount so before you even get\ninto this recursion remember that our\nsolution only is going to eliminate\nduplicates if we sort the input array\nthat's the easiest way to do it so make\nsure to call sort on the input array in\nyour language of choice it's pretty easy\nin Python so I would highly recommend\nusing python I have a couple good\ncourses for that python for beginners\nand python for coding interviews now\nlet's start with the base cases they're\npretty simple one we either reach the\ntarget amount total is equal to the\nTarget amount two is the total exceeds\nthe target amount there's actually one\nmore base case though and that's what\nwhat if we run out of candidates that\nwould mean our ey pointer is out of\nbounds so either this is true or I is\ngreater than or equal to candidates and\nit will usually just be equal to the\nlength of candidates so we can just put\nthat there so these are the two base\ncases the second one is simple that's\nwhen we just return we do not have a\nvalid combination and we never will at\nthis point this is where we do have a\nvalid combination so what do we do well\nclearly we have to update the result so\nI'm going to say result. pen to it not\njust the current combination cuz that's\ngoing to be a variable that we're\npassing around by reference so we want\nto actually create a copy of this one\nway to do that in Python is like this do\ncopy again python is such a readable\nlanguage such an easy language to use\nisn't it now don't forget within this\nbase case to return I mean I guess if\nyou didn't have the return it probably\nwouldn't hurt but given that all\nelements in candidates are positive if\nwe've reached the total sum everything\nafter this is just going to increase\nthat so might as well just put the\nreturn here early now for the recursive\ncase and this is probably going to be\nthe complicated part so let me go a\nlittle bit slow one is where we include\nthe element at indexi let's call that\ncandidates at indexi and the other is\nwhere we skip candidates at index I so\nthis first case is pretty simple it's\nsimilar to combination some one what\nwe're going to do is update our current\nelements we're going to include the\nelement at index I and then we're going\nto run DFS now for the index we're not\ngoing to pass index I because that would\nmean we're able to reuse the element at\nindex I but in this problem we're not\nallowed to reuse the same element so we\nhave to put a plus one here we cannot\nreuse candidates at indexi second we're\ngoing to pass in the current combination\nthat's pretty straightforward and third\nwe're going to pass in the new Total the\ntotal is just going to be the previous\ntotal plus this element whatever this\nelement contributed to the total there\nyou go now after we're done with this\nrecursive call we're going to have to\nundo the work that we just did and\nthat's pretty much as simple as removing\nthe element that we just appended to the\ncurrent so we can say current. pop\nbecause of course in the next case we\nwant to skip that element so we have to\nremove it from the current set of\nelements now the next part I wish it was\nas easy as doing this as easy as just\ncalling DFS on I +1\nwith the current combination with the\nprevious total since we're skipping the\nelement there's no need to update the\ntotal I wish it was this simple but it's\nnot we require two more lines of code\nand that is the loop that I was talking\nabout we want to say while the candidate\nis at index I is equal to the candidate\nat index I + 1 while that's the case\nincrement the pointer because I don't\nwant to use use the element at index I\nand I don't want to use any duplicates\nof that element either I want to skip\nthis element all together and the way to\ndo that is with this Loop like I showed\nyou the example where we had multiple\nones where we had one one and then we\nhad a two after it but it could have\nbeen the case that we had more than that\nwe could have had like four ones or five\nones so we already recursively did the\npath where we include one or more ones\nnow I want to do the path where we skip\nall of these ones so that's why we need\nthe loop don't just skip this one skip\nthis this this this and this so that we\nhave a fresh choice to make there's one\nissue with this what if we had an array\nlike this well I is always going to be\nequal to the next element and then we're\ngoing to end up with a comparison where\nwe compare this to the next element but\nit doesn't exist make sure you have this\nI + 1 is inbounds so that we don't get\nan index out of bounds error when we\nexecute this part so that's very\nimportant now this is the entire code\nwell I guess there's one thing that\nwe're missing if you're smart you'll be\nable to notice it we defined our DFS\nfunction but we never called it so let\nme do that down here DFS what do you\nthink the parameters are going to be\nwell we're going to start at index zero\nlet's put that the current combination\ninitially is going to be empty so we can\nhave an empty array here and lastly our\ntotal sum initially is just going to be\nzero so let me put a zero there after we\ncall this function our result should be\nupdated and then we can and return the\nfinal result so let me execute this and\nas you can see here it works it is\nefficient even though these run times\nare pretty random maybe there are some\nhacky ways that we can improve the\nexecution time but in terms of Big O\ncomplexity this is the final solution it\nis the most optimal if you found this\nhelpful check out n code. for a very\ncomprehensive road map and for a bunch\nof courses that will make your life a\nlot easier thanks for watching and I'll\n"
    },
    {
        "Name": "Word Search",
        "NcLink": "search-for-word/",
        "Pattern": "Backtracking",
        "Description": "Given a 2-D grid of characters `board` and a string `word`, return `true` if the word is present in the grid, otherwise return `false`.\n\nFor the word to be present it must be possible to form it with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7c1fcf82-71c8-4750-3ddd-4ab6a666a500/public)\n\n```java\nInput: \nboard = [\n  [\"A\",\"B\",\"C\",\"D\"],\n  [\"S\",\"A\",\"A\",\"T\"],\n  [\"A\",\"C\",\"A\",\"E\"]\n],\nword = \"CAT\"\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/79721392-44b6-4de7-c571-d3d1640ac100/public)\n\n```java\nInput: \nboard = [\n  [\"A\",\"B\",\"C\",\"D\"],\n  [\"S\",\"A\",\"A\",\"T\"],\n  [\"A\",\"C\",\"A\",\"E\"]\n],\nword = \"BAT\"\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= board.length, board[i].length <= 5`\n* `1 <= word.length <= 10`\n* `board` and `word` consists of only lowercase and uppercase English letters.\n",
        "Difficulty": "Medium",
        "Video": "pfiQ_PS1g8E",
        "PythonSolution": "class Solution:\n    \n    def exist(self, board: List[List[str]], word: str) -> bool:\n        m = len(board)\n        n = len(board[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0]:\n                    if self.dfs(board, word, 0, i, j, m, n):\n                        return True\n        \n        return False\n    \n    def dfs(self, board: List[List[str]], word: str, index: int, i: int, j: int, m: int, n: int):\n        if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[index]:\n            return False\n        if index == len(word) - 1:\n            return True\n        \n        board[i][j] = '#'\n        \n        if (self.dfs(board, word, index + 1, i - 1, j, m, n)\n            or self.dfs(board, word, index + 1, i + 1, j, m, n)\n            or self.dfs(board, word, index + 1, i, j - 1, m, n)\n            or self.dfs(board, word, index + 1, i, j + 1, m, n)):\n            return True\n        \n        board[i][j] = word[index]\n        return False\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's look at\nword search this is a pretty good\nproblem and it's definitely very popular\nso we're given a grid\nm by n with a bunch of characters or you\ncould say it's a board\nand we're also given a target word and\nwe want to\nlook for this word inside of our board\nand if we can\nfind the word we return true if we can't\nfind the word then we return false\nand so within our grid the word can be\nconstructed\nany way but it has to be either\nhorizontally or\nvertically neighboring cells so\nbasically what we're looking for let's\nsay this\nis our board we're looking for a path\ninside of this board where we can move\nhorizontally right we're moving to the\nright\nthen we go down and then we go to the\nleft\nso this is our path and we\nare looking for a word so we're looking\nfor a path that can make this\nword down here you can see in the\nexample they give us a target word\na b c c e d and that's the word we're\nlooking for we're looking for a path\nand we can find a path with exactly\nthose characters\ntherefore we can return true now the\nquestion you're wondering is how can we\nfigure this out is there a really\nefficient algorithm to solve this\nproblem the answer is\nno there's definitely not a super\nefficient one we just are going to go\nthrough\nthe brute force solution and that brute\nforce solution is going to be\nback tracking so basically this problem\nis actually pretty intuitive right how\nwould you solve this problem\nin real life if you didn't have any code\nwell you'd go brute force right\nlooking let's start at every single cell\nso we'd go through every single cell\nright let's say this is an e\nright it does our word start with an e\nno it starts with an a\nnow we have a c does our word start with\na c nope does our word start with a b\nnope does our word start with an a yes\nit does so now let's look at all the\nneighbors of a and look for our next\ndestination character our next target\ncharacter is b\nright so let's look down we don't have a\nb over here this is an\ns let's look up there's nothing up left\nthere's nothing left\nokay to the right we have a b gray now\nthe next character we're looking for is\na c\nare there any neighboring c's not up\nright\nwhat about to the left we can't reuse a\ncharacter\nso we can't reuse this a but we wouldn't\nwant to use it anyway but that's\njust another detail right we can't reuse\nany characters\ndown here there's an f that's not what\nwe're looking for but to the right\nthere's a c\nright obviously we can see that and the\nnext character we're looking for is a\nsecond c\nyou know we could run through this but\nit's mainly just brute force right we're\ngoing through every single position\nlooking at every single neighbor to see\nif it's even possible for us to make\nthis target word\nin this case the answer is obviously yes\nwe have an e\nand we have a d we can finish it up so\nin the code we're going to be doing\nbacktracking so let me\njump into that or rather we're going to\nbe doing recursive\nbacktracking so we're going to do this\nrecursively or in other words we're\ngoing to do this with depth for search\nso let's dive right into it so one thing\ni like to do with these problems is just\nget the dimension so i'm going to get\nthe number of rows and the number of\ncolumns\nso get the length of the board we get\nthe number of rows\nand get the length of the first row and\nwe get the number of columns\nalso remember how i said we can't\nrevisit the same character twice\nwithin our path therefore we're going to\nneed a variable\nor a data structure for our path we're\ngoing to use a set to\nadd all the current values from our\nboard\nor positions in our board that are\ncurrently within our path\nto make sure that we don't revisit the\nsame position\ntwice within our path but other than\nthat\nif you've seen any of my backtracking\nvideos you know i like to follow a\nformula so i'm just going to be going\nthrough that right now so i like to\ncreate a nested debt for search function\nwithin\nthe root or the regular function because\nthen we don't have to pass\nin some of the variables like the board\nand the word because this is a nested\nfunction\nbut we are gonna have to pass in the\nposition of the board that we're at so\ntwo variables row column for that and\nwe're gonna have to pass in a third\nvariable i which is going to tell us the\ncurrent\ncharacter within our target word that\nwe're looking for\nso if we ever reach the end of the word\nor if i\never equals the last position so if\ni if we ever finish the entire word\ntherefore we know we\nfound the word therefore we know we can\nreturn true right that's the good case\nthe other case is what if we go out of\nbounds\nright out of bounds of the entire board\nwhat if row\nis less than zero or column is less than\nzero\nright or what if row is\ngreater than or equal to the number of\nrows or if column\nis greater than or equal to the number\nof columns that's also out of bounds so\nor let's consider one more case what if\nthe\nboard what if the character that we're\nat in our word so word at position i\nis not equal to the character that we're\nat in\nour board so board at position row\ncolumn\nso if this is the case if we're if\nbasically we found the wrong character\nthen we also want to return false\nand there's one last condition we have\nto check what if the character\nor or what if the position we're at row\ncolumn this tuple what if this\nrow column position that we're at is\ninside\nof our path set what does that mean that\nmeans we're visiting\nthe same position twice within our path\nwe know\nall of these things that i've just\nlisted all these conditions\nare basically invalid if any of these\nare true then we have to return false\nbecause you know if we're out of bounds\nwe return false if we see the same\ncharacter twice\nwe return false if we see a character\nthat we are not\nlooking for we also return false okay\nbut once we're done with that\nthen we know okay we found a chara we\nfound the character we're looking for\nright so what can we do we can take our\npath and\nadd the current position to it so the\ncurrent row column\nto our path because we found a character\nthat we need\nso now we're going to be continuing our\nrecursive depth first search\nand so we're going to be looking for the\nresult\nof this depth first search so we're\ngoing to run depth for search right\nwe're going to run it in\nall four adjacent positions so what i'm\ngoing to do is say row plus\n1 leave the column the same and add\n1 to i we're adding one to i because we\nfound the character\nwe are looking for now we're going to\nlook for the next character right so now\ni'm just going to basically\ncopy and paste this a few times so so i\ncopy and pasted it four times because\nwe're going to look at all four of the\nadjacent positions so let me just fix\nyou probably see what i'm doing but\nbasically i'm saying row plus one\nleave column the same row minus one\nleave column the same\ncolumn plus one leave row the same and\ncolumn minus one\nleave row the same so we're looking at\nall four horiz\nof all four adjacent positions we're\nrunning depth first search\non all of them and if any of them return\ntrue\nthen our result is gonna return true\nremember we only need to find\nour target word one single time\nso if we ever find that word then we\nknow we can return true\nso i'm gonna go ahead and return that\nresult\nbut right before i return that result\ni'm going to do a little bit of cleaning\nup so i'm going to take our path\nvariable\nand remove from it the position we just\nadded to the path because we're no\nlonger\nvisiting that position right we're\nreturning from this function called\ntherefore\nwe don't have to continue to visit that\nposition\ninside of our path so this depth first\nsearch\nof recursive function is always the main\npart of the\nbacktracking problems once we're done\nwith this function\nthe only thing left for us to do is\nactually brute force go through every\nsingle position in our grid\nand run this depth for search function\non it\nso that's exactly what i'm going to do\nfor every single position\nevery single starting position in our\nboard i'm gonna run\nthat first search passing in the row\ncolumn\npassing in zero for the position of i\nbecause we're always starting at the\nbeginning of the word\nand if we ever return true if this\ndiffer search function ever returns\ntrue i can immediately return true from\nour function exists right i can just\nreturn true immediately i don't have to\nwait\nand if we never return true if this goes\nthrough every position in the board and\nwe never return true\nthen i'm gonna have to return false out\nhere because that means we did not find\nthe word that we were looking for\nso this is the entire function actually\nyou can tell that it's definitely not\nvery efficient right\nwe're running through the entire board\nright so what's the time complexity of\nthat running through the entire board is\ngoing to be\nn times m because those are the\ndimensions of our board\nand that's being multiplied by the debt\nfirst search function right\nbecause we're calling that debt for\nsearch function every single time for\nevery position in the board so the\nquestion becomes what's the time\ncomplexity of the debt for search\nfunction\nwell the call stack of that debt for\nsearch function is always going to be\nthe length of the word right because the\nword can only be so long we can only go\nthrough so many\ncharacters for the word so that's going\nto be the call stack of it remember\nwhere\nthough we have four different branches\nwe're calling the depth first search for\ndifferent times so it's really going to\nbe 4 to the power\nof the length of the word that we are\ngiven\nso it's going to be something like 4 to\nthe power of\nn where n is the length of the word so\nyou can see this problem is not very\nefficient so let's just clean this\nup so this is going to be 4 to the power\nof n roughly\nright so it's not a very efficient\nsolution this is the rough time\ncomplexity of the problem so i hope that\nthis was helpful\nif it was please like and subscribe it\nsupports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Palindrome Partitioning",
        "NcLink": "palindrome-partitioning/",
        "Pattern": "Backtracking",
        "Description": "Given a string `s`, split `s` into substrings where every substring is a palindrome. Return all possible lists of palindromic substrings.\n\nYou may return the solution in **any order**.\n\n**Example 1:**\n\n```java\nInput: s = \"aab\"\n\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n**Example 2:**\n\n```java\nInput: s = \"a\"\n\nOutput: [[\"a\"]]\n```\n\n**Constraints:**\n* `1 <= s.length <= 20`\n* `s` contains only lowercase English letters.\n",
        "Difficulty": "Medium",
        "Video": "3jvWodd7ht0",
        "PythonSolution": "class Solution:\n    \n    def partition(self, s: str) -> List[List[str]]:\n        res, part = [], []\n\n        def dfs(i):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    part.append(s[i : j + 1])\n                    dfs(j + 1)\n                    part.pop()\n\n        dfs(0)\n        return res\n\n    def isPali(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l, r = l + 1, r - 1\n        return True\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today\nso today let's look at a problem\npalindrome partitioning\nso we're given a string s and we want to\npartition it in such a way that\nevery single sub-string of the partition\nis a palindrome and we want to return\nall\npossible ways that we can partition it\nin\nlike by following this rule and if you\ndon't remember a palindrome is basically\na string\nthat if you reverse it it's the exact\nsame string\nso one thing to notice is no matter what\nstring we're given it's\npossible to partition it in this way why\nis that the case\nbecause in this case we have a a b\nwe know that any any single character\nlike\na is a palindrome right if you reverse a\nyou get a\nany character including b is a\npalindrome right\nreverse it you get b so one way to\npartition this is take\neach character and separate it right and\nthat's what the first partition over\nhere is right each character by itself\nso are there any other ways to partition\nthis other than just\nthis single way well if you take the\nfirst two characters\nyou see that that is also a palindrome\nright a\na reversa is still a a and of course b\nby itself we know any single character\nis definitely a palindrome\nso for the second partition we'll have\ntwo sub strings right\na and b so then this is our result\nbecause we cannot have any other sub\nstrings that are phalan drums right\na b is not a palindrome if you reverse\nit we get b a that's not the same string\nif you take this and you reverse it you\nget b a\na that's not a palindrome so the brute\nforce way in this case\nto solve this problem happens to also be\nthe main way to solve this problem which\nis\nbacktracking so we are going to use\nbacktracking to solve this problem and\nwhat we're going to do is create\nevery single possible way we could\npartition this\nand then check if those partitions form\npalindromes and if they do we are going\nto add them to our\nresult list right because ultimately we\nwant to re\nwe want a list that has every single way\nto partition this\nwhile maintaining palindromes so for the\nfirst\npartition we have three choices do you\nsee what they\nare if we want a first partition well\nthe first partition can either be a by\nitself right\nso a by itself which is if we just took\nthe first\ncharacter and said that that was one\npartition another\npartition is double a right if we just\ntook the first two characters\nas our first partition or the last one\nobviously if we just took the entire\nstring as our first partition\nnow we will check is this a palindrome\nhow are we going to check well we can\nstart comparing the first\nand last characters right and we see\nthat well they're not even equal\nright so this is not a palindrome so\nwe are not going to continue on this\nbranch\nor on this path for our depth for search\ntree but we know that this\nby itself is a palindrome right so this\nis going to be our first partition now\nwe're going to take the remaining\ncharacters\na and b and try to partition them\nright so for one partition of those\nremaining characters we could get a\nsingle a if we took this first one\nanother partition we could get\nis a b if we took\nboth of these characters but we look at\nthe first character and last character\nthis is not a palindrome\nthis is a palindrome but this is not a\npalindrome\nso we don't have to continue on this\npath and from\nhere we know we already took the first\ntwo characters as our first partition\nso we only have one choice for our\nsecond partition\nand that's just the character b and we\nknow a single character by itself\ndoes form a partition and we also know\nthat we have no more remaining\ncharacters right we already took the\nfirst three characters\nso what this tells us is this is one\npossible way to partition\nto make sure that all the substrings are\npalindromes right both of these\nsubstrings are palindromes so this is\none possible uh solution so now the only\npath for us to continue we can't do this\nand we can't do this\nand we cannot do this anymore we don't\nhave any more characters\nso we can continue this one how many\nchoices do we have well we took the\nfirst two a's\nright so now we only have one choice and\nthat's going to be the b\nso we for our third partition in\nthis line is going to be b so this one\nhad\ntwo uh partitions right two strings\nthis one has three and all of them\nhappen to be palindrome so this is\nalso a possible solution so that's how\nyou basically solve this problem\nwith backtracking it's not super\nefficient right it's going to be at\nleast 2 to the power of\nn because we're brute forcing it but now\nlet me show you the code\nso let's have our result this is what's\ngoing to store all of the partitions\nthat we\ncreate all the possible partitions let's\nalso have\na variable called part this is this\nbasically stands for partitions this is\nour\ncurrent partition right so if our\ncurrent partition happens to be\nthis this is just going to be the single\npartition the result is going to be what\nstores the partitions right so this will\npossibly have you know multiple\npartitions in it\nand now i'm going to create a nested\nfunction depth first search for\nour br our backtracking the only thing\ni'm going to pass into it is i the index\nof the character\nwe're currently at and so since this\nfunction is\nnested inside this function these two\nvariables as well as\ns the string are going to be accessible\nin this even if we don't pass them into\nit\nso since this is a recursive function\nfirst thing we check is the base case so\nif i\nhappens to be out of bound so if it's\ngreater than or equal to the length of\nthe input string\ns what are we going to do well in that\ncase\nthe same thing that we did over here\nright we knew that we had\nour a valid partition and we had no more\ncharacters to add so in that case we\nknow that this\nis a possible solution so what i'm going\nto do here is basically to our result\ni'm going to append the current\npartition that we have formed\nbut not only that i'm going to clone it\nbecause we know\nor rather i'm gonna copy it because we\nknow if we end up\nin a different recursive call making\nchanges to this variable there's only\none part partition variable so it's not\nlike there are multiple\npartitions being created we only have a\nsingle one so every time\nwe append to result we have to make a\ncopy of it\nand after we do that we can return\nbecause this is our base case\nif we haven't reached the last index\nwhat can we do well we can iterate\nthrough\nevery other character in our string\nright so\nwe're going to start at i and keep going\nuntil we get to the\nend of the string and\nfor this meaning so this is going to be\nour sub string right this is\nevery possible substring and we want to\nknow is it a palindrome\nso so the indices are going to tell us\nif\nfrom a string s starting at index i all\nthe way to j\nwe're going to check every possible\nstring i'm going to add one to j\nto get rid of the off by one error and i\nwant to\nknow is this a string is this a\npalindrome\ni'm also going to pass in the indices i\nand j\nso we know what our left and right\nboundaries are and actually since we are\npassing in these\nboundaries we don't actually need to\ncreate a substring we can just pass\ns itself so we want to know is s a\npalindrome if you take it\nto start at index i and end at index\nj is this a palindrome and so if it\nhappens to be a palm drum i'll actually\nwrite this helper function later we'll\njust assume we have it now so if this\nhappens to be a palindrome what can we\ndo\nwe can to our partition we can add this\nstring so s from index i\nto index j get rid of the off by 1 error\nwe can add this\nso this is our current partition and we\nwant to keep\nbecause we know s this substring is a\npalindrome\nand so now we can recursively do our\ndepth first search\nlooking for additional palindromes and\nof course we'll start at j\nplus one because that's going to be the\nnext\ncharacter and after we do our recursive\nfunction we have to clean\nup so since we know we only have one\nsingle partition variable\nafter we have added this and added the\nsubstring and then ran our debt for\nsearch\nlooking for all possible additional\npartitions\nafter that we can take the string that\nwe just added over here and then pop\nthat from our partition list and that's\nactually our entire\ndepth for search function you notice we\nhave our base case when we go out of\nbounds\nand with this loop we are generating\nevery single possible substring right\nfrom i to j\nwe're checking if it's a palindrome if\nit is then we're recursively continuing\nour depth for search\nif it's not a palindrome then we're just\nskipping that substring altogether and\ngoing to the next\niteration of the loop so that's our\nentire function and the only thing left\nfor us to do is to actually\ncall it so debt for search will pass in\nzero because we know that's the start\nindex\nand then what we're going to do is\nreturn result\nand before i forget we know we have to\nactually write this helper function that\nwe called before we even wrote it so\nlet's write that really quickly is\npalindrome\nit'll accept a string and it'll accept\nleft and right boundaries so we just\nhave to check if it's a palindrome\nso while left is less than right\nwe'll check if the character at the left\nposition\ndoesn't equal the character at the right\nposition that means\nit's not a palindrome so we can return\nfalse if it\nif they are equal then we can update our\nleft and right pointer so add one to\nleft\nand subtract one from the right pointer\nand if this loop this entire loop\nexecutes and all the characters actually\nwere equal\nthen we'll exit the loop and then we can\nreturn true because that means it\nis a palindrome and now let me just run\nit to prove to you that it works\nand hopefully it's somewhat efficient\nyep it runs perfectly and\nit is pretty efficient so i hope this\nwas helpful\nif you enjoyed please like and subscribe\nit supports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Letter Combinations of a Phone Number",
        "NcLink": "combinations-of-a-phone-number/",
        "Pattern": "Backtracking",
        "Description": "You are given a string `digits` made up of digits from `2` through `9` inclusive.\n\nEach digit (not including 1) is mapped to a set of characters as shown below:\n\nA digit could represent any one of the characters it maps to.\n\nReturn all possible letter combinations that `digits` could represent. You may return the answer in **any order**.\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/796a0dc1-2fcd-4ebb-0686-28f9007ec800/public)\n\n**Example 1:**\n\n```java\nInput: digits = \"34\"\n\nOutput: [\"dg\",\"dh\",\"di\",\"eg\",\"eh\",\"ei\",\"fg\",\"fh\",\"fi\"]\n```\n\n**Example 2:**\n\n```java\nInput: digits = \"\"\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= digits.length <= 4`\n* `2 <= digits[i] <= 9`\n",
        "Difficulty": "Medium",
        "Video": "0snEunUacZY",
        "PythonSolution": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        res = []\n        digitToChar = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"qprs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\",\n        }\n\n        def backtrack(i, curStr):\n            if len(curStr) == len(digits):\n                res.append(curStr)\n                return\n            for c in digitToChar[digits[i]]:\n                backtrack(i + 1, curStr + c)\n\n        if digits:\n            backtrack(0, \"\")\n\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nletter combinations of a phone number so\nwe're given a\nstring of digits that contain\nonly two through nine so the digits are\nonly going to contain the numbers\n2 through 9 and we want to return all\npossible letter combinations that the\nnumber\ncould represent and so basically what\nthis problem is about\nis like when you wanted to text people\nwith old phones you only had\nthese digits right so in order to have\ncharacters you'd map a number like two\nto the characters a b c\nand you can see the reason we're doing\ntwo through nine is because\none was not mapped to any digits right\nso we don't need to consider the one\ntwo was mapped to abc three was mapped\nto d\ne f basically each number or each digit\nfour five six each one was mapped to\nthree characters some were mapped to\nfour characters seven is mapped to four\nnine is mapped to four different\ncharacters so then if you're given\na string of digits let's say two 3 in\nthis\ncase right 2 3 is our string well how\nmany different\noutput strings could we have here you\ncan see we have a\nbunch right we have 9 different strings\nwhy do we have 9 different strings\nbecause this two could be three\ndifferent characters it could be\na b or c this\nthree could also be three different\ncharacters d\ne f so three times\nthree is nine so basically we can have\nwe can have nine different combinations\nof these characters right\nwe could have a d we could have a\ne we could have a f right and so on and\nso on right so\nwe could have b e b b f\nand then do the same thing for c right\nso then you would have nine different\nstrings\nand so basically you can tell that this\nproblem right like writing out the\nsolution like this it's not that\ndifficult because we're gonna basically\nbe forced to brute force this problem\nand it's a backtracking problem because\nwe have to brute force it right we have\nto basically find every single\ncombination\nthat we could get using the given digits\nand\nyou might have noticed i've been doing a\nlot of backtracking problems recently\nand that just goes to show you that\nbacktracking is a very important\nalgorithm\nso let me just show you kind of the\ndrawing of the backtracking solution so\nluckily for us in this case we're only\ngiven two\nthree right and so we only need to find\nokay two maps to these three characters\nthree maps to these three characters but\nwe know in total\nwe it's possible we could have a four we\ncould have a five if we had a four\nwe know four maps to the next three\ncharacters after this\nso g h i i think unless i'm forgetting\nsomething\nand basically we could have any\ncharacter right from\ntwo through nine so we're going to need\nto create a hash map\nor some kind of way to map every\ncharacter from\nor basically every digit from two all\nthe way\nto five six seven all the way to nine\nright and\nmap them to the characters that they end\nup being right we know nine is\ni think gonna be xyz we're basically\ngonna have to hard\ncode this map of characters there's not\nlike a clean way to do it mainly because\nsome of the characters\ni think seven has four characters right\nseven is mapped to four different\ncharacters and\nso whatever but this is a pretty small\nhash map right so it's not a big deal if\nwe have to hard code it\nbut now let's just look at this problem\nitself how are we going to solve it well\nso the first character is 2\nright so 2 could map to three\ndifferent characters so two being the\nfirst digit it can map to a\nb or c right and the next character we\nknow or the next digit is\nthree so from a we could have three\ndifferent\ncharacters that follow after it we could\nhave a d\nwe could have an e or we could have an f\nand that's going to be true for\nevery single one of these right we could\nbasically put a d\ne f after each of them and this\nis the entire backtracking tree so based\non this\nwhat's our solution because remember we\nwant to know the strings\nthat this could map to well this is one\nstring\nthis is one string this is another\nstring so basically for\neach of the leaf nodes in this tree\nwe're going to\nfollow the entire like list of\ncharacters that came before that's going\nto be the output strings right a\na d a e a f\nand so on right b d b e\nb f and the exact same thing for c\nso when you visualize it like this this\nis actually a pretty simple problem\nso now you just need to know how to\nwrite this backtracking algorithm and\ni'm going to show you how to do this\nrecursively but before i do that the\ntime complexity for this\nis basically the number of combinations\nthat we're going to have\nso the question is how many different\noutput\ncould we have for a string let's say the\ninput string is length\nn how many different outputs could we\nhave well since we know that there are\nsome characters like i think\nnine maps to four different characters i\nthink w\nx y z actually so the brute force is\ngonna be\nfour to the power of n that's how many\noutputs we could actually have right\nbecause maybe we'd get\na string s equal 9999 right so\nbasically we'd have four choices for\neach of those characters so 4 times 4\nbasically 4 to the power of n which is\nthe\nlength of the input string right so\nthat's the number\nof output strings that we're going to\nhave and the length of each\noutput string is going to be the same as\nthe length of the\ninput string right so really the time\ncomplexity is going to be\nbig o of n times\n4 to the n and basically this is the\nworst case time complexity\nokay so now let's get into the code\nwhich is going to be\nfairly short so the first thing we want\nto do is have a result\nthis result is going to contain the\ncombination strings that we're trying to\nbuild\nand the next thing we want to do is\ncreate a map of digits right we want to\ntake\nevery single input digit that could be\npossible like two and map it to the\ncharacters\nthat are possible so abc right for two\nand\nunless you wanna see me type this out i\nthink i'm just gonna copy and paste it\nso\nthis is what our digit map is going to\nbe like and you can verify this if you\nhave an old phone laying around that\nthis\nis the correct mapping from digits to\nthe following\nuh string characters so now let's write\nthat backtracking function\nit's going to be a recursive function\nand i'm going to\ndeclare this function inside of this\nfunction so that we don't need to pass\nin these parameters every time we call\nthis backtracking function\nand we also don't need to pass the\ndigits that we're on i'm only going to\npass in one variable i which is going to\ntell us what index we're at in\nthe digit string that we're given as the\ninput to our\nfunction and i'm actually going to pass\nin one more variable\nso the current string meaning basically\nthe current string that we're building\nso let's say our input was\nuh one two three and the current string\nwould contain something like\na right so if we've we've only visited\none so far we'd have a\nand then we'd want the next two\ncharacters from two and three\nso we know the base case is if i\nis greater than or equal to the\nlength of digits or actually an even\nbetter base case would be\nour current string let's say the length\nof the current string\nis exactly equal to the length of digits\nthat means that we've\nbasically been able to take every single\ndigit and then map it to a character\nbecause current string is going to\ncontain those characters\nand if that is the case then we are\nallowed to take our result and add to it\nthe current string that we just\nbuilt and then since this is the base\ncase after that we can just return\nif this is not true though that means we\nhaven't\nfinished building the current string\nthat means we need to continue\ngoing through the digit that we're at\nright at index i\nso let's create a loop to do that\nso basically i'm going to take digits of\ni that's going to tell us the current\ndigit that we're at right and i want to\ntake this digit that we're at and i want\nto map it to the list\nof characters that it maps to right so\nif we had nine we know nine maps to\nw x y z so how can i do that well that's\nwhy we created this\ndigit to character map we can take a\ndigit\nand then map it to a character so digit\nto\ncharacter i'm going to take this digit\nand now basically this is going to be\nthe\nthat string that it maps to and i want\nto just go\nthrough every character in this string\nso for every c every single character in\nthis string\ni want to brute force this right so for\nevery single character i'm just going to\ncall backtrack\ni'm going to make that recursive call\nright so\nfor i we're going to increment i by 1\nbecause we're moving to the next digit\nand for the current string we're going\nto just take the current string that we\nwere given\nand add one more character to it the\ncharacter that we're currently visiting\nc and that's actually all that we have\nto do\nwe have our single base case and we have\nour recursive case you can see that the\nonly thing\nthat might be different for you is that\nour recursive call is inside of a loop\nso with this backtracking function\ncomplete\nnow let's actually call this\nbacktracking function so\nwe the parameters to give it are going\nto be 0 for the\nindex and the current string is\ninitially just going to be empty right\nbut i'm actually going to need to make\none last modification so we're only\ngoing to need to call backtracking if\nthe digit string that we're given\nis non-empty and the reason is because\nif digits was\nempty then our recursive call would be\ncalled and then we'd execute the base\ncase\nonce so then we'd end up returning this\nas our result we'd add the empty string\nto result\nbut in the way this problem is defined\nif\ndigits if digits was empty like this if\ndigits was just an empty string the\noutput that they actually want is just\nan\nempty array like this so that's why we\nhave to\nput this inside of a condition but other\nthan that all we have to do is now\nreturn\nour result and the function is complete\nso you can see that it's pretty\nefficient about as efficient as you can\nmake a problem like this even though\nit's a rel it's what's it called it's an\nexponential function right\nbut i hope that this was helpful if it\nwas\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\nsee you pretty soon\nyou\n"
    },
    {
        "Name": "N Queens",
        "NcLink": "n-queens/",
        "Pattern": "Backtracking",
        "Description": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard so that no two queens can attack each other.\n\nA **queen** in a chessboard can attack horizontally, vertically, and diagonally.\n\nGiven an integer `n`, return all distinct solutions to the **n-queens puzzle**.\n\nEach solution contains a unique board layout where the queen pieces are placed. `'Q'` indicates a queen and `'.'` indicates an empty space.\n\nYou may return the answer in **any order**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/cdf2b34d-7905-4388-db0b-9a120ebf4a00/public)\n\n```java\nInput: n = 4\n\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n```\n\nExplanation: There are two different solutions to the 4-queens puzzle.\n\n**Example 2:**\n\n```java\nInput: n = 1\n\nOutput: [[\"Q\"]]\n```\n\n**Constraints:**\n* `1 <= n <= 8`\n",
        "Difficulty": "Hard",
        "Video": "Ph95IHmRp5M",
        "PythonSolution": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        col = set()\n        posDiag = set()\n        negDiag = set()\n\n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n\n            for c in range(n):\n                if c in col or (r + c) in posDiag or (r - c) in negDiag:\n                    continue\n\n                col.add(c)\n                posDiag.add(r + c)\n                negDiag.add(r - c)\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col.remove(c)\n                posDiag.remove(r + c)\n                negDiag.remove(r - c)\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nn queen so this is a pretty famous\nbacktracking problem and we're finally\ngoing to be solving it today\nand this is marked as a hard problem but\ni don't think it's super hard to come up\nwith what the solution would be at least\nto come up with how to solve the problem\ni think the hard part about this is\nactually\nimplementing the code of this problem\nbecause like i said it's backtracking so\nbasically we're just going to be doing a\nbrute force approach so the problem\nstatement is\nwe're given n queens we're given a board\nof size\nn by n a chess board right so the\ndimensions are n by\nn and we're also given n different\nqueens that we have to place somewhere\non this\nboard such that no two\nqueens ever attack each other so you\nhave to know a little bit about chess\nso the way a queen can move is that\na queen is allowed to move in any\ndirection horizontally so it can move to\nthe left\nor to the right it can move up or\ndown so it can move in all four\ndirections it can also move\ndiagonally so you know this diagonal\nwhich i call\nthe positive diagonal because you can\nsee it's kind of a positive\nslope right top right also it can move\nin the negative diagonal direction which\ni\nwhich you know you can kind of tell is\ngoing bottom right\nso it can move in these different\ndirections\nand that's kind of what makes it tricky\nso we want to place\nthe queens in such a way that they don't\nattack each other so right now you can\nsee this queen\nis going left right top bottom\nthis diagonal and this diagonal right so\nit's definitely not attacking any other\nqueen\nthis queen as well you can see it's\ngoing up\nleft right down diagonal and you could\ndo that with all of the queens right i\ndon't want to make it too messy though\nand then what we want to return is\nactually these boards themselves so in\nthis case\nwe were given n equals four and you can\nsee that these\ntwo different compositions are the ways\nwe could arrange the queens and then we\nwant to return that\nas a list of strings each string\nrepresents\none row in this board now the main thing\nyou notice initially is okay\nsince a queen can go horizontally or\nvertically therefore\nevery queen has to be in a different\nuh row right notice how every single\nqueen is in a different row that makes\nsense because if we ever put two queens\nin the same row then they'd be able to\nattack each other right\nso each queen has to go in a different\nrow\nnotice how each queen is also going in\na different column right each queen\nin this case is in a separate column\nbecause they can move\nvertically we don't want them to attack\neach other vertically\nas well so that's pretty straightforward\ni think but the hard part is\ndiagonals right notice how we have many\ndifferent diagonals in this\nboard let's just look at the positive\ndiagonals what i call the positive\ndiagonals the ones that can go\ntop to right so notice how\nin this case we have many different\ndiagonals and in each of the cases\neach queen is in a separate positive\ndiagonal right you can see that that's\nthe case\nwhat about negative diagonals okay this\nis one negative diagonal this is another\neach queen is in a separate negative\ndiagonal\nbecause we don't want any queens to\nattack each other\ndiagonally so this is going to be the\npart that's a little bit tricky to code\nat least until you've seen it before but\nit's actually really easy to implement\nonce you know the main idea\nso now let me kind of show you how we're\ngoing to apply backtracking to this\nsolution how we're going to apply the\nbrute force method to\nget each valid arrangement of the end\nqueens\nso what really really brute force idea\nthat you might have\nis okay let's just choose okay we can\npick any of these positions in the\nin the four by four grid let's put a\nqueen over here so that's the first\nposition we try okay\nnow let's try a different position right\nfor the second queen\nlet's try putting the queen in this\nposition right and then now we have all\nthese remaining choices let's keep\nputting a queen in every single position\nand trying that so this is one\narrangement then maybe we could take the\nfourth queen and put it over here\netcetera etcetera\nnow why is there any reason to do that\nthat's a little bit too\nbrute force if you ask me there's a much\nsimpler way we can do it\nright because for each queen instead of\nhaving n\nsquared choices how about we just have n\nchoices because we know for sure each\nqueen is definitely going to be in a\ndifferent\nrow so first we can go like this we can\nsay\nokay we can decide to put for this first\nrow itself right this first row we can\ndecide to put the queen in the first\nposition\nor we could decide to put the queen in\nthe second position\nor the third position or the fourth\nposition\nwhatever we do in that first row then\nwe're gonna move to the next row right\nso now our goal is to find\na different location where we can put\nthe second queen\nin this second row now we could try\nputting it over here\nor we could try putting it over here or\nwe could try putting it over here\nbut we can't put it over here why\nis it that we can't put it here because\nthey're in the same column so\nnow you already can tell we're going to\nneed to be maintaining\nthe columns of whatever previous\nqueens that we've already placed we\ndon't have to maintain the rows though\nright because i just showed you\nwhy because every time we place a queen\nwe're gonna move to the next row\nanyway until we get to the bottom right\nand then we're gonna make sure\nthat we're placing the last queen in a\nvalid location\nand if we are then we're done right so\nwe are gonna have to keep track of which\ncolumns we place a queen\nin and we're gonna have to keep track of\nthe positive\ndiagonals that we're placing a queen in\nand we're gonna have to keep track of\nthe\nnegative diagonals that we're placing a\nqueen in and we can uh\nkeep track of all of these with a set\nright\nso a set can tell us a hash set can tell\nus which column of zero\none two or three we have put a queen\nalready in\nand we can do the same for a positive\ndiagonal\nand a negative diagonal but i bet you're\nwondering how can we do it\neasily with positive and negative\ndiagonals right we don't have\nindices for something like this right\nwhat index does this diagonal belong to\nand i'll show you there's a bit of a\npattern when it comes to diagonals\npositive\nand negative diagonals let's say we\nstart at the origin the top\nleft position and then we go diagonally\nbottom right so this is what i'm going\nto refer to as a\nnegative diagonal because from left to\nright\nwe're end up going downwards right do\nyou\nnotice anything about this diagonal well\nwe're starting at 0\n0 right the row and column are 0 0\nas we move diagonally down we get to\nthis position right then the row and\ncolumn are\n1 1 then we get to this position where\nthe row and column are 2 2. so notice\nhow\neach time we're increasing the the\ncolumn value by one\nand we're increasing the row value by\none as well\nwhat does that tell us that tells us\nalong\nthis diagonal along this negative\ndiagonal\nthe computation rho minus\ncolumn is going to stay constant\nover here right in this position if you\ntake the row minus the column we get\nzero minus zero\nthat equals zero if you take the row\nminus column in this position we get\ntwo minus two that equals zero so we can\ndefine\nthis particular negative diagonal as\nbeing\nthe zero negative diagonal let's try it\nout on a different negative diagonal to\nsee if our pattern holds\nlet's start over here at a different\nposition\nrow zero column two and then go\ndiagonally down\nnotice how whenever we're going\nnegatively diagonal we're\nincreasing the column by one and we're\nincreasing\nthe row by one so in this position\nthe row which is zero minus the column\nwas negative two right zero minus two is\nnegative two\nwhen we get to the next position along\nthis diagonal we get\none minus three which is also negative\nnegative two so we can see that this\npattern holds the negative diagonal\nalong this\nis going to be the negative one diagonal\nthe negative diagonal along\nthis path is going to be positive one\nbecause we see one\nminus zero is positive one so i just\ndrew out a few of the diagonals if you\nwant to visualize it you can see this\ndiagonal\nis constant this diagonal is constant\nthis diagonal is constant etcetera\netcetera right\nso that's how we're going to be doing\nnegative diagonals is there a similar\npattern we can use for positive\ndiagonals let's see\nso let's say we started our positive\ndiagonal over here\nwe can see the row is three the column\nis zero and then we go diagonally top\nright right we go\nup in this direction now notice when we\ndo go in this direction\nwe're moving to the right we're\nincreasing the column by one\nbut we're decreasing the row\nby one so we can't use row minus column\nfor positive diagonals right because\nit's not going to stay constant\nover here the row minus column is going\nto be three over here the row minus\ncolumn is going to be\n1 so it doesn't work if we do row minus\ncolumn\nbut notice since we're increasing the\ncolumn\ngoing in this direction but we're\ndecreasing\nthe row that means row plus column\nis going to stay the same right the sum\nof these two values is going to stay the\nsame because we're\nwe're decrementing one but we're\nincreasing the other\nfor example in this position row plus\ncolumn is three\nin this position row plus column is also\nthree\nright so it's going to be three all the\nway what about\nthis diagonal does it also work well\nthree plus\none that's four in this position\ntwo plus two that's four and this is\nalso going to be four so you can see\npositive diagonals can be determined\nwith r\nplus c turns out that these three sets\nare the only information we need then we\ncan\nbrute force start placing queens how's\nthe algorithm going to go\nlike i mentioned we're going to try each\nof the four positions\nin the first row right and for each of\nthem so the decision tree is going to\nlook something like this right we'll try\na queen in position 0. we'll try a queen\nin position 1\nposition 2 position 3 right and this is\nall for the first row and we'll do the\nexact same\nthing continuously right for if we put a\nqueen here\nthen could we pl then we're gonna you\nknow try a queen in all the other four\nplaces so\ntwo three now if we place the queen here\nthat means we put a queen here so then\ncould we put a second queen in the same\ncolumn\nno that's how we're going to know how\nare we going to detect that we can't do\nthis\nwe're going to see that a queen has\nalready been placed in the same column\nset so we're not going to do that right\nso we can't place a queen here\nwhat about position 1 well it's clearly\nnot in the same\ncolumn right why shouldn't i be able to\nplace a queen over here well\nit turns out that it's already been\nadded to the negative diagonal\nthis position means the negative\ndiagonal is zero row minus column is\nzero\nso this position is also row minus\ncolumn\nzero that means the negative diagonal\nhas already been used so we also\ncan't put a queen in this second\nposition so this\npath in our decision tree also does not\nwork can we put a queen\nover here in this position yes we can it\ndoesn't\noverlap with the positive diagonal and\nit doesn't overlap\nwith the negative diagonal and they're\nnot in the same column right so we can\ncontinue\nthis one and we can also continue in\nthis one right it's also not in the same\npositive or negative diagonal\nalso not in the same column so that's\nkind of how the algorithm is going to\nwork\ni'm not going to draw the entire\ndecision tree because i think you\nprobably get the point these\nthree sets are going to give us all the\ninformation we need\nokay so like i mentioned the the three\nsets are going to be all the information\nwe need we have a column set we have a\npositive diagonal set and remember the\npositive diagonal is determined let's\njust place a comma is determined by\nr plus c and the negative\ndiagonal is determined by r minus c\nso let's just make sure we remember that\nwhen we're actually writing our code\nr minus c for the negative diagonal and\nwe're going to have a result which is\nbasically going to tell us all possible\nend queen solutions and we're also going\nto maintain a\nboard so initially i'm just going to\nmake the board a\narray of let's say and by the way i\ndidn't mention this but a dot\nis basically indicating an empty\nlocation so this multiplied by\nn is going to determine a row how many\nrows are we going to have well\nfor i in range n right it's an n by\nn board so i'm just initialing a board\nwith\nperiods or dots in every single position\nso then\nwe can define our backtracking recursive\nfunction\nand remember we're going to be doing it\nrow by row so initially we're going to\nstart at\nrow 0 then we're going to go to row 1\nrow 2 all the way until we get to row\nn row n is our base case that means\nwe're out of bounds that means we\nalready completed every single row\nso if we ever reach this position where\nrho is equal to n\nthat means we were able to find a valid\nn queen solution\nso what can we do well of course we're\ngoing to return but before we return\nwe're going to add whatever the current\nboard is and we're going to add it to\nthe result\nbut we are going to make a copy of this\nboard because we're still going to use\nit in\nsubsequent function calls for this\nrecursive function so we're going to\nmake a copy of this board\nand we're also going to change the\nformatting the way they want it each row\nis not going to be an array\neach row is going to be a string so\nbasically for each row here we're just\ngoing to join\neach substring together so let's make a\ncopy of this board\nwhich we can do by taking four\nlet's say row in the board each row\nwe're going to take each row and then\njoin it together so\nwe can do that in python like this empty\nstring dot\njoin this entire row together\nand then doing this we'll have a copy of\nthe board where each row is basically\njoined together right\nand then we're going to take that copy\nand append it to the result so\nresult.append\ncopy i mean i'm sure there's different\nways you can do this if you're using\njava or c\nplus plus this is just an easy way to do\nit in python so if we did not reach the\nbase case that's when we're gonna\ncontinue\nso we're gonna go through every single i\nin\nrange of n right we're gonna try every\nsingle position\nin the current row that we're at we're\ngonna see which\npositions are we allowed to place a\nqueen inside\nand this i actually refers to the column\nso i'm going to change it to for\nc and range n so basically if c is\nin column meaning it's already been used\nin this column or\nr plus c is already in the positive\ndiagonal\nwhich means the positive diagonal has\nalready been used or\nif the negative diagonal r minus c has\nalready been used\nthat's how we know we have to skip this\nposition so what i'm going to say\nis continue if that's the case that\nmeans we're not allowed to use this\ncolumn row position but if we are\nallowed to use this position\nlet's do exactly that then we can do a\nbacktracking\ncall you know do the same thing\nbacktracking call let's go to the next\nrow but before we do that we know we\nhave to actually update all of our sets\nright because we we weren't using\nthis uh combination but now we are using\nit so we have to say\ncolumn dot add this column and we have\nto say positive diagonal\ndot add row plus column\nand we have to say negative diagonal add\nrow\nminus column so that's just kind of some\nof the pre-work that we have to do\nand we also have to update the board\nitself right we have to say okay at this\nposition in the board row\ncolumn let's set it equal to a queen\nnot a dot anymore so that's what we're\ngoing to do before we start our\nrecursive backtracking solution\nand after we're done we have to do the\ncleanup that is required in most\nin most backtracking solutions right so\nwe have to basically do what we just did\nhere and\nundo all of it for the next iteration of\nthe loop\nso i'm just going to copy and paste this\nbecause we're literally just going to be\nhaving to rewrite every line so instead\nof\nadding all of these to the set i'm going\nto be removing all of these to the set\nright that's kind of what backtracking\nmeans\nwhere we're backtracking from what we\njust did to seeing if maybe multiple\nsolutions exist\nright that's the brute force element of\nthis so we initially set this equal to a\nqueen\nlet's set it back equal to an empty\nspace or a dot\nin this case and that's really it we\nhave no return condition\nin this backtracking so once this loop\nis done executing then we're done with\nthe entire function so now\noutside of here all we have to do is\ncall our backtracking function\npassing in row 0 and then once that is\ndone\nwe will have updated our result so our\nresult should contain\neverything we need so then we can just\nbe able to go ahead and say okay return\nthe result\nso you can see that the solution does\nwork and it is pretty dang efficient\neven though it's a backtracking brute\nforce approach so i hope this was\nhelpful\nif it was please like and subscribe that\nsupports the channel\na lot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Implement Trie Prefix Tree",
        "NcLink": "implement-prefix-tree/",
        "Pattern": "Tries",
        "Description": "A **prefix tree** (also known as a trie) is a tree data structure used to efficiently store and retrieve keys in a set of strings. Some applications of this data structure include auto-complete and spell checker systems.\n\nImplement the PrefixTree class:\n* `PrefixTree()` Initializes the prefix tree object.\n* `void insert(String word)` Inserts the string `word` into the prefix tree.\n* `boolean search(String word)` Returns `true` if the string `word` is in the prefix tree (i.e., was inserted before), and `false` otherwise.\n* `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.\n\n**Example 1:**\n\n```java\nInput: \n[\"Trie\", \"insert\", \"dog\", \"search\", \"dog\", \"search\", \"do\", \"startsWith\", \"do\", \"insert\", \"do\", \"search\", \"do\"]\n\nOutput:\n[null, null, true, false, true, null, true]\n\nExplanation:\nPrefixTree prefixTree = new PrefixTree();\nprefixTree.insert(\"dog\");\nprefixTree.search(\"dog\");    // return true\nprefixTree.search(\"do\");     // return false\nprefixTree.startsWith(\"do\"); // return true\nprefixTree.insert(\"do\");\nprefixTree.search(\"do\");     // return true\n```\n\n**Constraints:**\n* `1 <= word.length, prefix.length <= 1000`\n* `word` and `prefix` are made up of lowercase English letters.\n",
        "Difficulty": "Medium",
        "Video": "oobqoCJlHA0",
        "PythonSolution": "class PrefixTreeNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.end = False\n\nclass PrefixTree:\n    def __init__(self):\n        self.root = PrefixTreeNode()\n\n    def insert(self, word: str) -> None:\n        curr = self.root\n        for c in word:\n            i = ord(c) - ord(\"a\")\n            if curr.children[i] == None:\n                curr.children[i] = PrefixTreeNode()\n            curr = curr.children[i]\n        curr.end = True\n\n    def search(self, word: str) -> bool:\n        curr = self.root\n        for c in word:\n            i = ord(c) - ord(\"a\")\n            if curr.children[i] == None:\n                return False\n            curr = curr.children[i]\n        return curr.end\n\n    def startsWith(self, prefix: str) -> bool:\n        curr = self.root\n        for c in prefix:\n            i = ord(c) - ord(\"a\")\n            if curr.children[i] == None:\n                return False\n            curr = curr.children[i]\n        return True\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve\nimplement try aka a prefix\ntree so a try or a prefix tree is a\nspecial type of\ntree and it's used to efficiently store\nstrings and\nthe applications are some stuff like\nautocomplete\nand spell checker the reason is because\nthe prefix\ntree allows you to efficiently filter\nand search\nbased on prefixes so let's look at the\nactual implementation of it\nso we're going to have a object that's\nwhat we're going to be doing this time a\ntry\nobject and our job is to fill in three\nfunctions the first function is going to\nbe\ninserting a word into the try the second\nfunction is going to be\nsearching for a word in the try to see\nif the word\nexists and the third function is going\nto be to check\nif there is a word that starts with a\ngiven\nprefix so those are the three functions\nwe're gonna do\nand let me just go through the rest of\nthis explanation\nand then i'll show you what a try\nactually is so here you can see\nbasically what we're gonna actually be\ndoing\nthey're gonna be instantiating the try\nright we're going to be inserting a word\nsuch as apple right then we're going to\nrun search\ndoes the word apple exist but we just uh\nadded it so of course we're going to\nreturn true apple exists\nthen we're going to check does the word\napp exist\nit does not the word app does not exist\nand third we're going to try starts with\napp are there any words that start with\napp an answer is yes so we return true\nremember\napple starts with app so we return true\nthe\nprefix right this is the prefix app\nis the prefix of apple so\nnow let me show you the actual data\nstructure so let me show you what a try\nis and in this problem they told us that\nthe limitation\nis that the words are gonna only have\ncharacters from\nlowercase a to z right so this is\nlowercase a to z so that means we're\ngonna have exactly 26 characters\nto worry about right but so this is a\ntree right it's a prefix tree it's a\nspecial kind of\ntree so initially our tr our tree is\ngoing to be empty\nright but let's say we want to insert\napple\nso if we want to insert the word apple\nhow can we do that well this is what\nwe're going to do we're going to create\na node for the lowercase\nletter a right then we're going to\ncreate another\nnode for the lowercase letter p\nand we're going to basically keep doing\nthis for every\ncharacter in the word that we're\ninserting right we're going to say\na insert it p insert it second\np keep doing that and every time we're\ninserting a new character we're going to\nadd it as a\nchild of the previous character\nso we inserted the word apple right we\ncan clearly see that\none more thing we have to do to say that\nthis is\nthe word that we inserted is we have to\nmark the\nend of the word right so this is the\nend of the word right the letter e is\nthe end of the word so we're going to\nmark it such that\nso that this is identified as the end of\nthe word right not\nfor example this right if the if we mark\nthis as the end of the word\nthen we're basically saying we inserted\nthe word a p\nbut we know we actually did apple right\nfull on\napple this is the last character so we\nmark here as the last character\nwe are marking it even though it's kind\nof self-explanatory because this\ncharacter e\ndoes not have any children it's\nbasically obvious that this is the end\nof the word but we're still marking it\njust to be safe\nso you can kind of see what we're doing\nhere now right this\nis kind of the route right so\nreally what's going to be possible is we\nhave 26 characters right so\npotentially we could have a a a\nnode at the first layer for every\ncharacter right so a\nb c d etc right we could have a node for\neach of these\nbasically indicating that here is where\nwe're gonna put all of the words that\nstart with a b\nhere we're gonna put all the words that\nstart with a c here's where we're going\nto put all the words starting with d\nso the next thing we're going to do is\nrun search we're searching for the word\napple so how are we going to do that\nwell we're going to start\nhere at our root right this is\ntechnically our root even though it\ndoesn't really have\na character right so that's basically\njust a placeholder node right it doesn't\nhave any characteristics\nbut it's considered the root right and\nso we're gonna check does this\nroot have the child the of the first\ncharacter that we're looking for right\nso take a look this is the word we're\nlooking for\nobviously we're looking for the\ncharacter a so we check\nhey there's the a lowercase a right it's\nthe first character of the word that's\nwhat we're looking for great\nnow for this a we're looking for the\nnext character right so does this a have\na child\np character it has exactly that so we do\nhave this p\nright and this is what we're doing right\nwe're going character by character in\nthe word we're searching for and\nchecking\nif a node exists for each character\nconsecutively right as a child so\nnext character p does this have a child\np yes it does\nnext character l we have a child l next\ncharacter\ne this is the last character so we do\nhave an e\nover here right and last thing that we\nhave to confirm\nis okay this is the last character does\nis it marked\nsuch that this is the end of the word is\nit marked as if it was the end of the\nword\nit's blue right that's what we're doing\nto indicate that it's the end of the\nword\nso it is right so clearly we do have\napple we search for apple what do we do\nwe return\ntrue because apple does exist in the try\nso next let's run search again and this\ntime\nlet's check if a word app exists inside\nof our try app right not apple\nso obviously we know that starting from\nthe root again we do have an\na lowercase a just like we checked we do\nhave a lowercase p\nafter that and we do have a second\nlowercase p\nso since we do have all three of these\ncharacters right\na p p shouldn't this function return\ntrue\nno we're not returning true and the\nreason is\nthis node is the last character of the\nword right p\nand it's not marked blue meaning it's\nnot\nmarked as a word right remember we only\ninserted apple into our try right into\nour tree\nand we and we marked this as the end of\nthe word we never inserted\napp into the tree so this is not marked\nas the end of the word so we return\nfalse for saying that uh\napp does not exist in our tree app is\nnot\na word yet next let's run another\nfunction on our tree or try we're going\nto check\ndoes a word start with app how can we\ncheck if a word\nstarts with app well we're basically\nrunning the exact same thing what we've\ndone right we're starting at the root\nwe're going to check\ncharacter by character so this is pretty\nlike all three of these functions are\npretty similar right we're checking\ncharacter by character for all of them\nstart at a a exists check p p\nexists check another p p does exist\nso since we found all of the characters\nright\nwe're basically guaranteed that's either\nthis\nis a word itself which clearly it's not\nright we never inserted app\nor we're guaranteed that there is some\nword\nbelow that has been marked right because\nif\nwe inserted these characters we only did\nthat because we were inserting a word so\nthere's guaranteed to be\nat least something that is marked blue\ndown here right so\nso once we found this character the\nsecond p\nwhich is all the characters in here then\nwe can say true right there definitely\nexists\na word that starts with app right and so\nthis starts with function is the main\nreason we're even\nimplementing a try in the first place\nbecause if we want to\ninsert words and search for words exist\nright to check if a word exists we could\njust use a hash map for that right\nbecause\nhash maps can or hash sets can do both\nof those things in o of\none time right but this is really the\nproblem\nstarts with it allows us to check\nprefixes right so now\nlet's say we were inserting another word\nlet's say we're inserting the word\nape right a p e how are we gonna do that\nright we're inserting another word what\ndoes that mean are we gonna say\na p e and then just create a separate\nnode for each of these\nas children right and just connect them\nsuch as that right this is a child of a\nthis is the child of p are we gonna do\nthat no because we could\nreuse it right why would we have\nduplicate a's\nin the first position when we already\nhave an a\nover here so if we are inserting this\nword ape we're gonna\nleverage this a that we already created\ngreat\nand then we're adding the second\ncharacter p we're gonna leverage\nthis p that we already created and so\nwe've inserted\nthe first two characters what about the\nlast character the e\ndo we have an e over here no right\nthere's no\ne in the third position so what are we\ngonna do we're gonna create another\nchild node right now we create an e\nand last but not least we mark that this\nis the\nend of a word so you can see that a try\nactually has the potential to be pretty\nefficient because we are\nreusing a lot of nodes right we're not\nnecessarily creating a separate node\nfor every single word now let me just\nshow you one\nlast thing before we jump into the code\nso we're going to do one last function\nwe want to check does any word start\nwith\nb and i'm just illustrating why we're\neven implementing a try in the first\nplace it's because the starts with\nfunction\nis very efficient compared to other data\nstructures\nso for example let's say we had a list a\nlist\nof words a list of strings and let's say\nthe size of that list\nwas equal to a million right\nhow long would it take for us to check\nif\nany word starts with b worst case we\nwould have to check\nevery single word in the list and check\nif it starts with b\nand what if there was zero words that\nstarted with b then every time we would\nhave to go through that entire\nlist of a million words but with a try\nlike we've implemented right now it's\nvery efficient\nhere you can see we implement we have\ntwo words right we have one word here\nand we have a second word here and it's\npossible we could have a million\nother words right like clearly there's\nprobably a lot of words that start with\nthe character a\nand maybe so on but when we run this\nfunction\nstarts with b all we're checking is\nwe're starting at the root we're\nchecking\ndo we have any children with the\ncharacter\nb right we check this first\nlayer how large is that first layer\ngonna be well we know that there's\n26 lowercase letters right so worst case\nit would be lowercase\n26 and that's pretty efficient right\nso when we check we check hey there's a\nlowercase a but there's no lowercase b\nso\nfor this starts with function we can\nreturn false and\nthat was done very efficiently right uh\n26 is basically\nbig o of one so this is a super\nefficient way\nto to check prefixes right and that's\nwhy they call this a prefix\ntree prefixes can be checked very\nefficiently so\nnow let's actually jump into the code\nall three of the functions insert\nsearch and starts with are pretty\nsimilar functions\nso the even though we're going to write\na lot of code it's going to be mostly\nsimilar so let's jump into that\nso our job is to implement a try but we\ncan't really do that without\nimplementing a try\nnode so the first thing i'm going to do\nis create a try\nnode and all we're going to do is just\ncreate the constructor so in python\nthat's what i'm doing and net is\nbasically the constructor\nand i'm just going to have a couple of\nuh member variables for this so we are\ngoing to have\nchildren of a tri node right it could\nhave children it could have 26 children\nbut instead of doing an array i'm just\ngonna do a hash map because that's\neasier\nand remember we can also mark every\nsingle node\nas if it was the end of a word i'm gonna\nsay\nend of word is gonna be a variable\ninitially it's gonna be false\nbut we could set it to true if the\ncharacter was the end of a word\nnotice how we're not actually storing\nthe character itself\nin the try node that's gonna be implicit\nfrom the\nhashmap from this hashmap so if we were\nadding a\nlet's say a character a a lowercase\ncharacter a we would say\nto children we would say children for\ncharacter a\nis the key and we're going to create a\nnew tri node\nfor that character a right so that's how\nwe're going to be doing it that's how\nwe're going to be inserting a\nnode so that's our entire trinode\nclass now let's actually get into the\ntry class so the first thing we're going\nto do is initialize this so let's get\nrid of this comment and\nfor initializing this all we're really\ngoing to need is a\nroot node and we can get the rest of the\nnodes\nfrom that root so we're going to create\na root tri node\nand that's it that's all we're going to\ndo for the constructor and once the try\nnote is created we basically have an\nempty tree even though we have a root\nit's empty because it does\nit does not have any children so we\ntechnically have not inserted\nany words yet but now let's implement\nthe\ninsert word method this method\nfor this method we are gonna have to\niterate through every single character\nin the word so we're gonna initialize\nour self current\nis gonna be set to the root so we're\ngonna initially start at the root right\nand then we're gonna go\ncharacter by character in the word and\nfor every single character we're just\ngonna check two things\ndoes the word all does this character\nalready exist\nif it doesn't already exist so if this\ncharacter is\nnot in the current nodes\ndot children hash map right so if the\ncurrent\nif this character is not in our hash map\nyet\nthat means it hasn't been inserted yet\nso what are we going to do we're going\nto create a try node for this character\nso cur\ndot children and the key value we're\ngoing to use\nis the character and then we're going to\ncreate a new\ntri node so this is how we are going to\nbe inserting characters\nto children we're going to use the\ncharacter as a key value and then we're\ngoing to create\na empty tri node and we're only doing\nthat\nif the character doesn't already exist\nif it does already exist then we can\nskip that step and just\nsay that current is going to be set\nto that child right so if that character\nalready existed then we can just\nupdate ker and move to that character\nand then continue\nour for loop right so we're going to do\nthis for every character in the word\nand then by the end of this loop whether\nwe have to create\nevery node or the nodes already exist\nfor us\nfor this word right let's say it was\napple or something\nthe characters already exist or we just\ncreated them\nnow current is set to the last character\nof the word\nso what are we going to do to current\nwell we're going to\nmark it as the end of a word so we're\ngoing to set end of word\nequal to true now and then we don't\nreally have to return anything\nso that was pretty simple right not a\nlot of complex code we did have to\ngo through every character and we either\ncreated nodes\nor just iterated through those nodes and\nevery and the remaining two functions\nsearch and starts with are actually\ngoing to be\nvery similar to this insert function so\nnow let's get started on\nsearch so we want to search to determine\nif a word exists or not so\njust like the previous function we're\ngoing to start at the root node so\nself dot root and we're going to go\ncharacter by character\nin the word and we're going to check if\nthis character exists\nin our tree if it does not so if c\nnot in current.children if this\ncharacter\ndoes not exist then what do we have to\ndo we return false\nmeaning the word just just simply does\nnot exist if it\ndoes then we can move ourselves to that\nchild node so we can update cur and set\nit to\nthe child node of that character and\nthen we're gonna basically keep doing\nthis\nfor every character in the word if the\nword doesn't exist will return false if\nthe word does exist that means\nthe entire loop will execute and then\nwill be so then kerr will be the last\ncharacter\nof the word and we and we know that it\nis a word\nif ker has the end of word\nvariable set to true so this is the\nvariable we're going to be returning\nif this is set to true that means this\nis a word\nand will return true if it's set to\nfalse that means it's not a word and our\nfunction is ultimately going to return\nfalse and now last but not least let's\nget started with the starts with\nfunction\nand this function is actually going to\nbe the exact same as the\nsearch function except we're not going\nto have to\nuh determine if it's the end of a word\nor not right\nwe we're not checking if it is a word\nwe're right\nwe we are just given a prefix and we\njust want to know if there's any word\nthat\nstarts with this prefix so once again\nlook for the third time we're going to\nbe starting at the root\nand we're going to go character by\ncharacter in the prefix\nthis time right we're not given a word\nthis time and if this character is\nnot in our tree so if it's not in the\nchildren\nright now then we will return false\nmeaning the prefix does not exist\ntherefore\nno words start with this prefix\notherwise we will\nuh shift our current pointer to that\nchild\npointer of this character and continue\non\nand at the end if we do reach\ncur then we can immediately return true\nbecause we know that there's at least\none word that starts with this prefix\nwe don't have to determine that the\nprefix itself\nis a word so that is the entire code i\ncan zoom out so you can see the entire\nthing\nand we just have one small typo over\nhere this is children\nand so other than that this is the\nentire code\nso today you just learned a brand new\ndata structure and i hope that this was\nhelpful for you\nso this data structure can be pretty\nuseful it's a rare data structure to see\non leak code problems but i hope that\nyou did learn something new today and if\nthis was helpful please like\nand subscribe it supports the channel a\nlot and i'll hopefully\n"
    },
    {
        "Name": "Design Add And Search Words Data Structure",
        "NcLink": "design-word-search-data-structure/",
        "Pattern": "Tries",
        "Description": "Design a data structure that supports adding new words and searching for existing words.\n\nImplement the `WordDictionary` class:\n\n* `void addWord(word)` Adds `word` to the data structure.\n* `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `'.'` where dots can be matched with any letter.\n\n**Example 1:**\n\n```java\nInput:\n[\"WordDictionary\", \"addWord\", \"day\", \"addWord\", \"bay\", \"addWord\", \"may\", \"search\", \"say\", \"search\", \"day\", \"search\", \".ay\", \"search\", \"b..\"]\n\nOutput:\n[null, null, null, null, false, true, true, true]\n\nExplanation:\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"day\");\nwordDictionary.addWord(\"bay\");\nwordDictionary.addWord(\"may\");\nwordDictionary.search(\"say\"); // return false\nwordDictionary.search(\"day\"); // return true\nwordDictionary.search(\".ay\"); // return true\nwordDictionary.search(\"b..\"); // return true\n```\n\n**Constraints:**\n* `1 <= word.length <= 20`\n* `word` in `addWord` consists of lowercase English letters.\n* `word` in `search` consist of `'.'` or lowercase English letters.\n",
        "Difficulty": "Medium",
        "Video": "BTf05gs_8iU",
        "PythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}  # a : TrieNode\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.word = True\n\n    def search(self, word: str) -> bool:\n        def dfs(j, root):\n            cur = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n                if c == \".\":\n                    for child in cur.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in cur.children:\n                        return False\n                    cur = cur.children[c]\n            return cur.word\n\n        return dfs(0, self.root)\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\ndesign add and search words data\nstructure\nso this is another problem from the\nblind 75\nleak code problems list so this is the\nspreadsheet i've been using to track\nwhich\nuh videos we've uploaded for those 75\nproblems you can see that most of the\nsolutions have already been updated and\ntoday we are working on this problem a\ntree problem\nadd and search word so basically another\nday another problem from the sleep code\nblind 75 list the link\nto this sheet will be in the description\nif you do want to take a look\nso basically we're designing a data\nstructure to efficiently solve this\nproblem\nof basically adding words we're taking\nnew words\nadding them to the data structure and\nalso we're being given words and we want\nto search to see if those words\nmatch any previously added words to our\ndata structure\nso we only need to support three\nfunctions for this data structure one is\njust gonna be the constructor that's\ngonna initialize the object one is gonna\nbe adding a word and that one is pretty\nself-explanatory so we're just given a\nstring a word\nand then we're adding it to the data\nstructure now this word could only\nconsist\nof lowercase characters from lowercase a\nto lowercase z\nand the third one is going to be the one\nwhere the bulk of the algorithm is going\nto be contained so this is going to be\nthe searching\nwords so we're searching a word and the\nword can contain\nany character from lowercase a to\nlowercase c but there's\none additional character it could\ncontain a dot\ncharacter and what we're told is that\nthe dot character is actually like a\nwild card it can basically match\nany character in the string so for\nexample let's say in our word\nlist so far let's say we had just a\nstring a\nb right so this is what we have so far\nand we're trying to search\ndot b so basically would this search\nmatch any words that contain so far in\nour data structure the answer is yes\nbecause the dot would match any first\ncharacter right so this\nthat we basically match this lowercase a\nand then\nwe do have an additional b which matches\nthe second character\nin the string so a dot matches any\ncharacter that's what's going to be\ntricky for us\nto implement now the brew force way to\nsolve this problem is pretty simple\nright we would basically\nhave a list of words and then just\nfor every search we would just say okay\ndoes this search match\nany of the words in the input list now\nthat's not going to be super efficient\na more efficient solution is going to\nrequire a try data structure\naka a prefix tree so this is what we're\ngoing to be using to solve this problem\nefficiently i will say if you've never\nheard of this data structure\nor you've never implemented it before\nyou basically don't have a chance of\nsolving this problem efficiently\nbut if you have heard of this data\nstructure it's pretty intuitive\nwhy this data structure is used in this\nproblem basically\nyou know a prefix tree right so for\nexample if we were searching b\ndot dot we would want to first find all\nall words that start with the character\nb\nand then check you know are any of them\nof length\ntwo because the remaining portion of\nthis can match any string of length two\nso a try is basically a tree that has\nsome kind of\nroot node and each node can have up to\n26 children in this example because we\nhave lowercase characters from a\nto z so basically each node is going to\nrepresent a single character right and\nthen each node could have\nup to 26 additional uh children\nand basically a word in this case for\nexample you know this is\na if i had a b here and then another c\nthis is going to be a single word right\nand\nand so if we inserted the word let's say\nwe added the word\nabc into our try this\nis basically how it would look like now\none additional thing we have to say is\nfor a particular node such as c we have\nto say\nthis is the end of the word right\nbecause what we're trying to say is we\ndid not add the word\na we did not add the word a b we've only\nadded the word abc so we have to\ndesignate that this is the last\ncharacter now if we added\nanother word for example a b what we're\ngoing to do\nwe're not just going to repeat that\nwe're not just going to say okay now\nthere's going to be a lowercase a here\nthen there's going to be a lowercase b\nnotice how we already have those\ncharacters available to us\nwe're going to reuse these characters so\ninstead what we would do adding\nthis word we would say okay let's add an\na so let's start at the root add an a we\nsee there's already an a that exists\nthen we'd say okay from here let's add a\nb we see that a b\nalready exists so once we get\nto the end of the word right that was\nthe last character then we just say okay\ndesignate\nthis as an additional end of the word so\nnow we have two words\nalong this path we have one word a b we\nhave another word abc\nnotice how all words starting with an a\nare going to be here right we could have\nother words a\nmaybe a t or something right and other\nwords as well right\nbasically all words that start with a\nare going to be here that's what makes\nthis\nefficient that's why this is called a\nprefix tree because\nlet's say we wanted all words starting\nwith\nlet's say we were searching something\nlike this right we're searching\na b dot dot so we want all words\nfor example or even one word of length\nfive\nthat starts with a b then we'd go okay\nlet's find a\nthen find b right here and then we'd go\nthrough all possible children\nthat it has right in the tree we would\ndo a brute force depth first search\nbacktracking type approach\nand then we'd get a word we would try to\nfind a word like this one\nso with that being said let's run\nthrough the example you can see at the\nabove the first word that we're going to\nbe adding is bad\nso let's add a character for b\nlet's add a child for this a let's add a\nchild for it\nd so now we've inserted the word bad\nwe do want to designate this as the end\nof a word so i'll just mark it blue but\nin our code obviously we're going to do\nsomething different\nnext we're adding another word dad so\nwe have to start along a different path\nbecause these two words have a different\nprefix one starts with a b\none starts with a d so let's\nadditionally add a\nand additionally add d once again\ndesignating this as the end of a word\nwe're going to add one last word before\nwe start searching this one's going to\nbe mad\nso we don't already have an m so we do\nhave to insert that and then we have to\ninsert a\nand then d of course this is going to be\nthe end of a word so so far we have\nthree words all of them end with a d\nbut they all all three of them have\ndifferent prefixes that's why they're\nalong different paths\nnow let's get to the searching part the\ninteresting part so we're going to\nsearch for a word pad now so what we're\ngoing to do is we're going to start at\nthe beginning right\nare there any words pad in this so first\nwe're going to try\nare there any p's we're going to look is\nthere a p we don't see any right\nwe only have b d and m so we don't have\nany words starting with a p\nthat means immediately we know false pad\ndoes not exist in our input that's why\nin the output over here you can see\nfalse is what's returned next we're\nsearching another word that word is\ngoing to be\nbad so we're going to start at the root\nand see are there any b's\nwe're going to see that yes we do have a\nb over here\nthe next character in the string is a so\ndoes this b have a child\na yes it does it has an a over here the\nlast character is a d\ndoes this a have a child d yes it does\nit's over here\nnow we yes we found the characters we\nneeded but now\nlastly we have to say okay the last\ncharacter that in the\nsearching word is d is this in our try\nis this designated as the end of a word\nsince it's marked blue\nit is therefore we're going to return\ntrue for this\nuh input searching word and you can see\nthat's what's\nwritten in the output this returns true\nlet's go through the last two search\nexamples so in this example we have\ndot a d so what does that mean remember\nthe dot character means we can match\nany character so we're going to start at\nthe root and we're going to go down\nall three paths or or literally\nany of the paths and to do that we're\ngoing to have to use\ndepth first search or basically a\nbacktracking approach right\nand remember we're only looking for one\nword that matches this right so let's\nsay the first path we decide to go down\nis this one right so this is a b\nand we're allowed to use a b because the\ndot matches any character so\nthis matches so far right next we're at\nthe next character\na does this path have a child a yes it\ndoes\nso we found another match next we're\nlooking for a d\ndoes this have a child d yes it does and\nit's designated as the end of a word so\nin this case\nwe found one word that matches this and\nthat's all we need we just need one word\nso we are going to return true\nand you can see that up above now if\nthis one did not match for example if\nthis\nwasn't designated as the end of a word\nor maybe this was instead an\nx character we would say okay we didn't\nfind a match down this path\nbut it doesn't matter because remember\nthe dot matches any character so\nwe don't have to go down this path let's\ntry going down this path right and we\nwould do the same thing we'd say okay we\nhave an\na we have a d that means we found a\nmatch that means we can return\ntrue and you can see that this is not\ngoing to be\nsuper efficient right we possibly we\nwould have to go through every single\ncharacter that's in\nour try decision tree but it's still\nmore efficient than our brute force\napproach\nespecially for this next last example so\nwe're doing\none last search and in this search we\nhave we start with a b\nbut then we have two dot characters and\nthe reason this is more efficient with a\ntry\nrather than just brute forcing every\nlist because this\nat least tells us okay we're starting\nwith a b so what we're gonna do in our\ntry decision trees we're gonna say okay\nevery other word that starts with\nany other character than a b we're not\ngoing to consider them and we have a\npretty small\ntry right now but it's possible we could\nhave a really big one right\nso what this does for us is it\neliminates a lot of the possibilities\nwe say okay at least we know we're\nstarting with a b\nand yes we did find a matching b so\nwe can go down this path now we get to\nthe brute force portion\nwhere we have a dot right so basically\nin this case it's simple because\nwe only have one child but maybe we'd\nhave multiple and then we'd have to go\ndown\nall of those paths but in this case it's\nsimple right let's just check do we have\nany\ncharacters that go below it yes any\ncharacter will match this first dot now\nwe're looking for\nanother second dot do we have any\ncharacters that match it yes\nwe have a d and it's the end of a word\nso yes in this case\nwe also found a match so we can return\ntrue just like we have up above\nso once you can kind of understand this\nvisual example\nit's not super hard now it's time to\nactually implement the code and i'll\nadmit that it's actually a little tricky\nbut i'll go i'll try to guide you\nthrough it\nso one thing i like to do for try\nproblems is just define\na try node because it's going to have a\ncouple\nuh variables so in the constructor we're\nbasically going to initialize\ntwo fields so for this tri node we are\ngoing to have\na list of children now i'm going to use\na hashmap for that\nso basically what i'm going to say is\nfor each character we're going to say\nsomething like you know a\nis mapped to a tri node\nand we could possibly do that for every\nlowercase character from a to z\nand for every character we also need to\ndesignate if it's the end of a word so\ni'm just going to use a boolean for that\ncall it word and initially we'll set it\nto\nfalse and so basically the only thing we\nneed to do for the constructor for the\nconstructor of the word dictionary is\njust define a root so\nlet's call it root and it'll just be a\ntry note so initially you can see that\nwe don't have any characters\ninserted right we just have an initial\nempty try node\nit doesn't have any children so no\ncharacters are inserted\nnext we are going to do the add word\nportion this portion isn't too difficult\nso what we're gonna do\nis we'll set current equal to what our\nroot is so self.root is\nwhere we're gonna start and what we're\ngonna do is basically go through every\nsingle character\nin the word and what we're gonna do is\nwe're gonna check\nif this character is not already\ninserted because it's possible this\ncharacter\ncould already be inserted in the try so\nwe're going to check if\nif c is not in current\ndot children because of the current\nnodes children if c is not\nin there then we we need to obviously\ninsert it right so what we would do is\nsay current.children\nof c is going to be a new trinode\nwhere we inserted a trinode\ncorresponding to the character c\nand then of course what we're going to\ndo is we're going to update our current\npointer\nto this uh new try node\nif it didn't already exist that means we\njust created it if it did already exist\nthen we just\nshifted over to it right what we're\nultimately trying to do is insert\nevery character from this word into our\ntry and once\nthat's been completed what we're going\nto do at the end\nis say okay current dot word is now\ngoing to be set to true\nso we have created the characters and\ndesignated this as\na word okay now for the actual meat and\npotatoes of this problem\nand this part is actually going to be\nrecursive and let me show you\nwhy before we actually start doing the\nrecursive portion\nso this is going to start similar to\nwhat we had before right so current is\ngoing to be initially set to\nlet's say self.root right and then what\nwe would want to do\nis go through every single character in\nthe word in this case i'm actually going\nto\nuse the index of the word and you'll see\nwhy in a moment so\nfor i in range length of the word\nand then we're going to get the\ncharacter at position i so word\nof i and so remember this character\ncould be\nany character from a to z in which case\nthe problem would be straightforward\nright we would just search our try and\nsee does this character already exist\nand then we'd continue if it doesn't\nalready exist then we would return false\nbut we know this character could\nactually be a dot character that's\nwhat's going to make this tricky so if c\nequals a dot character the else\ncondition is if it is a regular\ncharacter\nnow let's start with the else case\nbecause it's a little more simple so if\nc\nis just a regular character what are we\ngonna do we're gonna check\nif c is not in current.children that\nmeans this character does not exist we\nneeded this character to exist we're\nsearching for this word but this\ncharacter does not exist\nso what do we do then well simply we can\njust return false that means we know for\nsure this word does not exist\nif it does exist then obviously we're\ngoing to shift our current pointer\nto that node so we're going to go to\ncurrent.children\nat character c and then we would just\ncontinue our algorithm right\nbut this case is going to be a little\nbit more tricky because remember if the\ncharacter is a dot that means\npotentially we're going down\n26 different paths because this dot\ncould match\nany of the 26 characters and we can't\nreally do that\niteratively very easily right we are\ngonna use backtracking or recursion\nto help us do that so for example let's\nsay we had a string like\ndot a b what we would want to do then is\nsay okay\ndot it could match any of the possible\ncharacters so what we would say then is\nwe would go through for every\nchild in current dot children\ndot values because remember for\ncurrent.children that's a hashmap\nand then we want only the values because\nthose are going to be the actual\nchildren\nso because we know that dot could match\nany character so for this\ndot we would basically match every\nsingle character and then we'd say okay\nfor each of these\nwe want to do the recursion on it so we\nwant to do\nthe depth first search on this and when\nwe're actually doing that depth for\nsearch\nit could just be an iterative matching\nso what we're trying to what i'm trying\nto get at is that this entire thing that\nwe just wrote\nis the recursive function this is the\ndepth first search\nright we have the iterative portion here\nwhere we don't have a dot and we have\nthe recursive portion over here\nwhere we do have a dot so let's wrap\nthis entire thing\ninside of a depth first search function\ndepth first search dfs\nand so let's just tab it over so now\nlet's think about it\nwhen we're doing our depth first search\nwhat are we going to pass\nin well we want to know what's the\nremaining portion of the word that we\nare trying to match right so we would\nwant to pass in the\nindex so let's call that j we're passing\nin the starting index\nj right and the other thing we're\npassing is what's the current\nroute that or the current node in our\ntry that we're at so\nin this case if so depending on which\none of these we're iterating through\nwe're gonna pass in that child node\nright so\nso that's what the the node that we're\ngoing to be passing in whatever child\nthat is\nso that's how we're going to call dfs so\nlet's define that up above so j\nis going to be uh the index parameter\nand let's call root what the\nnode that we're passing in is so okay so\ncurrent is\ninstead of being called self.root it's\nactually going to be initialized to the\nroot that we end up passing in\nand okay so here i passed in j but we\nwould\nwhat we would actually pass in is going\nto be i actually not just i\ni plus 1 because we're going down a\nchild\nso we're going to pass in i plus 1\nas the index of the character that we're\nlooking for\nright because because what we're saying\nis we're skipping the dot so we're going\nto have to increment i plus\none and this function is going to return\na boolean so if this function\nends up returning true that means we\nfound one path that matches and remember\nif we find a path that matches we return\ntrue\nimmediately we're done we don't have to\ndo anything else if we don't find a path\nwe're going to keep going down all\npossible paths\nuntil we do if we never find a true if\nwe never find a match then we're going\nto return\nfalse oh and one more thing so initially\nup above we said\ni is going to go through range of the\nlength of the word but we know we could\nbe starting at a different position here\nwe're always going to start at zero we\ndon't want to do that we always want to\nstart at j whatever it happens to be\nso that is the main recursive portion\nand the last thing is let's say we were\ngiven a word abc and let's say we found\na match right we didn't have any dots in\nhere what would that do\nwell we'd go through the for loop we'd\nalways execute the else condition\nand we would always find the current\nnode and then the entire loop would be\nfinished then what would we want to\nreturn out here\nwell we would want to return whatever\ncurrent happens to be\nso if current dot word is true\nthen we would return true if\ncurrent.word was false\nthen we would return false so we can\njust leave this\nas it is so that's the main portion of\nthis algorithm the last thing that we\nwant to do\nis actually call this step for search\nfunction right so what are the\nparameters that we're going to give it\nwell we're always going to start at\nindex 0 because we're going to start at\nthe beginning of the word so we can pass\nin 0 for j\nand we're always going to start at the\nroot node of our try so we can pass in\nself.root\nas the root node and then we would just\nwant to return the result that this dfs\nfunction returns\nso as you can see this function did work\nand it does work pretty efficiently\nso if you didn't already know what a try\nwas i hope that you learned that today\nso this\nis the entire code and if you did\nalready know what a try was i hope that\nyou learned a new application of it so i\nhope this was helpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Word Search II",
        "NcLink": "search-for-word-ii/",
        "Pattern": "Tries",
        "Description": "Given a 2-D grid of characters `board` and a list of strings `words`, return all words that are present in the grid.\n\nFor a word to be present it must be possible to form the word with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/06435c8e-bac3-49f5-5df7-77fd5dd42800/public)\n\n```java\nInput:\nboard = [\n  [\"a\",\"b\",\"c\",\"d\"],\n  [\"s\",\"a\",\"a\",\"t\"],\n  [\"a\",\"c\",\"k\",\"e\"],\n  [\"a\",\"c\",\"d\",\"n\"]\n],\nwords = [\"bat\",\"cat\",\"back\",\"backend\",\"stack\"]\n\nOutput: [\"cat\",\"back\",\"backend\"]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6f244a10-78bf-4a30-0a5f-b8f3e03ce000/public)\n\n```java\nInput:\nboard = [\n  [\"x\",\"o\"],\n  [\"x\",\"o\"]\n],\nwords = [\"xoxo\"]\n\nOutput: []\n```\n\n**Constraints:**\n* `1 <= board.length, board[i].length <= 10`\n* `board[i]` consists only of lowercase English letter.\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 10`\n* `words[i]` consists only of lowercase English letters.\n* All strings within `words` are distinct.\n",
        "Difficulty": "Hard",
        "Video": "asbcE9mZz_U",
        "PythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n        self.refs = 0\n\n    def addWord(self, word):\n        cur = self\n        cur.refs += 1\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n            cur.refs += 1\n        cur.isWord = True\n\n    def removeWord(self, word):\n        cur = self\n        cur.refs -= 1\n        for c in word:\n            if c in cur.children:\n                cur = cur.children[c]\n                cur.refs -= 1\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n\n        ROWS, COLS = len(board), len(board[0])\n        res, visit = set(), set()\n\n        def dfs(r, c, node, word):\n            if (\n                r not in range(ROWS) \n                or c not in range(COLS)\n                or board[r][c] not in node.children\n                or node.children[board[r][c]].refs < 1\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            node = node.children[board[r][c]]\n            word += board[r][c]\n            if node.isWord:\n                node.isWord = False\n                res.add(word)\n                root.removeWord(word)\n\n            dfs(r + 1, c, node, word)\n            dfs(r - 1, c, node, word)\n            dfs(r, c + 1, node, word)\n            dfs(r, c - 1, node, word)\n            visit.remove((r, c))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, root, \"\")\n\n        return list(res)\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nword search two and once again like\nusual this is a problem from the blind\n75 link code list\na list that we've been tracking on this\nspreadsheet and the link will be in the\ndescription to this\nand we are very close actually to being\ndone with all the major problems on this\nlist\nthat i wanted to do and probably at some\npoint i will finish up some of these\neasy ones like contains duplicates i\nthink that's a pretty trivial problem\ndon't know how many people are waiting\nfor a solution on that one but i\nprobably will do it eventually\njust for the sake of completeness so\nthis is word search 2 and word search 1\nactually we already solved on this\nchannel and that is leak code 79 so i do\nrecommend understanding that problem\nbefore you try to do this one because\nthis is definitely an extension of that\none\nso we are given an m by n board exactly\nthe same as we were in\nin word search one and we are given a\nlist of words this time\npreviously we were just given a single\nword but in this case we're given a\nlist of words and we want to know from\nthat list of words\nwhich of those words exist in this board\nand whichever ones do exist we want to\nreturn those words\nso previously we only wanted to know if\none word\nexisted in here or not so we returned\ntrue or false\nbut in this case we want to know how\nmany or exactly which of these words do\nexist\nso if we just reuse our solution from\nthe first word search\nwhat we're gonna do is we're gonna go to\nevery single position\nin this grid and we're gonna start a\ndepth first search recursively on here\nso it's just\nbacktracking right we're gonna be\nchecking brute force\nwhat's every word we could come up with\nright so starting at\no could we come up with a word in our\nlist of words right so we just go in\nevery\nall four directions basically right so\nif we go here we'll get oe\nif we go this way we'll get oa right\netcetera etcetera we could\nyou know possibly make a word like this\no a a n\nor we could make a word like this o a t\nh\nand this happens to be a word in our\nlist of words\nso we would return we would say okay o a\nt h this is a word so this is going to\nbe added to our solution set\nso it's going to go in the output so a\nvery brute force approach would be so\nfor every single word we're gonna run a\ndepth first search\nstarting at every single position and\ncheck okay could we make the word\noath starting from here could we make\nthe word oath\nstarting from here etc etc until we get\nyou know all the way\nto the bottom of the grid and we have\nrun a depth first search on every single\nposition now that's not going to be\nsuper efficient right\nand then we're going to have to do the\nexact same thing for the next word p\nright because maybe this word could\nexist so we'd have to brute force check\nevery single position etc etc etc\nand one way to analyze the time\ncomplexity of that would be something\nlike\nworst case four and four because that's\nthe number of directions\nyou know from a any position we could go\nwe could go in four directions now we\ncan't revisit the same\nposition twice of course so basically\nthe length of our depth for search is\ngoing to be the dimensions of the board\nlet's call that m by\nn right so that's how much one dfs would\nbe and we're going to be doing a dfs\nstarting at every single position so\nit's going to be something like\nm by n to the power or and by n\nmultiplied\nby 4 to the power of m n and we're going\nto be doing this for every single word\nso basically let's say w is the number\nof words so this is going to be super\ninefficient now there is a way basically\nwhere we can make this more efficient\nwhere we can get rid of this constant w\nbasically\nthe solution is going to be we're only\ngoing to have to run dfs\nstarting from each position a single\ntime because\nas we're checking you know what are all\nthe words we can create\nstarting at this position right starting\nat this character a\nwhat are all the words that we could\ncreate now the main idea that we're\ngoing to be doing instead of\njust checking a single word at a time\nlike running dfs on here just to check\nif this word exists\nlet's check simultaneously let's check\nall the words in our set\nwhich of them can be created starting at\nthis position so that's the idea we're\ngoing to be using\nand we're going to be using a data\nstructure which is going to be very\nuseful for it because what we're going\nto notice is we can\ncheck all words starting at here based\non the prefix right so\nclearly here we only want words starting\nwith the letter\na right so the prefix is going to be a\nand\nwhat kind of data structure can help us\norganize these words\nbased on their prefix guess what\neither you have heard of this data\nstructure before or you haven't if you\nhaven't heard of this data structure\nthen you probably don't have a chance of\nsolving this problem in the optimal way\nso i would learn what this data\nstructure is first but if you do already\nknow it\nthe solution is actually not too bad to\nimplement so this\nthe data structure we're going to be\nusing is a try aka\na prefix tree which is going to help us\norganize these words based on their\nprefixes\nso let's say we had a pretty small grid\nand we had a pretty small list of words\nthe words are\napp ape and ace so we want to know which\nof these words can be found\ninside of this grid now let's use the\nidea of prefixes that i mentioned so\nlet's say we're going to start our dfs\nhere right so this is the first position\nwe're going to be at and we can't\nrevisit\nthis position twice makes sense so far\nso so far we have a single character\nright\nwe have found the character a right so\nwe can basically we want to know all the\nwords that we could create starting at\nthis position dfs from here and of\ncourse then we're going to repeat that\nby doing a dfs from here\nhere and here but we're so far we're\nonly starting here\nand of our entire list of words we want\nto know which one of them\nhave a prefix of a because\nif you know if we had a word such as\nbat then we'd say okay bat does not\nstart with an a so basically we don't\neven have to consider that right we\ndon't have to run a dfs on here\nsearching for the word bat it doesn't\neven exist in this position\nright the letter b does not start here\nso what we're gonna have to do is\nbasically go through every single word\nthis word starts with an a\nthis word starts with an a this word\nstarts with an a so potentially\nso far all of the words could be\nfound starting at this position right so\nwe haven't eliminated any of these just\nyet\nso now let's say we go down first right\nof course if we go\nup that's out of bounds so you know\nwe're just going to return there because\nwe're going to see okay\nthe it ended with the the word a a does\nnot exist in our list of words so of\ncourse we're not gonna do that of course\nif we went left\nthat also would not work but we can go\ndown so let's\nstart going down first so we add a p to\nour word so far so so far we have ap so\nthen again we're going to just go\nthrough every single word check okay\ndoes this start with ap\nyes does this start with ap yes does\nthis start with ap\nno so so we don't want to consider this\nword anymore right but as you can see\nthis is going to get kind of complicated\nright\nwe're having to go through the list of\nwords every single time that's not\nreally helping us out in terms of\nefficiency\na more intuitive way would be if we\ncould check the prefixes of these words\nmore easily and of course we know a data\nstructure prefix tree\nis exactly what that is for so basically\nwhat a prefix tree is going to be it's\ngoing to be\nyou know every single character is going\nto be a node so one node is going to be\na\nand we're just going to take these words\nand add them to our prefix tree so\nwe want all words starting with the\ncharacter a to go\nhere right so let's add childs of these\nso what characters come after a\nof course we have a p and then we have a\nc so\nall words that start with a p are going\nto go down here\nand all words that start with a c are\ngonna go down here\nand how many different words do we have\nthat start with ap we have\nuh app and we have ape\nand all words that start with ac is just\none word\nace so do you see how this is this tree\nis organizing these words based on the\nprefixes\nso now we started at a right we want all\nwords that start at a so so this is\nwhere we're going to be at so far and we\nsee that\nof course there are three words that\nstart with\na and by the way let's say ap\nthis is not a word even though it is a\npath in our tribe because basically\nlet's just say we call\nthese three leaf nodes happen to be the\nend of words it's possible that we could\nhave a word ap\nbut in this case we don't up here right\nwe don't have ap\nso this this node is not going to be\nmarked as the end of a word\nso only these three are marked as end of\nwords but so now when we go down in this\ndirection we go to a p\nall we're going to do from this position\nis check does this have a child p\nif it does we're going to say okay let's\ngo there so now this is going to be all\nwords\nthat potentially start with ap so this\nprefix\nnow if we did not have a p right then we\nwould say okay\nwe went down here ap we don't have any\nwords\nthat start with ap so in that case we\nwould just return that's our base case\nright if we didn't have any words with a\nprefix of ap\nwhich we could check pretty easily with\nthis prefix tree\nwe wouldn't want to continue going down\nthis direction\nso you can see that we're making things\na lot more efficient for us using this\ntry\nso now from p we can't go down that's\nout of bounds we can't go left\nwe can't go up because we already\nvisited that position so we can go\nright which is going to add the\ncharacter e so from here from this p we\nwant to check do we have a child\ne well this is not the e this is though\nright\nokay so so far we we did find a path\nin our prefix tree now let's check is\nthis the end of a word since it's marked\npurple that's what i'm just indicating\nso yes this is the end of a word\ntherefore we found a single word down\nthis path that we were maintaining\ncalled a p e that yes you can see it's\nfound in our list of words\nso therefore we found one word that we\ncan make from this grid\nthat you know can be found basically so\nwe're going to add\nape to our results now from here\nwe would want to continue now we can't\ngo right we can't go down we can't go\nleft because we already visited there so\nwe would go\nup so we'd say okay add a c right so\nfrom here\na p e a p e and then we add a c\ndoes this word exist well this does not\nhave a child of c\nso of course we can't do that and that\nmakes sense because this word apec\ndoes not exist in our input list of\nwords so therefore at this point we\nwould return because we don't even have\nany words that start with this prefix\nso so far we did find one word ape now\nwhen we started here the first\ndirection we went was down but it's\npossible we could also go right so let's\ndo that so\nnow we have ac so we started here we\ncheck does this have a child c yes it\ndoes it's over here right so now we\ncan't go right we can't go up we can't\ngo back left so\nnow we go down a c e do we have a e\nchild\nunder this c yes we do and this is the\nend of a word right it exists in our\nlist of input words so now we found\nanother word\nace and then we would continue from our\ngrid in the only\nposition we can go to which is the p\nright so we'd add a p we'd say okay does\nthis e have a child\np it does not so therefore we can't\ncontinue so that's going to be our base\ncase\nbut it's okay because we at least found\none word so we can go ahead and add that\nto\nour list of words ape and ace so now is\ngoing to be the easy part so we we\nstarted our dfs from this position now\nlet's start the dfs\nfrom c so we look in our prefix tree we\ndo have\na prefix starting at a do we have a\nprefix starting at c\nwe don't so immediately we can say okay\nwe know for sure\nnone of our words start with the\ncharacter c we didn't\nwe didn't just have to we didn't have to\nrun through the list of words to do that\nwe just did that\nin an o of one operation we just checked\ndo any\nis our root node does our root node have\na child\nc it does not so therefore none of the\nwords\nstart with a c so we don't even have to\ncontinue the dfs from this position\nand you can tell that's the same is\ngoing to happen for the character e\nnone of the words start with e we don't\nhave an e root node in our prefix tree\nsimilarly p we don't have any root node\np in other words start with p\nso so we're not going to find any\nadditional words in\nthis grid we only found two words ape\nand ace\nwe found ape and ace we did not find app\nso we're going to return these two words\nas a\nlist so once you kind of understand that\nthis problem can be solved by the prefix\ntree\nand you know how to implement a prefix\ntree and you know how to implement\nbacktracking dfs which you can learn\nfrom word\nor word search one this problem is not\ntoo difficult\nso now let's write the code so the first\nthing i want to do is actually implement\na try node\nclass or a try class basically and so\nin the constructor of this if you have\nwritten a try\nbefore you'll know that there are mainly\ntwo things that we worry about for a try\nnode and that\nis its list of children so that's going\nto be one member\nvariable for this class a list of\nchildren now you could use a list in\nthis case\nall characters i think are going to be\nfrom lower case a to z but a more\ngeneric way to handle it is just using a\nhash map\nso the key is going to be the character\nand the value in this hash map is going\nto be the child\nnode the child tri node and also for\neach\nnode you want to be able to mark if it\nis the end of a word or not so\none member variable for is word it's\ngoing to be a boolean initially we can\nset it to false\nnow to our try we are going to want to\nadd words to it so let's define one\nfunction add word\nand this is really going to be the only\nfunction so we'll be passed in a string\na word and we just want to add that word\nto our try\nso let's get our current pointer to be\nat the\nroot node which is just the self node\nand then we're gonna go character by\ncharacter in this word and just start\nadding them\nnow it's possible that the the character\nmight not exist in our tri node if it\ndoes not exist so if c\nnot in current dot children if this\ncharacter does not exist then we're\ngoing to obviously have to insert it\nso current.children at character c we\nwant to create a try node for this\nparticular character\nif it already exists then we're going to\nskip this if statement and simply we're\njust going to\nmove our current pointer to that\nposition so current.children\nat character c so that's the try node\nthat we want and at the end all we have\nto do is return the current pointer\nor actually not return the current\npointer at the end we have to mark that\nthis is now going to be the end of the\nword so the last character that we ended\nat\ncurrent is word we want to set that to\ntrue\nwhen we insert a word now the reason\nwe're not going to define a search\nfunction like searching a word in this\ntrinode is because we're going to be\ndoing that\nsimultaneously as we do our depth first\nsearch on the\nboard so now let's start getting into\nthe dfs\nwe're actually the first thing we're\ngoing to want to do is create a root\ntri-node\nso so let's create a trinode with the\nclass that we just defined and\nfor every word that we're given in the\ninput so for w in the list of words we\njust want to go ahead and take\neach word and add it to our try so root\ndot add\nword w and now we can start going ahead\nand doing the depth first search so\nfirst i like to do is get the dimensions\nof the board so rows and columns\nwe can get the length of the board we\nknow for sure that the board is going to\nbe non-empty and\nthe list of words is going to be\nnon-empty as well they do tell us that\nin the problem description\nnow i'm going to create two sets result\nand visit so result\nis going to be the set of words it's\npossible we could visit\nthe same word twice inside of our board\nso we don't want to have to\nreturn duplicates and the visit set is\npretty self-explanatory when we run a\ndfs\non the board we don't want to get stuck\nin like an infinite loop or mainly\nwe don't want to repeat the same\ncharacter twice we're not allowed to do\nthat\nso once we have those defined we are\ngoing to define a dfs\nrecursive function we're going to be\ngoing through every position so we want\nto pass in the coordinates row column as\nthe coordinates\nwe want to pass in the current node that\nwe're at\nin our try you know depending on what\ncharacters we've already visited before\nand we also want to pass in what is the\nword so far so for example you know we\nvisited two characters ac\nwe want that to be stored in this word\nvariable and of course if the node that\nwe're visiting happens to be the end of\na word what we're going to do is just\ntake that word and add it to our result\nwhich is out here we don't have to pass\nit into every recursive call\nso for this dfs let's go ahead and\ndefine the base cases so of course if we\ngo out of bounds\nrow is less than 0 or column is less\nthan zero\nor row is too big meaning it's the\nnumber of rows\nor a column is too big meaning it's the\nnumber of columns or\nmaybe this position row column is\nalready been visited so if it's already\nin visit then we're going to return\nor maybe the character that we're at for\nexample\nboard at position row column maybe\nthis character is not even in\nour try maybe it's in bounds right but\nit's\nnot even in our try at the current\nposition that we're at\nin our try node right meaning this\ncharacter\nis not in node.children\nright if it's not in the children of the\ncurrent node that we're visiting that\nmeans this character doesn't exist in\nour tribe therefore\nit's not one of the words that we were\ngiven in our input list of words so\nif any of these are true then we're\ngoing to return that's our base case if\nthat's not true first thing we want to\ndo is make sure we mark\nthis position as visited and after\nafter we're done the last thing we do\nbefore we return is we're going to have\nto\nmark this as unvisited basically since\nthis\nis backtracking uh we we can't visit the\nsame one twice but once we're no longer\ndone visiting it after we return\nthen we can go ahead and you know remove\nthis position from being visited\nso since we got to a new character we\nwant to update some variables so we want\nto update\nnode so node is going to be set to\nnode.children\nof the current character that we just\nvisited which is board\nat position rc so we're updating the\nnode because we know that that node does\nexist\nand we're updating the word right so\nwe're taking the current word\nadding to it the new character that we\njust reached\nboard at rc and before we do the\nrecursive case again before we look at\nthe neighboring positions we do want to\ncheck is this the end of a word so we\ncan check that based on our node so if\nnode is word\nis true then of course we can take our\nresult\nand add to it the word that we just\nbuilt right the string\nitself not the node we're not going to\nadd the node to result we're going to\nhave the string\nword so this is just basically you know\nchecking if it actually is a word\nin our list of words and we're you know\ndoing some uh bookkeeping here\nand once that is done we can go ahead\nand actually do our recursive case\nyou could write it with a loop but i\nlike to be lazy and i think it's pretty\nokay to just copy and paste\ndfs four times so we're gonna pass in\nthe coordinates and we're gonna pass in\nthe node and we're going to pass in the\nword that so far we have built\nso let's just copy and paste this four\ntimes going in each of the four\ndirections\nup down left right so all that we have\ndefined our dfs function about 15 lines\nof code so remember what we actually\nwant to do with that dfs is go through\nevery single\nposition every single starting position\nin the grid so i'm going to do\na quick 2d loop a quick nested loop on\nthe entire\ngrid and call dfs from\neach starting position in the grid now\nfor node what are we going to pass in\nwe're going to pass in our root node\nthat we defined up above and for the\nword\ninitially it's going to be empty right\nso that's what we're going to pass in\nfor the word\nonce that is all said and done we want\nto return our result but don't forget\nour result\nis a set to eliminate duplicates we can\ncast it into a\nlist pretty easily in python so that's\nwhat i'm going to do\nas you can see this is the entire code\nso this\nis the entire code and all of its glory\nso this\nyou can see that this solution does work\nonce or twice it actually did give me\ntime limit expire i think there is a\nslight\noptimization that you can make to this\nproblem i don't think it actually\nimproves the overall time complexity\nbut once you find a word in the try\nbasically what you can do is actually\nremove\nthat if it's a leaf node you can remove\nthat\nfrom the try because you don't want to\nhave to you don't have to search for the\nsame word twice that's a slight\noptimization that you can make but i\nbut i think this solution is mainly good\nenough and it's too big to even\nfit on the screen that's how you know\nthis is a hard problem no matter what\nyou do it's going to be a lot of code\nthat you have to write\nbut i hope that this was helpful if it\nwas please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Number of Islands",
        "NcLink": "count-number-of-islands/",
        "Pattern": "Graphs",
        "Description": "Given a 2D grid `grid` where `'1'` represents land and `'0'` represents water, count and return the number of islands.\n\nAn **island** is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. You may assume water is surrounding the grid (i.e., all the edges are water).   \n\n**Example 1:**\n\n```java\nInput: grid = [\n    [\"0\",\"1\",\"1\",\"1\",\"0\"],\n    [\"0\",\"1\",\"0\",\"1\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"0\",\"0\"]\n  ]\nOutput: 1\n```\n\n**Example 2:**\n\n```java\nInput: grid = [\n    [\"1\",\"1\",\"0\",\"0\",\"1\"],\n    [\"1\",\"1\",\"0\",\"0\",\"1\"],\n    [\"0\",\"0\",\"1\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"1\",\"1\"]\n  ]\nOutput: 4\n```\n\n\n**Constraints:**\n* `1 <= grid.length, grid[i].length <= 100`\n* `grid[i][j]` is `'0'` or `'1'`.\n",
        "Difficulty": "Medium",
        "Video": "pV2kpPD66nE",
        "PythonSolution": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n\n        islands = 0\n        visit = set()\n        rows, cols = len(grid), len(grid[0])\n\n        def dfs(r, c):\n            if (\n                r not in range(rows)\n                or c not in range(cols)\n                or grid[r][c] == \"0\"\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n            for dr, dc in directions:\n                dfs(r + dr, c + dc)\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == \"1\" and (r, c) not in visit:\n                    islands += 1\n                    dfs(r, c)\n        return islands\n",
        "Transcript": "let's solve Li code 200 number of\nislands this is actually one of my\nfavorite problems because I feel like a\nlot of graph problems build upon this\none and you can learn a lot from just\nthis one problem it's also a really\npopular interview question a lot of big\ntech companies including Google and uber\nask it so it's a good question a common\nquestion to understand so we're given a\n2d grid where ones represent land zeros\nrepresent water we want to count the\ntotal number of islands that exist right\nand in this case an island is defined as\none's being connected and jacent ly\nhorizontally or vertically not\ndiagonally right so they have to be\nconnected horizontally or vertically and\nthe entire grid is surrounded by water\nso in this example case we can see that\nthere's only one island right this\nportion of one's and they're all\nconnected horizontally and vertically\nand there's nothing else the rest of the\ngrid is just made up of water so we\ndon't have to look at it\nso if you don't know how to solve the\nproblem the first thing you should do is\nnot try to write any code just look at\nthe picture and try to get as much\ninformation as you can so think about it\nhow would a kid solve this problem if\nyou gave them the picture and told them\nto count the number of islands well the\nfirst thing you would do is notice okay\nlet's start at the top left hey there's\na one here right okay that means it's an\nisland how many other ones are connected\nto this one horizontally and vertically\njust by looking at it right you kind of\ndraw the outline there's all these ones\nthat are connected to each other so then\nthat's one island we can say that the\nnumber of islands we have so far is one\nright and if you look at the other ones\nright maybe we have to count those as\nwell like this one but you notice it's\nalready a part of the island that we\ndrew right this outline it's already\nthere we're not going to count it twice\nthese ones are part of the same island\nso the count of islands remains one and\nafter looking at each of these ones we'd\nconclude the same thing right they're\nall a part of the same island next we\ncould look at some of these zeros right\nokay we check is this an island nope its\nwater\nso just cross it out right don't need to\nconsider it anymore\nis this an island nope it's water this\nis water\nthis is water this is water this is\nwater this is water this is water\nit's getting pretty repetitive but this\nis water stillwater this is still water\nbut now we get to a one that means we\nfound another island and it's not a part\nof this island that we already counted\nright it's a part of a new island so\nwe're gonna update the number of islands\ncross one out now we're gonna put two\nbut we have to remember that we have to\ncount all the ones that are connected to\nthis one and there's only one right\nneighbor that it has right and so the\ntotal number of islands is now two when\nwe get to this one again we see it's\nalready a part of the island that we\nalready counted right so we don't have\nto count it again so we visited every\nsingle cell and we concluded that the\ntotal number of islands is two so now we\nkind of have an idea of how the\nalgorithm works but with a difficult\npart is that you might not know unless\nyou know a little about a little bit\nabout graph algorithms is how do we\nactually determine this entire area\nright how do we get all of the adjacent\nneighbors of an island how do we mark\nthem as visited right let's take a look\nat how we can do that so when we first\ngot to this one we realized we got to an\nisland but then we wanted to mark the\ncontiguous land of this island as\nvisited right so the first thing we\ncould do is say okay well the the\nadjacent neighbors of this one also have\nto be marked visited so its neighbors\nare this one below it and this one to\nthe right of it okay but we're not done\nyet right there could be even more ones\nconnected to these two that we just\nvisited and then we can say that for\nthis one below the the first one its\nneighbors are this one and this one but\nwhat about this one but above it well\nit's already visited so we don't want to\nmark it twice so we're not going to do\nthat now let's get the neighbors of this\none that was to the right of the\noriginal one so it has one neighbor to\nthe right of it it also has a neighbor\nbelow it but hey we already marked that\nvisited so we don't need to do that\nagain and then let's look at this one\nand see it's neighbors well it only has\none\nand then we notice that this one doesn't\nhave any neighbors that aren't already\nvisited and this one doesn't have any\nneighbors that aren't already visited\neither so you might already know what\nthis algorithm is but it's basically a\nbet a breadth-first search we're just\ndoing a graph traversal algorithm\nstarting at the original point over here\nand marking each layer of ones so in the\nfirst layer we got this the second layer\nwe got this the third layer we got this\nand the fourth layer we had just a\nsingle value so this is really easy to\nvisualize and if you already know this\nalgorithm you can code it up pretty\nquickly so knowing what we just learned\nlet's code it up so the first thing just\ndo some input validation if we had an\nempty grid we don't want to have to run\nour algorithm and we can simply just\nreturn zero\nthere aren't any islands in that case\nthe next thing I like to do is just get\nthe dimensions of the grid so the number\nof rows and the number of columns we can\nget the number of rows by getting doing\nthis and the number of columns by doing\nthis we also want to be able to mark\npositions or cells visited when we're\nmarking island masses so I'm going to\nuse a set to do that we could also use a\n2d grid if we wanted to but I think sets\nare a little easier we also want to\ncount the number of islands we can\ninitialize that as zero so we want to\nvisit every single position in the grid\nso let's iterate through each row and\ncolumn so R is going to go through every\nsingle row C is going to go through\nevery single column if we visit a zero\nwe don't have to do anything right but\nif we visit a one then we have to do\nsomething then we have to traverse it\nand mark it visited and don't forget\nthat this 2d grid is actually made up of\nstrings not numbers that always trips me\nup I think it's kind of annoying that\nLICO does that but it does so now we\nhave to run our traversal\nI'm gonna run breadth-first search\nbecause I kind of like it so run\nbreadth-first search on this cell\ncolumn we also have to increment the\nnumber of islands but remember we're\nonly going to be incrementing the number\nof islands if we get to a one that we\nhaven't already visited so we're going\nto make sure that if we execute this we\nwe've gotten to a position we haven't\nvisited and then ultimately we're just\ngoing to return the number of islands\nbut we didn't actually write our\nbreadth-first search let's do that right\nnow so breadth-first search is not a\nrecursive algorithm it's iterative so we\nneed a data structure to use for memory\nso a queue is normally used for\nbreadth-first search so we want to mark\nthis position visit it as well so to\nvisit we're gonna add this cell that\nwe're about to use our traversal on our\nc we're also going to add it to our\nqueue and so while our queue is not\nempty that means we're gonna be\nexpanding our island so we're gonna pop\nfrom the queue and we want to check the\nadjacent positions of this position that\nwe just popped so the way I like to do\nthat is use a loop so we know that\nthere's four directions that we can go\nin the direction to the right which is\none zero the direction to the left which\nis negative one zero the direction above\nnow for each of these directions we're\ngonna check something first we want to\ncheck that this position is in bounds\nthe way in Python I like to check that\nis just if R Plus D R is in range of\nrows and check that the column plus\ndirection that we're moving in is also\nin range of columns and that this\nposition is a land position so this is\nequal to 1 meaning its land and lastly\nthat this position hasn't already been\nvisited so if this is true then we can\nadd that to our queue because that means\nwe have to run breadth-first search on\nthis cell as well we also have to mark\nit visited so we don't visit it twice\nI noticed that we're doing this\ncomputation a lot by adding row plus\ndifferent a direction of row so I'm\nso that's a little bit cleaner and\nthat's pretty much the entire breadth\nfirst search function it's gonna be\nrunning until the queue is empty which\nmeans that there's no more land\npositions to visit I had a sloppy bug I\nforgot to add this row column position\nas a tuple which we want to do as a pair\nnot two elements separately I also use\nthe wrong function name for visit we\nhave to use visit add not append\nbecause it's a set and on a list and\nthere is their breadth-first search\nsolution to this problem sorry about a\nfew of the bugs that i had oh that they\ndidn't trip you up too much and also the\nneat thing about writing it this way is\nif your interview asked you at the end\nokay could you do a depth-first search\nsolution to this you can actually do it\nreally easily this pop left that we\nwrote if you just change it to a regular\npop meaning a pop right it'll pop the\nmost recent element that we added\ninstead of the first element that we\nadded which means it'll basic b it'll\nbasically be a depth-first search but\nit's non recursive it's iterative if you\nenjoyed and if this was helpful please\nleave a like and subscribe and thank you\n"
    },
    {
        "Name": "Max Area of Island",
        "NcLink": "max-area-of-island/",
        "Pattern": "Graphs",
        "Description": "You are given a matrix `grid` where `grid[i]` is either a `0` (representing water) or `1` (representing land).\n    \nAn island is defined as a group of `1`'s connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is defined as the number of cells within the island.\n\nReturn the maximum **area** of an island in `grid`. If no island exists, return `0`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/8eeb491c-c8ff-4ed6-78ed-ce4cf87d7200/public)\n\n```java\nInput: grid = [\n  [0,1,1,0,1],\n  [1,0,1,0,1],\n  [0,1,1,0,1],\n  [0,1,0,0,1]\n]\n\nOutput: 6\n```\nExplanation: `1`'s cannot be connected diagonally, so the maximum area of the island is `6`.\n\n**Constraints:**\n* `1 <= grid.length, grid[i].length <= 50`\n",
        "Difficulty": "Medium",
        "Video": "iJGr1OtmH0c",
        "PythonSolution": "class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n\n        def dfs(r, c):\n            if (\n                r < 0\n                or r == ROWS\n                or c < 0\n                or c == COLS\n                or grid[r][c] == 0\n                or (r, c) in visit\n            ):\n                return 0\n            visit.add((r, c))\n            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n\n        area = 0\n        for r in range(ROWS):\n            for c in range(COLS):\n                area = max(area, dfs(r, c))\n        return area\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem max area of an\nisland this is actually very similar to\nanother problem that we have solved\ncalled number of islands it's pretty\nmuch the same general algorithm but\nwe're returning a slightly different\nresult rather than counting the number\nof islands we're actually going through\nevery island and figuring out which one\nof them has the max area and then we're\ngoing to return the max area of any of\nthese islands so the general idea is the\nsame we're given a 2d grid where zeros\nrepresent water as you can see they're\nblue and ones represent land and of\ncourse an island is going to be you know\nconsecutive one values that are\nconnected either horizontally right like\nfrom the left and right side or\nvertically so up and down you know two\ncells that are connected diagonally\ndon't really count so you know if i add\none here\nuh you know if this was a one it would\nstill uh basically this and this are not\nconnected they're not an island they're\nseparately an island this is a separate\nisland this is a separate island this is\na separate island and this is a separate\nisland so there's really two parts to\nthis algorithm\nfirst you need to be able to get the\narea of any given island and you can do\nthat with your graph algorithm of choice\ni prefer doing it with the dfs depth\nfirst search so understanding debt for\nsearch is a prerequisite for this\nproblem and the good thing is if you do\nhave a good understanding of dfs then\nthis problem is pretty easy all you\nreally have to do is kind of understand\nhow dfs fits into the context of this\nproblem and in this case it's actually\npretty simple so i'll be walking through\ndfs and then walking through how we can\napply that to this algorithm so running\ndfs on an island such as this one so\nsuppose you know we start here we wanna\nwe see that it's a one value right that\nmeans it's an island but is the area of\nthis island just one itself or are there\nother cells connected to it that are\nalso land and if there are we want to\nrun dfs in all directions to basically\ncount how many cells are connected so\nthe way dfs works is we're going to run\ndfs above which we see is out of bounds\nso dfs is a recursive algorithm and\nsince up above we're out of bounds the\ndfs is going to return zero basically\ntelling us that the area of the island\nin the above direction is zero similarly\non the left and right side it's not out\nof bounds but this is water so it\ndoesn't count as an island but of course\nwhen we go down we see we reach a one\nand this one has not been visited so far\nso again uh we reach another one value\ncell and again recursively we're going\nto run dfs in all four directions so\ngoing to the left which is water so\ndon't do anything there going down which\nis also water don't do anything we're\nalso going to go up above actually even\nthough we've already visited that cell\nwhich is kind of a problem we don't want\nto have to go and run dfs recursively on\na cell that we've already visited so the\nway in dfs to get around that is to have\nyou know some kind of data structure we\ncan call it visit it's going to be a\nhash set so\nusing this hash set we can kind of mark\nthe positions that we've already visited\nso that we don't end up revisiting them\nthat will help us with the time\ncomplexity of this problem and the last\ndirection from here is to go right where\nwe see that yes there's an island so uh\nyou know we we run dfs from this\nposition as well we look up nothing\nthere down nothing there left we've\nalready visited that right side is\nunvisited so that's the last cell\nthere's you know in all other directions\nthere's nothing else so after running\ndfs on this island what did we get what\ndo we want our dfs to return well of\ncourse we want to know the area of every\none of these islands right that's the\nonly reason we're even running dfs so\ndfs from this island should return the\nvalue 4 because that's the area of this\nisland now it probably makes sense how\ndfs fits into this problem once you get\ngood at writing dfs dfs becomes trivial\nall we have to do is figure out how to\napply it to this problem and it's pretty\nsimple in our case we're going to run\ndfs on every single island and then you\nknow keep track of which one of these\nhas the maximum area as you can see this\none has the maximum area of six so we're\ngoing to end up returning six in this\nproblem now how are we gonna run dfs on\nevery single island the easiest way to\ndo it since we don't know which cells\nare zero and which ones are one until we\nactually look at every single individual\ncell that's exactly what we're gonna\nhave to do we're gonna start at the top\nleft look at every single cell if we see\na one value we're gonna run dfs on it\nand figure out the area of that island\nif we don't see a one value we're going\nto skip it so we're going to have by the\nend of it we're going to have visited\nevery single position and run dfs on\nevery island so we will know which one\nis the maximum the only problem is what\nif we run dfs on this position and then\nwe run dfs on this position won't we get\nthe same exact area won't we run dfs on\nthe same island twice well no and that's\nthe reason we are using our visit set\nbecause we don't want to run dfs on an\nisland multiple times so at this point\nyou can probably see that the time\ncomplexity of this problem since in the\nworst case we're really only going to be\nvisiting each cell you know a constant\nnumber of times it's not going to be you\nknow exponential or anything the time\ncomplexity is going to be the size of\nthe entire grid which\nwe're given is m by n so in that case\nthe overall time complexity is going to\nbe m times n\nand that's also going to be the memory\ncomplexity because remember we are\nhaving a hash set which could\nin the worst case contain every single\ncell in the grid\nand of course dfs is recursive so\nthere's a call stack associated with it\nbut uh this is going to be the memory\nbottleneck the hash set so the time and\nspace complexity is going to be big o m\ntimes n that's enough for us to now jump\ninto the code okay so now let's write\nthe code if you've seen any of my graph\nvideos you probably know i like to solve\nall these problems in a very formulaic\nway the first thing i like to do is just\nget the dimensions of the grid because\nusually it comes in handy so let's get\nthe number of columns and the number of\nrows in the entire grid the only other\ndata structure we're going to be needing\nis the visit hash set so let's declare\nthat above and now we want to write our\nrecursive dfs function i like to just\nwrite the dfs inside of our root\nfunction because in that case we won't\nhave to pass in every single parameter\nall we are going to be passing in is the\nposition that we're going to be visiting\nso rc is going to be the row column that\nwe are running dfs on we won't have to\npass in the visit or the grid itself and\nwith dfs we always want to handle the\nbase case first with all recursive\nfunctions\none base case is if we go out of bounds\nhow do we determine that well if rho is\nless than zero or a row is too big it'll\nbe too big if it's exactly equal to the\nnumber of rows that we have uh or you\nknow the same thing with the column if\nit's less than zero or it's equal to the\nnumber of columns and there's two other\ncases remember one is if we reach water\nwe don't want to run dfs on water so if\nthe grid column position is equal to\nzero and last but not least we don't\nwant to revisit the same position so if\nthe row column pair is already inserted\nin our visit hash set then we don't want\nto revisit it so in all of these cases\nwhat do we want to return well remember\nour dfs is trying to calculate the area\nof every island in this case we didn't\nfind an island so we want to return zero\nand after that don't forget to add\nthis row column pair to our hash set to\nindicate that it has been visited and\nafter we do that we want to calculate\nthe area of uh this position right of\nthis island how are we going to do that\nwell the current cell that we're at is\ngoing to count as one of the area values\nand the other\npositions we can pretty much run dfs on\nall four directions right so let's call\ndfs i'm passing in how about row plus\none uh column right and we can actually\njust copy and paste this four times so\nlet's do that this can also be done with\nlike a for loop to go through all four\ndirections but i just prefer writing it\nout it's not too much code and it's\npretty easy so we just want to replace\nthese with all four directions so\nanother direction is row minus one\nanother direction will be\ncolumn plus one and another direction\nwill be column\nminus one so that's all four directions\nso each of these dfs's is calculating\nthe area of the remaining portion of the\nisland in each of these four directions\nthen we're adding all four of them up\nincluding the one cell that we are\ncurrently visiting right now and once\nwe've added all those up all we really\nneed to do is return it because that's\nwhat our dfs is trying to do just return\nthe area of the island if it hasn't\nalready been visited so now that we've\nwritten our dfs we've pretty much solved\nthe entire problem all we really have to\ndo is iterate over uh the entire grid\nwhich we can do just like this nested\nfor loops going through every row going\nthrough every single column in the grid\nand actually let's maintain a single\nvariable let's call it area or you could\ncall it the result initially it's going\nto be set to zero right this is the max\narea that we're maintaining\nevery single time we call our dfs we\nwant to potentially update the area if\nit's greater than the current area so\nwe're going to take the max of the\ncurrent area and the max\nof the dfs call that we're going to be\ndoing on the row column pair that we're\ncurrently iterating through and once\nthat is done we will have the max area\nso all we have to do is return it and\nlast let's run this code and make sure\nthat it works okay i was very dumb uh we\nforgot to add the plus sign to each of\nthese i don't know how i forgot that but\nlet's not forget it so yeah so in case\nit wasn't clear all we're doing is\nadding all four of these together adding\nit to the one as well so now let's run\nit to make sure that it works and as you\ncan see on the left yes it works and\nit's about as efficient as we can get\nfor this problem i will say that one\nother optimization you can do is you\ndon't actually need an external visit\nset you can actually just use the grid\nitself to determine if you've visited a\nposition or not but we're not guaranteed\nthat we can write over the input grid so\ni don't think it's a big deal to use a\nhash set i guess you could clarify with\nyour interviewer if you really want to\nbut it's just a small optimization that\nisn't a big deal in my opinion but i\nreally hope that this was helpful if it\nwas please like and subscribe it really\nsupports the channel a lot consider\nchecking out my patreon if you'd like to\nfurther support the channel and\nhopefully i'll see you pretty soon\n"
    },
    {
        "Name": "Clone Graph",
        "NcLink": "clone-graph/",
        "Pattern": "Graphs",
        "Description": "Given a node in a connected undirected graph, return a deep copy of the graph.\n\nEach node in the graph contains an integer value and a list of its neighbors.\n\n```java\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n```\n\nThe graph is shown in the test cases as an adjacency list. **An adjacency list** is a mapping of nodes to lists, used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nFor simplicity, nodes values are numbered from 1 to `n`, where `n` is the total number of nodes in the graph. The index of each node within the adjacency list is the same as the node's value (1-indexed).\n\nThe input node will always be the first node in the graph and have `1` as the value.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ca68c09d-4d0e-4d80-9c20-078c666cf900/public)\n\n```java\nInput: adjList = [[2],[1,3],[2]]\n\nOutput: [[2],[1,3],[2]]\n```\n\nExplanation: There are 3 nodes in the graph.\nNode 1: val = 1 and neighbors = [2].\nNode 2: val = 2 and neighbors = [1, 3].\nNode 3: val = 3 and neighbors = [2].\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/96c7fb34-26e8-42e0-5f5d-61b8b8c96800/public)\n\n```java\nInput: adjList = [[]]\n\nOutput: [[]]\n```\n\nExplanation: The graph has one node with no neighbors.\n\n**Example 3:**\n\n```java\nInput: adjList = []\n\nOutput: []\n```\n\nExplanation: The graph is empty.\n\n**Constraints:**\n* `0 <= The number of nodes in the graph <= 100`.\n* `1 <= Node.val <= 100`\n* There are no duplicate edges and no self-loops in the graph.\n",
        "Difficulty": "Medium",
        "Video": "mQeF6bN8hMk",
        "PythonSolution": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        oldToNew = {}\n\n        def dfs(node):\n            if node in oldToNew:\n                return oldToNew[node]\n\n            copy = Node(node.val)\n            oldToNew[node] = copy\n            for nei in node.neighbors:\n                copy.neighbors.append(dfs(nei))\n            return copy\n\n        return dfs(node) if node else None\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem\nclone graph so we're given a reference\nto a\nnode that is in a connected undirected\ngraph so it's convenient for us that the\ngraph\nis completely connected and all we want\nto do is return a\ndeep copy of that graph in other words a\nclone of that graph and for every single\nnode\nwe have two things we are given a value\nand we're also given a list of its\nneighbors so this is what's telling us\nyou know how the graph happens to be\nconnected these are the edges\nin our graph now if you're not super\nfamiliar with what a deep copy is so\nlet's say that this\nis our example our input graph we're not\njust going to create a shallow copy\nmeaning like this\nis the exact same graph like the color\nis yellow\nfor both of these meaning like it's the\nexact same graph we didn't actually\ncreate a clone of it\nso this is not what we're looking for\nthis is also not what we're looking for\nso this is a\nnew graph because the color is slightly\ndifferent\nbut you see that the values aren't\nexactly how they're supposed to be we\nhave a\n3 here whereas we have a 2 in the\noriginal graph right so basically we\nhave these two's\nvalues mixed up so that's not what we\nwant either we want an exact clone so\nit has the exact same structure and\nvalues right the values and structure is\nthe exact same\nand this happens to be a new graph this\nis not the exact same graph as this one\nbecause this one is blue\nwhereas this one is yellow so how are we\ngoing to solve this problem well you can\nsee\ni'm going to use a hash map like pretty\nmuch every graph problem and we're going\nto use\ndepth for a search where you can also\nuse breadth first search if you want but\nlet me show you the general algorithm\nso you can see these edges are\nundirected meaning you know if\none has a neighbor two well two is also\ngoing to have a neighbor 1 in its\nneighbor list\nso let's say that 1 is our entry point\nin the graph what are we going to do you\ncan see initially our hash map is empty\nwhat we're going to try to do is map the\nold nodes\nto the new nodes or the copy nodes so we\nstart at one so what's the first thing\nwe should do well obviously we should\ncreate a copy of this\nnode that's what i'm gonna do so create\na copy of one\nnow this copy of one is not complete yet\nright because take a look at the\noriginal one it has two neighbors\nthree and two so what can i do\nwe know we're gonna have two neighbors\nfor node one right\ncan i just take these two original nodes\nand then put them over here\nthree and two no i can't do that because\nfor these nodes three and two we\nactually have to create copies of\nthem as well so you can see that this is\ngonna be recursive\nso first thing i'm gonna do is i'm gonna\ngo to its first neighbor which let's\njust say it happens to be two in this\ncase right\nso i'm gonna now i'm gonna i'm gonna\nstart cloning starting at two so\nwe're at two we're gonna create a clone\nof two oh and by the way before i forget\nbefore we make a clone of two we know we\njust created a clone for one so what are\nwe gonna do\nwe're gonna map the original node one\nto its now clone node once we're mapping\nthe old node\nto the new node and i'm going to show\nyou why we're doing that in a second\nso now we're going to go to node 2 right\nand we're going to create a clone of\nnode 2. so let's create that clone\nnode 2. we're also going to add it to\nour hashmap right we're mapping the\nold node 2 to its clone so the clone\nin blue is the new node\nso now we've cloned one and we've cloned\ntwo\nand for two now let's look at two's\nneighbors well\nlook you can see that it has a neighbor\nof one\nright and it has a neighbor of four so\nfirst we're gonna end up trying to do is\ncreate a clone for\ntwo because we know that we have to in\nthe list of neighbors for two we have to\nadd the clone\none which we haven't done yet so what\nwe're gonna end up doing is we're gonna\ntry to clone one but we're gonna see\nin our hash map look we already ended up\ncloning\none so basically what i'm saying is now\nwe can say okay we can add\nthis edge that two is connected to one\nthat two has a neighbor\nthat happens to be one and basically\nthe reason i'm doing that is because we\nknow this edge is going to be undirected\nit goes both\nways so that's what i'm trying to do\nhere so now we know that 2 is connected\nto 1\nwe also know we have to clone node 4.\nso now we're going to visit position 4.\nlet's create a clone for 4\nso let's add it to our hash map as well\nwe're mapping the original node\n4 to its clone so now we're at the node\n4. we want to clone\n4's neighbors first you see that 4 has a\nneighbor\n2 which we already cloned so we're going\nto take this original node 4 right we\nknow the original node\nwe know the original node 4 has a as an\noriginal neighbor of 2\nso then we're going to take that 2 look\nit up in our hash map see okay we\nalready created a\nclone of it and this is the clone and\nthen we're gonna end up taking four and\nconnecting it to\ntwo and let's just say that you know\nwhen we created the node four we ended\nup connecting two\nto four so let's just make this edge go\nboth\nways because we know that originally the\nedges are undirected\nso now that we've for four we wanted to\ncreate a clone of two\nwe also want to create a clone of its\nsecond neighbor three\nso now let's create a clone of three so\nwe know that four is going to be able to\nconnect\nto this neighbor of three so we're\ncreating a clone for it\nand we're gonna take the original three\nnode and map it to its\nnew copy node of three so now we're\nalmost done\nright you can see that all four of the\nnodes have been copied\nbut for three we haven't added threes\nand neighbors right\nthree isn't ended up connecting to any\nother nodes yet but we know in the\noriginal three has two neighbors\nthe first neighbor is four so we're\ngoing to say okay we know that\nthis 4 needs to have a clone but the\ngood thing is we already created a clone\nfor that node\nand this is the clone so now we have it\nso we're gonna take\nthree and ah and connect it to\nfour so we're gonna make this edge\nbasically double directed\nand three also has another neighbor of\none and so basically what we need to do\nis make a clone of that one but we\nlook in our hash map first and we see we\nalready cloned one\nthis is the clone so we're gonna take\nthree and\nconnect it to one right but wait we have\none last problem right this\none should also be connected to the\nthree right you're right and that's what\nwe're doing recursively now\nso we originally started at one then we\nwent to two\nthen we went to four then we went to\nthree now what we're going to end up\ndoing is\nreversing that because we remember we're\ndoing this recursively so we're gonna\npop back up to four\nwe're gonna see four has already cloned\nits neighbors three already cloned its\nneighbors\nwe're gonna pop back to two two already\ncloned its neighbors\nwe're gonna pop back to one one we ended\nup cloning\nthe neighbor two right but we didn't end\nup\ngoing this way so from three now we're\ngonna end up\nwe're gonna end up checking okay did we\nalready clone three let's look in our\nhash map yep we already did\nso this is the clone that we created so\nall we really need to do is make one\nconnected to three so basically make\nthis edge double directed\nso now you can see that we finally\ncreated a complete clone\nof the graph we did this in o of n\ntime where n is basically the number of\nedges plus the number of vertices right\nthe number of nodes plus the number of\nedges connecting them because we have to\nbasically make a clone of each of these\nand with that being said now let's jump\ninto the code\nso we remember that we only need a\nsingle data structure\nold to new which is a hash map mapping\nthe old nodes to the new nodes and i'm\ngoing to implement this in depth first\nsearch\nand you can see that this function is\nnested in the outer function which just\nmakes things easier meaning that this\ndata structure doesn't need to be passed\ninto every single function call\nbut we do need to pass in everything\nevery time the node that we're visiting\nso in depth first search we're going to\npass in the node\nfirst thing we're going to check is if\nthe node is\nin our hashmap if it is in our hashmap\nthen that means we already made a clone\nof it\nif we already made a clone of it then\ni'm just going to return that clone\nwe don't need to create another clone so\nif it exists return the new node\nso if this statement doesn't execute\nthat means a clone doesn't already exist\nso let's create that clone i guess i'll\ncall it a copy so we're going to create\na\ncopy of this node so we're going to use\nthe node constructor and the value we're\ngoing to give it is the value of this\noriginal node and we're also going to\ntake that copy and then add it to our\nold to new hash map so\nold to new so the old node is just node\nand the new node is the copy\nso we're mapping the old node to the\ncopy\nand then we want to make copies of every\nsingle\nneighbor of the original node so\nnode.neighbors\nlet's go through every single neighbor\nand let's run depth first search on that\nneighbor\nfor the and so basically if we run debt\nfor search on that neighbor what it's\ngoing to do is it's going to return\nthe copy that we end up creating and\nwith that copy what am i going to do\ni'm going to take this old node or this\nnew node the copy that we made\nand i'm going to take its list of\nneighbors\nand i'm going to append to that list of\nneighbors\nthis uh the return statement from this\ndebt first search call\nso let's copy and paste that in here so\nthat's all i really really need to do\ndepth first search\nand add it to the neighbors of this copy\nthat we just\nmade and once we're done making all\nthe copies of the neighbors then we can\nreturn the copy that we just made in the\ncurrent function call and it's actually\nthat simple because\neven though this is called that first\nsearch it might even be better to call\nthis function\nclone because cloning is basically what\nwe're doing we're taking the original\nnode and creating a clone\nof that node and we're cloning all of\nits neighbors recursively that's what\nthis recursive\ncall is right and then to the neighbors\nthat we're creating we're\nadding them or appending them to the\nlist of neighbors of this node\nand so it's actually the last thing to\ndo is easier than you would think we're\ngoing to\ncall debt for search passing in the\noriginal node that we're given in the\noriginal function call\nand then we're just going to return the\nresult of that\nbecause that's going to give us the\nconnected graph it doesn't really matter\nwhich\nnode we return i think so any node that\nwe end up returning\nis good after the entire clone has been\nmade\noh and one last thing we forgot to check\none edge case the original node that\nwe're given could be\nnull so if the node\nis non-null then we're going to call\nthis function return the result\nelse if the node is null we'll just\nreturn\nnull so with that being said this\nfunction\nshould work and there you go it's pretty\nefficient even though\nthis indication makes it seem like it's\nnot i think if i ran it one more time it\nwould probably be closer to like 50 or\n60 percent\nbut i hope this was helpful if you\nenjoyed\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Walls And Gates",
        "NcLink": "islands-and-treasure/",
        "Pattern": "Graphs",
        "Description": "You are given a $m \\times n$ 2D `grid` initialized with these three possible values:\n\n1. `-1` - A water cell that *can not* be traversed.\n2. `0` - A treasure chest.\n3. `INF` - A land cell that *can* be traversed. We use the integer `2^31 - 1 = 2147483647` to represent `INF`.\n\nFill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest than the value should remain `INF`.\n\nAssume the grid can only be traversed up, down, left, or right.\n\n**Example 1:**\n\n```java\nInput: [\n  [2147483647,-1,0,2147483647],\n  [2147483647,2147483647,2147483647,-1],\n  [2147483647,-1,2147483647,-1],\n  [0,-1,2147483647,2147483647]\n]\n\nOutput: [\n  [3,-1,0,1],\n  [2,2,1,-1],\n  [1,-1,2,-1],\n  [0,-1,3,4]\n]\n```\n\n**Example 2:**\n\n```java\nInput: [\n  [0,-1],\n  [2147483647,2147483647]\n]\n\nOutput: [\n  [0,-1],\n  [1,2]\n]\n```\n\n**Constraints:**\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 100`\n* `grid[i][j]` is one of `{-1, 0, 2147483647}`\n",
        "Difficulty": "Medium",
        "Video": "e69C6xhiSQE",
        "PythonSolution": "class Solution:\n    def islandsAndTreasure(self, grid: List[List[int]]) -> None:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n        q = deque()\n\n        def addCell(r, c):\n            if (\n                min(r, c) < 0\n                or r == ROWS\n                or c == COLS\n                or (r, c) in visit\n                or grid[r][c] == -1\n            ):\n                return\n            visit.add((r, c))\n            q.append([r, c])\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 0:\n                    q.append([r, c])\n                    visit.add((r, c))\n\n        dist = 0\n        while q:\n            for i in range(len(q)):\n                r, c = q.popleft()\n                grid[r][c] = dist\n                addCell(r + 1, c)\n                addCell(r - 1, c)\n                addCell(r, c + 1)\n                addCell(r, c - 1)\n            dist += 1\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve another graph problem\nwalls and gates so we're given an m by\nn grid where each position\ncould have three possible values a\nnegative one which represents a\nwall aka an obstacle that we're not\nallowed to\nvisit we're not allowed to visit these\nwalls a\nzero which identifies a gate so\nthis is an example of a gate in this\ncase and the third value\nis infinity which basically represents\nan empty room\nand basically for every single empty\nroom aka every position that's marked as\ninfinity initially we want to identify\nwhat's the nearest gate to that room and\nthen we want to take the distance\nuh from that room to the nearest gate\nand then replace\nthat infinite value with it so and\nif it is impossible basically if an\nempty position cannot reach a gate\nin our graph then basically we're going\nto leave that position as\ninfinity so for example let's take a\nlook at this example\nuh the easiest one over here right how\nfar away is this\nempty room from a gate well it can go in\ntwo directions it can go down\nwhich is an obstacle so we're not\nallowed to travel in that way\nwe can't go up or to the right those are\nout of bounds but we can go to the left\nand of course right next to it happens\nto be a gate so what we're gonna place\nhere\nis a one meaning this is one position\naway from a gate\nand similarly this one how far away is\nthis from a gate will one\ntwo three positions right from a gate so\nwe could put a three here we could put a\ntwo here and a one here\nuh what about this one we could go one\ntwo three so it's three positions\nfrom this gate but it happens to be that\nthere's a closer gate\nif we go to the right and then we go up\nright so the closer gate is actually two\nplaces away so we're gonna put two\nin this position and now what happens if\nthere was a gate over here what would we\nmark these two as well basically they\nstart out as\ninfinity and we would leave these two\npositions as infinity\nso any positions that cannot visit a\ngate are going to be\nremaining as infinity so the first idea\nthat you might have for this problem is\nbasically for every position we want to\nknow what's the closest gate why can't\nwe just run a dfs right\nbasically a dfs until we reach the gate\nor you know we reach as many positions\nas we can when we return what was the\nclosest gate\nto that position right and then do that\nfor every single position in the entire\ngrid now what's the time complexity\ngoing to be\nof that well a dfs is going to basically\nbe the size of the grid and we're going\nto do that for every single position in\nthe grid so basically it's going to be\nsomething like m by\nn squared so the question is can we do\nbetter than this big o time complexity\nwell let's try out a bfs\nsolution right we tried dfs let's try\nout breadth first search and see\nwhat that leads to us let's say we\nstarted our bfs\nat some arbitrary position like this one\nis it possible that we can eliminate\nrepeated work if we do that\nwell we're gonna start here and then\nvisit in all four directions\nand see you know what's the closest gate\nthat we can get to\nso starting here we have a distance of\nzero it takes us a distance of one to\nget to these positions and then finally\nwe can get a distance of two\nto get this position right but since we\ndon't want to revisit the same node\ntwice the same position twice\nwe're gonna you know do exactly that\nonce we get to a position we're gonna\nleave it as visited so\nyou know if we go from here to here it\ntakes us two positions so you know then\nwe can say okay for this position it\ntook us two but when we go\nup right we get to this position you\nknow we can't really go in any other\ndirection so basically this is going to\nbe remaining as a dead\nend we're never going to get a distance\nin this position right because we don't\nwant to revisit the same position\ntwice we can't go back in the direction\nthat we came from\nso a bfs solution starting from the\nrooms is not going to work if we want to\nget an actual\no of m by n solution it's not going to\nwork if we do it from the rooms but\nlet's reverse our thinking a bit why\ndon't we do a bfs solution\nfrom the gates so for example from this\ngate we can say okay let's mark all\nadjacent rooms basically as saying okay\nall of the adjacent rooms are one\ndistance away\nfrom this gate and then let's continue\nthat so from\nyou know this room doesn't have any\nother rooms adjacent to it but this room\ndoes\nso we can say okay for this room it's\ntwo in this room it's also\ntwo this is two positions away from this\ngate and we continue right we say okay\nthis room is three\nand continue from here this room is four\nand from here\nsimilarly right we'd say okay this is\nthree this is four\nand this is four right but is that\nactually true is this room\nfour positions away well we forgot about\nthis gate\nright so a better way of doing this\nwould be to\nsimultaneously do a bfs from both\ngates at the exact same time so in that\ncase if we ever reach\na position so let's let's see what\nhappens when we do a bfs simultaneously\nso from here we're going to say this is\none these two are one position and this\nis also one position now\nfrom all of our ones we're going to\ncontinue the bfs right so\nfrom this one we'll say these rooms are\ntwo away from this one we'll say this\nroom\nis two away right now from this\nuh room right this is two away we're not\ngonna go to this position and say that\nit's three positions away because with\nthis has already been visited\nwe've already found the minimum distance\nthat this is away\nfrom a bfs right so every time we expand\none layer\nwe're saying okay first let's find all\nthe rooms\none distance away from a gate next let's\nfind\nall the rooms two distance away from the\ngate\nand three and we keep doing that until\nevery single\nposition in our grid has already been\nvisited or we\nbasically cannot continue and we know\nbfs solutions are implemented with a q\nso once our q\nis empty that's how we know we can stop\nso let's just continue a little bit more\nso from this to\nthe only unvisited neighbor is this one\nso this is three\npositions away this one is also here\nso now we're going to do a bfs from the\nremaining threes\nwe can see only this three actually has\na neighbor\nso we'll say this one is going to be\nfour and when you take a look at the\nactual\noutput that they built our solution\nexactly matches what they did and we\ndidn't have to revisit the same node\ntwice\nall we had to do was initialize our\nqueue with the\ntwo initial positions for the gates\nand then expanding outwardly basically\nincrementing the distance every time we\ncomplete a\nfull layer of our bfs uh traversal\nand that actually led to us having a\ntime complexity of\nm by n we're also going to have that as\nthe memory complexity because we're\ngoing to have a visit set to make sure\nwe don't visit the same position twice\nbut once you kind of know that this is\ngoing to be a bfs from multiple sources\nat the same time implementing the code\nis pretty straightforward if you know\nhow to do bfs\nso first things first let's get the\ndimensions of our grid so the number of\nrows and the number of columns i usually\nlike to do this at the beginning\nso and we're also going to have a visit\nset that\nis going to make sure that we don't\nvisit the same position multiple times\nand we're also going to have a q which\ninitially\nlet's uh set to being empty but we're\ngonna initialize that with the\ngates first of all right so now let's go\nthrough every single position and\nactually initialize\nour cue right and we know we're just\ngonna do that with the gate so we're\ngoing to go through the entire grid\nso iterating over the entire grid and\neven though we're doing this it's not\nactually going to change the overall\ntime complexity so we're going to go\nthrough every position\nif rooms at this position is equal to\na gate meaning it's equal to a zero\nthen we're going to add it to our queue\nso we're going to say q dot append\nthis position and let's make sure to add\nit to the\nvisit set because we don't want to have\nto visit this same position twice\nand now we can actually start doing our\nbfs so initially the distance is going\nto be zero\nbecause we're gonna be popping the\nactual gates first of all so\nwe're gonna say while q is non-empty\nwe're going to go through every single\nposition in the queue currently right\nbasically\nthis layer of the queue and\nso we're going to be popping from the q\nso pop left\nfrom this q we're going to get the\ncoordinates of the gates that we\ninitially added right that's going to be\nthe first\nlayer the first layer we're going to be\npopping are the gates that we just added\nright\nso for each gate we're basically going\nto say okay\nlet's change this gate to being the\ncurrent distance\nso since the current distance is\ninitially zero and remember the gates\nstart\nout as having a value of zero we're not\nactually going to be modifying the value\nof the gates but the reason i'm putting\nthis line here is because\nafter we pop the gate layer the next\nlayer that we're going to add to our\nqueue is going to be all the rooms\nthat are one distance away so after this\nfor loop\nlet's make sure that we remember to\nincrement our distance\nby one every time we complete a full\nlayer of the queue\nand so basically for this room let's\njust go ahead\nand add room we're going to add every\nsingle\nneighbor of this room and you can see i\nhaven't actually defined that function\nyet so\nlet's do that up above once i actually\nwrite this out so basically what i'm\ndoing is\ngoing to be adding all four adjacent\nrooms to the queue\nand and we obviously know that some of\nthese rooms might be out of bounds some\nof them might have already been visited\nthat's why i'm going to put this in a\nhelper function to basically abstract\nsome of that logic for us so let's\ndefine the function up above over here\nso add room we're just going to pass in\na couple coordinates\nso basically if this row is\nless than zero or if the row is out of\nbounds meaning it's too\nbig meaning it's equal to the number of\nrows\nor the exact same thing for column if\ncolumn is less than zero\nor column is too big or\nif this position row column has already\nbeen visited\nor one last condition basically if\nthis room is a wall\nor an obstacle right because remember\nnot every position in our graph\nis a empty room it's it could it's\npossible it could be\na obstacle meaning it's equal to\nnegative one so if\nany of these above conditions is true\nwe're going to immediately return\nbecause this is an\ninvalid room so we're not going to\nactually add it to the queue\nor the visit set but if it's not invalid\nthat's when we can go ahead and say okay\nvisit\ndot add to the hash set and go ahead and\nqueue\ndot append to the hash set as well\nright so basically you can see why i'm\nputting this stuff inside of a helper\nfunction because we don't want to have\nto call that four times\nand i don't really want to put a loop in\nhere because i just think it's kind of\nmessy i'd rather just write it out like\nthis\nbut so with all of that done we can see\nthat we have added the rooms we're\nmaking sure to increment the distance\nevery time we complete a\nlayer and we're basically going through\nrooms labeling what's the minimum\ndistance\nfrom that room to a gate once we're done\nwith that we don't actually have to\nreturn anything because we just have to\nmodify\nmodify the room's 2d array in place\nso this is all the code that we're\nactually going to have to write so you\ncan see that this solution is\nefficient we're basically visiting the\nentire grid a couple times i think two\nor three times because of course we have\nthis initial loop and then we actually\nhave to run our bfs solution\nbut it's still a linear time solution\nwith respect to the size\nof the input array so i hope that this\nwas helpful if it was\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Rotting Oranges",
        "NcLink": "rotting-fruit/",
        "Pattern": "Graphs",
        "Description": "You are given a 2-D matrix `grid`. Each cell can have one of three possible values:\n* `0` representing an empty cell\n* `1` representing a fresh fruit\n* `2` representing a rotten fruit\n\nEvery minute, if a fresh fruit is horizontally or vertically adjacent to a rotten fruit, then the fresh fruit also becomes rotten.\n\nReturn the minimum number of minutes that must elapse until there are zero fresh fruits remaining. If this state is impossible within the grid, return `-1`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5daa219c-ae90-4027-41c3-6ea4d9158300/public)\n\n```java\nInput: grid = [[1,1,0],[0,1,1],[0,1,2]]\n\nOutput: 4\n```\n\n**Example 2:**\n\n```java\nInput: grid = [[1,0,1],[0,2,0],[1,0,1]]\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= grid.length, grid[i].length <= 10`\n",
        "Difficulty": "Medium",
        "Video": "y704fEOx0s0",
        "PythonSolution": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        q = collections.deque()\n        fresh = 0\n        time = 0\n\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    fresh += 1\n                if grid[r][c] == 2:\n                    q.append((r, c))\n\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        while fresh > 0 and q:\n            length = len(q)\n            for i in range(length):\n                r, c = q.popleft()\n\n                for dr, dc in directions:\n                    row, col = r + dr, c + dc\n                    if (\n                        row in range(len(grid))\n                        and col in range(len(grid[0]))\n                        and grid[row][col] == 1\n                    ):\n                        grid[row][col] = 2\n                        q.append((row, col))\n                        fresh -= 1\n            time += 1\n        return time if fresh == 0 else -1\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem rotting oranges\nwe're given an m by n grid where each\ncell could have three different values\nit could have a zero which represents\nempty it could have a one which\nrepresents a fresh orange or it could be\na two which represents a rotten orange\nevery minute that passes any fresh\norange that is four directionally\nadjacent meaning either up down left or\nright so if it's right next to a rotten\norange then that fresh orange will also\nbecome rotten we want to return the\nminimum number of minutes that must\nelapse until no fresh orange exists but\nit might be impossible you know suppose\nif a fresh orange was actually not next\nto any other oranges at all including\nany rotten oranges then that fresh\norange would never become rotten so if\nit's not possible then we can return\nnegative one but if it is possible we\nreturn the minimum number of minutes\nthat it takes so you can see in this\nexample which is actually a very simple\none because we are only given a single\nrotten orange but we could be given\nmultiple rotten oranges but in this case\nwe see that this is the rotten orange\nright right now we're at time equals\nzero and let's say one unit of time\npasses now we're at time equals one what\nhappened well the adjacent oranges to\nthe rotten one also became rotten so\nthis is rotten now and this is rotten\nnow okay now another unit of time passes\nit's time equals to what happened well\nall the other oranges which were\nadjacent to rotten oranges like these\ntwo also became rotten okay now we're at\ntime equals three what happened well\nthis orange which is adjacent to a\nrotten orange also became rotten now\nwe're at time equals four and this last\norange also became rotten because it's\nnext to a rock it's next to a rotten\norange so at time equals four\nfour minutes later all oranges are\nrotten so we return four that's exactly\nwhat they expect in this example let's\nsay this is the grid that we were given\nand these orange things are the oranges\nand let's say these two initially were\nrotten what kind of algorithm can we do\nto make sure that the adjacent oranges\nalso become rotten and then track the\ntime that it takes for you know each\nlayer to become rotten well you could\ntry a dfs right that's like the first\ngraph algorithm that most people try in\nthis case it's not really going to work\nwe run a dfs let's say on just one of\nthe or the rotten oranges let's say we\npick this one first okay we run a dfs on\nthe adjacent spots okay here's an\nadjacent spot so this becomes rotten\nthis becomes rotten that's time equals\ntwo then this becomes rotten at time\nequals three then these two become\nrotten at time equals four and then\nlastly this one but that doesn't really\nwork because it took us five units of\ntime to make these rotten but that's not\nactually what's gonna happen right these\ntwo initial rotten oranges are\nsimultaneously going to be making the\nadjacent oranges rotten right like after\none unit of time this orange is going to\nbecome rotten from this one and this one\nis going to become rotten from this one\nafter another unit of time this is going\nto become rotten from this one and this\nis going to become rotten from this one\nand this is going to become rotten from\nthis one as well after two units of time\nafter three units of time this last one\nis going to become rotten either from\nthe one above it or from the one to the\nright of it so in three units of time\nall of the oranges became rotten but we\ndidn't use dfs if you were watching\ncarefully you might have noticed that\nthe the main algorithm we were actually\nusing\nis bfs breadth first search right which\nis also a standard algorithm and the\nreason it's helpful for us is because we\ndon't have to finish running dfs on a\nsingle rotten orange we can run the bfs\nalgorithm simultaneously on multiple\nsources at the same time so basically\nwhat we're doing is running multi-source\nbfs and usually bfs is implemented with\na queue data structure so basically what\nwe're going to be doing is initializing\nour cue with the initial rotten oranges\nwe're going to pop through every initial\nrotten orange and then we're going to\ncall that one unit of time and then to\nour q we're going to add the next rotten\noranges so these two would not be in our\nqueue anymore but this one over here and\nthis one over here would then be added\nto our q and then we're gonna you know\npop through those ones as well and then\ncall it our second unit of time and then\nkeep going like that but how do we know\nwhen we're actually finished well once\nour cue is empty then of course we can\nstop but it's not guaranteed that we\nwill actually have made every single\norange rotten suppose there was an\norange all the way over here that's a\nfresh orange it's not rotten yet of\ncourse we know that these oranges are\ngoing to become rotten but this is not\ngoing to become rotten so basically\nafter our cue is completely popped what\nwe're going to notice is there is a\nfresh orange remaining and the way we're\ngonna know about that is because we\nshould keep track of how many fresh\noranges there are initially right in our\ncase i think there's about uh seven\nfresh oranges right and then by the time\nour bfs algorithm is done we're down to\none fresh orange because we still have a\npositive number of fresh oranges that\nmeans we were not able to make every\norange rotten and therefore we're gonna\nhave to return negative one as our\nresult but if we were able to\ndo that right let's say this orange\ndidn't exist we you know make all these\noranges rotten then we keep track of how\nmuch time did it take us to make all of\nthe oranges rotten it was three units of\ntime i think so then we're going to\nreturn three so that's the overall\nalgorithm as you can kind of tell from\nthe bfs it's multi-sourced but we're\nstill only going to be visiting each uh\norange each cell in our grid at most\nonce so we can say that the time\ncomplexity is going to be n times m\nwhere these are the dimensions of the\ngrid and i think in the worst case that\nthe memory complexity is also going to\nbe the same because we're going to be\nusing a q and all that so that's enough\nfor us to get into the code so let's do\nthat now okay so now let's code it up so\nthe first thing we're going to do is\ninitialize our deck it's going to be\nempty initially we're going to also have\ntwo more variables one is going to be\nthe time to keep track of how much time\nhas passed and another is going to be\ncalled fresh to keep track of how many\nfresh oranges we have at any given point\nin time initially let's just set these\nboth to zero but let's actually iterate\nover the entire grid and actually before\nwe do that it would be good to get the\ndimensions of the grid so the number of\nrows and the number of columns so now\nlet's iterate over the entire grid just\nto do some pre-work the pre-work is\ngoing to be doing two things at the same\ntime so we can just write some nested\nloops to iterate over the grid one we're\ngoing to be doing is counting the number\nof fresh oranges right so if any cell in\nthe grid is equal to one remember that\nones represent fresh oranges so if this\nis equal to one we can just increment\nthe number of fresh oranges the second\nthing we also want to be doing is to\nidentify all of the rotting oranges\nbecause remember we need to add them to\nour queue so that we can actually run\nthe bfs in the first place right the\nmulti-source bfs so if any of these grid\ncells are equal to 2 that means it's a\nrotting orange and that means we can go\nahead and append it to our queue and by\nappend we're going to be appending the\ncoordinates of that rotting orange so\nnext what we're going to be doing is\nrunning our while loop while our queue\nis non-empty and we can say that if\nfresh is also greater than zero right\nbasically if either of these uh you know\nif our cube becomes empty or if fresh\nequals zero then the loop is going to\nstop if neither of those are true then\nwe're going to continue the loop so now\nwe have a certain number of rotten\noranges in our queue and we want to\nactually pop every single one of them so\nbasically we're going to create another\nloop while\nyou know let's say we have three oranges\nin our queue then we're gonna iterate\nthrough the loop three times we're gonna\npop those three oranges but at the same\ntime we're actually gonna be adding uh\nthe adjacent oranges to that q as well\nmarking them as rotten so that's why\nwe're creating the while the for loop\nrather than saying while the queue is\nnon-empty because uh this will just take\na snapshot so for example if the length\nof our queue is equal to three this loop\nwill execute three times even though\ninside of the loop we're going to be\nadding to the queue updating its length\nbut this uh you know the range function\nisn't going to execute each time after\nthat we want to of course pop from the\nqueue and when we pop we're popping the\ncoordinates of the rotten orange at this\npoint we want to go through all of the\nfour adjacent spots for this orange so\nwhat we're going to say is drdc\nthe difference in run difference in a\ncolumn in directions and we're actually\ngoing to create a variable for this\noutside of our loop and it's basically\nthe four directions that we could move\nin so it's going to be pairs let's say 0\n1 and 0\nnegative 1 and 1 zero and negative one\nzero so these are the four directions we\ncould move in so that's what dr dc is\ngoing to represent so\nlet's actually calculate what the row\nwould be so initially we're starting at\nrc and then the you know adjacent spot\nthat we're looking at is going to be d r\nplus r and d c plus c so this is one of\nthe four adjacent spots row column and\nwhat we want to do with this position is\nmake sure that it's in bounds and that\nit's a non-rotten orange so meaning that\nit's a fresh orange let's actually\nchange this comment to that and it's a\nfresh orange and then we want to make it\nrotten so to save a bit of time i'm\nactually just going to copy and paste\nthis so what we're doing here is\nchecking that the row\nbasically if the row is out of bounds if\nit's less than zero or if it's too big\nor if the column is out of bounds or\nit's too big or the grid cell is\nactually not a fresh orange if any of\nthese are true we're going to continue\nto the next iteration of the loop\nbecause that means this is either out of\nbounds or it's not a fresh orange but if\nit is a fresh orange and it's in bounds\nthen we want to make it into a rotten\norange so we can do that very easily\nlike this and we also want to add that\nposition to our queue so that row column\npair so that over the next iteration of\nthe while loop that we can include that\nright even though we're appending to the\nqueue this portion of the you know for\nloop isn't going to change right that\nlength was a snapshot we're not going to\ncontinuously update that and last but\nnot least make sure to uh decrement the\nnumber of fresh oranges because that's\none of the you know indicators of if we\ncan stop the algorithm or not and\nremember this loop was going through all\nof the rotten oranges and then the\nadjacent\nfresh oranges were being set to rotten\nas well so that actually happened in one\nunit of time so after that loop is done\nexecuting we can increment our time by\none after uh this loop is finished then\nit's time to return our result but how\ndo we know if we can return the time or\nif we have to return negative one well\nwe can return the time if fresh is equal\nto zero that means we made every single\norange rotten but else if it's not then\nwe have to return negative one that\nmeans there's some oranges that we just\ncan't make rotten okay so that's the\nwhole code now lastly let's just run it\nto make sure that it works and actually\ni just noticed i made a couple of little\nmistakes so over here on this line i\nforgot one of the or statements so let's\nadd that as well and actually here we\nhave q.pop but remember we're actually\nadding to the queue when we append we're\nadding to the right side of the queue so\nwhen we pop from the queue we want to\nmake sure we're popping from the left\nbecause we want to pop you know the more\nrecently added oranges right that's why\nwe're taking this length if the length\nwas three we would want to pop the 3\noranges from the left side not the same\noranges that we're adding to the queue\nso make sure that this is a pop left so\nthat being said let's run the code to\nmake sure that it works and as you can\nsee on the left yes it does and it's\npretty efficient so i really hope that\nthis was helpful if it was please like\nand subscribe it really supports the\nchannel a lot consider checking out my\npatreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Pacific Atlantic Water Flow",
        "NcLink": "pacific-atlantic-water-flow/",
        "Pattern": "Graphs",
        "Description": "You are given a rectangular island `heights` where `heights[r][c]` represents the **height above sea level** of the cell at coordinate `(r, c)`.\n    \nThe islands borders the **Pacific Ocean** from the top and left sides, and borders the **Atlantic Ocean** from the bottom and right sides.\n\nWater can flow in **four directions** (up, down, left, or right) from a cell to a neighboring cell with **height equal or lower**. Water can also flow into the ocean from cells adjacent to the ocean.\n\nFind all cells where water can flow from that cell to **both** the Pacific and Atlantic oceans. Return it as a **2D list** where each element is a list `[r, c]` representing the row and column of the cell. You may return the answer in **any order**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/3899fae1-ab18-4d6b-15b4-c7f7aa224700/public)\n\n```java\nInput: heights = [\n  [4,2,7,3,4],\n  [7,4,6,4,7],\n  [6,3,5,3,6]\n]\n\nOutput: [[0,2],[0,4],[1,0],[1,1],[1,2],[1,3],[1,4],[2,0]]\n```\n\n**Example 2:**\n\n```java\nInput: heights = [[1],[1]]\n\nOutput: [[0,0],[0,1]]\n```\n\n**Constraints:**\n* `1 <= heights.length, heights[r].length <= 100`\n* `0 <= heights[r][c] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "s-VkcjHqkGI",
        "PythonSolution": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        pac, atl = set(), set()\n\n        def dfs(r, c, visit, prevHeight):\n            if (\n                (r, c) in visit\n                or r < 0\n                or c < 0\n                or r == ROWS\n                or c == COLS\n                or heights[r][c] < prevHeight\n            ):\n                return\n            visit.add((r, c))\n            dfs(r + 1, c, visit, heights[r][c])\n            dfs(r - 1, c, visit, heights[r][c])\n            dfs(r, c + 1, visit, heights[r][c])\n            dfs(r, c - 1, visit, heights[r][c])\n\n        for c in range(COLS):\n            dfs(0, c, pac, heights[0][c])\n            dfs(ROWS - 1, c, atl, heights[ROWS - 1][c])\n\n        for r in range(ROWS):\n            dfs(r, 0, pac, heights[r][0])\n            dfs(r, COLS - 1, atl, heights[r][COLS - 1])\n\n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                if (r, c) in pac and (r, c) in atl:\n                    res.append([r, c])\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve pacific\natlantic water flow so this is another\nproblem from the blind 75 list and\nthat's why i'm doing it today the link\nto this spreadsheet will be in the\ndescription again\nand so we will be able to fill in one\nmore graph problem today from that blind\n75 list we're nearly done with that list\nnow at least most of the important\nproblems on this list i think there are\nsome binary questions that i haven't\nreally done and\ni might not do these because i feel like\nbinary questions rarely come up in\ninterviews\nbut for this problem so the text is a\nlittle small so let's focus\nmore on the picture so we're given a two\ndimensional\ngrid of values and so each value\nrepresents a\nheight so this has a height of 4 this\nhas a height of 5 etc etc\nwe are claiming that the top border\nof our grid everything you know right\nabove our grid and everything to the\nleft of the grid is going to be\ncalled the pacific ocean and everything\nto the right of the grid and everything\nbelow the grid\nis going to be the atlantic ocean\nso for any particular cell we want to\nknow\ncan this cell reach the pacific ocean\nand can it reach the atlantic ocean\nif it can then we are going to include\nthis position\nin the result if it cannot reach the\natlantic and pacific ocean then we don't\ninclude it in the result\nso how do we know if this cell can reach\nthe pacific and atlantic ocean because\nclearly there's a path\nyou know straight to it well there's one\ncondition\nwe want to know if water from this cell\ncan flow to the pacific end to the\natlantic and\nwater can only flow from the perspective\nof a\ncell to an adjacent cell that has\na value that is lower than the original\ncell or\nequal to the cell and it can only flow\nin four directions\nstraight above to the left to the right\nand below that's pretty straightforward\nusually you can't go diagonally in these\ntypes of graph problems\nand so in this case for this five we see\nthat the above neighbor\nthree is less than five this is less\nthan five this is less than five and\nthis is less than five so\nclearly five can go to all of its\nneighbors\nnow let's take a look at the three okay\nthree has a neighbor one\none is less than three so it can\ndefinitely flow in that direction and\nnow\nsee this one is bordering the atlantic\nocean so clearly\nthat means five is able to reach the\natlantic ocean\nnow let's look left it can reach four\nand four can definitely reach two\nbecause two\nis less than or equal to four so from\nthis perspective we can also now reach\nthe pacific ocean\nso water from this position can flow to\nthe pacific\nand it can flow to the atlantic so this\nposition is going to be included in\nour result so a brute force and naive\nway to solve this problem is to\nsimply go to every single position\ndo some kind of graph traversal dfs or\nbfs would probably work\nand doing that search check from a cell\ncan we reach the top\nand left border and can we reach the\nright\nand bottom border and if we can then\nwe're going to add this cell\nto the solution set if we can't then we\ndon't add it right\nso if we're doing a dfs or bfs on every\nsingle position\nstarting at every single position in the\ngrid we're gonna get a time complexity\nof basically the size of the grid let's\nsay that's that's\nn times m which is you know the\ndimensions of the grid\nand if we do that from every single\nstarting point we're gonna get\nn by m squared as the big o\ntime complexity and you might think well\nsince\nwe're doing this recursively we're\nprobably doing a lot of repeated work\nright so for example if i'm starting at\n3\nright doing a dfs from here i'm gonna go\nto its neighbors and then do dfs from\nhere\nhere here and here and maybe\nyou know by doing that i can cut out the\nrepeated work right\nand so i won't and so we won't have to\nyou know restart a dfs for every single\nposition\nin the entire grid and you might think\nthat that will work\nbut i'm pretty sure it doesn't i'm not\ngoing to go through\nthe details of why and somebody in the\ncomments can correct me if i'm wrong\nmaybe there is a clever way to get that\nto work\nbut i i tried to do it myself and i was\nnot able to so i don't know if it's\nactually possible\nto do it that way there's a different\nclever way to solve this problem\nhow about rather than us going through\nevery single cell\nand checking if this cell can reach\npacific and reach atlantic how about\nwe go for start from the pacific ocean\nright and let's find every\ncell that borders the pacific ocean\nclearly\neverything in the first row borders the\npacific ocean right that means\neverything in this cell can reach the\npacific ocean\nand everything in the left column can\nalso\nreach the pacific ocean and starting\nfrom each of these nodes\nwhat we're going to do is now find what\nare all the\nother nodes that can also reach the\npacific ocean right so\nat the end we would have you know some\nkind of set maybe you know it looks\nsomething like this right\nor whatever and then we know okay these\nare all all the ones in purple\ncan reach the pacific ocean and\nsimilarly\nwe would also do that with the atlantic\nocean we know everything\nhere on the right side can reach the\natlantic ocean\neverything at the bottom can reach the\natlantic ocean similarly we do some kind\nof dr\ngraf traversal starting from each of\nthese positions\nright and see okay what what nodes can\nreach the\npacific ocean as well and at the end we\nwould want to go through every single\nposition in the grid and we'd want to\nfind\npositions like this one that can reach\nthe atlantic\nand pacific ocean that we marked as\nbeing able to reach the atlantic\nand pacific and then from these ones\nthat can reach both we would add them to\nour result and then return the results\nso that's kind of\nthe general algorithm of how we're going\nto do things the reason this is more\nefficient\nthis is going to be big o n times m\nwe're not going to be revisiting nodes\nmult\nyou know several times we're not going\nto be re-running a graph traversal\nwhat we're going to be doing is starting\nat each of these nodes right doing a\ndepth first search right so\nfor example let's say we started at this\none right we'd do a depth first search\nand then see all the other nodes that\ncan reach the pacific ocean right\nyou know let's say we marked these and\nthese right and then maybe we do the\nsame thing starting at this one\nright and we'd you know go over here\nmaybe and then go over here and then\nwe'd come back here if we ever got to a\ncell that we\nrevisited we would not want to continue\nour debt for search from\na repeated cell right so we we just\nwouldn't do that\nso that's the main idea of this\nalgorithm but there's one last point i\nwant to make before i start going\nthrough the code\nand that is remember how if we're\nstarting at a cell like this one\nwater can flow from this cell to a cell\nthat has a smaller\nvalue right like a cell a small cell\nlike three for example and then it can\nflow down to a smaller cell like one and\nthen it can reach the ocean right\nso if we are going starting from a cell\nand reaching the ocean\nwe are allowed to go at equal heights so\none can reach one\nor we can go in decreasing heights like\nthese ones\nbut if we're going in the opposite\ndirection if we're starting\nat the atlantic ocean and going to a\ncell like 1\ngoing to a cell like 3 and going to a\ncell like 5 then we're\ngoing to have to do the opposite we can\ngo to cells of\nequal heights or cells of increasing\nheights right\nyou kind of see why that's the case\nbecause what we're saying is\nwater is allowed to flow from five to\nthree to\none so therefore water from the ocean is\nallowed to go\nfrom one to three to five because that\ndoes mean that\nfive can reach the ocean so with that\nbeing said\nthe first thing i'm gonna do is go\nthrough\nthe first row which is gonna be pacific\nocean\nvalues and then i'm gonna and from there\ni'm gonna run depth first search to see\nall the other nodes\nthat can reach the pacific ocean and i'm\ngonna do the same thing at the\nbottom row seeing which nodes can reach\nthe atlantic ocean\nand i'm gonna be maintaining those in a\nset let's call it a visit set it's going\nto be a hash set so that\nwe don't end up adding duplicates to it\nso now getting into the code so the\nfirst thing i like to do with these\nproblems is just get the dimensions of\nthe grid so we're guaranteed that this\ngrid is not going to be empty so we\ndon't have to\nyou know worry about that so let's get\nthe length of heights which is going to\ngive us the number of rows\nand then get the number of columns as\nwell\nand so i'm going to be having two hash\nsets pacific and atlantic\nmaintaining all the positions that can\nreach the pacific and atlantic oceans\nrespectively\nand then what i'm gonna do is i'm gonna\ngo through every single position\nin the first row so i'm gonna go through\nevery single column\nin the first row right and what's going\nto be every single position in the first\nrow from here it's going to be\n0 0 right in the first row is 0 and\ncolumn is going to be the column\nposition and so what i want to do\non this position is run a dfs right so\ni'm going to run a dfs on this position\nright\nand so i'm going to pass in a visit set\nto this dfs function\nsince this is the first row the first\nrow means it's the pacific ocean right\nit's not the atlantic it's the pacific\nso that's what i'm going to pass in as\nthe visit set\nthe pacific ocean so i want to visit\nthis position and i want to see all the\nother positions it can reach\nnow we know that water from the ocean\nto other cells can only go at equal\nvalues or\ngreater values right remember we\nreversed the thinking since we're going\nfrom the ocean to the cells we're going\nto have to do the opposite\nso we can go to greater cells so i want\nto always pass in a previous height\nvariable to this so if we're going to\nvisit a cell i want to make sure that\nyou know we're allowed to visit that\ncell so i'm going to pass in a previous\nheight so\nsince there is no previous height for\nthis position i can just give it a\ndefault value and i'll just give it the\nsame height as this position because\nthat's going to be allowed remember\nwe're always allowed\nto visit heights of the exact same\nheight\nas the previous position and so while\nwe're at this\nright we're going through every position\nin the first row\nwhy not go through every single position\nin the last row\nwhich tells us the atlantic ocean right\nso what's the last row it's going to be\nthe number of rows\nminus one and going through every column\nin that rows and\nso instead of passing in pacific let's\npass an atlantic\nbecause the bottom row refers to the\natlantic ocean and similarly we'll pass\nin the height\nof this position as the previous height\nso we're calling this dfs function so\nlet's might as well define it up above\nhere now\nthe first two parameters are going to be\nthe row and column and the next is going\nto be the visit set now\nsince we're reusing this function for\nboth atlantic and pacific we'll just\ngive it a generic name like visit we\ncould be passing in either of these two\nsets and the last parameter is the\nprevious\nheight so if this position has already\nbeen visited meaning\nif row column is in\nvisit then we're going to return we're\nnot going to continue this function or\nif it's out of bounds we're also not\ngoing to return right because remember\nwe're already going\nfrom the ocean from let's say the\npacific ocean and trying to visit\nall the cells that we can because that's\ngoing to tell us\nall the cells that can reach the pacific\nocean so we're not even trying to reach\nthe ocean right now\nwe're going from the ocean to all the\ncells so if we go out of bounds then\nwe're going to have to return so\nif let's say r is less than 0 or\nc is less than zero or if r is\nequal to the number of rows that means\nwe've gone too large\nor if c is equal to the number of\ncolumns that also means we've gone too\nlarge\nand the last case where we would want to\nreturn is if\nthe height of this position row column\nis less than the previous height\nbecause remember we're only allowed to\ngo to heights of greater height or equal\nso if the height was too small\nthen we would want to return if we're\nnot returning that means we're finding a\nnew cell so let's go ahead and add it to\nvisit we're visiting this new cell row\ncolumn\nand then on all four of its neighbors we\nalso want to run dfs\non all four of those neighbors and we\ncould do that with a loop but i'm lazy\nso i don't want to write that out i'm\njust going to\ncopy and paste this four times so so row\ncolumn\npassing in visit and passing in the\nprevious height which is just going to\nbe\nheights at this position row column\nlet's copy and paste this four times and\nso\nwe're gonna go through all four of its\nneighbors so row plus one\nis one neighbor row minus one is a\nneighbor column plus one\nis another neighbor and column minus one\nis another neighbor\nand that's going to be the entire dfs\nfunction for us\nit's going to be marking all nodes that\ncan visit\nthat can reach the pacific ocean or the\natlantic ocean depending on what we pass\nin\nand so right now we're doing that for\nthe first row and the last row\nbut we also know the first column is\ngoing is going to be\nthe pacific ocean and the last column is\ngoing to be the atlantic ocean so let's\ndo that so for every\nrow in range of rows\nwe want to get every position at the\nleft\nmost column and call dfs on it so\nfor row we're just going to pass in the\ncurrent row we're going to go through\nevery single row and for column we're\ngoing to pass in zero\nright we know that the first column is\nzero and if\nand the first column can reach the\npacific ocean so that's what we're going\nto pass in and for heights\nwe're just going to give it the default\nvalue of this position\nand similarly let's do the same thing\nfor the last row\nlet's do the same thing for the last\ncolumn so for\ncolumns instead of zero let's do columns\nminus one\nand instead of pacific let's pass in the\natlantic ocean because that's\nwhat the rightmost column refers to and\nheights is going to be the same default\nvalue\nand so we don't have to rewrite the dfs\nfunction right because we already wrote\nit up above here we're reusing that\nfunction\nso once these two loops have executed we\nwill have marked\nevery single position that can reach the\npacific ocean\nin here and we'll have done the same\nwith the atlantic ocean so\nnow after that let's just go through\nevery single position in the grid\nbrute forcing it so every single\nposition every single row every single\ncolumn\nand for every single position we want to\nknow if\nthis position row column is in\nthe pacific ocean and if row column\nis in the atlantic ocean then what we\nwant to do\nis let's first declare a result list\nif this position was in both atlantic\nand pacific we want to go ahead and add\nit to\nour result and we want to add it as a\nlet's say as a sub list and so once\nwe've done that then we have definitely\nfound out every single\nposition that can reach both atlantic\nand pacific ocean and then we can go\nahead and return that result\nokay i had a pretty stupid bug so sorry\nabout that so when we're passing in\nuh we're you know we're finding the\nposition of heights so\nyou know we have column because that's\nwhat we're at for row we should have\nzero because that's the position that\nwe're starting at so sorry about that\nlet's change this to a zero and\nsimilarly down here\ni actually think we have this right so\nrows minus one because that matches over\nhere but down here\nwe have row and column zero so we want\nto change column to zero over here\nand over here we do have row so that\nmatches but columns minus 1\nis the column value that we want to pass\nin so with those changes you can see\nthat this solution does work and it is\nabout as efficient as you can get for\nthis problem\nso i hope that this was helpful if it\nwas please like and subscribe\nit supports the channel a lot and i'll\nhopefully see you pretty soon\n"
    },
    {
        "Name": "Surrounded Regions",
        "NcLink": "surrounded-regions/",
        "Pattern": "Graphs",
        "Description": "You are given a 2-D matrix `board` containing `'X'` and `'O'` characters.\n\nIf a continous, four-directionally connected group of `'O'`s is surrounded by `'X'`s, it is considered to be **surrounded**. \n\nChange all **surrounded** regions of `'O'`s to `'X'`s and do so **in-place** by modifying the input board.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9e6916bf-0e25-4e15-9619-cbc42d2d8f00/public)\n\n```java\nInput: board = [\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"O\",\"O\",\"X\"],\n  [\"X\",\"O\",\"O\",\"X\"],\n  [\"X\",\"X\",\"X\",\"O\"]\n]\n\nOutput: [\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"O\"]\n]\n```\n\nExplanation: Note that regions that are on the border are not considered surrounded regions.\n\n**Constraints:**\n* `1 <= board.length, board[i].length <= 200`\n* `board[i][j]` is `'X'` or `'O'`.\n",
        "Difficulty": "Medium",
        "Video": "9z2BunfoZ5Y",
        "PythonSolution": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        ROWS, COLS = len(board), len(board[0])\n\n        def capture(r, c):\n            if r < 0 or c < 0 or r == ROWS or c == COLS or board[r][c] != \"O\":\n                return\n            board[r][c] = \"T\"\n            capture(r + 1, c)\n            capture(r - 1, c)\n            capture(r, c + 1)\n            capture(r, c - 1)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"O\" and (r in [0, ROWS - 1] or c in [0, COLS - 1]):\n                    capture(r, c)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"O\":\n                    board[r][c] = \"X\"\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"T\":\n                    board[r][c] = \"O\"\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem surrounded\nregions this is a pretty interesting\nproblem and I think you're going to be\nreally surprised by the solution that we\ncome up with today and I definitely\nthink this problem is well worth your\ntime so now let's get into it in this\nproblem we're given an M byn Matrix\nboard containing only X's and O's and we\nwant to capture all regions that are\nfour directionally surrounded by x's and\nby the way capturing a reason I don't\nknow if you can hear that flight noise\nthere's an airplane above but let's\ncontinue the problem capturing a region\nis defined by flipping all of the O's\ninto X's if and only if those O's happen\nto be surrounded by x's and this is best\nunderstood with an example so let's take\na look at this input board this is the\ninput board and this is the result so\nhow do we get to the result well take a\nlook at the board here we have two\ndifferent regions of O's this is one\nregion let me use a different color this\nis one region and this is the second\nregion why are these separate regions\naren't they connected diagonally well\nyeah they're connected diagonally but\nremember look above we only want four\ndirectionally surrounded right so\nbasically these cannot be connected\ndiagonally they have to be connected\nhorizontally or vertically like these\nthree are so these are two separate\nregions in the result you can see that\nthis region was flipped right one of the\nregions was flipped right why was this\nregion flipped because take a look it's\nsurrounded by X's right there's an X\nhere x here x here x here x here x here\nuh by the way actually we don't care\nabout this x because this x is diagonal\nright we care about horizontal and\nvertical X's so this x this x this X\nthis X and I think this is the last X\nright it's surrounded by all X's so\ntherefore we can capture this region\nwhen we say capture we mean convert the\nO's into X's as you can see in the\noutput what about the second region\nisn't this region also surrounded by X's\nwhy didn't we flip it in the output well\nlet's take a look this is has an x on\nthe left of it has an X above it has an\nx to the right of it but at the bottom\nthere's no X it's on on the border right\nso because this region is connected to\nthe Border we're not going to flip it\nright so basically any regions that are\nnot connected to the Border are going to\nbe flipped only the regions that are not\nconnected to the border so how can we\nsolve this problem should we run a DFS\non you know the entire board and then\ntry to figure out somehow which regions\nare not connected to the border and then\nflip them well definitely that is\npossible but depending on how you do it\nthat's a complicated approach actually\nthere are many ways to solve this\nproblem I'm going to show you a slightly\nclever and easy way to solve this\nproblem but I think you can actually\nlearn a lot from the type of solution\nI'm going to show you it has to do with\nreversing the way you think about the\nproblem what I and some people like to\ncall reverse thinking so let's get into\nthat solution right now so up above you\ncan see the example that we're trying to\nsolve this General problem we're trying\nto solve but before we even get into\nthat let me just kind of ask you a\nsimple question let's say I had a piece\nof paper like this one let's say I cut\nit like this right I have a small region\nover here called a this is the a portion\nof the paper and I have a other portion\nthis is the B portion of the paper let's\nsay I want to keep only this portion I\nonly want to keep the a portion of the\npaper so how can I ask for the a portion\nof the paper well I can say only give me\na right only the a portion of the paper\nthat's the simple way to talk about it\nbut a more complicated and kind of a\nuseless way to talk about it in English\nat least would be would be to say give\nme everything in the paper except for B\nright give me this entire paper except\nfor B right just cross B out just give\nme everything except for B why would you\nsay that when you can just say just give\nme a right of course that's the simp way\nto say it but sometimes this reverse way\nof thinking can be helpful especially in\nprogramming I'm sure you guys already\nhave kind of experienced that so how is\nthis going to be helpful in this problem\nlet me explain in the problem they told\nus to capture they told us to capture\nthe surrounding regions only right only\nthe surrounding regions in other words\nonly this region that's surrounded\nanother way the opposite way of saying\nthat is capture everything except the\nUNS surrounded regions right I basically\nrestated the first bullet point with a\nlonger sentence right capture everything\nin this board except the UNS surrounded\nregions the regions that are not\nsurrounded in other words capture the\nentire board except for this region\nbecause this region is not surrounded\nhow do we know that this region is not\nsurrounded is there an easy way to\nfigure that out yes it's very easy\nbecause this region is connected to the\nBorder any any region in the board\nconnected to the border right there were\nsome O's over here some O's over here\nhere or down here we are not going to\ncapture those so this is where things\nare going to get a little bit clever I\nwouldn't expect most people to be able\nto figure this part out especially\nbeginners how are we going to actually\nimplement this this second bullet point\nbasically we're going to go we're going\nto scan through every border cell right\neverything on the outside we're going to\nlook for any O's we found one o over\nhere right so we found one region that's\nnot surrounded right we know for sure\nthis region is UNS surrounded because\nit's connected to the border now we're\ngoing to run a DFS on on this region\nbecause we don't want to capture it how\nare we going to do that well we're going\nto give it a temporary uh basically a\ntemporary value we're we're going to\nchange all the O's into T's so I'm going\nto change this o into a t right now this\nthis o is not connected to anything\nright it could be it could have been\npossible maybe there's another o over\nhere and it kind of forms this region\nthat's connected to the border right and\nthen we would change all of those into\nT's as well right but in this case it's\njust a region of size one so that's all\nwe do now why are we changing it to a\ntemporary variable because remember\nwe're trying to capture everything\nexcept unsur regions so now we we marked\nthis as a UNS surrounded region right so\nnow what are we going to do we have this\nboard we're going to just do a double\nnested Loop iterate through every single\nRow in this uh input grid and anytime we\nsee an O value we're going to change it\ninto an X because now we know for sure\nthat anytime we see an O It's defin\nitely part of a surrounded region\nbecause any regions that were UNS\nsurrounded we already changed them to a\nt so anytime we see an O we're going to\nchange it to an X so what I'm going to\ndo is we see we see you know this is an\nX leave it as it is X leave it we see an\nO down here change it to an X Change\nthis to an X this is already an X Etc\nchange this to an X and this is already\nan X when we get to this T we're going\nto ignore T's right we're only changing\nO's into X's right so that's the second\nphase of the algorithm first we marked\nT's now we're marking X's now the last\nthing we have to do take a look at our\nboard and take a look at the desired\nboard that we want to return what's the\nonly difference basically the UNS\nsurrounded regions we change them to T's\nbut we still want them to be O's so\nbasically again we're going to do a\ndouble scan we're a a a double four Loop\nscan through the entire grid right\nanytime we see a t we're going to change\nit into back into an O so basically this\nT over here would be changed you know\nback into an O and then we have the\ndesired board that we want and we can\naccomplish this we're going to have to\nobviously iterate over the entire board\nlike two or three times or something so\nthat overall time complexity let's say\nis going to be n * m where these are the\ndimensions of the board but that is the\nentire time complexity so I hope that\nthis solution makes sense to you so with\nthat being said I think we're ready to\ndive into the code now okay so now let's\nwrite out the code and you can see that\nwe don't have to actually return\nanything we just have to modify the\nboard in place with these two\ndimensional problems the first thing I\nusually like to do is just get the\ndimensions of the board so let's get the\nnumber of rows and let's get the number\nof columns I think we're guaranteed that\nthis board is always going to be\nnon-empty and I'm going to break this\nalgorithm up into three phases so the\nfirst phase is going to be to capture\nthe unsur rounded regions remember all\nthe regions that are uh connected to the\nBorder we need to capture them and\nchange them into T's so any o is going\nto be converted into a t for temporary\nor something you could do any kind of\nspecial character that you want the\nsecond phase is going to be to capture\nthe surrounded regions right and we can\ndo that with a double for Loop right\nwe're basically going to be converting\nO's into X's when we do this right all\nthe remaining O's are going to be\nchanged into x's and the last phase of\nthe algorithm is just going to be to uh\nuncapture those UNS surrounded regions\nso basically those t's are going to be\nconverted back into O's so these are the\nthree phases of the algorithm and by the\nway only the first phase is going to\nneed DFS the second and third phases are\ngoing to be four Loops only let's\nactually write out that DFS because\nwe're going to be needing it so let's\nwrite out a DFS for capture we're given\nsome coordinates let's call it row and\ncolumn we're only going to be converting\nO's into X's or O's into T's now the\nmain thing is the base case so let's\nwrite it out basically if we go out of\nbound so if row is less than zero or\ncolumn is less than zero row is equal to\nthe number of rows which means it was\ntoo big or column is equal to the number\nof columns which means it also went out\nof bounds and the other case is remember\nwe're only capturing O's so if the board\nat this position is not an O then we can\nalso return so a board at row column is\nnot equal to an O then we can also\nreturn so this has gotten to be a very\nlong line let me shorten it up a little\nbit so that is the main base case and\nthe uh rest of the function is pretty\neasy so if the base case did not execute\nthen we're going to be changing the uh\nvalue at this uh position changing the O\ninto a t so let's change it into a t and\nthen we're basically just going to run\ncapture in the four adjacent Direction\nso I'm just going to type that out you\ncould do it with a for Loop if you\nwanted to but I'm lazy let's just copy\npaste this a couple times so this will\nbe row minus one this will be column +\none and the next will be column minus\none so we're looking in all four\nadjacent directions and capturing only\nthe O's right because that's our base\ncase if we go out of bounds or if we get\nto something that's not an O we're not\ngoing to capture it this function is\nonly going to be run on the border cell\nso let's do phase one of the algorithm\nlet's do a double nested for Loop over\nthe entire grid even though this is not\nactually necessary because technically\nwe're only going to be looking at the\nborder of the grid but I'm just coding\nit up this way because it's short it\nshortens up the code a little so we're\ngoing to be iterating over the entire\nboard anytime we see a uh value that is\nan O right we want O's so if we get to\nan O and if this happens to be a border\ncell right so B basically we're looking\nfor all the UNS surrounded regions which\nare connected to the border and have O's\nright because O's are regions so the way\nI'm going to figure out if this is\nconnected to the border is basically if\nrow is in this pair of values either the\nrow is equal to zero or it's equal to\nthe number of rows minus one this is a\ngood way to do it in Python at least I\nthink so because we're basically doing\ntwo comparisons in one we're checking if\nrow is equal to zero or equal to this\nand we can also do it uh with another\nthing so we're we're checking if this is\nconnected to the border so we're saying\nif this is true and uh row Is On The\nBorder or uh the column is in the border\nso we can say column is either equal to\nzero or it's equal to columns minus one\nso if this is a border cell what are we\ngoing to do well we're going to capture\nthis region right so we can call our\nhelper function capture on this row and\ncolumn easy as that so we're already\ndone with phase one we've already\ncaptured all UNS surrounded regions\nconverted them into T's and the next\nportion of the algorithm is actually\ngoing to be very trivial because we're\nnot going to even need DFS we're just\ngoing to do a double nested for loop on\nthe entire grid and convert all O's into\nX's right that's all we got to do this\nis capturing the surrounded region so if\nwe ever see an O then we convert it into\na x right we don't even need to run DFS\non this because we don't even have to\nfigure out which regions are Sur rounded\nall remaining O's are guaranteed to be\nsurrounded regions last but not least we\nhave to do phase three of the algorithm\nwhich is just converting the t's back\ninto O's let me make some space so that\nwe can fit this all on one screen\nbasically that's going to be trivial as\nwell I'm just going to copy the above\nfor Loop that we did instead of checking\nif it's equal to an O we're converting\nT's into O's so if it's equal to T\nconvert it back into an O believe it or\nnot that is the entire algorithm I hope\nthis was broken down and easy to\nunderstand let's run it to make sure\nthat it works and as you can see on the\nleft yes this solution does work and it\nis pretty dang efficient so I really\nhope that this was helpful if it was\nplease like And subscribe it supports\nthe channel a lot and hopefully I'll see\n"
    },
    {
        "Name": "Course Schedule",
        "NcLink": "course-schedule/",
        "Pattern": "Graphs",
        "Description": "You are given an array `prerequisites` where `prerequisites[i] = [a, b]` indicates that you **must** take course `b` first if you want to take course `a`.\n\nThe pair `[0, 1]`, indicates that must take course `1` before taking course `0`.\n\nThere are a total of `numCourses` courses you are required to take, labeled from `0` to `numCourses - 1`. \n\nReturn `true` if it is possible to finish all courses, otherwise return `false`.\n\n**Example 1:**\n\n```java\nInput: numCourses = 2, prerequisites = [[0,1]]\n\nOutput: true\n```\nExplanation: First take course 1 (no prerequisites) and then take course 0.\n\n**Example 2:**\n\n```java\nInput: numCourses = 2, prerequisites = [[0,1],[1,0]]\n\nOutput: false\n```\n\nExplanation: In order to take course 1 you must take course 0, and to take course 0 you must take course 1. So it is impossible.\n\n**Constraints:**\n* `1 <= numCourses <= 1000`\n* `0 <= prerequisites.length <= 1000`\n* All `prerequisite` pairs are **unique**.\n",
        "Difficulty": "Medium",
        "Video": "EgI5nU9etnU",
        "PythonSolution": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        preMap = {i: [] for i in range(numCourses)}\n\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n\n        visiting = set()\n\n        def dfs(crs):\n            if crs in visiting:\n                return False\n            if preMap[crs] == []:\n                return True\n\n            visiting.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visiting.remove(crs)\n            preMap[crs] = []\n            return True\n\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n        return True\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nlook at a graph problem actually it's\ncalled\ncourse schedule we're given a total\nnumber of courses and these are our\nnodes and they're labeled from zero\nto n minus 1 basically so some courses\nhave\nprerequisites for example if you want to\ntake course 0\nyou have to first take course 1 and\nthat's represented as a pair\nor as an edge in our graph so if you\nwant to take course\nzero you have to first take course one\nand the only\nquestion we want to answer is is it\npossible for us to finish every course\nso let's just look at the first example\nwhere given number of courses are two so\nthat means we have one course\nzero and another course one we know that\nthe prerequisites are like\nthis meaning that if we want to take\ncourse one\nwe have to first take course 0 and i'm\ngoing to represent it as an\nedge going outward from 1\ninto 0. so what do they mean by possible\nlet's just run through each of our\ncourses and see is it possible to take\neach one\nso for zero is it possible to take zero\nwell we don't have any\noutward edges from zero so that means\nzero does not have any prerequisites so\nit is possible for us to complete course\nzero then we look at course one it has\none prerequisite which is\nzero and we know zero is possible to\ncomplete\nso once we finish course zero then we're\nallowed to take\ncourse one which has no other\nprerequisites right the only\nprerequisite was\ncourse zero so therefore both of these\ncourses are possible\nto complete so we can return true\nso let's look at an example where it's\nactually impossible so we're given\nn equals two that means we have two\ncourses\nzero and one and we're given two\nprerequisites so\none zero and zero one this one means\nthat if we want to finish course one we\nhave to first complete\ncourse zero so zero is a prerequisite\nthe second one means that if we want to\nfinish course\nzero we have to finish course one first\nso\none is a prerequisite of zero so the\nproblem with this\nis kind of obvious right there's a cycle\nso we if we want to finish course zero\nwe gotta go finish course one\nif we wanna finish course one we gotta\nfinish course zero and it just goes like\nthat\nforever so neither of the courses are\npossible to finish\nso in this case we return false\nso we can actually solve this problem\nusing\ndepth first search we can also use\nbreadth first search and i'm going to\nshow you\njust the depth for search version\nbecause i like it better\nso given this new example the first\nthing you want to do is visualize it so\ni'm going to draw a picture\nso we're given five nodes so we have\nzero one\ntwo three four that's five nodes\nwe're also given five prerequisites so\nin this case we end up having five\nedges right from zero to one zero to two\none two three one to four\nand three to four so my goal here\nis for each of these nodes i just want\nto know right for each of these\nclasses can we complete this course or\nnot\nand how do we know if a course can be\ncompleted well\njust looking at this picture is obvious\nright xero has a prerequisite\nof two but two does not have any\nprerequisites which is great\nit also has a prerequisite of one and\none has\ntwo prerequisites three and four\nthree has one prerequisite of four and\nfour\nluckily for us does not have any\nprerequisites\nso looking at this it's kind of obvious\nthat\nwe can complete all these courses so\nlet's do the algorithm to be able to\ndetermine that\nwe see that these are kind of our base\ncases right 2\nand 4 don't have any prerequisites\nthat's useful information but we don't\nneed a graph to tell us that\nwe can use a data structure called an\nadjacency list\nand i'm going to call it prerequisite\nmap because the\nwhat the data structure i'm going to use\nis a hashmap to represent this\nso for each of our courses we are going\nto have\na list of all of its prerequisites so\nfor zero we know\nzero has two prerequisites one and two\nand we're going to repeat that for every\nsingle course so for one\nwe know that two does not have any\nprerequisites so we can just put\nan empty list over here 4 also does not\nhave any prerequisites so we get another\nempty list so now we're going to run\ndepth first search on\nevery single node i'm going to do it in\nthe order from\nzero to n minus one so\nbe starting at zero so we're going to\nrun debt first search on it right\nhow are we gonna do the depth first\nsearch well we have our prerequisite map\nso we're gonna do it recursively we see\nthat it has two prerequisites\none and two so now let's run depth first\nsearch\non the first neighbor\none so now we look at one we see that it\nhas two neighbors\nthree and four so let's recursively run\ndepth first search\non its first neighbor three so since\nthree is a prerequisite of one\nnow we wanna know if we can take we can\ncomplete course three\nso we look at its prerequisites it only\nhas\none four so now we're going to check\nit's only prerequisite\nfor can we complete course four and then\nwe want to look at the prerequisites\nof course for which we know are empty\nthis is good right so now we see that\nthis is empty\nso what does that tell us that tells us\ncourse 4\ncan be completed which we basically\nalready\nknew because course 4 has an empty\nuh empty prerequisite list so i'm just\ngoing to put a little\ncheck mark here to say that we know\ncourse 4\ncan be completed and so recursively\nwe're going to\nend up going back to our three and we\nsee that it only had\none prerequisite and we were able to\ncomplete that prerequisite for\nso therefore three is also\na course that can be completed and so\nwhat we can actually do\nis from its prerequisite list we see\nfour we can just remove the four we\nknow it can be completed and so i'm\nrepresenting that\nby having an empty list here right just\nan empty list means that it has no\nprerequisites therefore it can be\ncompleted so i removed the only\nprerequisite that three\nhad then from three we can actually go\nbackwards to one which we see here\nwe can kind of get rid of this 3 because\nwe know\n3 can be completed and then from the 3\nwe're going to end up going to 4 to\ncheck again\nif 4 can be completed because it is a\nprerequisite\nof one and since we already know four\ncan be completed we can get rid of that\nas well so now we know for sure that one\ncan also be completed and now\ni'm gonna go back to zero which is where\nwe how we even got to one in the first\nplace and we look at the prerequisites\nof zero\nwe see one is no longer a prerequisite\nbecause we\nbasically know that one can be completed\nbut we still have to look at this\ntoo so then we're gonna go to the last\nunvisited node in our entire graph which\nis\ntwo so now we've gotten to the last\ncourse two we see it's an empty list\nright\ntherefore two can be completed it has\nno neighbors it has no prerequisites so\ni can put a little check mark here\ntwo can be completed and then we can\nfinally go\nback to our original node 0\ncross out its last prerequisite which\nwas\n2 and now when we look at 0 even\n0 has an empty list of prerequisites\ntherefore we know zero can be completed\nso since we were able to complete every\nsingle\ncourse that that means we can return\ntrue\nevery course is completable and the time\ncomplexity for this\nis going to be big o the\nnumber of nodes we have which is n i'll\nuse\nn as that and i'll use p for the number\nof prerequisites that we had\nbecause if you notice in this graph we\nhave to\nwe have to visit every single node\nand we have to visit and we have to move\nalong\nevery single edge and once we get rid\nof the prerequisites from here we don't\nreally have to\nvisit a course twice because once we\nknow it can be completed\nwe we can instantly do that we don't\nhave to go through its prerequisites\ntwice\nso i'm gonna show you one last example\nthis is the example\nthat what we're going to do how are we\nactually going to detect this loop\nbecause we see\nso i'm just going to cross this stuff\nout because we're looking at a different\nexample\nbut here we see that zero has a\nprerequisite of one\none has a preset pre-rec of two two has\na pre-rec of 3. so this is a loop\nwe cannot complete these courses but how\ncan we actually\nhow can we actually detect this loop i'm\ngoing to show you how really quickly so\nto detect a loop i'm going to use one\nlast data structure and it's going to be\na\nset though i think you could just use an\narray if you want to call it the visit\nset and all it's going to contain is the\nlist\nof courses that we're currently visiting\nalong\nour depth first search so let's say we\nstart at 0 then we add zero\nto our visit set we take a look at the\nprerequisites of zero we see it as one\nprerequisite so then we\nmove to one so now we visit one\nso we're going to add one to our visit\nset and we look at the prerequisites of\none it has one prerequisite two so then\nwe\nmove to two we run debt for search on\ntwo\nso to do that we have to first visit two\nso\ntwo is also going to be added to our\nvisit set and lastly\nwe see two has one prerequisite of zero\nso then we of course want to\nvisit zero and so now we're going to\nvisit\nzero twice but you see that zero is\nalready in the visit set therefore we\ndetected\na loop therefore we have to return\nfalse these courses cannot be\ncompleted so now let's finally look at\nthe code so\nthe first thing i want to do is create\nour pre-map\nso our list of prerequisites so we know\nfor each\ncourse initially we can set it to an\nempty list so an empty list of\nprerequisites and we want to do that for\nevery course that we got which the\nnumber of that is just\nnumber of courses so this is if you're\nnot familiar this is some python stuff\ni'm just saying that for every course\ninitially we want to map it to an\nempty list and we know that the\nprerequisites are actually contained in\nthis\nnested list variable so let's iterate\nthrough that let's get each\ncourse prerequisite pair from that list\nand then just start appending them so\npre-map\nof course we want to append to this list\nthis prerequisite so we also want a\nvisit\nset which is going to store\nthe it's going to store all the courses\nalong the current depth first search\npath and of course it's initially just\ngoing to be empty so since we're going\nto do this\nrecursively i'm going to define a nested\nfunction depth first search inside of\nour can finish function because then\nwe'll have access\nto all these variables without having to\npass them in as a parameter\nthe only parameter that we have to pass\nin is the current\ncourse that we're visiting and so like\nmost recursive functions we want to look\nat our base cases first the first\nbase case is if course is in\nthe visit set already so what this\nmeans is that we're visiting a course\ntwice\nso we detected a loop so we can return\nfalse meaning that this course cannot be\ncompleted\nthe other base case we know is if\nthe prerequisites of this course happen\nto be an\nempty list what that tells us is that\nthis course\nhas no prerequisites and we can return\ntrue because it can definitely\nbe completed if neither of these\nconditions that\nis satisfied then we can take this\ncourse\nand add it to our visit set because that\nmeans we are currently visiting this and\nwe're going to recursively run debt\nfirst search\non its prerequisites so i'm gonna loop\nthrough the prerequisites of this course\nfor each one i'm gonna run debt for\nsearch on it\nso debt first search on this\nprerequisite if it happens to return\nfalse though then we know we can return\nfalse immediately we don't have to wait\nbecause if we find\none course that can't be completed then\nwe can return false for the entire\nfunction\nso i forgot to put a not over here so if\nnot meaning if\nit returns false then we return false\nbut if this does not execute that means\nit's a course that can be taken and\nwe want to return true in that case but\nbefore we return true we want to remove\nit from our visit set\nbecause we are no longer visiting this\nwe've already finished visiting it\nso visit remove this course\nand also since we know this course can\nbe visited\nwhat we can do is say pre-map we can\nset it to an empty list so that\nif if we ever have to run debt first\nsearch on it again\nwe will in that case execute this\ncondition\nand return true immediately we will not\nhave to repeat\nall this work of running debt first\nsearch on\nits neighbors so that's all for our debt\nfor search function\nthe function is done all we have to do\nis call it now\nbut we have to potentially call it for\nevery single\ncourse in the number of courses that we\nhave\nand if any of them happen to return\nfalse\nthen we have to return false immediately\nand if they don't return false then we\ncan return\ntrue all courses can be completed\nand the reason we are looping like this\nis mainly because\nwhat if our graph is not fully connected\nlike what if we have a graph like this\none has a prerequisite of two\nand maybe three has a prerequisite\nof four so these are two separate\ngraphs that are not connected right so\nwe have to ch we have to\nmanually iterate through every course\nand check\ncan one be completed can two be\ncompleted can three\nand can four be completed so this is the\ndepth first search\nsolution you can see that it does run\nvery efficiently about as efficiently as\nthe breadth for search solution as well\nand i hope this was helpful if it was\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Course Schedule II",
        "NcLink": "course-schedule-ii/",
        "Pattern": "Graphs",
        "Description": "You are given an array `prerequisites` where `prerequisites[i] = [a, b]` indicates that you **must** take course `b` first if you want to take course `a`.\n\n* For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nThere are a total of `numCourses` courses you are required to take, labeled from `0` to `numCourses - 1`. \n\nReturn a valid ordering of courses you can take to finish all courses. If there are many valid answers, return **any** of them. If it's not possible to finish all courses, return an **empty array**.\n\n**Example 1:**\n\n```java\nInput: numCourses = 3, prerequisites = [[1,0]]\n\nOutput: [0,1,2]\n```\n\nExplanation: We must ensure that course 0 is taken before course 1.\n\n**Example 2:**\n\n```java\nInput: numCourses = 3, prerequisites = [[0,1],[1,2],[2,0]]\n\nOutput: []\n```\n\nExplanation: It's impossible to finish all courses.\n\n**Constraints:**\n* `1 <= numCourses <= 1000`\n* `0 <= prerequisites.length <= 1000`\n* All `prerequisite` pairs are **unique**.\n",
        "Difficulty": "Medium",
        "Video": "Akt3glAwyfY",
        "PythonSolution": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        prereq = {c: [] for c in range(numCourses)}\n        for crs, pre in prerequisites:\n            prereq[crs].append(pre)\n\n        output = []\n        visit, cycle = set(), set()\n\n        def dfs(crs):\n            if crs in cycle:\n                return False\n            if crs in visit:\n                return True\n\n            cycle.add(crs)\n            for pre in prereq[crs]:\n                if dfs(pre) == False:\n                    return False\n            cycle.remove(crs)\n            visit.add(crs)\n            output.append(crs)\n            return True\n\n        for c in range(numCourses):\n            if dfs(c) == False:\n                return []\n        return output\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\ncourse schedule two and if you haven't\nalready seen i've actually solved the\nfirst one which i recommend\nwatching that video or at least solving\nthat problem before you try to solve\nthis one it's a little bit more\ndifficult\nbut it's also very similar so we are\nagain given\nn courses labeled from 0 to n minus 1\nand these are basically going to be the\nnodes in our graphs so this is a graph\nproblem and again some courses have\nprerequisites\nso course a has a prerequisite of course\nb and what that means is you have to\ntake\ncourse b before you take course a so\nthat's pretty intuitive right\nand so instead of knowing if we can take\nevery single course\nin this problem we want to know for all\nof the courses\nand all of the prerequisites that we're\ngiven we want to return the order\nof courses that we would take in order\nto finish\nall the courses so we care about the\norder but there's one little subtlety\nit's possible that we can't take\nall courses given the prerequisites so\nif it's\nnot possible we have to return an empty\narray so we have to\nwe have to determine if it's even\npossible and then we have to return the\norder\nso this example is pretty simple we're\ngiven two courses zero\nand one and the prerequisite is so in\norder to take course one\nwe have to first take course zero so\nthen in that case what's the order\nof course we have to take zero first and\nthen course one\nso the output is going to be zero one\nwhich is exactly what we have\nover here now what if i added one more\nprerequisite so what if i said\nokay to take course zero we are required\nto take\ncourse one as well what does that mean\nthat means\nokay the first prereq tells us that to\ntake\ncourse one we have to take course zero\nand the second one tells us to take\ncourse zero we have to take\ncourse one now look at this is it\npossible to take\nthese courses it's not to take course\nzero we have to take course one to take\ncourse one we have to take course zero\nthere's no\nvalid order so we return an empty array\nand we know to return an empty array\nbecause\nwe have a cycle in\nthis graph right there's a cycle that\ntells us that it's not possible\nso now let's actually look at the\ngeneral algorithm for it and it's\nactually\ntopological sort this is a standard\ngraph algorithm but you actually\ndon't even need to know what this\nalgorithm is when you solve this problem\nthis\nproblem actually teaches you what\ntopological sort\nis so similar to course schedule one\nwhat we're gonna\ndo is starting at every single node\nwe're gonna run\ndepth first search on the node so let's\nstart at node zero let's run depth first\nsearch on it\nto do that we would before we do that we\nwould need to build an adjacency list\nso for each node we would need to know\nits neighbors\nso for course 0 we would need its\nneighbors which are going to be\n1 and 2. basically it's prerequisites\nright that's going to be\nthe prereq map so it's an adjacency list\nso i'm just going to quickly write that\ndown\nso now we have our prereq map right it\ntells us for each\nnode what are the prerequisites so zero\nright has two prerequisites one and two\nbecause it has two\noutgoing edges to one and two\none has a single prerequisite three two\nhas\nno prerequisites right because look it\nhas two incoming edges but it does not\nhave any\noutgoing edges so it does not have any\nprerequisites three has a single\nprerequisite of two\nfour has a single prerequisite of zero\nand\nfive also has a single prerequisite of\nzero\nand so we are going to build the output\nwe're gonna do depth for search\nstarting at every single node and\nremember the output we're trying to\nbuild is the order\nin which we can take courses so just by\nlooking at it you can tell\nokay zero has two prerequisites one and\ntwo\nso of course we're gonna need to take\none and two before we end up taking\nzero but let me show you the algorithm\nso let's start at zero we don't update\nour output yet we want to take the\nprerequisites\nfirst so let's go to one of the\nprerequisites\nby which we can tell from our prereq map\nso we're gonna be at node one right now\nand\none has a single prerequisite three so\nwe're gonna need to take the prereq\nbefore we can take\ncourse three and now we see three has\na prereq of two a single prereq so all\nwe have to do is take\ncourse two before we take three so now\nwe are\nat course two and lovely that it does\nnot have\nany prerequisites what does that mean\nfor us\nso so far we've taken a path we've gone\nfrom zero to one to three\nall the way to two and now we don't have\nany more prereqs\nso we are allowed to take course two\nright it does not have any prereqs we\ncan add it to our output so i'm going to\nadd\na 2 to our output and so what i'm going\nto do now is\ncross out 2 because we never have to\nvisit it\nagain because once we've added 2 to our\noutput we don't want to add\n2 twice right there's no need to add a\ncourse\nto our output twice so i'm going to\ncross it out\nso we are never going to visit this node\nagain and now i'm going to in our depth\nfirst search i'm going to go\nback to where we came from we came from\nthis three\nso now that three look it does not\nthree does not have any more prereqs\nright we've already visited two\nit doesn't have any more prereqs so we\ncan also\ncross it out we never have to visit it\nagain and we\nadd it to our output and i'm just gonna\nrepeat this process\nall the way along our green path that we\njust\nwent along so we're gonna go back to one\none\nwe just visited three we are never gonna\nvisit it\nand one has no prerequisites anymore so\nwe can add this\nto our output and we go all the way back\nto zero now hold on a second so look\nzero has two prerequisites one and we\nalready visited one\nbut it has one more prereq two so\nlet's go to two but we see\nright we already visited it we don't\nhave to do it again we can cross this\nout\nwe can cross this out so in reality zero\ndoes not have\nany prerequisites remaining so what do\nwe do we add\nzero to our output now in reality\nour our algorithm is going to say okay\nwe ran depth first search on zero so now\nwe're going to run debt for search on\none but we know that we already did that\nright we already recursively did that so\nwe don't have to do it\nand actually before i forget since we\nadded zero to our output let's cross it\nout so we ran debt for search on xero\nwe're gonna try to run debt for search\non one but we know we already did that\nwe're gonna try to run debt for search\non\ntwo but we know that we already did that\nwe're gonna try to run debt for search\non three\nbut we know that we already did that so\nnow we're going to try to run debt for\nsearch on four which we haven't visited\nyet\nand let's just use our common sense from\njust looking at the graph we can see\nthat okay\nwe need to take these courses in this\norder two\nthree one zero what about four and five\ntechnically they both have a single\nprerequisite of zero right so once we\ntake zero\nwe can take four and five but we can do\nit in\nany order right we can take four or five\nor we can take\nfive four it doesn't matter because\nthese courses aren't a prerequisite of\neach other\nbut the way our algorithm is gonna work\nwe are gonna start\nin order so we're gonna go at four we're\ngonna see\nit has a single prerequisite of zero\nright we can see that in our prereq map\nand we know we know that we already took\ncourse two so we can also say okay\ncourse four has also been taken we've\ndone the prerequisites we can take\ncourse four and we're going to do the\nexact same thing with five now we're\ngoing to try to see look it has a single\nprorack\nzero we've already done that so now\nwe're allowed to take\ncourse five so this is the topological\nsort of this graph and we know that the\ntopological sort is not necessarily\nunique right like this\ncould have been a five and a four so\nit's not unique\nand we also know that if we detect any\ncycles\nwe have to return an empty list\nbecause because that means that a\ntopological sort\nis not even possible and by the way\nsince we are visiting\nevery single node and every single\nvertex or rather every single edge right\nwe have to travel along\nevery single edge i think at least twice\nand we're probably gonna visit every\nsingle node\nup to two times so it is going to be\na so the time complexity is going to be\nthe number\nof edges plus the number of\nvertices or by vertices we also mean\nnodes\nso we could also write this as o of p\nwhere p is the number of prerequisites\nwhich is actually the number of\nedges and plus n where n\nis the number of courses which is also\nequal to the number of vertices\nand one last thing how would we actually\ndetect a\ncycle like with our algorithm well let's\nsay we had a\ncycle so let's say two actually did have\nan outgoing node and it had a node\nall the way to zero in that case what\nour algorithm would do is okay we're\nstarting at zero we're gonna go\nto one just like we did previously then\nwe're gonna go to three just like we did\npreviously then we're gonna go to two\njust like we did previously and then\nlastly\nstarting at two we're gonna go to its\nonly outgoing edge which is at zero\nand at that point what our algorithm is\ngonna do is it's gonna see okay\nwe started at zero we remember that\nthis is the path that we've taken we\nwent all the way\naround and we landed back at zero so\nthis means we have a cycle\nthat means we stop our algorithm\nimmediately and return an\nempty list we do not have to continue\nand the way\ni'm gonna handle this is i'm gonna use a\nhash set\nand with the hash set i'm going to\nbasically remember our current\npath so we were we know we can recognize\nwhen we detect a cycle so now let me\nactually show you the code\nokay so now let's write the code the\nfirst thing we want to do is build an\nadjacency list with the prereq\nso i'm going to do that prereq and in\nsome python what i'm going to initially\ndo\nis for every course i'm going to map it\nto an empty list so initially it's going\nto be\na empty list of prerequisites and now\ni'm actually going to fill it in so\nwe're going to\niterate through every single course\nprereq\npair in our prerequisites list that\nwe're given\nso for this pair in our prerequisites\nlist\ni'm going to say prereq of this course\nlet's add that to our list so append it\nto our list and this might not have been\nclear from\nmy picture but a course has three\npossible states one where it's already\nvisited right that's where i crossed it\nout in red it's already been added to\nthe output\nit's been visited we do not have to ever\nconsider it again\nthe next state is visiting\nright so it's currently being visited\nthat's the green path and that's what's\ngoing to allow us to detect\nif we have a cycle and the last is\nunvisited meaning a course has not been\nadded to the output and it's not\ncurrently along\nthe the visited path so that's that's\npretty self-explanatory\nso i'm going to obviously create an\noutput list which is going to be empty\ni'm also going to have\ntwo sets one visit set and one cycle set\nso these sets are going to allow us to\nknow if a\nnode or course has already been visited\nor if it's currently\nalong the given path which this is the\ncycle is obviously going to let us know\nis going to help us detect cycles now\ni'm going to define\nour depth first search function i'm as\nyou can see i'm doing it inside of\nanother function\nbasically so i don't have to pass all\nthese parameters\ninto this and all of these variables\nwill be accessible\ninside this function so the only thing i\nhave to pass in is the course number\nthat we're currently visiting so the\nfirst thing i want to do is detect a\ncycle so if this course\nis already inside of our cycle set that\nmeans we're visiting\nit twice that means we've detected a\ncycle that means\nwe're going to return false and then\nwe're going to be able to\nterminate our algorithm and return an\nempty list if a course has already been\nvisited\nthat basically means we don't need to\nvisit it twice\nso i'm going to return true we're not\ngoing to you know stop our algorithm\nand return an empty list but we don't\nneed to visit this course\ntwice now i'm going to recursively run\ndebt for a search but before we do that\nwe do have to add this course to our\ncycle we want to be able to know\nif we have a cycle so if we ever see\nthis course again\nyou know recursively we'll know that we\ndetected a cycle but for now we're going\nto go through\nevery prerequisite of this course so\nfrom our prerequisite map\nwe're going to get all of the\nprerequisites we're going to run\nrecursively depth first search on this\nprerequisite\nand if that returns false because we\nknow we have two return values true and\nfalse\nif it returns false we know we just\ndetected a\ncycle so in that case if this equals\nfalse we have to\nalso return false if it doesn't equal\nfalse it equals true then we're just\ngoing to continue\nto go through all the prerequisites and\ncontinue to\nrun up for search and when all of that\nis said and done\nwe will take from our cycle we're going\nto remove the course because it's no\nlonger\nalong the path that we're going so we\ncan remove it from\ncycle we can also add it to visit\nbecause we just\nwent through this course and we went\nthrough all of its prerequisites\ntherefore we can say that it's been\nvisited\nand since this course has been visited\nwe can finally\nadd it to our output which was our\nultimate\ngoal so we can add it to our output\nbecause we just\nwent through all of its prerequisites\nand from those prerequisites we just\nadded them to our output\nso now we are allowed to add this course\nto our output\nwe can only add a course after we've\nadded its prerequisites right\nand since we added this to our output we\nknow it's a course we're allowed to take\nso we can return true not false we're\ngoing to return true\neverything was fine because since we're\nreturning true we know that this never\nexecuted so we never had to return false\nwe ultimately returned true so now we've\nbasically written\nall the code that we need we just have\nto execute it so\nwe have to go through every\ncourse in the given number of courses\nand we're going to do it in order but\nyou technically could do it in\nany order and what we're going to do is\nrun debt first search on every single\ncourse\nbut we do have to check if the return\nvalue\nof any of these calls happens to be\nfalse what that means is we detected a\ncycle\nand what that means is we are forced to\nreturn an\nempty list we're not going to return\noutput we're going to return an\nempty list because we because it's\nimpossible to take the given courses\nbut if this never executes meaning the\ndebt for search\nnever detected a cycle this will never\nthis will never execute and the loop\nwill be finished running\nand when that happens we know we can\nreturn the output that we spent all our\ntime building\nand the output will be in the order that\nwe want it to be\nso that's the algorithm let me delete\nthese comments so you can see the entire\ncode\non one page so this is the entire code\ni'm gonna run it and show you that it is\npretty efficient\nokay whoops one little bug output is a\nlist\nso the function to add elements to a\nlist is actually append\nso with that working hopefully i don't\nhave any other typos and yes\nyou can see that this is a very\nefficient algorithm\nthis is topological sort but you might\nnot even recognize that\nand there are different ways to write\nthis so i prefer writing it like this\nbecause\nit keeps things pretty simple right we\nonly have two sets we don't have to\nremember\ncolors or other ways of solving this\nproblem\nbut i hope it was helpful if you enjoyed\nplease like and subscribe it supports\nthe channel\na lot and i'll hopefully see you pretty\nsoon\n"
    },
    {
        "Name": "Graph Valid Tree",
        "NcLink": "valid-tree/",
        "Pattern": "Graphs",
        "Description": "Given `n` nodes labeled from `0` to `n - 1` and a list of **undirected** edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n\n**Example 1:**\n\n```java\nInput:\nn = 5\nedges = [[0, 1], [0, 2], [0, 3], [1, 4]]\n\nOutput:\ntrue\n```\n\n**Example 2:**\n\n```java\nInput:\nn = 5\nedges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]\n\nOutput:\nfalse\n```\n\n**Note:**\n* You can assume that no duplicate edges will appear in edges. Since all edges are `undirected`, `[0, 1]` is the same as `[1, 0]` and thus will not appear together in edges.\n\n**Constraints:**\n* `1 <= n <= 100`\n* `0 <= edges.length <= n * (n - 1) / 2`\n",
        "Difficulty": "Medium",
        "Video": "bXsUuownnoQ",
        "PythonSolution": "class Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        if not n:\n            return True\n        adj = {i: [] for i in range(n)}\n        for n1, n2 in edges:\n            adj[n1].append(n2)\n            adj[n2].append(n1)\n\n        visit = set()\n\n        def dfs(i: int, prev: int) -> bool:\n            if i in visit:\n                return False\n\n            visit.add(i)\n            for j in adj[i]:\n                if j == prev:\n                    continue\n                if not dfs(j, i):\n                    return False\n            return True\n\n        return dfs(0, -1) and n == len(visit)\n    ",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve a problem\ngraph valid tree so this is another leak\ncode premium problem so we are going to\nbe solving it\non lint code because it's free on that\nwebsite so we are going to be leveraging\nthat\nand also this is another problem from\nthe blind 75\nlist so this is graph valid tree so we\nare going to be filling in one more\nproblem from that blind 75 list today\nso this is a graph problem we are given\nn\ninput nodes labeled from zero to n\nminus one and we're given a list of\nundirected edges the undirected means\nthat the edges will go both ways so you\nknow we have\na couple nodes like this so the edge\ncould go in either direction\nand we just want to write a function to\ncheck whether these edges and nodes\ncreate\na valid tree or not so we know it's\ngoing to be some kind of graph right\nit could the graph could look something\nlike this right we don't care\ntoo much about the values here but let's\nsay this was the shape of a graph\ndoes this count as a tree well yeah this\nis a pretty familiar looking tree right\nso we would say yes this\nis a tree but if i add one more edge\nlike\nthis one is this a tree it's not\na tree and the reason being is because\nwe have a\nloop inside of this graph trees are not\nallowed to have loops that's just\nsomething that you you know you just\nhave to kind of know the definition of\nbecause in this problem they don't tell\nyou what exactly is the definition\nof a valid tree so we know trees can't\nhave\nloops and there's one more condition for\nit to be a tree a tree\nneeds to be connected so for example if\ni had a graph that looks like\nthis this is not a tree because\nevery node is not connected right like\nthis node over here is just by itself\nit's not connected with the rest of the\nnodes\nso for it to be a valid tree we can't\nhave\nloops and every node needs to be\nconnected\nso simply we can take our input nodes\nand our edges\nand then check are they connected and do\nthey\nnot have a loop and to be able to do\nthat so\nyou can see the format that we're given\nour edges in but\nwe want to use these using these edges\ncreate an adjacency list so basically\nfor each node for example you know one\nwe want to know what neighbors does one\nhave in this example\none only has a single neighbor right and\nthat's zero\nwhat neighbors does two have in this\ncase two has a single neighbor and it's\nzero that's basically what we wanna do\nwe wanna create a list\nof neighbors for every single input node\nand once we get that it'll be easy to\ntraverse the graph and then we can\nperform our check to make sure that it\nis a tree\nso let's say we were given a graph like\nthis is this a valid tree well just by\nlooking at it we can tell\nyes that it is but what kind of\nalgorithm can we do to determine that\nwell let's start at any node in this\ngraph we're always just going to choose\nnode 0 because it's you know the\nsmallest value every single graph is\ngoing to have at least a node 0 if we\ndon't even have node 0 like if we if the\nnumber of nodes\nif we don't have any nodes at all then\nwe can return true basically an\nempty graph does count as a tree\ntechnically\nbut so in this case we don't have an\nempty graph so we're going to start at\nnode\n0. what are we going to check basically\nwe're going to do a standard\ngraph traversal you could do breadth\nfirst search but i'm going to do\ndepth first search and so for every\nsingle node we're basically going to go\non and visit its neighbors recursively\nand then\ncontinue to do that until we visited\nevery single node that's connected\nto the zero node at the end what we're\ngoing to do is\ntake the number of input nodes that we\nwere given in this case it's 5\nand then we're going to check if the\nnumber of visited nodes\nmatches if the number of visited nodes\nmatches the input value for nodes that\nmeans that\nevery every node inside the graph is\nconnected right that's one of the things\nwe're looking for is\nis the graph connected if the number of\nnodes we visit\nmatches the number of nodes given to us\nwe can guarantee that that graph\nis connected the other thing we're going\nto check for is to make sure that this\ngraph\ndoes not contain any cycles or loops\nif we ever encounter a cycle like for\nexample you know we have an edge like\nthis\nif we went here we went here we weren't\nhere and then we got back to zero\nthat counts as a cycle then we would\nhave to return false immediately but if\nwe don't reach a cycle\nand this condition ends up being true\nthen we're going to return true\nso since we start at 0 what we're going\nto do is to\nour set of visited nodes it's going to\nbe a hash set because that's the most\nefficient way to do\nit so we're going to add that node 0\nbecause 0\nhas been visited so then we're going to\nrecursively go to\nits first neighbor 1 so now we're going\nto be at 1 right and from from the\nperspective of 0\nwe're gonna visit one after we're done\nwith that we're gonna visit two then\nwe're gonna visit three bills first\nwe're gonna start at one so now we're at\none right\nwe're gonna go ahead and add one to the\nvisit set\nand we notice one has two neighbors\nright\nit has a neighbor 0 and it also has a\nneighbor\n4. now one problem with our algorithm is\nfor every node including 1 we're always\ngoing to want to visit\nevery single neighbor it has we know\nthat the neighbor\nzero has already been visited right so\nif we end up going\nback here we're gonna see okay we're\nvisiting zero again\nzero happens to be in our visit set so\nthat means we detected a loop\nbut technically this graph does not have\na\nloop so how can we get around this edge\ncase if\nevery time we visit a node like one\nwe're going to end up going\nback to where we came from and that's\nalways going to give us a false\npositive of detecting a loop it's going\nto be a false positive for a loop\nhow can we get rid of that well every\ntime we visit a node such\nas 1 what we're going to give it is one\nadditional value\nand that's going to be previous previous\nis gonna be what the\nprevious node we just visited was\nso when we get to one we're gonna say\nthe previous node that we\nvisited was zero so we're not gonna go\nback\nto zero from this position if there\nhappened\nto be another way back to zero for\nexample let's say four\nended up connecting to zero then we\nwould detect a loop right\nbut one if we ever got to four we would\nsay okay the previous value\nfrom four will happen to be one right so\nthis four\ncame from one so so we won't get any\nfalse positives if we do it like this\nso from one the only node we're gonna\nvisit is gonna be\nthe neighbor four so yes we're gonna go\nto four now and we're gonna see okay is\n4\nalready visited it's not so let's add it\nto the visit set so\n4 is going to be added as a node that's\nbeen visited\nnow we know the previous node from 4\nhappened to be 1 right so we're never\ngoing to go back directly to 1\nwe're going to skip that and we're going\nto check does 4 have any other neighbors\nit does not\nso this is going to be our base case for\nour debt for search we're going to\nreturn\ntrue because so far we have not\nencountered a loop so we can return true\nif we did encounter a loop then we would\nhave to return false but so far we're\ngood we're gonna return\nand then we're gonna get to one and from\none we have no more neighbors left to\nvisit either so then we're gonna return\nback to zero and by the way what kind of\nprevious value would we\nfeed into zero because it's going to be\nthe first value we end up\nit's going to be the first node that we\nend up visiting so we can give it a\ndefault previous value of negative one\nbecause we know that no nodes in the\ngraph are actually going to have a value\nof negative one because they start at\nzero\nso now let's go to the next neighbor of\nzero we'll go down to two\nokay check has two been visited it\nhasn't so let's add it to our visit set\ntwo is being added\nnow two does not have any additional\nneighbors it only has that neighbor that\nit came from\nnode zero so we're we're not going to\nkeep going and then we're gonna go to\nthe last neighbor of zero we're gonna go\ndown to\nthree and once again check has three\nbeen visited it hasn't\nso then we're gonna add three to the\nvisit set then we're gonna go back to\nzero\nand then zero does not have any\nadditional neighbors so now we're done\nwe didn't detect a loop so that's good\nbut let's make sure that the graph\nis connected it does the so the number\nof input nodes we were given is always\ngoing to be given as a parameter it was\nn\nequals five now let's check the length\nof this visit set\nbecause that tells us how many nodes are\nconnected and it happens to exactly be\nfive right so in this case we are going\nto end up returning true\nnow if i change the graph let's say this\nedge did not exist\nof course then we would not have visited\nthis three node\nthen you know the length of our set\nwould have been four but the\nn value was five so does n equal four\nthe size of our visit set no\nthat does not match right so therefore\nin this case we would have to return\nfalse we didn't detect a loop but\nthe graph is not connected so we have to\nreturn false because it's not a valid\ntree\nand similarly let's say we had an\nadditional node from\nfour to zero then in our debt for search\nwhat we would have done\nis okay we have gone to zero and then\nwe're visiting zero so we check\nis zero already in our visit set yes it\nis zero is right here so that means\nwe're visiting\nit twice that means we detected a loop\nthat means we return false\nimmediately so that's the main idea of\nthis algorithm\nnow the time complexity since we're only\nyou know having to traverse each node\nonce at most once and each edge at most\nonce\nthe overall time complexity is going to\nbe number of edges\nplus the number of vertices or nodes so\njust e\nplus v and that's also going to\nbasically be the memory complexity as\nwell\nbecause this is we're going to be doing\nthis recursively\nand we're also going to be needing to\ncreate an adjacency list\nof connecting every single node to all\nof its neighbors\nand i think it'll be if it's not super\nclear right now i think it'll be pretty\nclear once i show you the code it's not\ntoo bad let's get into it\nso one base case is if we aren't given\nany nodes at all so if n was zero so\nin that case we would return true\nthere's no graph to traverse\nbut an empty graph does technically\ncount\nas a tree and if\nwe do have some nodes then we're going\nto create an adjacency list so\nwhat i'm going to do isn't first of all\nfor every single node\nin our input so basically n is the\nnumber of nodes\nso for i in range n i'm going to create\na pair\nin our hash map and each pair is going\nto be\nthe value of that node and an empty list\ninitially\nand then i'm going to go through every\npair of\nnodes in every single edge so\nan edge is basically a pair of nodes\nbeing connected right so what i'm going\nto say\nis and remember these edges are not\ndirected so they go both\nways so for the adjacency list of n1\ni'm gonna append n2 to that list and\nsimilarly for the adjacency list of n2\ni'm gonna append n1 and then i'm going\nto start defining our depth first search\nremember we are going to pat we are\ngoing to know which node we're visiting\nso i'm going to use\ni as the value of the node that we're\nvisiting remember we're also passing in\none other variable the previous node\nthat we came from so that we don't you\nknow get false positives\nfor loop detection and so you can see\ni'm defining this function inside of our\nouter function that just means i don't\nhave to pass\nin the variables like adjacency list\ninto this\neach time and actually i need to define\none more variable that's going to be\nvisit which is going to be a\nset which is going to keep track of all\nthe nodes we've visited so one base case\nis going to be if i is in the visit set\nthat means\nit's already been visited that means\nwe've detected a loop that means we can\nreturn\nfalse if not that means i hasn't been\nvisited so then we can go ahead and add\nit to visit so\nlet's add i and then let's go through\nevery single\nneighbor of i so every single node let's\ncall it\nj in the adjacency list so the list of\nneighbors\nof i and if j happens to be equal to the\nthe previous node the node that we came\nfrom then we're going to skip\nthis iteration of the loop we can do\nthat with the continue statement\nif it's not the previous node that we\ncame from then we're going to call debt\nfor search on this node j\nand as the previous value we're going to\npass in i because that's where we're\ncoming from when we arrive at node j\nnow if the return value of this is\nequal to false so if not the result of\nthis\nthen we're going to immediately return\nfalse because that means we detected a\nloop\nif this does not return false then we're\nbasically going to continue we're going\nto go through all the other neighbors\nof the node i and if we go through every\nsingle neighbor without returning false\nthen we can return\ntrue meaning we did not detect a loop so\nwe want to now return the result right\nand of course we know we're going to\nhave to call our debt for search\nfunction we're gonna start at node 0 and\nas a previous value we're going to pass\na negative 1 because negative 1 is never\ngoing to exist\nin our graph but is this enough remember\nour dip for search what it's returning\nas the true and false is only detecting\nif there's a loop like a cycle or not\nbut it's not making sure that the entire\ngraph is connected so\nwe're only going to return true if this\nfunction returns true\nand if n which is the input\nof the number of nodes exactly matches\nthe length\nof the visit set basically every single\nnode happened to be visited that means\nevery node is connected\nthat means the graph is a tree so only\nif both of these are true are we going\nto return true\nso this is the entire code and i can\nshow you if i slide this up a little bit\nthat this does run\nand it does run pretty efficiently so i\nhope that this was helpful we're\nbasically just doing a standard debt for\nsearch\non this graph and if this was helpful\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Number of Connected Components In An Undirected Graph",
        "NcLink": "count-connected-components/",
        "Pattern": "Graphs",
        "Description": "There is an undirected graph with `n` nodes. There is also an `edges` array, where `edges[i] = [a, b]` means that there is an edge between node `a` and node `b` in the graph.\n\nThe nodes are numbered from `0` to `n - 1`.\n\nReturn the total number of connected components in that graph.\n\n**Example 1:**\n\n```java\nInput:\nn=3\nedges=[[0,1], [0,2]]\n\nOutput:\n1\n```\n\n**Example 2:**\n\n```java\nInput:\nn=6\nedges=[[0,1], [1,2], [2,3], [4,5]]\n\nOutput:\n2\n```\n\n**Constraints:**\n* `1 <= n <= 100`\n* `0 <= edges.length <= n * (n - 1) / 2`\n",
        "Difficulty": "Medium",
        "Video": "8f1XPm4WOUc",
        "PythonSolution": "class UnionFind:\n\n    def __init__(self):\n        self.f = {}\n\n    def findParent(self, x: int) -> int:\n        y = self.f.get(x, x)\n        if x != y:\n            y = self.f[x] = self.findParent(y)\n        return y\n\n    def union(self, x: int, y: int):\n\n        self.f[self.findParent(x)] = self.findParent(y)\n\nclass Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        dsu = UnionFind()\n        for a, b in edges:\n            dsu.union(a, b)\n        return len(set(dsu.findParent(x) for x in range(n)))\n    ",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nnumber of connected components in an\nundirected graph\nand yes this is once again a problem\nfrom our blind 75 list\nthe link to the spreadsheet will be in\nthe description if you want to take a\nlook you can see about\n18 people are currently viewing it\nincluding me but\nso this is a problem problem 34 from\nthat list number of connected components\nso this is the graph one we'll be\nsolving today\nprobably tomorrow i'll finally go ahead\nand do alien dictionary\nso the main reason i've been putting off\nalien dictionary and even this problem\nis because i couldn't really find a free\nversion of these problems on the website\nlint code so i actually went ahead and\nand shelled out the\n35 bucks for a leak code monthly\npremium subscription so for the next 30\ndays i will have leak code premium so if\nyou have any premium problems that you\nwant to suggest feel free to do that in\nthe description\nbig shout out to my patreon supporters\nfor making this possible\nbut yeah so now let's actually get into\nthe problems so we're given a graph of\nn nodes pretty simple so far so the\nnumber of nodes will\nbe given to us with an integer n and\nwe're also just given an array of\nedges belonging to this graph every edge\nis undirected it connects two nodes\na and b together and all we need to do\nis just return the number of connected\ncomponents in the graph now what is a\nconnected component you probably already\nknow but it's basically just\nan individual portion of the graph\nthat's all contiguous\nsee how everything in this portion is\nconnected we also have\na second portion which is disjoint right\nso these two components are disjoint\nright they they are not connected to\neach other but\neach of them separately is connected\nright like every of these three nodes is\nconnected together\nthese two nodes are connected together\ntherefore we have two\ndifferent contiguous components so\nthere's not a lot of edge cases with\nthis problem it's pretty straightforward\nso for example if we were just given\ntwo nodes zero two no edges between them\nthen we would just return the number of\nnodes we're given two nodes\ntherefore we have two connected\ncomponents right one node by itself does\ncount as a connected component\nand of course if we're not given any\nnodes n equals zero then we return zero\nbut\nclearly this is pretty straightforward\nso far so there's a couple of ways to\nsolve this problem\nso we're given the edges as a list of\nedges but we could make an adjacency\nlist\nwhich would make it easy to do a dfs\nsearch on the entire graph so that's one\nway to solve this problem just go\nthrough every single node starting at\nzero right so we start at zero\nthen do a dfs search from here so we're\ngoing to mark\nzero as visited we're going to see okay\nwe can reach a one mark that is visited\nfrom the one we can reach a two mark\nthat as visited so so far\nwe've only done one dfs\nsearch right so therefore we found one\nconnected component now\nnow we are then going to try to do a dfs\nstarting from one\nright but what we're going to find is\nthat's already been visited so we don't\nwant to\nadd that to the number of connected\ncomponents right so so far we still only\nhave one connected component\nwe can do the same exact thing for\nsecond node for node number two it's\nalready been visited no need to\nincrement the number of connected\ncomponents\nthen we're gonna get to node three this\none has not been visited therefore now\nwe have\ntwo connected components so now let's\njust do a dfs on here to mark\nall of them visited three is visited it\nhas one neighbor four\nfour is visited and then there's none\nleft so we got two connected commands\nwe'll try to do a dfs from four but it's\nalready been visited so therefore\nwe in the end notice we only had two\nconnected components\nnow this isn't a bad algorithm at all\nthe overall time complexity is basically\ngoing to be\nit's basically going to be big o of e\nplus v because notice we are gonna have\nto go through every single\nedge when we traverse the graph end when\nwe actually build the adjacency list and\nwe're also gonna have to go through\nevery node\niterating through it as we traverse the\ngraph and as we you know\ntry to do the dfs starting at every\nsingle position so this is going to be\nthe overall time complexity\nnot bad at all but there actually\nhappens to be a more natural way to\nsolve this problem and if you have heard\nof the algorithm called\nunion find it's a pretty rare algorithm\nto need on leak code but if you do know\nthis algorithm\nthen you basically know that this\nalgorithm was literally made for a\nproblem like this\nliterally made to be able to count\nconnected components\nas well as to be able to identify you\nknow disjoint sets and all that stuff\nso i'm gonna use this problem as an\nopportunity to go over union find once\nagain i think i've done this once before\nin a previous problem but let's dive\ninto this so we're gonna mainly be\nmaintaining two\narrays one called the parent array and\nwe're going to have a value in that\narray for each node that we're given in\nthe input and initially\nthe array is just going to look like\nthis 0 1 2\n3 4. so each index so the index 0\nrepresents\nthe 0 node index one represents\nthe one node and the value in every\nsingle array clearly matches that\nof every single node initially at least\nso initially they do match\nwhat that basically means is each node\nis the parent\nof itself so the way union find works\nit's basically a forest of\ntrees so we're gonna have multiple trees\ninitially clearly we have\nn trees uh one for every single node\nin the input and as we go through every\nsingle edge such as zero and one what\nwe're gonna do is take okay let's say\nzero is gonna be the parent so zero is a\nparent of itself\nbut what we're gonna do to one is say no\none's parent now\nis going to be zero basically what we're\ndoing is just connecting\nthe two nodes right and since we know\nthat we just\nmade a single connection what we can say\nnow is that okay we started out with\nfive different connected components\nwe just merged two of them every time we\nperform a merge we're basically taking\nthe number of connected components we\nhave\ndecrementing it by one so that's how we\ncan keep track of the connected\ncomponents\nand there's one slight un and it's not\nrequired but it's an optimization that's\npretty easy to make with this problem\nwe're going to maintain the rank of\nevery single component so basically for\nevery single node we're going to\nmaintain\nwhat's the size of it basically you know\nif this is the parent what's the size of\nits entire connected component right now\nwhat we would\ninitially for each of them it's\nobviously going to be one right the size\nfor\nall of them is going to be one initially\nbut\nsince we just made this merge we're\ngoing to leave the rank\nof one as it is because it's not the\nparent but for the parent\nzero we can say okay it's rank is now\nnot\none it's actually going to be two really\nwe're just talking about the size\nif this was the parent which it is the\nparent right so what\nin our rank array we could change the\nfirst one\ninto a two and the reason we're\nmaintaining this rank is basically just\nan optimization\nso right now you can clearly see we have\none component of size two and we have\none component of size one if we were\nif we were merging these two right would\nwe want to merge\nthis one as a child of this one if we\ndid that\nwe would get something like this right\nwe'd get one\nand then zero right we'd get basically a\nlinked list so why would we do\nthat when we would rather merge the\nsmaller connected component\nunderneath the bigger one so if we do\nthat we'll get something like this\nright and clearly here you can see if\nthis was a tree the height of the tree\nis now minimized before we had a tree\nthat was basically a linked list now we\nhave a tree that's actually kind of a\nbinary tree if you you know adjust your\nhead by 90 degrees you can kind of see\nwhat i'm talking about but so that's the\nmain algorithm\nso so far we've just done the first edge\nso now let's look at the second edge in\nour input one\nand two so we're connecting one and two\nand the way\nwe're gonna merge these is first we're\ngonna get the root\nparent of both of these so for two two\nitself\nis its parent but for one one has\nanother parent zero so when you\nget the root parent of two\nnodes that's how you know if they're\nalready connected or not\nbecause if if maybe this two\nwas connected to one then we would say\nokay one two's parent is one\none's parent is zero and and then what\nwe would say is okay one and zero both\nhave the same root parent so therefore\nthey're already merged so we don't need\nto merge them again but in this case you\ncan see\ntwo has its own two is the parent of\nitself one has a root parent of zero\nso therefore they're not connected so we\ncan connect them together we can union\nthese two components together\nso this one is larger this one is\nsmaller so we're going to add this\nas a child of zero where we're always\nadding to the root parent right we're\nnot going to add it to one we're going\nto add it to\nzero even though this edge is connecting\nthese two together\nwhen we add that edge itself we're going\nto make sure that 2 is connected\nto the root parent because we want to\nminimize the height of the tree\nand once we do that we know that the\nrank of this is actually going to\nincrease so in our rank array we're\ngoing to get rid of two and now it's\nactually going to be\nthree and also what i didn't update in\nthe first go around was the parent of\none and two so\none and two have new parents now they\nboth have parents of zero\nzero so this array is what we're going\nto use to go through every node and find\nits root parent\nso we've done both of the first edges\nnow the last\nand third edge we're connecting three\nand four together so in this case it\ndoesn't really matter which one is the\nparent i'm just gonna draw it like this\nbecause it's easier\nso three will be the parent of four so\nfor node three we will update its rank\nits rank is going to be two\nand the parent of three is going to stay\nthe same but the parent of four is now\ngoing to be three so that's just kind of\nthe bookkeeping we're going to be doing\nto update\nour parent and rank arrays but each time\nwe made a union operation we\nwere taking our initial number of\ncomponents five decrementing it by one\nand so we did a union three different\ntimes\nso we got a result of two two is the\nnumber of connected components we have\nat the end\nbut let's say we just had one more edge\nlet's say we had an edge\nzero two so let's say we're trying to\nmerge zero and two right\nfirst we'll get the parent of two the\nroot parent which is zero\nthen we'll get the root parent of zero\nzero is the root parent of zero so what\nwe're going to find\nsince both of these have the exact same\nroot parent\nthat means they're already connected so\nwe had two connected components we're\nnot going to decrement this by one\nbecause we\ndidn't end up you know decreasing the\nnumber of connected components we didn't\neven do a union operation so in that\ncase\nwe would return before we made any\nchanges to the graph\nonce we see that they both have the same\nparent we return immediately\nso that's the main idea of this\nalgorithm once you've implemented it\nyou've written it out and coded it once\nor twice or three times\nit gets pretty straightforward because\nmost union find problems are pretty\nsimilar\nso now let's get into the code and like\ni said this is a leak code premium\nproblem\nbut if you don't have leak code premium\ni'd recommend solving leak code 547\nso this problem leak code 547 number of\nprovinces is pretty much exactly\nlike a union find problem so if you want\nto practice union find go ahead and do\nit on this problem it's pretty much the\nexact same\nso like i mentioned we're going to have\na parent array initially\neach node so for i and range of\nn each node is just going to be the\nparent of itself and we're gonna have a\nlist of ranks each\nuh you know component is just gonna have\na rank of one initially so\nand then we're gonna define our two\nfunctions find and union find is the\nsimpler one so let's start with that\nlet's say we're given a\nnode n1 we want to find its root parent\nso for n1 we want to return its root\nparent so initially we'll just set the\nresult equal to n1 and we'll say\nwhile result is not equal to the parent\nof itself we know we can stop searching\nonce we've gotten to a node\nwhere the node itself is its own parent\nbecause that means we can't go any\nhigher we found the root parent\nso in that case what we would do is just\nreturn the result which is the root\nparent but if we don't\nhave that what we can do then is\nbasically update the current\npointer to be its parent\nright we just want to go up that chain\nuntil we get to the parent now before we\ndo that\none thing i didn't mention in the\ndrawing explanation because i don't want\nto get too\nin-depth it's basically an idea of path\ncompression i would google it it's\npretty simple\nto understand that's just kind of how\nunion find problems are optimized it's\njust adding one line of code which can\noptimize it so basically what we're\nsaying is before we go to the parent\nwe want to set the parent of result\nequal to its grandparent so if we did\nhave a linked list that we were going up\nthe chain of what we would do now is\nbasically make the linked lists\na little bit shorter so we're just\nsetting our parent equal to the parent\nof our parent if it happens to exist if\nit doesn't exist if we don't actually\nhave a grandparent then\nthis line will basically do nothing so\nthat's pretty simple for the\nfind function and last we're going to do\nthe union so we're going to take two\nnodes this time n1 and n2 and we want to\nunion their components together\nso first thing we need to do is find the\nroot parents of each of these nodes this\nis exactly why we just wrote our find\nfunction first\nbecause we want to get the root parents\nof n1 and n2\nand then we can go ahead and merge them\ntogether now it's possible that they\nhave the same parent in which case we're\njust going to return immediately\nso if p1 equals p2 we're going to return\nimmediately we're going to return 0 to\nindicate that we did not actually\nperform a union\notherwise we're actually going to do the\nunion and remember we're going to do\nthis union by\nrank so let's say the rank of p2\nis greater than the rank of p1\nin that case p2 is going to be the\nparent of p1 so we're going to say for\np1\nlet's set its parent equal to p2 and\nthen we can\nincrease the rank of p2 because since\nit's the parent\nwe've just added some children to it so\nwe're going to add to it the rank\nof whatever p1 happened to be before\nthat\nand the else case is basically just\ndoing the exact opposite of this so\nthat would be if p1 was greater\ntherefore we'd want p\np1 to be the parent of p2 and we'd want\nto increase the rank\nof p1 by whatever the rank of p2\nhappened to be before that\nonce that's all said and done we're just\ngoing to return 1 to indicate that we\nactually did perform a successful union\nand those return values are going to\ncome in useful for us right about now\nwhen we go through every single\nedge so let's go through every single\nedge which is a pair of nodes\nin our input edges so we're going to be\nunioning n1 and n2 together\nso we can call union on n1 and n2\nremember the number of connected\ncomponents we initially start out with\nis\nn so we're going to set the result equal\nto n every time we perform a successful\nunion operation we want to decrement the\nresult by\none which is the return value of union\nif it's successful if it's\nunsuccessful then we're going to return\nzero in which case our result is\nnot going to be updated at all right if\nwe don't perform a union there's no need\nto update the number of connected\ncomponents\nso you can see that the math works out\npretty nicely for us\nonce that is completed we can go ahead\nand return the result which is the\nnumber of connected components that's\nwhat we originally wanted to do\nand it wouldn't be a video of mine\nwithout a typo i don't know how i missed\nit but on this first line i didn't\nactually\ndeclare the variable so for i in range\nand you probably caught that earlier\nso sorry if it was frustrating to watch\nbut as you can see\nwe've run the code and this problem is\npretty efficient union find is about as\nefficient as you can get for this\nproblem this problem is literally made\nfor union finding so i hope this was\nhelpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully see you pretty soon\n"
    },
    {
        "Name": "Redundant Connection",
        "NcLink": "redundant-connection/",
        "Pattern": "Graphs",
        "Description": "You are given a connected **undirected graph** with `n` nodes labeled from `1` to `n`. Initially, it contained no cycles and consisted of `n-1` edges.\n\nWe have now added one additional edge to the graph. The edge has two **different** vertices chosen from `1` to `n`, and was not an edge that previously existed in the graph.\n\nThe graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` represents an edge between nodes `ai` and `bi` in the graph.\n\nReturn an edge that can be removed so that the graph is still a connected non-cyclical graph. If there are multiple answers, return the edge that appears last in the input `edges`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1a966522-e4d9-4215-18a1-4df7d26c3700/public)\n\n```java\nInput: edges = [[1,2],[1,3],[3,4],[2,4]]\n\nOutput: [2,4]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5cf17b17-8758-4f0a-8829-99cea143b100/public)\n\n```java\nInput: edges = [[1,2],[1,3],[1,4],[3,4],[4,5]]\n\nOutput: [3,4]\n```\n\n**Constraints:**\n* `n == edges.length`\n* `3 <= n <= 100`\n* `1 <= edges[i][0] < edges[i][1] <= edges.length`\n* There are no repeated edges and no self-loops in the input.\n",
        "Difficulty": "Medium",
        "Video": "FXWRE67PLL0",
        "PythonSolution": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        par = [i for i in range(len(edges) + 1)]\n        rank = [1] * (len(edges) + 1)\n\n        def find(n):\n            p = par[n]\n            while p != par[p]:\n                par[p] = par[par[p]]\n                p = par[p]\n            return p\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return False\n            if rank[p1] > rank[p2]:\n                par[p2] = p1\n                rank[p1] += rank[p2]\n            else:\n                par[p1] = p2\n                rank[p2] += rank[p1]\n            return True\n\n        for n1, n2 in edges:\n            if not union(n1, n2):\n                return [n1, n2]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve redundant connections but\nbefore i do i just want to mention if\nyou have any problem suggestions you can\nfeel free to leave those in the comments\ni do have a\npretty large backlog that i'm working\nthrough right now so it might take me a\ncouple weeks to get to your suggested\nproblem so this is a pretty good problem\nto solve\nthis can actually be solved in a naive\nway which is going to be o of n squared\nand that's just a basic like depth first\nsearch solution for it for this graph\nsimilar to many other graph problems but\nyou can actually reduce this\nto a regular o of n a more optimized\nsolution and that actually requires a\nalgorithm that you might not have seen\nbefore\nunion find it's a rare algorithm to need\non leak code so most people don't use it\nbut this problem can use union find to\nget a much better solution\ni'm also going to explain why we're\nallowed to use the union find algorithm\nin this problem because it's not super\nclear\nso we're given a definition a tree is an\nundirected graph\nthat contains no cycles so basically\nthis is the key an undirected graph that\ncontains no cycles\nwe're given a graph that started as a\ntree started as a graph that was\nundirected\nand had no cycles we had n nodes these\nnodes are labeled from\none all the way to n but we ended up\nadding\none additional edge and we know every\nedge basically just connects\ntwo vertices and this edge is undirected\nso so this\nedge ended up connecting two two\nvertices and this edge\ndid not already exist in the graph in\nthis case the graph\nis represented as an array of edges and\nthe number of edges is basically\nn basically the number of edges is equal\nto the number of nodes that we have\nas i mentioned every edge is going to be\nconnecting two nodes together\nso we want to return an edge that can be\nremoved from the graph\nthat will turn the graph back into a\ntree\nif there are multiple edges that we can\nremove that will turn the graph back\ninto a tree\nthen we will return the last edge in the\ninput that that basically satisfies that\ncondition\nand they guarantee us that in the input\nlist of edges that were given\nevery single edge is going to be unique\nso let's take a look at this\nexample notice how if we remove any of\nthe edges if i remove this\nnow this graph no longer has a cycle\nright because\ninitially it had this cycle right so if\ni remove this\nedge it doesn't have a cycle so that\nsatisfies the condition so does that\nmean\none two is the result one two is the\nedge that we can return\nno because it turns out if i remove this\nedge\nit also satisfies the condition it\nbreaks the cycle that we initially had\nthe same is true for the third edge so\nin this case\nwhich of the so which of these three\nedges are we going to return basically\nthe one that occurs\nlast in the input which is going to be 2\n3.\nso i guess the next question you might\nhave is is that always going to be the\ncase is it if we remove\nany of the edges it breaks the cycle so\nthat are we always going to be returning\nwhatever the last edge is given to us\nnot necessarily let's take a look at\nanother edge if we added let's say two\nfour basically if i increased the number\nof nodes to\nfrom three to four so i added an edge\nover here\nthat connects these two nodes now\nif i break and this is the last edge\noccurs in our input if i break\nthis edge does that get rid of the loop\nthat we have no we still have a loop\nover here right so\nthis breaking this edge does not turn us\ninto a tree that's what we were looking\nfor\nso we're not always going to be\nreturning the last edge my next question\nto you is\nif we have n nodes and we have n edges\nright that's what we're given always\nwe're always given the same number of\nnodes same number of edges\nis it guaranteed that we're always going\nto start out with a loop and the answer\nis\nyes let me show you the intuition of why\nthat's true\nlet's say we start out with two nodes if\ni add a\nsingle edge to this notice how we were\nable to take\nthe total number of disjoint graphs we\nhad two graphs that were not connected\nright\nonce we added an edge we were able to\nreduce that number\nto one graph right now we have one\nconnected graph\nand you want to know something about a\nconnected graph\nif you add a new edge to this connected\ngraph\nyou are going to create a cycle so for\nexample in this case\nwe don't even have any more unique\npossible edges we could add other than\nfor example a\nself loop on two or a self loop on one\nor just adding\nanother edge right but we know that the\nedges are undirected basically what i'm\nsaying is\nif we keep adding edges to a graph that\nis already a connected graph\nthen we're creating a cycle let's look\nat a couple more examples\nso now we have four nodes if i add four\nedges to this graph that are all unique\nedges we are gonna end up with a cycle\nit's impossible to\nnot end up with a cycle if we add four\nunique edges to this graph let me show\nyou why\nlet's say we added one edge here then we\ncould add\nanother edge here right and then we\ncould add another edge\nhere and then the fourth edge we could\nadd would be here\nthis way we end up with a cycle but hold\non maybe there are other possibilities\nright\nwell maybe instead of connecting these i\ncan also connect\nthese oh that ends up with the cycle too\nright notice that\nmaybe we just don't connect this with\nanything else maybe we add an edge here\nthat ends up with a cycle\nif i add an edge over here that ends up\nwith a cycle no matter how we do it we\nend up with a cycle\nright maybe i start out like this i try\nto be clever now what we\nstill will end up with a cycle and\nthat's going to be true no matter what\nif we have\nn nodes and n unique edges we're going\nto end up with a cycle\nno matter what but my question to you is\nhow do you\nknow that adding this edge right let's\nsay we already have these three edges\nhow do you know that\nadding this edge is creating a cycle for\nus it's because\none is already connected with three\nthree and one are already connected see\nhow\nall four of these nodes are already\nconnected\nso when i add this edge i already knew\nthere was a path from\nthree to get to one now i'm creating a\nsecond path\nfrom three to get to one notice how\nthat's what's creating the cycle\nthis is the reason why we're allowed to\nuse the union find algorithm\nbecause we're looking at the connected\ngraphs and once we add\nthe once we notice we found an edge in\nour input array\nthat caused us to take a connected graph\nand add\nanother redundant connection that's why\nthis is called redundant connections we\nadded another connection that was not\nneeded\nthree could already get to one why\nbother adding this edge\nthat created a loop so the last edge\nso the first edge in our input array\nedges\nthat causes a redundant connection is\ngoing to be the edge that we return\nso the solution we're going to be doing\nis union find and we are going to be\ndoing union find by\nrank which is the most efficient way to\ndo it so what we're going to be doing\nis iterating through every single edge\nfor example\nthis one one two we know that we start\nout with three nodes right because we're\ngiven three edges therefore n equals\nthree we have three nodes each node is\nnumbered from one\ntwo to three right so we start out with\nthree nodes that are not connected with\neach other right\nand the rank of each of those separate\ngraphs is one basically the size of the\ngraph right\nwhat we're gonna be doing is going\nthrough each edge so for example one\ntwo that means we're going to be\nconnecting one and two\ntogether we're connecting them in the\nshape of a tree so one of them is going\nto be the parent node of the\nother and we're going to be doing that\nbased on rank so for example\nif the size of this graph was\nor maybe we had something separate right\nmaybe we had something like this\nif we had one graph of size 2 and\nanother graph\nof size 1 then we would want to add the\nsmaller graph\nas a child of the larger graph\nbut in this case we know that both of\nthe ranks or in other words\nsize is the same of both of these\nthey're both one so it doesn't really\nmatter what we do\nlet's add two as the child of one so\nsince i added so since now one has\nanother child the size of this is\nactually gonna be two now so let's\nupdate the rank of it\nto two but we also have to update the\nparent so\ninitially notice how the parents are all\none two and three what that means is one\nis a parent of one right that's\nthat just basically means it has no\nparent and two\nis initially a parent of two but notice\nnow two is not two actually has a real\nparent now two has a parent\nof one so what we're gonna do is erase\nthis two\nand instead set it to one because now if\nwe ever\nget to two and we wanna know who's the\nparent of two we can go\nup this link all the way to one and see\nthat one is a parent of two\nnext we're going to go to the next edge\none and three this means we're going to\nbe connecting\none and three together so since one is\nthe parent of one and three is the\nparent of three let's get the ranks of\nboth of these\nthe rank of one is going to be two the\nrank of three\nis going to be one since one has a\nlarger rank\nthan three that means three is going to\nbe the child\nof one so let's add three as a child of\none\nand by doing that we can also update the\nnew rank\nof one because now the size of this has\nactually increased\nto three so let's change this to\nthree and let's update the parent of\nthree initially three was just the\nparent of itself\nnow we're going to change that to also\nbeing one\nbecause the parent of three is clearly\none now\nso now let's go to the last edge in our\ninput array two\nthree so what this is telling us is we\nwant to merge\ntwo and three together basically we want\nto connect them together\nwe're always gonna be connecting by the\nparent so what we're gonna do when we\nwhen we have two so far we've done our\nunion algorithm now we're gonna do the\nfind\nportion of union find every time we're\ngiven two nodes to merge together we\nneed to\nfind what their parents are so for to\nget two's parent we're gonna go\nup the link see that the parent is one\nfor three\nwe're going to go up the link see that\nits parent is also one\nwhat does that tell us if we're trying\nto merge two and three together into the\nsame graph\nif they have the exact same parent which\ncan be\nyou know found from the parent array\nthat means they're\nalready connected that means if we added\nthis\nnew edge to our graph we're adding a\nredundant connection\nthat means that this edge is the edge\nthat we're going to return\nas our result it's the one that we\nidentified first so with that being said\nnow let's jump into the code so as\nmentioned we are going to have a parent\narray so initially we can just\ninitialize that for every single node\nitself is going to be the parent so for\ni in\nrange of the length of edges\nplus one because we are starting with\nzero even though our nodes are going\nfrom one to n\nwe are going to have a zero in this\ninput array just because it makes the\nmath work out easier we're not actually\ngoing to be using that zero node\nand we're also going to have a list of\nranks which initially is just going to\nbe set to one\nso and it's going to be the size of\nlength of edges\nplus one and then we can basically just\ndefine our standard algorithms for\nuh union and find so let's start out\nwith find because it's easier so for\nif we were given a node n then we want\nto find what its parent is\nso we're going to go to its first parent\nand when we say parent we want to find\nthe root parent it's possible\nthat a parent could go multiple it could\ntake multiple links to get to the parent\nso\nwe're going to get the first parent of\nthis parent\nof n and it's also possible that n could\nbasically be the parent of\nitself so we're going to basically keep\ngoing until we find\nthe last root parent so while is\nnot equal to parent of n\nthen we're going to basically keep going\nup the length so we're going to set p\nequal to parent of itself\nso while p is not equal to its own\nparent we're going to basically keep\ngoing up the link so then we're going to\nupdate p\nto the parent of itself but we are going\nto add one thing to this algorithm it's\ncalled path compression basically\nbefore we get to this portion what we're\ngonna say is for\np we're gonna set its parent actually to\nthe parent of its parent basically\nit's grandparent so we're gonna say its\nnew parent\nparent of p is going to be parent of\nits parent and so this part is a little\nbit complicated but basically it's\nmaking sure that we\nshorten the links as we go up the chain\nof parents\nso if we had to go up the link one more\ntime if we had to repeat this\nfind operation it would be a little bit\nfaster the next time that we did it\nand at the end when this is no longer\nthe case basically\nonce we've gotten to the root parent is\nwhen we're going to be returning p\nso this function is pretty short the\nnext one that we're going to be\nimplementing\nis the union function so if we were\ngiven two nodes n1 and n2 and we had to\nunion them together that's what we're\ngoing to be doing so\nto union them we would have to find both\nof their root parents first right so\nthat's why we implemented the find\nfunction first so we're going to want to\nget p1 and p2 the parents of n1 and n2\nwe can do that with our find function\nfind n1\nand find n2 one case is that\nboth of the parents are equals for\nexample p1 is equal to p2\nin that case we're going to return false\nbecause we cannot complete this\noperation so we're going to say\nreturn false if can't complete meaning\nthey're already merged\nthat's how we're gonna know that we\nfound a redundant connection so we'll\nreturn false if they have the same\nparent if they don't have the same\nparent then we're gonna union them we're\ngonna be unioning them by rank so if\nthe rank of p1 is greater than the rank\nof p2 that means that rank that means p1\nis going to be the parent of p2\nif the opposite is true then that means\np2 is going to be the parent of p1 in\nthe else condition but let's do the if\ncondition first\nso p1 is going to be the parent so what\nwe're going to do is for p2 we're going\nto set its parent\nequal to p1 we also then have to update\nthe rank\nof p1 because it's now has more children\nthan it had before\nso we're going to add to the rank of p1\nbasically whatever the rank of p2 was\nprior to union unioning them together\nin the else condition we're basically\ngoing to be do the doing the opposite so\nfor p1 we're going to set its parent\nequal to p2\nand we're going to add to the rank of p2\ni just noticed that i called my uh\nparent\narray parent but i've been referencing\nit as pair\nso let's just shorten this to par and\nthe last thing we're gonna do in this is\nreturn true if we were able to\nsuccessfully union them together so\nlet's return true\nand that's basically the entire code now\nwe get to the easy part where we're\nactually going to be calling these union\nfind functions\nso let's go through every single edge so\nfor n1n2 this pair of edges\nthis pair of nodes in our edges input\narray we're gonna be calling\nunion on these two n1 and two and\nif it returns false so if not the result\nof this function\nthen we have to return this edge n1\nand 2 as the resulting edge that they're\nlooking for and we know for sure\nit's guaranteed that at least one edge\nis going to lead to a redundant\nconnection in this problem so this is\ndefinitely going to execute we don't\nhave to put a return statement out here\nso this\nis the entire code so i hope that you\nlearned something today i hope this\nvideo was helpful maybe you learned\nunion finding it today\nand it's usually something that you can\njust memorize that if you need to\nso i hope this was helpful if it was\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Word Ladder",
        "NcLink": "word-ladder/",
        "Pattern": "Graphs",
        "Description": "You are given two words, `beginWord` and `endWord`, and also a list of words `wordList`. All of the given words are of the same length, consisting of lowercase English letters, and are all distinct.\n\nYour goal is to transform `beginWord` into `endWord` by following the rules:\n    \n* You may transform `beginWord` to any word within `wordList`, provided that at exactly one position the words have a different character, and the rest of the positions have the same characters.\n* You may repeat the previous step with the new word that you obtain, and you may do this as many times as needed.\n\nReturn the **minimum number of words within the transformation sequence** needed to obtain the `endWord`, or `0` if no such sequence exists.\n\n**Example 1:**\n\n```java\nInput: beginWord = \"cat\", endWord = \"sag\", wordList = [\"bat\",\"bag\",\"sag\",\"dag\",\"dot\"]\n\nOutput: 4\n```\n\nExplanation: The transformation sequence is `\"cat\" -> \"bat\" -> \"bag\" -> \"sag\"`.\n\n**Example 2:**\n\n```java\nInput: beginWord = \"cat\", endWord = \"sag\", wordList = [\"bat\",\"bag\",\"sat\",\"dag\",\"dot\"]\n\nOutput: 0\n```\n\nExplanation: There is no possible transformation sequence from `\"cat\"` to `\"sag\"` since the word `\"sag\"` is not in the wordList.\n\n**Constraints:**\n* `1 <= beginWord.length <= 10`\n* `1 <= wordList.length <= 100`\n",
        "Difficulty": "Hard",
        "Video": "h9iTnkgv05E",
        "PythonSolution": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n\n        nei = collections.defaultdict(list)\n        wordList.append(beginWord)\n        for word in wordList:\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                nei[pattern].append(word)\n\n        visit = set([beginWord])\n        q = deque([beginWord])\n        res = 1\n        while q:\n            for i in range(len(q)):\n                word = q.popleft()\n                if word == endWord:\n                    return res\n                for j in range(len(word)):\n                    pattern = word[:j] + \"*\" + word[j + 1 :]\n                    for neiWord in nei[pattern]:\n                        if neiWord not in visit:\n                            visit.add(neiWord)\n                            q.append(neiWord)\n            res += 1\n        return 0\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve word ladder this is a hard\nproblem but i don't think it's super\ndifficult there's just one little thing\nthat kind of makes it really annoying to\nget this to pass on leak code but the\nidea is we're given a beginning word and\nwe're given an end word and we're given\na list of words we want to create a\nsequence from this beginning word to the\nend word and the end word is definitely\ngoing to be need to be a part of our\nword list but the beginning word\nactually might not be a part of the word\nlist and so we want to create a sequence\nfrom the beginning word to the end word\nthat sounds pretty easy but there's one\nrestriction that we have to follow and\nthat restriction mainly is that every\nadjacent pair of words in that sequence\ncan only differ by a single character\nexactly one character they have to\ndiffer by exactly one character and so\nwe want to find a sequence from that\nbeginning word to the end word where\nevery word in between is a part of the\nword list and we want to return the\nshortest sequence so the sequence will\nbasically be the number of words so for\nexample in uh this example down here we\ncan see that there's a sequence from the\nstarting word hit and notice how this is\nthe beginning word so it doesn't have to\nbe a part of our list of words but every\nother word in the sequence does have to\nbe a part of the list of words and that\nincludes the end word so cog does have\nto be a part of our list of words and so\nin this example the shortest sequence is\nof length five because it has five\ndifferent words in it now the convenient\nthing for us is that every single word\nincluding the beginning end word and\nevery word in the list is going to be\nguaranteed to be the exact same length\nin this case every word has three\ncharacters in it so it's pretty easy to\ntake two words and figure out what's the\nthe\ndifference in characters between them\nright we can just compare character by\ncharacter and see that there's one\ncharacter difference therefore we could\nform a path between these two words\nright and each edge between these words\nlet's say log and cog is going to be\nbi-directional right we could go from\nlog to cog or we could go the other\ndirection right so this is starting to\nlook like a bit of a graph problem right\nwe want we want to find the shortest\npath from the beginning node hit all the\nway to the end node cog and the the way\nthe edges are going to work so hit could\nbe connected to any of the words in this\nword list where it has a single\ncharacter difference so let's think\nabout this so hit which one of these\nwords could it be connected to is there\na single character difference between\nhit and hot yes that's the case so hit\nand hot are going to be connected in\nthis problem what about dot nope it\ntakes two character difference between\nhit what about dog again two character\ndifference\nlot again two character difference same\nwith log and same with cog but hot could\nbe connected to some of these characters\nor some of these words right so we're\nrealizing that building a graph like\nthis with all the edges like an\nadjacency list pretty much between the\nwords is going to be very helpful for us\nand there's a naive way to create this\nadjacency list which is going to\nbasically be a nested loop on the entire\nlist of words which let's say ends up\nbeing n squared where n is the number of\nwords and let's say the length of each\nword which is always going to be the\nsame is m because we're going to need to\ncompare character by character between\nthe words so creating that adjacency\nlist is going to be something like n\nsquared times m\nbut and you might think that that's good\nenough unfortunately this won't pass on\nleak code and i really think that's kind\nof stupid that it does that the main\nthing to notice to build the adjacency\nlist faster is to look at the\nconstraints they tell us that the length\nof the of the list of words in our case\nthat's n so it's going to be n squared\nright is going to be less than or equal\nto 5000 whereas the length of the word\nitself is going to be less than or equal\nto 10. so there's actually a way where\nwe can change this time complexity to at\nleast generate that adjacency list to\nsomething like n times m squared because\nthe m is going to be smaller than the n\nso we can actually make it kind of like\nthis but i'm pretty sure that the\noverall time complexity because after we\nactually create this graph we are going\nto run a breadth-first search algorithm\nto find the shortest path we could do it\nwith dfs but usually to find the\nshortest path breadth first search is\nmuch more efficient and i'm pretty sure\neven in this case the breadth first\nsearch solution is going to be n squared\nbecause this is going to be the number\nof edges we could potentially have right\nbecause that's how many words we have we\ncould have n squared edges and we're\nalso going to have to compare words so\non each operation when we're traversing\nthe graph it's going to be multiplied by\nthe length of the word so the overall\ntime complexity for the bfs is still\ngoing to be n squared which is you know\npretty much this so you might think well\nthen why isn't it passing on leak code\nand you know that's a good question i\nthink in general though doing it like\nthis is going to be faster we use this\nto generate our adjacency list and then\nwe do a bfs with this time complexity\nand basically there's kind of a small\ntrick that i'm going to show you which\nwill get it to pass on leak code so like\ni said the first part is building an\nadjacency list and the naive way would\nbe to go through every word hot compare\nit with every other word that's going to\nbe n squared and then the length of the\nword which is m but there's a little bit\nof a trick so how about we we do it some\na different way right we know that for\nany word we want at most one character\ndifference right so let's take a look at\nhot our first word and let's take a look\nat every pattern it could fall into if\nwe changed one character at most if we\nchanged the first character to any other\ncharacter we could transform this into\nstar for the wild card and then o t\nright we changed the first character we\ncould also transform it into h change\nthe middle character star\nand then t right and then also to a\nthird word h o and the last character is\ngoing to be a star right so these are\nthe three patterns that hot fits into\nand now let's take a look at a different\nword dot and let's quickly do the same\nthing for this so the first pattern will\nbe uh star o t next d\nstar t\nlastly d\no star so notice how okay these two\npatterns between the words are different\nthese two patterns between the words are\ndifferent but the first pattern for each\nword is the exact same since these both\nboth of these words hot and dot have the\nsame pattern\nwhen we remove the first character that\nmeans that they have a one character\ndifference between these words and that\nmakes sense right if we change the first\ncharacter from here to a d or change the\nfirst character from here to an h these\ntwo words will be the same that means\nthey have a one character difference so\nusing this idea we are going to create\nan adjacency list where the where the\nkey of the adjacency list is going to be\nthe pattern by pattern i mean one of\nthese wild card type strings and the\nvalue of this adjacency list in our case\nit's going to be a hash map or a\ndictionary so each pattern is going to\nbe mapped to a list of words so each\npattern to a list of words so for\nexample if we take the pattern star\no\nt we'll have a corresponding list of\nwords for all words that fit this\npattern right we so far we found hot\nfits this pattern we also found that dot\nfits this pattern\nand by just looking at our list we can\nsee that lot is also going to fit this\npattern so we have three words that fit\nthis pattern so if we wanted all the\nneighbors of hot in our adjacency list\nhow would we find them right because the\nkey we're not it's not it's not like hot\nis the key of this adjacency list so to\nfind all the neighbors of hot what we\nhave to do is first for for hot find all\nof its patterns right the first pattern\nstar ot will go to that straw and say\nokay these are all the neighbors of hot\nthese are all the neighbors in the graph\nof course we can't include itself so\nwe'd say okay dot and lot are going to\nbe the neighbors of hot but we also know\nthat hot could have a couple other\npatterns that it fits into h star t are\nthere any other words in our list that\nmatch this pattern well hit\nis going to match that right hit is\ngoing to match the pattern h star t so\nin that list we would have hot and hit\nso that's how we'd get another neighbor\nfor hot and lastly we'd see are there\nany other words that fit this pattern h\no star in our list you can tell that i\ndon't think any other words are going to\nfit that pattern only hot itself fits\nthat pattern so it doesn't have any\nadditional neighbors so the all the\nneighbors of hot are going to be dot lot\nand hit from up above here and so how\nare we finding the neighbors so\nbasically what's the computation of what\ni just did it's it's going to be since\nto find all the neighbors we're going to\nhave to go from hot consider okay if we\nremove this character or remove this\ncharacter remove this character so\nbasically we're going through every word\nin our list which is n and then we're\ngoing through every single character\nthat we remove which is m\nright so that's how many possible\ndifferent patterns we could have in\ntotal and then to actually add each word\nto the list is going to be another m so\nthat's kind of how you can get the\ncomplexity n times m squared to at least\ngenerate the adjacency list now let's\nassume we have that adjacency list and\nwe have a graph then the algorithm is\nactually pretty straightforward it's\njust going to be a basic bfs search so\nthis is something like how our graph is\ngoing to look like we know that the\nbeginning word is hit the destination\nword the end word is cog so we want to\nfind the shortest path from here all the\nway to here so we know that a good way\nto define a shortest path is a bfs\nsearch so from our first initial spot\nwe're going to look at all neighbors\nthat it has from the picture it's pretty\nobvious hot is the only neighbor so so\nfar we have a path of length 2 because\nwe're counting the number of words that\nis what determines the length of the\npath and of course it's not going to be\nthis simple to get the neighbors because\nwe know that our adjacency list is a\nlittle bit more complicated and again\nfrom hot we're going to go to its two\nneighbors and we're never going to\nrevisit the same neighbor twice but we\nare going to potentially have to go\nalong each edge at least once we're also\nnot going to go along the same edge\ntwice but the number of edges i'm pretty\nsure\ncould be the number of words n squared\nand for each neighbor to find each\nneighbor we're going to have to do an m\noperation where m is the length of of a\nparticular word is which is where i'm\ngetting this time complexity n squared\ntimes m i'm pretty sure leak code has\nthe wrong time complexity for this\nsomebody can correct me if i'm wrong\nthough because for a graph with n nodes\nthe maximum number of edges could be n\nsquared\nand again from here so we don't want to\neven though there's an edge between\nthese two nodes we don't want to go\nalong that edge because that's going to\nbe revisiting the same nodes twice so\nnow we're going to go along our next\nlayer so from dot we can reach dog and\nfrom lot we can reach\nlog one now there's just one last\nunvisited node both of these log could\nvisit it or dog could visit it but at\nthe end we're gonna have a single\nanother node so what was the path so we\nhad one word two word three four\nfive it took us five layers of our bfs\nto reach this so we're gonna say that\nour result is five and when you look at\nthe output that's exactly what they had\nas well so with that being said we can\njump into the code now so now let's get\ninto the code and like i mentioned we\nwant to make sure that the end word is\nactually in the word list because that's\na requirement if it's not then we have\nto return 0 because that's what we want\nto return if there doesn't exist a path\nfrom the beginning word to the end word\nwe're going to have a list of neighbors\nthis is going to be our adjacency list\nand this is the first time i'm actually\ngoing to do\ncollections.default dict i usually avoid\ndoing this i actually manually create\nthe dictionary but in this case it's\ngoing to be helpful to do this basically\nthis is a dictionary where we if we're\ninserting a new value for the first time\nthe default value is going to be an\nempty list also to our word list i'm\ngoing to go ahead and append the\nbeginning word because it's not a part\nof the word list initially so\nbeginword now let's actually build the\nadjacency list so first let's go through\nevery single word in this word list and\nnow for each word we want to find every\npossible pattern for this word so i'm\ngoing to use a pointer j just to go\nthrough every single position of this\nword of course we know every word is\ngoing to be the exact same length and\nfor each position of this word i want to\nreplace a character with the wild card\ncharacter so i'm going to i'm going to\ntransform this string word into a\npattern string where we're going to take\nthe first uh\nj characters initially j is just going\nto be zero so we're going to take that\nwe're going to replace the j character\nthe 0th character with a star and then\nwe're going to get the remaining\ncharacters skipping the jth character so\nj plus one to the end of the string so\nwe're just gonna go through every\nposition replacing a character with the\nstar and then for this pattern we're\ngonna say okay in our neighbor list the\nall the the strings that fall into this\npattern so for this pattern we want to\nappend the current word we want to say\nthis word is a part of this pattern and\nthat's going to help us traverse the\ngraph later on and of course we're going\nto do that for every single word in the\nentire uh list and we're gonna do it\nwe're gonna have that star go in every\nposition of the word next let's do our\nbfs there's a couple data structures\nwe're gonna need we don't wanna revisit\nthe same position twice so we're gonna\nhave a set to make sure we don't do that\nwe know we're gonna start at the\nbeginning word so let's add beginning\nword to the set and we also need a cue\nand we're gonna similarly add the\nbeginning word to this cue and we're\njust gonna continue popping we're gonna\ngo layer by layer until we get to the\nend word and initially our result or our\nlength of the path is going to be 1\nbecause we have at least one word the\nlength is going to be the number of\nwords along the path and now we're going\nto continue going while the q is\nnon-empty if we find the word we're\ngoing to end up returning the result if\nwe don't find the word when the loop\nexits we're going to end up returning 0.\nso let's do that\nand so we want to go through the entire\nlayer and then we want to\nincrement our result by one so i'm gonna\nincrement result by one after we go\nthrough the entire layer and then we're\ngonna continue going layer by layer\nuntil our q happens to be empty so let's\ngo through whatever the length of the\nqueue currently is let's go through\nevery single\nnode and pop that note so q dot pop\nleft and when we pop we're going to be\ngetting a word that we ended up adding\nif this word equals the\nend word then we can return the length\nof the path aka the result if it's not\nthe end word then we're going to go\nahead and take the neighbors of this\nword and add them to the queue how can\nwe get the neighbors of this word well\nfirst we have to see all the patterns\nthat this word falls into and then we\nhave to get all the other words that\nfall into the exact same pattern because\nthat's the most efficient way to get the\nneighbors so first let's go through for\nevery j in range of the length of this\nword so that we can replace each\ncharacter with the wild card character\nso let's transform this word into the\npattern so basically the exact same\nthing that we just did up above i'll\nliterally just copy and paste it so this\nword could be replaced with the pattern\nright and now we're using this pattern\nwe can get all the neighbors of this\nword\nso let's go through four neighbor word\nin neighbors of this pattern now of\ncourse we might be able to get that same\nword but the reason we're not going to\nget the same word is we're going to\ncheck if this neighbor word is not\nvisited so if neighbor word\nnot in visit that's when we're going to\nbe\nprocessing that word so we definitely\nwon't be looking at the same word twice\nso if this neighbor word has not been\nvisited we can of course add it to visit\nand we can add it to the queue so q dot\nappend\nneighbor word uh for some reason up\nabove i said if end word is in the word\nlist i meant to say if it's not in the\nword list in that case we're going to\nreturn zero\nbut other than that the code is correct\nyou can see that it's pretty efficient\nthat's because we kind of use this trick\nto find the adjacency list i feel like\nthis shouldn't be required to pass this\nproblem though i think that's kind of\ndumb on leak codes part but for some\nreason it is but once you kind of know\nthat trick this problem basically just\nreduces to a breath first search so i\nhope that this was helpful if it was\nplease like and subscribe it supports\n"
    },
    {
        "Name": "Reconstruct Itinerary",
        "NcLink": "reconstruct-flight-path/",
        "Pattern": "Advanced Graphs",
        "Description": "You are given a list of flight tickets `tickets` where `tickets[i] = [from_i, to_i]` represent the source airport and the destination airport. \n\nEach `from_i` and `to_i` consists of three uppercase English letters.\n\nReconstruct the itinerary in order and return it.\n\nAll of the tickets belong to someone who originally departed from `\"JFK\"`. Your objective is to reconstruct the flight path that this person took, assuming each ticket was used exactly once.\n\nIf there are multiple valid flight paths, return the lexicographically smallest one.\n* For example, the itinerary `[\"JFK\", \"SEA\"]` has a smaller lexical order than `[\"JFK\", \"SFO\"]`.\n\nYou may assume all the tickets form at least one valid flight path.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e5ea2ea5-da22-4c22-a5c1-5840dab7fb00/public)\n\n```java\nInput: tickets = [[\"BUF\",\"HOU\"],[\"HOU\",\"SEA\"],[\"JFK\",\"BUF\"]]\n\nOutput: [\"JFK\",\"BUF\",\"HOU\",\"SEA\"]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9bfece1f-1fec-4618-4f95-31b2abcd3100/public)\n\n```java\nInput: tickets = [[\"HOU\",\"JFK\"],[\"SEA\",\"JFK\"],[\"JFK\",\"SEA\"],[\"JFK\",\"HOU\"]]\n\nOutput: [\"JFK\",\"HOU\",\"JFK\",\"SEA\",\"JFK\"]\n```\n\nExplanation: Another possible reconstruction is `[\"JFK\",\"SEA\",\"JFK\",\"HOU\",\"JFK\"]` but it is lexicographically larger.\n\n**Constraints:**\n* `1 <= tickets.length <= 300`\n* `from_i != to_i`\n",
        "Difficulty": "Hard",
        "Video": "ZyB_gQ8vqGA",
        "PythonSolution": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        adj = {src: [] for src, dst in tickets}\n        res = []\n\n        for src, dst in tickets:\n            adj[src].append(dst)\n\n        for key in adj:\n            adj[key].sort()\n\n        def dfs(adj, result, src):\n            if src in adj:\n                destinations = adj[src][:]\n                while destinations:\n                    dest = destinations[0]\n                    adj[src].pop(0)\n                    dfs(adj, res, dest)\n                    destinations = adj[src][:]\n            res.append(src)\n\n        dfs(adj, res, \"JFK\")\n        res.reverse()\n\n        if len(res) != len(tickets) + 1:\n            return []\n\n        return res\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem reconstruct itinerary\nthis is a pretty difficult problem but\nit's doable if you have a good\nunderstanding of graphs and graph\ntraversals especially dfs which we're\ngoing to be using in this problem but\nwe're given a list of airline tickets\nand these tickets are basically a graph\nedge we have a from and a two so\nbasically a source and a destination and\nit connects two nodes together in this\ncase the nodes are going to represent\nairports or cities and basically using\nthis list of tickets we want to\nreconstruct the itinerary and basically\nwhat that means is we want to\nreconstruct the flight history of a\nperson who had this list of tickets all\nof the tickets belong to someone who\ndeparted from jfk so no matter what this\nis going to be our starting edge in our\ngraph so basically if you take a look at\nthis picture we're always going to be\nstarting at jfk so we're pretty much\nguaranteed that jfk is going to be a\nnode in our graph they also tell us that\nwe can assume all tickets form at least\none valid itinerary so basically we're\nguaranteed that there is a solution and\nin the solution that we create we have\nto use every single ticket exactly once\nand there's one last thing that they\ntell us there could be multiple\nsolutions and if there are multiple\nsolutions we want to return the one that\nhas a smaller lexical order basically\nthe one that comes first in sorted order\nand you can't really tell that from this\nexample because there's really only one\nsolution but let's take a look at\nanother so here we have a different\ngraph let's say you know a was jfk in\nthis context i'm just using abc to keep\nit simple but we're starting at a we\ncould uh you know we want to go over\nevery single edge basically each edge\nrepresents a ticket we want to go over\nevery single edge and we want the\nhistory of the destinations to be our\nresult so you know let's say we're\ncreating our result a is going to be\nfirst and then you know what we could do\nis we could say okay let's visit uh c\nfirst right we get to c and then we go\nback to a right from c so\nyou know what we could say is okay we\nfirst go to a then go to c then go back\nto a and then we go to b and then we go\nback to a from b and then that would\nleave our result looking something like\nthis that's one possible solution but\nthe other solution would have been to go\nto b first and then go to c what that\nwould have looked like is a\nb\na\nc a now which one of these has a smaller\nlexical order which one of these comes\nfirst in sorted order well the first\ncharacter a is the same but the second\ncharacter could be b or c which one of\nthese comes first b comes first so of\ncourse of these two we would prefer the\nsecond one we would return the second\norder as our result so that's something\nto keep in mind and the way we can\nactually handle this is going to be\npretty easy i'll show you how we can you\nknow make sure that we return the\nsmaller lexical order result now this\nexample is very simple because there's\nreally only one you know ordering that\nwe could possibly create and to get that\nordering what we could do is just run\ndfs starting at jfk we know we're always\ngoing to start at jfk we create a dfs\nrunning on this and you know using this\ndfs technically we are allowed to visit\nmultiple the you know the same node\nmultiple times as i showed in the\nexample just a moment ago but what we\ncan't do is go over the same edge\nmultiple times we can't reuse one of our\ntickets but in this case if we run a dfs\nstarting at jfk you know what we'll get\nis jfk first then this one then this one\nthen this one and then this one so\nthere's really only one ordering and you\ncan see that that's the output for this\nexample the expected output and so\nthat's what we can return but if we of\ncourse had multiple choices like this or\nyou know adding a bunch more edges and\nwe still have to go over every single\nedge and we have to return the smallest\nlexical order you know let's see how we\ncan do that algorithm so like i\nmentioned you really have to have a good\nunderstanding of graphs to be able to\nsolve this problem i'm going to assume\nyou kind of already know dfs and the\nbasics of graphs so what we're going to\nuse to do the traversal on this graph in\nthe first place is you know create an\nadjacency list of course we're already\ngiven the list of edges but we have to\nactually create an adjacency list out of\nthat to be able to traverse over the\ngraph and the way we're going to be you\nknow creating this adjacency list is\njust going to be by using a hashmap\nwe're going to map every single node to\nthe you know every single source rather\nto the possible destinations that we can\ntake and the easiest way to build an\nadjacency list is just kind of iterate\nover the input which is tickets in this\ncase right it's a list of source\ndestination pairs so what we would do is\nsay okay jfk has a san francisco sfo at\nleast i assume that's san francisco uh\nand then it also has a second one\natlanta atl and we can start adding\nthose to our adjacency list like this is\nthe list this is the source right so\nfrom jfk we can travel to these two\ncities but what i'm going to tell you\nright now is that we should have this\nlist in sorted order because we're going\nto be running dfs and as we run dfs\nwe're going to start at the first\npossible source that we could visit from\njfk right we're going to try sfo and\nmaybe we find a result starting at sfo\nin that case we could return that as the\nresult but what if it turned out that\nmaybe we could have also found a result\nof you know going to atlanta first\nrather than sfo in that case this is the\nresult that we would prefer because it\ncomes first in sorted order so what we\nwant is for each of these lists to be in\nsorted order and we could build the\nadjacency list and then sort each of\nthese lists independently but the easier\nway to do it is actually just to sort\nthe input and i'll show you why because\nthe way we're going to be sorting the\ninput is by doing this these are pairs\nof values right the first uh value is\ngoing to be the first key that we're\ngoing to use to sort so you know these\ntwo jfks would be next to each other but\nthen if there's a tie between the first\nvalue then we want to use the second\nvalue as our sorting keys so among these\ntwo which is going to come first sfo or\natl of course atl because it comes first\nyou know that's just something to keep\nin mind so if we have this in sorted\norder then our adjacency list will be\nsorted by default right and i'm actually\ngoing to build this adjacency list now\nassuming that this thing is in sorted\norder or at least i'm going to be going\nthrough the sorted order version of this\nuh list of tickets so first is going to\nbe atl and it has jfk as one of its\ndestinations so let's do that and atl\nalso has sfo as one of its destinations\nso let's add that next we have jfk it\nhas atlanta as one of its destinations\nand it also has sfo as one of its\ndestinations and then lastly we have sfo\nwhich only has one destination which is\natl so let's add that so now we're gonna\nstart running our dfs so let's focus on\nthe picture now so we're gonna be\nstarting at jfk you know we have two\noutgoing edges from jfk we could go to\nsfo or we could go to atl which one are\nwe going to decide well we're going to\nlook at our adjacency list and see which\none comes first well atl comes first so\nlet's visit atl so we're going to go\nalong this edge and now we're going to\nbe at atl and when we do that we're\nactually going to remove atl from our\nadjacency list at least temporarily for\nnow and by the way as we you know go\nalong this we're also going to be\nbuilding our result our result is just\ngoing to be you know the travel history\nof these airports we know initially we\nstart at jfk and right now we just\nvisited atl so that's going to come next\nokay now from atl we have two outgoing\nedges we could go to sfo or we could go\nto jfk which one are we going to decide\nwell let's see which one comes first in\nsorted order it's jfk so let's go to jfk\nnext so we're going back to jfk so we\nvisited both of these two edges and\nlet's remove jfk as an\nas a destination from atlanta and in our\nresult now let's add jfk again because\nwe started at jfk then we went to\natlanta then we're back at jfk now from\njfk we only have one outgoing edge\nremaining sfo and that you can tell from\nour adjacency list as well so let's pop\nsfo now we're at sfo let's add that to\nour result as well now from sfo we only\nhave one destination it makes things\neasy for us that's atlanta so let's pop\natlanta from here let's go along that\nedge and let's add atl to our result and\nfrom atl now we only have another a\nsingle edge outgoing it's to sfo so\nlet's pop sfo travel along that edge and\nadd sfo to our result so this was a\nvalid way because we just visited every\nsingle edge how exactly do we know we\nvisited every single edge though well\nour result is going to be keeping track\nof all of the nodes that we visited in\nour graph right not the edges we know\nevery time we visit one of the edges\nwe're going to be adding another node to\nour result and we know that we actually\ninitially start with a single node which\nis jfk before we even travel along any\nedges right we start at jfk so basically\nwe know we are finished when the length\nof our results array is equal so i'll\nwrite it out is equal to the length of\nour tickets plus\n1. so down here you can see when length\nof result is equal to length of tickets\nplus one that's how we know that we are\ndone the plus one comes from the fact\nthat we already start with a single uh\nnode in our result array and then every\nother node comes from traveling along\none of the edges in our graph so that's\nthe main idea now in this example it was\nkind of simple for us because the first\nyou know solution ended up working the\nfirst path that we tried ended up\nworking but if it didn't suppose we\nactually had a graph that looked like\nthis one and let's say we started at the\na node in this case we have two choices\nof where we could go we could go to c\nfirst or we could go to b first we're\ngoing to choose b because it comes first\nin lexical order compared to c so we\ntravel along this edge and we end up\nvisiting the b okay well now we're stuck\nhere there's no outgoing edges from b we\ncan't even get back to a so what we\nfound is we tried to be greedy we tried\nto take the first character that came\nright the the first the alphabetical\ncharacter but it didn't work out for us\nso we end up backtracking we say okay\nwe're actually not going to travel along\nthis edge at least just yet we're\nactually going to travel to the c first\neven though it comes after in order\ncompared to the b just because we know\nthat at least here we might be able to\ncreate a valid path so we go to c then\nwe go back to a and then we go to b so\nbasically what we\nrealized from this example is that\nsometimes in some of the cases we're\ngoing to have to backtrack so we might\ngo along an edge and realize that it\ndoesn't work and then we're going to\nhave to reverse our decision and then\ntravel along a different edge so that's\nsomething we're gonna have to keep in\nmind let's actually jump into the code\nin a second and stay tuned because it's\nactually gonna be pretty tricky but\nlet's discuss the time complexity of\nthis solution and since i mentioned we\nare going to be doing some form of\nbacktracking the overall time complexity\nto run a dfs on the entire graph in the\nworst case it would be like a v plus e\nright basically the size of the graph\nbut since we are backtracking\npotentially for every single edge that\nexists in the graph the overall time\ncomplexity is going to be you know the\nsize of the graph squared and you know\nsince we know that the number of edges\nis actually going to be you know\napproximately the same or greater than\nthe number of vertices we can actually\nthink of this as pretty much being e\nsquared as the time complexity and as\nthe memory complexity we can consider it\nto be big o of the number of edges one\nbecause we're going to be storing it in\nour adjacency list and when we do the\nfunction recursively this could be the\nsize of the call stack in the worst case\nso this is the time complexity this is\nthe memory complexity now let's code it\nup okay so let's code it up we are going\nto first create our adjacency list we\nare going to map every single source\nnode to an empty list initially so let's\ngo through every single source\ndestination in our input which is\ntickets and just map the source to an\nempty list for now and then let's\nactually build the adjacency list so\nlet's go through every source\ndestination in our tickets and then say\nfor this source we want to append to it\nthis destination and that's really all\nthe pre-work that we have to do now we\nactually get into our dfs where we are\ngoing to be passing in some source node\nand then running dfs on it seeing if we\ncan actually find a valid path and then\nupdating our result accordingly right\nour result is basically going to be that\npath that we found that is valid and in\nlexical order now we know that we have a\nstarting point in our results initially\nwe start at jfk and we actually don't\nhave to pass this variable into our dfs\nbecause our dfs is declared inside of\nthe outer function but now for the base\ncase of this dfs one is that we find our\nsolution how do we know if we find our\nsolution again well if the length of the\nresult is exactly equal to the length of\nthe tickets plus one and in that case\nwe're going to return true saying that\nwe did find a valid path now one of the\ncases where we can't find a valid path\nis if the this source that we're at is\nnot actually in our adjacency list what\nthat means is that this source does not\nhave any outgoing edges from it in that\ncase we can go ahead and return false\nthat means we can't find a valid path\nokay so now what we want to do is\nactually iterate through all of the\nneighbors of our current\nsource node right so for this source\nnode we're going to go through all of\nthe adjacent neighbors and let's\nactually call it v so for the input that\nwe're given this source we're going to\ngo through all of its neighbors we're\ngoing to call that neighbor the v and we\nactually want to enumerate over this and\nbasically what enumerate is going to do\nfor us is going to allow us to iterate\nover the index at the same time as the\nactual\nvalue which is the vertex but what\nyou're about to see is actually we're\ngoing to be modifying the adjacency list\nas we iterate through it right because\nif we visit this v\nvertex this node then we want to remove\nit we want to remove the i index from\nthe adjacency list currently but we\ncan't really\nyou know update a list as we iterate\nthrough it that's not really good to do\nit in many cases it's not even allowed\nso you know rather than iterating over\nthis i'm going to actually create a\ntemporary array of that so i'm going to\ncreate a copy of it and in python you\ncan do that just like this just pass\nthat list into a list constructor and\nthat'll create a copy for us and then\nlet's iterate over that copy instead\nbecause we want to be updating the\nactual adjacency list because that's\nwhat's going to be used in future\nrecursive calls okay so we're we're\nvisiting one of the neighbors this is\nthat neighbor what we want to do is pop\nit from our adjacency list so let's get\nthe adjacency list of the source and\nthen pop it so we're popping the i index\nand once we pop it we also want to\nappend it to our result what we're\nsaying is this is our current path so we\ncan add that v that vertex to our result\nand then what we want to do is run our\ni'm just gonna you know leave that as a\nplaceholder for now and then if that dfs\nends up returning true then we can\nreturn true and then stop the function\ncall because we're just looking for one\npath and we will know that that path is\nthe smallest lexical order one because\nwe sorted our tickets which i just\nrealized i forgot to do so let's\nactually do that up above before we\nbuild our adjacency list let's not\nforget to actually sort our tickets\nby default in python this will\nsort the tickets based on the pair\nbasically the logic that i summarized\nearlier in the video but in some\nlanguages you might have to you know\ncustomize that source comparator okay by\njumping back to the logic down here so\nthis is the decision that we're making\nkind of in our back tracking if we find\nthat it returns true that's great but if\nit doesn't return true then we have to\nbacktrack this decision so what what we\njust did up above what we did was we\npopped this so instead of popping let's\ninsert it back into our adjacency list\nso at this index we want to add v back\nto it and we you know added this to the\nend of our result so now let's actually\npop from the end of our result to remove\nthat right basically reversing this\ndecision that we make and then making a\nnew decision on the next iteration of\nthe loop now of course it's possible\nthat you know down this decision you\nknow down this recursive call we don't\nfind a solution so in that case we end\nup returning false from this function\nbut we know we are guaranteed at least\none solution so we know that when we\nactually called this dfs function which\ni'm going to do right now called the dfs\nand we know that the parameter we want\nto pass in is jfk that's always going to\nbe our initial source node so we pass in\ndfs and then what we end up returning is\ngoing to be our result and of course\nthis time it wasn't really the logic i\nmisnamed one of the variables i don't\nknow why i named it time it should be\ntemp okay now let's rerun this and i\nleft our placeholder dfs as it is we\nforgot to pass in the variable we know\nthat the variable is v\nv is the node that we're going to be\npassing in okay let's try this again\nokay awesome now it actually works you\ncan see that it's pretty efficient on\nthe left this is a pretty challenging\nproblem but i think that this solution\nwhile it's difficult it is also doable\nfor a hard problem so i really hope that\nthis was helpful if it was please like\nand subscribe it really supports the\nchannel a lot consider checking out my\npatreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Min Cost to Connect All Points",
        "NcLink": "min-cost-to-connect-points/",
        "Pattern": "Advanced Graphs",
        "Description": "You are given a 2-D integer array `points`, where `points[i] = [xi, yi]`. Each `points[i]` represents a distinct point on a 2-D plane.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the **manhattan distance** between the two points, i.e. `|xi - xj| + |yi - yj|`.\n\nReturn the minimum cost to connect all points together, such that there exists exactly one path between each pair of points.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e0cd5270-73b5-42d4-3c3f-5451f795ca00/public)\n\n```java\nInput: points = [[0,0],[2,2],[3,3],[2,4],[4,2]]\n\nOutput: 10\n```\n\n**Constraints:**\n* `1 <= points.length <= 1000`\n* `-1000 <= xi, yi <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "f7JOBJIC-NA",
        "PythonSolution": "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        adj = {i: [] for i in range(N)}\n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i + 1, N):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                adj[i].append([dist, j])\n                adj[j].append([dist, i])\n\n        res = 0\n        visit = set()\n        minH = [[0, 0]]\n        while len(visit) < N:\n            cost, i = heapq.heappop(minH)\n            if i in visit:\n                continue\n            res += cost\n            visit.add(i)\n            for neiCost, nei in adj[i]:\n                if nei not in visit:\n                    heapq.heappush(minH, [neiCost, nei])\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nminimum cost to connect all points and\nsurprise this actually is not a problem\nfrom the blind 75 list that we've been\nworking on recently\nand the reason i'm solving this problem\nis because honestly it actually\nshould be a part of that list like this\nis one of those problems i think that's\nmissing from the blind 75 list reason\nbeing\nis this is a problem related to minimum\nspanning trees a concept that a lot of\npeople skip over i think when they\ngrind leak code so this is what we're\ngoing to be doing today and you might\nhave heard of an algorithm for minimum\nspanning trees there's actually a couple\nprims algorithm and there's also crust\ngoals\nwe're going to be doing prims algorithm\nbecause i think it's easier to implement\nand it's actually more efficient most of\nthe time\nand you might remember this algorithm\nfrom college most\nmost computer science curriculums do\nteach it but if you're anything like me\nyou probably forgot it the instant\nthat you you know finished the class\nthat you learned it in\nbut that's okay and this algorithm\nprim's algorithm is actually not as\ncomplicated as you might expect\nso we're just given a list of points\nthat represent some coordinates on a 2d\nplane so\nwe're for each point we're given two\nvalues the x-coordinate and the\ny-coordinate so the cost of connecting\nany two particular points like let's say\nthese two points circled\ndown there the cost of connecting them\nis just going to be the absolute value\nof the\nx difference plus the absolute value of\nthe y difference so it's actually not\nyou know the the cost of connecting them\nis not going to be like the diagonal\nit's going to be the\nx distance and the y distance in other\nwords the manhattan distance if you've\nheard of that term\nthat's pretty easy to calculate good for\nus and for the entire\nset of points in this case we're given\nfive points we want to know what's the\nminimum\npossible cost to connect all points\nand they also say that any pair of\npoints is going to be connected by\nexactly one\nsimple path i think that's that\ninformation is actually redundant just\nsaying that we want the minimum cost to\nconnect all points\npretty much tells you this is going to\nbe a minimum spanning tree problem\nso the only question is where the heck\nare the edges for this graph we're only\ngiven\npoints right so but they do tell us\npretty much what an edge is going to be\nright with the cost\nof each uh connection is just going to\nbe the distance so we have to create our\nedges\nourselves so basically all possible\nedges could be you know every single\npoint\nto connect it to every other point right\nthat's going to be a set of edges and we\ncan continue that so for example you\nknow this point to connect\nall the other uh points as well so we're\ngonna have to kind of manually create\nthe points\nso for each pair of points in the entire\ngraph we're just gonna take the\nmanhattan distance between them and just\ncall that an\nedge and then you know have our list of\nedges or basically we're going to create\nan adjacency list\nso that is kind of like the pre-work we\nhave to do that's step one\nin this problem creating the edges but\nas soon as you create the edges\nthis is literally just a problem that\nyou can go ahead and take\nprim's algorithm and just apply the\ntextbook definition of prim's algorithm\nto this problem and you will get the\noptimal solution and the time complexity\nof that is going to be n squared log n\nbecause n squared is going to be the\nnumber of edges we're going to have\nright because\nto connect each pair of points we could\npotentially have n squared edges where n\nis the number of points that we're given\nand login\nis going to come from prem's algorithm\nbecause we're going to be using\na min heap in this problem so it's\npretty similar in a way to jigstra's\nalgorithm\ndigixtra's minimum path algorithm\nif you if you are familiar with that\nprim's algorithm is pretty similar to\nthat so let's\njump into it so prim's algorithm is an\nalgorithm to find minimum spanning trees\nso there's a few concepts you have to be\nfamiliar with to understand prim's\nalgorithm to obviously\nyou need prim's algorithm to solve this\nproblem efficiently so i'm just gonna\ngive some of the background in case you\ndon't know it\nso basically let's say you have a graph\nand in this case\nwe have a graph with five nodes or\nvertices right\nand to connect all of these nodes\ntogether\nwithout forming a cycle so we want\nevery node to be connected together but\nwe don't want to form a cycle how many\nedges is it going to take us to\naccomplish that it's going to take\nexactly n minus 1 edges so if we have\nfive nodes it's going to take exactly\nfour edges to connect all of them\ntogether\nwithout creating a cycle because take a\nlook right now i have four edges\nright if i add another edge that's not a\nduplicate if i add an edge here we\ncreate\na cycle if i add an edge here we create\na cycle right\nthat's just kind of something you know\nand i think it intuitively does make\nsense\nbecause you know if you start out with\nfive nodes you add one edge\nnow we have four different you know\nconnected components we have one here\none here and then a couple here every\ntime you add an edge you're decreasing\nthe total number of connected components\nby one\nso if we start out with five nodes we\nadd four edges we de\nwe decrease the number of connected\ncomponents by four then we're going to\nbe left with one connected component so\nif we add another edge on top of that\nwe're going to get a cycle\nso we want to connect all of these\nwithout creating a cycle because that's\nwhat a minimum spanning tree is\nso our goal is to connect all of these\nwith\nexactly four edges but prim's algorithm\nor\nthe definition of a minimum spanning\ntree is also\none more condition we want to minimize\nthe total\ncost of the edges now i didn't actually\ndraw all of the edges all the possible\nedges out right now it would look\nsomething like this right basically for\nevery single node\nit could possibly be connected to every\nother single node and the reason i'm not\ndrawing it is as you can see\nit's going to get really complicated\nreally quickly\nso this is pretty much what it would\nlook like if i drew every possible edge\nthat could exist\nin this graph and i think that's going\nto make it a little bit too messy but\nlet's just assume\nthat those edges do exist that for any\npoint we could possibly connect it\nto another point so the way prim's\nalgorithm works is we can choose to\nstart at\nany single node in the entire graph\nand then very simple we're just gonna\nperform\na bfs a breath first search on\nthat node where we are gonna\ncontinuously be\nfor every node that we're adding we're\ngonna have two data structures we're\ngonna have a\nvisit data structure to to make sure\nthat we don't add\nthe same node twice because if we add\nthe same node twice\nthat's how you know we're gonna get a\ncycle we want to avoid\ncycles the second data structure we're\ngonna use is a minimum heat\nwhich is gonna keep track of our\nfrontier\nof our breadth first search now what is\na frontier\nwell you might know that let's say we\nhad a single node\nso we visited this this is in our graph\nright this is part of our\nminimum spanning tree what's the\nfrontier then basically every possible\nnode\nthat could be added from this position\nright so\ninitially if we just had one node these\nfour nodes\nwould be in our frontier but we're not\njust gonna have\neach node in the front here so we're\ngonna have you know let's say\nnode one and we're also gonna add the\nweight of connecting node one so let's\nsay the weight of the edge was something\nlike five\nthen we'd add one five in our min heap\nbut we're not going to add it in this\norder we're gonna add it in the opposite\norder\nfive one because when we're popping from\nthe min heap\nwe're gonna be wanting to pop whatever\nnode we can connect\nnext with the minimum possible cost\nso let's say we had five you know three\ntwo and you know up here we have a six\nor something\nout of all these four nodes which of\nthem can we connect with the minimum\npossible cost that's what we're going to\nuse our min heap for\nlooking at it you can tell okay this one\nbecause it has a cost of\n2 so then we're going to connect that\nthat so then that's going to be a part\nof our frontier\nso next we're going to say okay we have\ntwo nodes\na part of our frontier next what we're\ngonna do is add\nmore nodes to our frontier even though\nwe already had\nall three of these nodes we're gonna add\nthem again\nto our frontier because now possibly if\nwe're if we're starting from node four\nand we're trying to connect to three\none or two it's possible that the\nconnection\nfrom four to three or four to two or\nfour to one\ncould be smaller than the connection\nfrom one\nto those respective nodes so we always\nwant to connect a node\nwith the minimum possible cost that it\ntakes us if it costs\nless to connect it to four then to\nconnect it to one\nwe're going to take the one with the\nsmaller cost and of course\nas we visit nodes we visit zero we visit\nfour we're gonna add them to our hash\nset so\nthat we don't you know starting from\nfour we're not gonna go back to one and\nadd one\nagain because that would create a loop\nand how do you know that we can\nstop the execution of prim's algorithm\nwell once the\nlength of our visit set the the number\nof nodes that we've added\nis equal to 5 which is the number of\nnodes that we started\nout with so with all that being said you\njust have to understand how these data\nstructures are contributing to the\nsolution and then we can go ahead and\nwalk through it so let's start at zero\nyou can start at any node you can start\nat three\ntwo four but in this case we're gonna\nstart at zero just because it makes\nsense\nso when we start at zero what we're\ndoing is we're adding it to visit and\nwe're adding it to the frontier so\nwhat's the\ncost of connecting zero well if we're\njust connecting a single node to the\ngraph we're not actually including any\nedges so the cost is going to be zero\nand the node value is going to be zero\nand so the way this algorithm works is\nat each step we're just going to\npop from the min heap so let's pop the\nfirst value\nthis right so the total cost so far is\nzero right we don't actually have to add\nany cost\nand that's actually one other variable\nwe're going to be maintaining let me\njust write it down down here\nso so far the cost is zero we're going\nto continuously be adding to it though\nbut next for zero we're now going to add\nevery one of its\nneighbors to the frontier and the way\nwe're gonna add it i haven't drawn it\nout but there is gonna be like an\nadjacency list\nso we will have a list of neighbors for\nzero of course it could be connected to\nevery single point in the entire graph\nthat's just how this\nproblem is defined now i'm not going to\nwrite the exact\ncost of each of these edges because i\nthink it's pretty\nobvious from the picture that this is\ngoing to be the one that's closest and\nthe cost of connecting to that is going\nto be 4 based on the\npoint values that we were given in the\nprevious picture so\nout of all these four these are going to\nbe in our frontier\nso all of these are going to be in our\nfrontier and you can see i drew them\nhere i didn't specify the actual cost\nof 2 3 and 4 because i don't want to\nfocus too much on that because we know\nthat this is going to be the minimum so\nthis\nis the one that we care about right now\nbecause we already can tell from the\npicture that it's the smallest\nand so that's the step right so you take\nthe entire frontier add it to the min\nheap\nnext step we're just going to repeat the\nsame thing that we just did we're going\nto take a look at our frontier\npop the minimum from it we know that\nthis is the minimum so pop\nit when you pop a node we have to add it\nto visited so we popped the one node\nright\nand so we're going to add it to visit\nand the cost of that one was\nfour right so let's just add four to our\ntotal cost so far\nand since this one was popped let me\njust draw that that is definitely going\nto be an\nedge inside of our minimum spanning tree\nso now we\nare at one and now we're going to add\nevery adjacent node or every neighbor of\nthis\nto our frontier as well so you can see\nthat that this is kind of what the graph\nis going to look like\nwe're not going to add 1 to our frontier\nbecause it's actually already been\nvisited\nbut we are going to add 2 3 and 4 to our\nfrontier now notice they already exist\nin our frontier right so we're going to\nbe adding them\nmultiple times that's kind of how the n\nsquared is going to come from right we\ncould possibly add\nn squared nodes to this min heap because\nwe're going to be adding it for every\npossible\nedge that exists in our graph and every\ntime we pop from the min heap it's going\nto be\nlog n so basically the time complexity\nis n squared multiplied\nby log n so i'm not going to redraw all\nthree of these\nnodes but you can assume that yes there\ncould be duplicates of them\ninside of our min heap now looking at 1\nwhich\nnode is the closest to it now of course\n3 is the closest node\nto our entire graph this is our entire\ngraph right we have two nodes right\nwhat's the closest node that we can add\nto this graph right we could add it\nanywhere we could\nsay okay this is going to be connected\nto zero right or three is going to be\nconnected to zero or three is going to\nbe connected to one we could add\nany node but we know just by looking at\nthe picture that this is what's the\nclosest\nis gonna be and i'll just tell you okay\nfor that node three the cost is gonna be\nthree so now we continue another\niteration of our loop\nlet's pop the minimum from the frontier\nthis is gonna be the minimum three has\nbeen popped\nso let's add an edge connecting it to\nour graph so so far this is what our\ngraph looks like since we popped 3 add\nit to visit and let's add the cost\nof it so 3 was the cost of adding node 3\nso total our cost\nis going to be seven so far so now three\nhas been visited now let's add the\nfrontier\nof the neighbors of three of course one\nand\nzero have already been visited so we're\njust focusing on two\nand four we're going to add those to our\nfrontier they're already in our frontier\nbut yes we're going to be ending up\nadding duplicates\nto the frontier right so i'm not going\nto you know actually focus too much on\nthe drawing but\nthere could be multiples of these in the\nfrontier and now\nwell which of these edges that are in\nour front here or the nodes in our\nfrontier what's the minimum cost that we\ncould pop\ni'm just gonna tell you that for the\ncost of node four\nit's going to be four and it's going to\nbe this right you can tell by the\npicture that's pretty obvious\nthis is going to be the shortest way to\ninclude the node 4.\nso let's pop this node add it to\nthe edges list so 1 or 3\nand 4 are going to be connected and the\ncost of that one was\nfour so let's add four and let's add it\nto the visit now\njust so you know that let's say we did\nend up popping the same node multiple\ntimes because technically that's\npossible right\nwe pop one four but we still have a four\nremaining\nin the frontier so we what if we popped\nfour again what would we do well we\nwould actually see that okay let's take\na look at our visit well four\nis already been visited right so there's\nno need to add this to visit again and\nthere's no need to add the frontier\nof that again and there's no need to\ntake the cost of that\nand add it to our total cost because\nfour was already connected to the graph\nwe don't wanna you know add a redundant\ncost\nokay but so now you can see that four\nhas been added to our graph\nnow what's the remaining neighbors of\nfour of course these three nodes have\nalready been visited so the only edge we\ncould possibly add that would be useful\nwould be\nthis to there but you can see that\nthat's a pretty long path right surely\nwe have a shorter path in our graph\nto the two node so so you can see four\nof them are already connected we just\nneed to connect one last one so let's\npop from our frontier again\nthis is gonna be obviously two is gonna\nbe the one that's popped but what\nexactly is gonna be the cost of it\nwell i'll just tell you the cost is\ngonna be nine and which edge is it gonna\nbe well by looking at the picture we'd\nprobably think one of these two is gonna\nbe connected to two either\nlike this or like this and i'll tell you\nthat the paths are actually not\nof equal length if they were equal\nlength it wouldn't really matter what\nwhich one we chose right\nit would it would lead to the same cost\nanyway but in this case i'll tell you\nthis is the shorter one\nso and yes the cost of that is going to\nbe nine so we can pop this so we can say\nokay\ntwo has now been added two has been\nvisited now it wasn't\npreviously visited but now it's visited\nand the cost of adding it was 9. so the\ntotal cost\nthat we ended up getting was 20 20 was\nthe total cost\nand now we know we're done because every\nnode in our graph has been connected you\ncan tell by the red\nedges all of the nodes are connected we\nadded\nfour edges and we visited every single\nof the five\nnodes so the algorithm prim's algorithm\nis just that simple i mean it's not\nreally simple until you've actually done\nit a few times you've practiced it and\nlearned these concepts of\nvisit minheep and now we're actually\ngoing to jump into the code it's about\n20 to 30 lines\nokay so let's write it out and like i\nsaid so the first thing we're going to\nbe doing\nis actually creating the adjacency list\nbecause that's not given to us we're\njust given a list of points so i'm going\nto get the number of points we have\nand then i'm going to start creating\nthat adjacency list so\nand basically i'm going to refer to each\npoint in our list as\nbasically the index of that point so the\nfirst point in our points list is going\nto be point zero\nthe next one is going to be 0.1 etc etc\nso we can just say for i in\nrange of the number of points we have so\nfor i in\nrange of n the number of points we're\nbasically going to take each point i\nmap it to a empty list so far now we're\nactually going to build out that list so\nfor i in range of n\nso for every single point we want to\ncompare it to every\nother point in the graph so for j in\nrange i plus 1 all the way to n so we\ndon't want to compare each point to\nitself\nwe just want to compare it to every\nother point in the entire graph\nand when we do that we want to get the\ncoordinates so\nfor the point at i we're just going to\nget the x and y\ncoordinates so points at index i\nand we're going to do the exact same\nthing for the point at index\nj inside of our loop we're going to get\neach point\nthat we're comparing it to and then\nwe're just going to take\nthe distance the manhattan distance\nbetween them and we can get that by\ntaking the absolute value of x1 minus x2\nthe absolute value of y1 minus y2\nand so i'm going to just comment up\nabove that for each node work\nwe're mapping it to a list of points\nand for each point we're basically going\nto have the\ncost and the node or the neighbor\neach neighbor is going to be a pair\nright so each edge is basically a\nweighted edge don't forget about that\nso we're going to say adjacency for i\nappend to it the cost or the distance\nright and the node itself which is node\nj and we're going to do the exact\nopposite because technically these are\nundirected edges they go both ways so\nlet's just do the exact opposite so\nadjacency of j append to it the distance\nsame distance but instead we're\nappending i because that's its neighbor\nso this is how you build that adjacency\nlist and technically we could actually\nnot have to write this for loop out we\ncould actually you know\ncompute these calculations while we are\nrunning prim's algorithm but the reason\ni'm doing it before is just to\ngive a clear distinction this is the\nedge portion this is like the extra\nportion of this problem\nthe following part is literally just an\nexact\nimplementation of prem's algorithm\nnothing fancy\nso let's define our variables we're\ngoing to have a result which is of\ncourse going to be the total cost\ninitially it's going to be 0. we're also\ngoing to have a visit\nset so it's going to tell us the the\npoints that have already been visited\nwe're also going to have a min heap\nwhich is initially not going to be empty\nwe're going to be starting at point\nzero and the cost of it is also going to\nbe zero so let me just put in a comment\nthat each pair is going to be the cost\nand the point cost goes first the order\nis important because that's what the min\nheap is going to be minimizing it based\non\nand so now we're actually going to do\nthe loop and remember we're going to\nkeep going while the length of visit is\nless than the total number of points\nwhich is n\nand on each iteration we're going to be\npopping from the min heap in python we\ncan say heap q\ndot heap pop and from it we'll get a\npair of values\nokay we have to specify which heap we're\npopping from min heap\nmin h and we're going to get a pair of\nvalues the we can call it cost\nand the point let's call it i and\nremember\nwe are adding duplicates to our min heap\nso if we popped it this could have\nalready been visited so let's just check\nif\ni is in visit then we're just going to\nskip this iteration of the loop we\ndon't want to have to process this same\nnode that's already been popped before\nbut if it hasn't been popped then we're\ngoing to take the cost of it\nadd it to the result so we're adding\nthis fresh new\nnode that we haven't visited yet and\nwe're also going to add it to visit now\nto make sure that it never gets visited\nagain\nand then we're going to go through every\nneighbor in its adjacency list\nso the adjacency list of i and remember\neach neighbor actually isn't just\none value it's going to be the cost so\nlet's call it neighbor\ncost as well as the neighbor right up\nabove you remember that in our adjacency\nlist we added a pair of values in that\nlist cost and the node itself\nso now for each neighbor so for nay if\nthe neighbor\nis not in visit then we're going to be\nadding it to our min heap\nso then we can say heap q dot heap push\nto the min heap we're going to be\npushing a pair of values remember we're\npushing the cost first so neighbor cost\nand then the neighbor and that's it\nright so we're just for every neighbor\nall we're having to do is just add it to\nthe min heap right and then we're going\nto go to the next iteration of the loop\nrepeat the exact same thing until we\nvisit every single node\nonce we've done that we know for sure\nthe result has the total cost\nthat it took so then at the end all we\nhave to do is return that\ncost let me make sure i don't have a\nspace and yeah that's the exact thing so\nyou can see this is the portion that's\nprim's algorithm everything else is just\nsome pre-work that we had to do yes we\ncould have taken this pre-work and mixed\nit up into here but i just want to give\na clear\nunderstanding to you all of what exactly\nprim's algorithm entails this is just\nstuff that's not necessarily related to\nprim's algorithm\nwe do need an adjacency list though to\nperform this algorithm efficiently\nso i hope that this was helpful if it\nwas please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Network Delay Time",
        "NcLink": "network-delay-time/",
        "Pattern": "Advanced Graphs",
        "Description": "You are given a network of `n` directed nodes, labeled from `1` to `n`. You are also given `times`, a list of directed edges where `times[i] = (ui, vi, ti)`. \n    \n* `ui` is the source node (an integer from `1` to `n`)\n* `vi` is the target node (an integer from `1` to `n`)\n* `ti` is the time it takes for a signal to travel from the source to the target node (an integer greater than or equal to `0`).\n\nYou are also given an integer `k`, representing the node that we will send a signal from.\n\nReturn the **minimum** time it takes for all of the `n` nodes to receive the signal. If it is impossible for all the nodes to receive the signal, return `-1` instead.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ba9b9be8-b888-45d6-627a-e719d1ac4e00/public)\n\n```java\nInput: times = [[1,2,1],[2,3,1],[1,4,4],[3,4,1]], n = 4, k = 1\n\nOutput: 3\n```\n\n**Example 2:**\n\n```java\nInput: times = [[1,2,1],[2,3,1]], n = 3, k = 2\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= k <= n <= 100`\n* `1 <= times.length <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "EaphyqKU4PQ",
        "PythonSolution": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        edges = collections.defaultdict(list)\n        for u, v, w in times:\n            edges[u].append((v, w))\n\n        minHeap = [(0, k)]\n        visit = set()\n        t = 0\n        while minHeap:\n            w1, n1 = heapq.heappop(minHeap)\n            if n1 in visit:\n                continue\n            visit.add(n1)\n            t = w1\n\n            for n2, w2 in edges[n1]:\n                if n2 not in visit:\n                    heapq.heappush(minHeap, (w1 + w2, n2))\n        return t if len(visit) == n else -1\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nnetwork delay time the reason i'm\nsolving this problem is because it's a\nrare problem that you actually have to\nuse\najixtra's however you pronounce that\nname\nthis algorithm it's the shortest path\nalgorithm\nit's not super common on leak code but i\nthink it's a really cool\nproblem to solve a cool algorithm to\nimplement so obviously this is a graph\nproblem we're given\na network of n nodes labeled from\n1 to n and we're also given a list of\ntimes the times are going to be our\nedges so\nit's going to be directed edges so a\ntime\nis a triple value the first value in\nthis triple\nis going to be the source node so for\nexample this node 2\nthe second node the second value is\ngoing to be the target\nnode for example 1 is this node\nand the reason it's a target is we can\nsee that there is an\noutgoing edge going from two to the one\nso every edge is going to be directed\nright we can see there's a directed edge\nthere a directed edge here\nthe third value and this is also pretty\nimportant for this algorithm\nis the weight of the edge in the context\nof this problem the one basically just\nmeans the amount of time\nit's going to take for us to go from\nhere to this node right\nbut this is the weight of the edge so\nwe're given\na original node k so this is our\nstarting point the node k is going to be\nthe starting point\nso for example in this problem in this\norigin in this graph\nwe're given k equals 2. that means this\nis the starting point\nfor us what we want to do in this\nproblem\nis starting at two how\nlong would it take for us to visit\nevery single node basically if we\nif we sent a signal from here in every\ndirection so in this direction\nand in this direction how long would it\ntake for that signal to reach\nevery single node now if it's not\npossible for example\nin this case it is possible but what if\nwe had a fifth node over here\nthat's just not connected to these four\nnodes over here then it would be\nimpossible\nfor this node to send a signal here in\nthat case\nwe're simply going to return negative\none because it's not possible\nbut what about in this problem because\nit is possible\nhow long is it going to take that's the\nonly question now looking at the picture\nit's pretty obvious\nstarting at 2 how long is it going to\ntake for this to reach a signal\nit's going to take 1 right because the\nweight of the edge\nis 1. how long is it going to take for\nthis node to\nto get the signal also one because\nthe the weight of the edge is one so now\nwe're over here\nlet me just change the color to make it\na little bit better by the way this was\nthe original node how long did it take\nthis node to get the signal\ntechnically zero right because it's the\none sending the signal\nhow long did it take this three to reach\nthe signal one\nhow long did it take this to reach a\nsignal one now we're going to continue\ngoing\nfrom this three we know that this one\ndoesn't have any more nodes that it can\nsend the signal to but this three\ndoes it has a node over here four right\nnow how long is it going to take this\nfour to reach the signal\nwell the weight of the edge is one so\ndoes that mean it's going to take\nthe for one second or whatever our time\nunit is to reach this\nno because we have to add the one from\nover here right\nremember our signal first started over\nhere\nthen it traveled over here with one then\nit's going to travel again\nover here with one so in total once we\nhave visited this\nnode it's going to have taken two units\nof time to reach it\nnow after this node reaches gets the\nsignal\nthat means everybody has gotten the\nsignal how long did it take what's the\nlargest value we have\nit took this one right this one took two\nseconds or whatever\nso therefore we're going to return two\nbecause after\ntwo you know units of time every node\nhas received the signal so our output\nvalue\nin this case is going to be 2. now from\nlooking at this example that we ran\nthrough you might be able to tell that\njigstr's algorithm is actually a breadth\nfirst search algorithm\nthat i'm going to show you the general\nidea of\nbut the one difference about regular\nbreadth for searches\nthis algorithm actually uses a minimum\nheap\naka a priority queue so we're going to\nbe needing this data structure it's not\na super common data structure\nbut it is it is needed for this graph\nalgorithm let me show you the actual\nalgorithm after that we're going to jump\ninto the code\nso in case you want to google this\nalgorithm or do some more research it is\ncalled\njigsaw's algorithm it is a shortest path\ngraph algorithm\nand it's pretty common you have probably\nlearned it in school if you study cs\nand what it does is in this case let's\nsay our source or our starting point is\nthis node the value one what it does\nis for every other node it basically\ntells you the shortest path right so\nfor example three what's the length of\nthe shortest path\nto this node well from directly from one\nto three\nit takes one so one is going to be the\nshortest path\nfor this node what about this two node\nwhat's the shortest path to this node\nright\nwith this it's pretty obvious because\nthere's only one\nway to get here anyway but take a look\nat this node\nthere's two different ways to get there\nnow this\nis this the shortest path it's the\nobvious path right it's just\none node away but the edge has a weight\nof four that's a problem because take a\nlook at the second path that we can do\nwe can go to\nthree right over here then we can go to\nthe four\nand then we can get to the two right\nthat took three\nedges didn't it that took one edge two\nedge\nthree edges but when we total these\nvalues up\nwe get a sum of three that means\nthis path is actually shorter than the\npath up here so\nit's not always clear right that's why\nwe need an algorithm\nand that's exactly what we have we have\njigsaw's algorithm\nand we're going to be doing a breath\nfirst search right so starting at this\nnode the start node 1 we're only going\nto be possibly visiting nodes that are\nthat are right next to our frontier\nright\ndepth first search would be we just go\none direction we just keep going right\nbut breadth first search\nis we're gonna do this layer by layer\nright we're going to go to the first\nlayer\nthe next layer and so on if we had a\nbigger graph right that's how breadth\nfirst search works\nand every node that is on our\nfrontier right so if this is our\nstarting point we have two\noptions of nodes we can visit this node\nor this node\nthese both are going are going to be\nadded to our min\nheap and we're only going to visit the\none with a shorter path\nthat does make sense so far doesn't it\nit makes sense that we would want to\nvisit\nthis node because it has a shorter path\nrather than visiting this node first\nwhich has a longer path right that makes\nsense so far\nthat's why we're using a minimum heap\nminimum heaps can get us the minimum\nvalue\npretty efficiently right every time we\nwant to get a minimum value from the min\nheap\nit's just a log n operation\nokay so the way we initialize this\nalgorithm is we know that we're starting\nhere right what we're going to actually\ndo\nis add this node to our min heap\ninitially right so\nand in our min heap we're going to be\nkeeping track of two values\nobviously the path length right because\nwe're always going to be popping\nfrom the min heap based on the minimum\npath right so that's what\nthat's like our key value that's what we\nactually care about right that's what's\ngoing to determine\nwhich one we pop but we also want to\nkeep track of which node it is right so\ninitially\nthe path to reach uh the initial node\none\nis zero right because we're that's where\nwe're starting so\nit doesn't cost us anything to get there\nand the node itself\nis obviously one so this is how we're\ngonna start then we're gonna pop\nthis value it's only one value so far so\nit's it's simple\nof where we're popping right once we pop\nthis value\nwhat's our next step well like i said\nthis is a\nbreadth first search right so we're\ngonna take a look at the node over here\nit's one we're gonna look at all of its\nneighbors right\nit has two neighbors right we're\nchecking that first\nlayer this we're going we're going layer\nby layer\nwith breadth first search right so this\nis our first layer right\nwe're gonna take the first neighbor\nthree how long does it take to reach\nthree one\nwe're not visiting it yet we're simply\nadding it to\nour min heap so the path length is one\nand this is for node three then other\nnode that we can reach\nis two the path length is four let's add\nthat\nas well four and the node is two\nand since we've already visited the node\none we can cross it out now\nso now we're popping another value this\ntime we have two values so which one are\nwe gonna pop well this is a min heap\nright we're gonna pop the value with the\nminimum\npath it's this one right of course\nthat's the one with the shortest path\nthat's what we're gonna pop\nnow so as we pop every element\nwe're basically determining the minimum\npath so now we can say for sure that the\nminimum path to reach three\ntakes us one right because one was the\nvalue that we added\nto our min heap and again we're just\ndoing a breath first search\nwhat are all of the nodes that three has\nneighbors with\nit it only has neighbors with one node\nright this four we have a directed edge\ngoing exactly to four so let's add\nfour to our min heap\nso we're adding the node 4 right so\nthat's what we're going to put in the\nnode position\nwhat are we going to put in the path\nposition are we just going to put\n1 because it only takes 1 for us to get\nthere from\n3 that's not actually what we're going\nto put we're going to take\nthe total that it took to reach three\nwhich was\none and it's taking us another one\nto reach four so we're gonna add the\ntotal to this right we're not just\nkeeping track of the single one\nwe're keeping track of the total path it\ntakes\nfor each node we want to know how long\nit takes to reach node 4\nall the way from our starting position\nwe care about the starting position so\nwhen i put the path value\nof the path length for this node i'm\ngoing to put a 2 value\nso now we are once again done with this\nnode so now again we are going to decide\nwhich one are we going to pop\nfrom our min heap we want to pop the\nvalue with a\nshorter path so we're going to pop this\none\nso now we're at this node right and how\nmany nodes can this node\nreach well it only has a single outgoing\nedge\nto this node 2 right and we see that\n2 has actually already been added to\nour min heap right but the only\ndifference is this time\nand i'm running out of space so i'm just\ngoing to add a little slot is that\nfor this 2 it's how long\nfirst of all how long did it take to\nreach this it took a distance of\ntwo to reach this four and plus one\nmeans that to reach this to reach this\ntwo now it's actually a distance of 3\nwhich is\nshorter than this one right so now\nwe can actually add that same node 2\nto our min heap but this time we're\ngoing to have\na distance of 3 which is shorter so we\nvisited this node\nand now you can see that we only have\none node remaining to visit\ngood thing for us both of our options in\nthe\nmin heap lead to that node which one are\nwe gonna pick\nit's a min heap so we're gonna pick this\none 3\nis less than 4 so we're going to pop\nthis from our min heap\nso now we finally popped the last node\nit's a path length of\n3 so now that we've reached every single\nnode in our array and by the way this\nnode does not have any outgoing edges so\nwe don't have to do anything more\nand we even though we do have an a value\nleft in our min heap\nonce we pop it we're going to see that\nit's the same node that we've already\nvisited we visited this two node and we\nvisited every node now and you can see\nthe max\nvalue that we got in terms of length is\nthree\nso three is going to be our output in\nthis case it takes\nthree units of time or whatever for us\nto start at this\nposition and then send a signal to every\nother node\nin the graph so analyzing the time\ncomplexity of this problem is actually a\nlittle more difficult than you think so\ni'm going to use\ne to tell us basically the number of\ntotal edges\ninside of our graph that we're given\nand v for the total number of nodes or\nvertices that we're given\nand just so you know the maximum number\nof edges\nthat we could possibly have is about\nproportional to the number\nof nodes squared because like it's just\nkind of how it works so like if we had\ntwo nodes\nor rather three nodes you know there's\nwe could have bi-directional edges\nfor every pair of nodes and if you just\nbasically this is just something that's\ntrue and that's what i'm going to assume\nso the max size of our heap could\nactually be\nv squared even though we have let's say\nfour\nedges we noticed that some of the uh\nor rather we have four nodes we notice\nthat some of the nodes could be added\ninto the min heap\nmultiple times that's dependent on the\ntotal number of edges that's why we're\nsaying v\nsquared is the total number of nodes\nthat could be in the heap\nso every heap operation is possibly\nworst case\nlog v squared and how many times\nare we going to be doing this operation\nit's going to be e\ntimes worst case basically the number of\nedges because for every edge\nis how many times we can add values to\nthe heap\nright so and this and the way logs work\nlogarithms if you take this 2 we can\nactually\nget rid of that too put it over here\nright put the two over here and we know\nhow big o\ncomplexity works we don't care about\nconstant values\nso this two actually goes away so the\noverall\nbig o time complexity with a\npriority queue for a jigsaw's algorithm\nis going to be e\nlog v this is just the general overview\nnow let's get into the code\nso we're actually given a list of edges\nand we want to create an adjacency list\nof that first\nfor jigsaw's algorithm so the first\nthing i'm going to do is create a\ndictionary or a hashmap of\nedges initially it's just going to be an\nempty list\nso i'm going to go through every edge in\nthe input\nso for so for every edge u i'm going to\nget a list of all of its\nuh neighbors right because we know that\nthat's pretty useful for a gixxer's\nalgorithm we're going to\nbasically get every single outgoing\nneighbor so v\nis the neighbor node and w is the weight\nof that node so we're going to add that\nto edges\nlist for you so this is just creating an\nadjacency list for us which is going to\nbe useful\nnow i'm going to create that min heap we\nremember\nwe want to just initialize this min heap\nwith the first value and the\nweight of it's going to be 0 because we\nknow it doesn't cost us anything to get\nthere and that\nstarting node is given to us as k i'm\nalso going to have one more data\nstructure it's going to be a set\nbasically it's going to keep track of\nall the nodes that we've visited because\nwe know we don't want to go\nin a cycle we don't want to go in a loop\nso we do have to\nsort of keep track of that i'm also\ngoing to have a variable t\nfor the result initially it's going to\nbe 0 basically the max\nvalue that we end up getting or the last\nnode that we visit\nand the cost or the length to visit that\nnote is going to be the value that we\nreturn\nso now we're just going to continue our\nalgorithm while our min heap\nis non-empty we're going to keep popping\nfrom\nour heap while it's not empty we know\nthat there's two values that we added\nthe\nweight was the first value the second\nwas the actual node itself so we're\ngoing to say\nkeep q dot heap pop\nfrom our min heap this is basically how\nyou do it in python it's\npretty easy in python that's what i like\nand\nlike i said we don't want to visit a\nnode multiple times so if we see that\nthis node\nn1 is in visit meaning it's already been\nvisited then we're just going to\ncontinue to the next\niteration of the loop we don't want to\ngo through all of this node's neighbors\nif it's already been visited otherwise\nwhat we're going to do is\nadd it to visit so that we don't visit\nit again and we're also going to update\nour result\nt so we're going to set it to the max of\nwhat it already is\nand the max of the weight that we just\ngot the weight is remember the time it\ntakes to reach\nthis node so we're going to update that\nnow we're going to do the breath first\nsearch\nportion of it so we're going to go\nthrough all the neighbors\nof this node so the no the neighbor and\nthe neighbor's\nweight so i'm just going to call that n2\nand w2 because i'm bad at naming\nthese so in edges basically neighbors\nof this n1 original node that we just\npopped from\nour min heap we're going to go through\nit and for all of the neighbors that\nhaven't already been visited so if\nn2 is not in visit it's it has not been\nvisited yet\nthen we're going to add it to our min\nheap so heap q dot\nheap push on to our min heap\nis going to be this node n2\nbut remember the first value we're\nadding is the weight so\nweight 2 but remember this weight\nis just this weight 2 is just the weight\nthat it takes\nfor one edge but we want to keep track\nof the total\nuh path length to reach this node so\nwe're actually going to add that\nw1 the first weight to it\nas well so w1 plus w2\nthe total path that it takes to reach n2\ni know that this algorithm is actually\npretty complicated\nit's not a lot of code it's about 20\nlines but it's actually\nyou know it does take some practice to\nget used to it after you've written it a\nfew times you do kind of understand the\nsubtleties of it\nit's pretty easy to go wrong with this\nalgorithm but we've basically\nwritten the entire thing so now we can\nreturn\nt after this loop is done executing\nafter the min heap is empty\nour t should give us the uh basically\nwhat it takes to reach every single node\nif it's possible right remember if it's\npossible\nand we know that it's possible basically\nwe've visited\nevery single node if the length of visit\nis equal\nto our input value n which tells us the\ntotal number of nodes if we visited\nevery node then we can return\nt remember the other condition was if we\ncan't visit every single node\nwe return negative one and that is the\nentire algorithm remember the overall\ntime complexity is big\no the total number of edges multiplied\nby log the total number of vertices\nso this was a pretty long one it was\npretty difficult i actually had a lot of\nbugs when i was writing my code for this\nvideo\nand i hope that this came across pretty\nclear\nif this was helpful please like and\nsubscribe it supports the channel a lot\nand i'll hopefully\n"
    },
    {
        "Name": "Swim In Rising Water",
        "NcLink": "swim-in-rising-water/",
        "Pattern": "Advanced Graphs",
        "Description": "You are given a square 2-D matrix of distinct integers `grid` where each integer `grid[i][j]` represents the elevation at position `(i, j)`.\n\nRain starts to fall at time = `0`, which causes the water level to rise. At time `t`, the water level across the entire grid is `t`.\n\nYou may swim either horizontally or vertically in the grid between two adjacent squares if the original elevation of both squares is less than or equal to the water level at time `t`.\n\nStarting from the top left square `(0, 0)`, return the minimum amount of time it will take until it is possible to reach the bottom right square `(n - 1, n - 1)`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/11a45dd8-625f-4be6-9fbb-a3b6ffcc1100/public)\n\n```java\nInput: grid = [[0,1],[2,3]]\n\nOutput: 3\n```\n\nExplanation: For a path to exist to the bottom right square `grid[1][1]` the water elevation must be at least `3`. At time `t = 3`, the water level is `3`.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e585e59c-a1f9-4d10-538d-9e52bcdb6200/public)\n\n```java\nInput: grid = [\n  [0,1,2,10],\n  [9,14,4,13],\n  [12,3,8,15],\n  [11,5,7,6]]\n]\n\nOutput: 8\n```\n\nExplanation: The water level must be at least `8` to reach the bottom right square. The path is `[0, 1, 2, 4, 8, 7, 6]`.\n\n**Constraints:**\n* `grid.length == grid[i].length`\n* `1 <= grid.length <= 50`\n* `0 <= grid[i][j] < n^2`\n",
        "Difficulty": "Hard",
        "Video": "amvrKlMLuGY",
        "PythonSolution": "class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        visit = set()\n        minH = [[grid[0][0], 0, 0]]  # (time/max-height, r, c)\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        visit.add((0, 0))\n        while minH:\n            t, r, c = heapq.heappop(minH)\n            if r == N - 1 and c == N - 1:\n                return t\n            for dr, dc in directions:\n                neiR, neiC = r + dr, c + dc\n                if (\n                    neiR < 0\n                    or neiC < 0\n                    or neiR == N\n                    or neiC == N\n                    or (neiR, neiC) in visit\n                ):\n                    continue\n                visit.add((neiR, neiC))\n                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve swim in Rising water this is\na graph problem we're given an N byn\ngrid so it's going to be a square grid\neach position in the grid represents the\nelevation at that point and so basically\nsome amount of rain is falling at time T\nthe depth of the water everywhere is\ngoing to be T but you're going to find\nthat we actually don't need to worry\nabout this T variable we don't really\nneed to worry about the water itself\nbecause we are allowed to swim at any\nposition so from one square to another\nsquare if and only if the elevation of\nboth the squares is less than or equal\nto t t is the amount of time that's\npassed and like I said we're actually\nnot going to have to keep track of what\nT is the reason being let's keep reading\nthe problem we can swim an infinite\ndistance in zero time so you know if\nlet's say this was our our 2D grid right\n1111 uh we could swim this entire\ndistance in zero time and the question\nthey're asking is if we start at the top\nleft of the grid and we go to the bottom\nright of the grid What is the least time\nit takes for us to reach the bottom\nright Square so clearly we want to know\nthe time but why did I say we don't\nactually have to keep track of this time\nbecause think about it initially we're\ngoing to be at time zero so let's say\nthe top left of our grid is zero then\nlet's say the right and bottom are are\ntwo right and then maybe the bottom\nright is also two so this is our grid\nright we're starting here we want to get\nto the bottom right so both of the paths\nare pretty much the same to get there so\nmy question to you is what is going to\nbe the time it takes for us to get here\nwell remember initially there's zero\nwater and for us to be able to reach\nthis position too we can only reach it\nif T is less than or equal to 2 because\nthat's the maximum elevation that we've\ngone at so really what the question is\nasking is what's going to be the path\nfrom the top left to the bottom right\nsuch that the the maximum height along\nthis path is minimized right because the\nbottleneck is going to be whatever the\nmaximum height is because if the maximum\nheight is let's say uh four then no\nmatter what we do we're going to have to\nwait for time to be less than or equal\nto four so the question is what path can\nwe take to minimize what the t is and\nthen return that particular T value so\nin this first example this is what the\ngrid actually looks like and you can see\nwe have two paths right we can go like\nthis bottom right and what's going to be\nthe max elevation we reach along this\npath it's going to be three right so\nthat therefore the time we return has to\nbe three or uh if we go along this path\nsame thing right even though this is a\ntwo so so for us to reach this position\nto reach this two we would have to wait\nfor time to be less than or equal to two\nbut to reach this third position no\nmatter what we're going to have to wait\nfor time to equal three now of course\none idea you might have is just consider\nevery single possible path and then take\nalong each path what is the maximum\nheight and then return the minimum of\nthe maximum height from all those paths\nright and if we're going to be going\nthrough every single path it's going to\nbe exponential but there's actually a\ntrick a greedy way we can solve this\nproblem and you might remember a greedy\nalgorithm called jigra algorithm and we\ncan do a modified version of this\nalgorithm which will give us a Time\ncomplexity of n^2 * log n so let me show\nyou that solution right now so like I\nsaid we're going to be doing a modified\nversion of jra's algorithm it's pretty\nmuch exactly like this algorithm just a\nslight difference and you might know\nthat this algorithm requires a minimum\nHeap now this it's a breath first search\njer's algorithm is basically a BFS\nsearch a breath first search but instead\nof doing a regular Q we're going to be\nusing a priority CU AKA a heap so we're\ngoing to use a minimum Heap which is\ngoing to contain the frontier of where\nwe're at so consider we start at the top\nleft what's our Frontier going to be\nit's going to be the adjacent positions\nright this position and the bottom\nposition which are going to be in our\nFrontier so we're going to take both of\nthose and add them to our front here so\nwe're really going to add the\ncoordinates of these positions so think\nof the columns as being 012 and the rows\nalso being 012 remember this is our\nTarget position we want to know from\nhere what's going to be the path that we\ncan take that's going to get us here\nsuch that the maximum height along this\npath is minimized so why am I using a\nMin Heap why am I using Jar's algorithm\nbecause remember we're being greedy what\ndid I just say we want to minimize the\nmaximum height along the path that takes\nus to the result so if we start here at\nzero which one of these paths am I going\nto choose first would I choose the\nheight of two or would I choose the\nheight of one well of course we'd want\nthe minimum height right because it's\npossible with a height of one we could\nalso find another path that will take us\nto the result where the max height will\nstill remain as being one right whereas\nif we go down this path we're basically\nguaranteeing okay the maximum height\nalong the path to the the result is\ngoing to be at minimum two so of course\nwe want to try the Min path first we\nwant to try the smaller height first so\nwhen we take a position like this and\nadd it to our Min Heap we're going to\nadd three values the first one is going\nto be the key for our minimum Heap which\nis going to be the height so in this\nposition the height is one so that's\nwhat we're going to add as the main key\nfor this Min Heap right so when we pop a\nvalue from this Min Heap we want to pop\nthe one that had a minimum height\nthe other two values of course we're\ngoing to be adding are the row and\ncolumn which are basically the\ncoordinates of this position and I'm\nprobably not going to write them out\neach time just to keep this code a\nlittle bit cleaner so that's kind of the\nmain idea and each time we're going to\nbe popping the minimum from our Min Heap\nuh you know and then continuing on the\nfrontier so you know if we pop this\nvalue then we're going to look at its\nneighbors bottom and right the other two\nneighbors are out of bounds or which\nhave already been visited we don't want\nto visit the same uh position twice so\nwe're going to have a visit hash set for\nthat but I'm not going to draw that just\nto keep things a little bit more simple\nand suppose we take two pths you know\nbottom right and we get to this two\nposition and we take another path you\nknow top right and then go down and get\nto this position this one position right\nand remember our goal is to find uh to\nget to this this end point right so from\nthese two which of these two would I say\nis going going to be the path that leads\nto the result of course I would want to\nfavor this one by looking at it right\nbecause okay the height over here is one\nthe height over here is two so that must\nmean that this path is going to be the\npath with a smaller Max height but\nthat's not actually true take a look at\nthis path there's a three along this\npath whereas the maximum height along\nthis path uh was a two right this two or\nthis two so of course I would actually\nwant this path to be the one that leads\nus to the result because the max height\nalong that that path is a two so how can\nI do that this is where we modify jra's\nalgorithm we don't really care about the\nedge weights in this algorithm we're not\nfinding the shortest path we're finding\nthe path with the smallest Max height so\nwhen I get to this position when I get\nhere what I'm actually going to say is\nthe value I'm going to put here when I\nadd this to the Min Heap it's not going\nto be a one with the row and column I'm\nactually going to add a three because\nI'm saying to get to this position in\nthe first place it took us a Max height\nof three so it's it's a bit disingenuous\nto say that this path only took a Max\nheight of one so I'm not going to add a\none in this position I'm going to add a\nthree so each time we add a coordinate\nto the Min heat we want the maximum of\nits own height and the height that came\nbefore it so with that being said let's\ngo through a really quick dry run so\ninitially we have zero uh our Min Heap\nlet's pop it and then let's get its\nneighbor so we have a two below it and\nwe have a one to the right so let's add\nthose so we add one row column and we\nadd two row column so excuse me if this\ndrawing gets a little bit messy but so\nnow once again we're going to pop from\nthe Min heat we're going to pop this one\nbecause it has a smaller Max height so\nwe're going to uh pop it we're going to\nadd its two neighbors right uh right and\nbottom and those two neighbors have a\nheight of three and four respectively\nright so those are the max Heights along\neach of those paths so we add those four\nand that three to our Min Heap and now\nwe're going to pop again from the Min\nHeap this time we're going to pop this\ntwo uh because that's the minimum height\nright now so we're going to pop this to\nwe're going to look at the bottom and\nthe right now the right has already been\nvisited but the bottom has not been\nadded to the Min Heap yet so let's add\nthat to the Min Heap it has a height of\none and you know we'll add those\ncoordinates but I'm just writing row\ncolumn just because to keep it a little\nbit cleaner but actually hold on a\nsecond I added a one here was that the\ncorrect thing to do because the the\nposition that came before it was a two\nit's disingenuous to say that this to\nreach this position only takes a height\nof one when in reality what came before\nit was a two so what we're adding what\nwe're really adding to it is the maximum\nof itself which is one and the one that\ncame before it which is two so the max\nof one and two is obviously going to\nevaluate to two so we're going to add\ntwo and the row column to the Heap now\nwe're going to pop again from the\nminimum Heap and this is going to be the\none that we pop so we'll add its\nneighbors it doesn't have a bottom\nneighbor it doesn't have a left neighbor\nthe above neighbor has already been\nvisited the right neighbor hasn't been\nvisited so let's add that to the m Heap\nso again we'll take the maximum of\nitself and what came before it so\nbasically the max of two and two so two\nis going to be what we add and of course\nits coordinates once again we're going\nto pop from the in Heap pop the same one\nthis two We'll add its neighbors uh it\nonly has one neighbor this height of one\nbut that's actually going to be a two\nbecause we know that you know the\nmaximum height along this path itself\nwas two so we're going to add a two row\ncolumn now once again one last time\nwe're going to pop from the Min Heap\nwe're going to pop this value we pop it\nand before we continue we're going to\nsee that okay it's its coordinates are\nthe destination coordinates so we can\nreturn now what are we going to return\nwell what was the max height along this\npath what was the max height along this\npath that uh we had to do obviously a\ntwo in either of these positions but are\nwe actually going to have to look\nthrough the entire path again no because\nwhen we added this to the Min Heap we\nadded it as a two and then we added its\ncoordinates so we can say that the max\nheight to reach it was a two this is the\nvalue that we're going to return and\nthen we're done so that's kind of the\ngeneral picture of how this algorithm is\ngoing to work coding it up is not too\nbad if you know Jar's Alm and you know\nhow to use a minimum Heap so now let's\ndive into that code so the first thing\nI'm going to do is get the length of the\ngrid we know it's a square grid so we\ncan just uh say that n is both of the\ndimensions we are going to have a visit\nhash set to make sure we don't visit the\nsame coordinate twice so let's do that\nwe're also going to have a minimum Heap\nremember we're going to initialize the\nminimum Heap with values the first value\nis going to be the time that's going to\nbe the key that's going to determine\nwhat we actually pop from them in Heap\nand then we're going to add the\ncoordinates the time is basically also\nthe max height so you can call it time\nor the you know Max height that it'll\ntake and initially we're going to add\nthe top left coordinate so what are the\nwhat's the height of the top left\ncoordinate it's going to be whatever is\nin that position in the grid and the\ncoordinates themselves are going to be 0\n0 that's the top left and since we're\nadding this to the Min Heap we can go\nahead and actually add to visit uh the\nposition 0 0 cuz we don't want to have\nto visit that again and last but not\nleast we're going to need a little\nhelper variable for us directions which\nare going to tell us the four directions\nthat we can travel in 01 uh you'll see\nwhere we're going to be using these in\njust a moment it'll make the code a\nlittle bit cleaner for us mainly that's\nwhy I'm doing it so these are the four\ndirections we can travel in that's going\nto be useful for us when we're doing our\nBFS solution so while our Min Heap is\nnonempty that's when we're going to be\npopping just like I showed in the\ndrawing explanation so we can say in\nPython at least the way we can pop from\nA Min Heap is going to be Heap q. Heap\npop and we're going to get three\nvariables right the time or the max\nheight it took us uh and the row column\nso those are going to be the three\nthings that we pop now if we're also\ngoing to take this and add it to visit\nuh because this previously was not\nvisited so we can say that this\ncoordinate has now been visited now if\nthis is the destination so if row is n\nminus one and\ncolumn is n minus one that means we've\nreached the destination so what we're\ngoing to return is whatever the time or\nthe max height it took us to get to this\nposition but if we're not returning it\nthat's when we're going to actually\nstart traversing the four neighbors so\nwe're going to use the difference in R\nthe difference in column the basically\nthe directions in our directions\nvariable that we defined and using those\nwe're going to compute the neighbor row\nand the neighbor column we can say the\nneighbor row is just going to be R plus\nDr neighbor column is just going to be\nthe column plus the difference in the\ncolumn now it's possible that these\ncould be out of bounds or this\ncoordinate has already been visited so\nlet's check that so if neighbor row is\nless than zero or neighbor column is\nless than zero or neighbor row is equal\nto n meaning it's out of bounds or\nneighbor column is equal to n meaning\nit's also out of bounds or this position\nhas already been visited so we can check\nthat like this so neighbor row neighbor\ncolumn in visit so if any of these\nevaluate to true then we're going to\nskip this position basically we're going\nto continue to the next iteration of the\nloop but if none of these do evaluate\nthen we want to mark this position as\nvisit because we're about to add it to\nour Min Heap so let's first add U Market\nas visit and actually I just noticed if\nwe're going to be marking it as visit uh\nright as we add it to the Min Heap\nthere's no need to Mark something as\nvisited after it's been popped from the\nMin Heap so I'm going to delete that\nline of above and so we're going to mark\nthis as visit and then we're going to go\nahead and add it to our our Min um Heap\nso we're going to say Heap q. Heap push\nto the Min Heap this uh coordinate so\nwhat are we adding as the coordinate so\nof course we're going to add the\nneighbor row and the neighbor column but\nremember what's the first variable we're\nadding we're adding the max height that\nit took so we're either going to say the\nmaximum of itself or or rather it's its\nuh previous position so maximum of T and\nthe maximum of whatever the height is at\nthis particular position so the height\nat neighbor row neighbor column so this\nwill make sure that the value that we\nadd here is always going to be the max\nheight along the path that it took for\nus to reach this neighbor row and\nneighbor column position and believe it\nor not that is the entire code we don't\nhave to put a return statement on the\noutside because it's guaranteed that we\ncan reach the target position and once\nwe do we're automatically going to\nreturn whatever the max height was to\nreach that Target position so this is\nthe entire code you can see that it is\nvery efficient it's a very efficient\nsolution so I hope this was helpful if\nit was please like And subscribe it\nsupports the channel a lot and I'll\nhopefully see you pretty soon thanks for\nwatching\n"
    },
    {
        "Name": "Alien Dictionary",
        "NcLink": "foreign-dictionary/",
        "Pattern": "Advanced Graphs",
        "Description": "There is a foreign language which uses the latin alphabet, but the order among letters is *not* \"a\", \"b\", \"c\" ... \"z\" as in English.\n\nYou receive a list of *non-empty* strings `words` from the dictionary, where the words are **sorted lexicographically** based on the rules of this new language. \n\nDerive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid order of letters, return **any** of them.\n\nA string `a` is lexicographically smaller than a string `b` if either of the following is true:\n* The first letter where they differ is smaller in `a` than in `b`.\n* There is no index `i` such that `a[i] != b[i]` *and* `a.length < b.length`.\n\n**Example 1:**\n\n```java\nInput: [\"z\",\"o\"]\n\nOutput: \"zo\"\n```\n\nExplanation:\nFrom \"z\" and \"o\", we know 'z' < 'o', so return \"zo\".\n\n**Example 2:**\n\n```java\nInput: [\"hrn\",\"hrf\",\"er\",\"enn\",\"rfnn\"]\n\nOutput: \"hernf\"\n```\n\nExplanation:\n* from \"hrn\" and \"hrf\", we know 'n' < 'f'\n* from \"hrf\" and \"er\", we know 'h' < 'e'\n* from \"er\" and \"enn\", we know get 'r' < 'n'\n* from \"enn\" and \"rfnn\" we know 'e'<'r'\n* so one possibile solution is \"hernf\"\n\n**Constraints:**\n* The input `words` will contain characters only from lowercase `'a'` to `'z'`.\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 100`\n",
        "Difficulty": "Hard",
        "Video": "6kTZYvNNyps",
        "PythonSolution": "class Solution:\n    def foreignDictionary(self, words: List[str]) -> str:\n        adj = {char: set() for word in words for char in word}\n\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            minLen = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n                return \"\"\n            for j in range(minLen):\n                if w1[j] != w2[j]:\n                    adj[w1[j]].add(w2[j])\n                    break\n\n        visited = {}  # {char: bool} False visited, True current path\n        res = []\n\n        def dfs(char):\n            if char in visited:\n                return visited[char]\n\n            visited[char] = True\n\n            for neighChar in adj[char]:\n                if dfs(neighChar):\n                    return True\n\n            visited[char] = False\n            res.append(char)\n\n        for char in adj:\n            if dfs(char):\n                return \"\"\n\n        res.reverse()\n        return \"\".join(res)\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem alien dictionary\nand yes this is another problem from the\nblind 75 list\nthis is the problem 32 a graph problem\nalien dictionary i've been wanting to do\nthis problem for so long now and we're\nfinally doing it because now we actually\nhave lee code premium\nand again thank you for all my patreon\nsupporters for making that possible so\nlet's get into the problem now\nand by the way the the link to this\nspreadsheet will be in the description\nif you want to take a look so this is a\npretty hard\nproblem i will admit it's a hard graph\nproblem so this problem\nis going to involve the algorithm\ntopological\nsort that you may or may not have used\nbefore you may not have even heard of\nthis before\ntopological sort involves a d a g a\ndirected\na cyclical graph a graph that has\ndirected edges but\nno cycles so the premise is we're given\na new alien language that uses\nenglish alphabet letter so it's going to\nbe basically lowercase a to lowercase\nz but the ordering of these characters\nis unknown to us now we know in regular\nenglish\nthe ordering is basically a b c all the\nway to z\nright this is the order there's 26\ncharacters but basically they're saying\nthat now we have a different ordering of\nthese characters and where\nand the goal for us is to try to figure\nit out\nand what we're given to figure it out is\nbasically a\nlist of words which happen to be given\nto us\nin sorted order they say lexographically\nsorted that's basically just sorted\nbased on\nhow regular sorting of words works so\nour goal is to return\na string of the unique characters that\nwere given\nin this new alien language based on the\nwords that were given\nand we're going to return this in sorted\norder in increasing order\nbased on the new language's rules now if\nthere is\nno solution we're returning an empty\nstring so we have to figure out what\nthat even\nmeans what does it mean for there to be\nno solution\nand also there could possibly be\nmultiple solutions and if there are\nluckily for us we're allowed to return\nany of the valid solutions\nnow they tell us that two strings s and\nt\ns is going to be smaller than t if\nat the first letter where they differ\nthe letter in\ns comes before the letter in t in the\nalien language and this is pretty\nintuitive like\nif we know if we were given two words\nsuch as\napple and banana how are we gonna\nsort these two words well we're gonna\nlook at the first character right we see\nokay the first characters are\ndifferent and a we know a is less than b\nright that's how the ordering works in\nenglish so we're going to check\njust the first differing character since\na is less than b\nthat means a comes first in the ordering\nso how would we order these words\nbasically how they're listed right now a\napple comes before banana what if we\nwere given a different word\nsuch as apple and ape well in that case\nwe look at the first characters okay\nthey're the exact same so we still don't\nknow how to sort them yet right we look\nat the second characters\np p they're the exact same we look at\nthe third characters\np and e and we know in english\nthe letter e comes before p right so\nthe correct ordering of these words is\ngoing to be the opposite it's going to\nbe ape\nand then apple right so that's how we\nwould sort these words now\nthe difference in this problem is that\nthe input that we're given\nis already sorted right so these words\nare\nalready sorted so we're going to use\nthat to our advantage to basically\nfigure out the ordering of the\ncharacters character by character\nand there's just one edge case we have\nto worry about so if\nwe're given two words where they have\nthe exact\nsame prefix right where basically the\nshorter word\nis a prefix of the longer word if that's\nthe case\nthat means the smaller word is always\ngoing to become\nfirst in the ordering so for example if\nwe had one word\nape and another word apes no matter\nwhat since see since these words since\nthis word is basically a prefix of the\nsecond word\nthey match right so whatever the longer\nword is gonna be is always going to come\nafter the shorter word and if that was\nnot the case what if we were given a\nlist of words where that was not the\ncase what if we were given\napes and then we were given ape well\nbased on what they just told us that's\ninvalid right they say the opposite must\nbe true so what we can say is if we ever\nsee\nsomething like this in our list of words\nthen we know there's no solution and\nthat's going to be\none case where we return an empty string\nso they tell us that this input list of\nwords\nis supposed to be in sorted order so\nwe're going to use that to our advantage\nand so remember if these two words are\nin sorted order how was it determined\nthat they're in sorted order how was it\ndetermined that this word\nmust come after this word well it must\nbe based on the first\ndiffering character right that's what\nlexographically ordered\nmeans so let's just go for every pair of\nwords\nlet's go character by character and find\nthe first\ndiffering character and see what kind of\ninformation that gives\nus so let's look at the first characters\nwell they're the exact same\nlet's look at the second characters\nthey're the exact same let's look at the\nthird characters\nthey're different we have a t that comes\nbefore an\nf so that must mean in the alien\nalphabet\nt comes before f so\nthis is not in regular english this\nisn't true but in our alien language\nthis seems to be the case\nso let's just keep track of that let's\njust remember okay\nt comes before f\nnext let's look at the next two words so\nwe're going to look at the first two\ncharacters and immediately they're\ndifferent so we know that these two\nwords were sorted based on this first\ncharacter\nand we know that e comes after w because\nthey're in that order we have a\ncharacter w and we know for sure\ne is going to come after that w now who\nknows maybe there are some characters in\nbetween here right maybe\nit's actually going to be w f\ne something like that right but we don't\nreally know that for sure\nall we know so far is this is true and\nthis is true that's all we can assume\nfrom this ordering right we know that\nthese first two characters\nare in that order but the remainder of\nthe characters might be in any order\nright because\nwhen words are sorted they're only\nsorted on the most significant\ndiffering character so now let's look at\nthe next two words\nlook at comparing each first character\nthey're the exact same let's go to the\nnext character\nr and t now they're different so now we\nknow for sure\nr comes before t so let's go ahead and\ndo that\nin our drawing right r comes before t\nnow we see that we already have a t in\nour graph right\nand actually i haven't actually\nmentioned that this is a graph but it's\nstarting to get intuitive why we would\nwant to represent these relationships as\na graph now right\nwe could separately say r t but why not\ninclude this node that we already have\nso we know\nr comes before t we know this for sure\nnow time to finally look at the last two\npair of words\nlook at the first two characters e and r\nso that's the first differing\npair so we know that e comes before\nr and we know that r is actually already\nin our graph so then we can say okay\nlet's\ntake this edge and then hook it up over\nhere so once you recognize that you can\nuse those relationships of characters\nand the relative order of those\ncharacters to build a graph this problem\nbecomes\ndoable right then all we need to do is\nnow traverse this graph now\nin this example it's pretty\nstraightforward right clearly we see\nthat the order is non-ambiguous right\nwe're going to start with a w\nthen e then r then t then f\nand that's you know going to be the\nentire order and you can see\nthat this order is also in the output\nthat they gave us\nin this example so this matches up\npretty easily so you'd think okay at\nthis point the problem is easy but\nactually there's a lot of different ways\nthis graph can be represented\nand traversing the graph itself is not\nsuper intuitive\nand there are multiple ways to do it you\ncan do a bfs solution a breadth first\nsearch solution\nor you can do a depth first search\nsolution and i\nmuch prefer the dfs solution there's so\nmany more like bookkeeping things you\nneed to do with the bfs solution\nthat i don't really think it's worth\ndoing i think the dfs solution even\nthough it's recursive is just so much\nbetter so that's what i'm going to be\nfocusing on\nso let's change this problem slightly\nlet's say that this\nf actually pointed at the w\nso now if we were traversing this graph\nwhat the heck would the relative order\nbe we could start at any node we could\nstart at\nr and then say okay t f w e and then we\nsay okay we got back to r so we already\nvisited that but is that a valid order\nlike this is\nvery ambiguous it's not that this has\nmultiple solutions it's that this is\ninvalid there's a contradiction right\nwhat if we had a shorter cycle what if\nwe had okay w\nand then e comes after w and then w\ncomes after e do you see how that's a\ncontradiction\nwe can't have opposite rules right it's\nbasically like if we had an input list\nof words\nthat was something like this we had w e\nand then e e so clearly we have a\ndifferent character here meaning e\ncomes after w like this but then maybe\nwe got that same word w-e\nso how can we say that this list of\nwords is sorted\nwhen you know the same word is in both\npositions and then there's another word\nin between that\nthat doesn't make sense basically that's\nhow you know that there's a\ncontradiction in that case we return the\nempty string there's no real solution\nand we know that because there exists a\ncycle in our graph now what if this last\nword in our input actually didn't exist\nwhat if we cross it out\nin that case we would never get this\nconnection where e\nhooks up to r we have two separate\ngraphs right but there's no\ncontradiction here it's just that now we\nhave multiple solutions so we could say\nokay the relative order\nis either we are tf right basically\ngoing through this\nand then doing this one right or we\ncould even do it in the opposite order\nrtf we right\nthat's one way or we could even do a\nbreath first search approach right put\nthese two first wr then put these two\ne t and then put f right all that really\nmatters is that\nthis like if there's a connection if\nthere's a directed edge from this node\nto this node all that matters is when we\nreturn the output string\nthis character shows up before this one\nand similarly this character shows up\nbefore this one\nand this character shows up before this\none etc etc\nwe really need to guarantee that that's\nthe case so at this point you might\nthink okay let's just start\nat the beginning of each of these\ncomponents and then just go through it\nright like say okay w\ne r t f and then just build the output\nstring like that\nand i'll show you one reason why that's\nactually not gonna work\nif we were given an input list of words\nlike this\nwhat we would we would end up getting is\nbasically a graph that looks like this\nand this is a perfectly valid graph\nright\nwhat's one valid ordering of this well\nbasically\nabc right that's one valid ordering but\nlet's say we did a dfs\nsearch on this let's say we started our\ndfs here\nso we got an a in our output then let's\nsay we went to this node first\nthen we got a c in our output then\nfro from our dfs then from a you know we\nsee this is the base case from then we\ngo back up to a we say okay now let's go\nto b\nin our dfs so then we got a solution a c\nb now from our b what we're going to end\nup doing is going to c\nso in reality c should come after b\nbut we see in our input it came before b\nso basically from our dfs we got an\ninvalid ordering\nof this graph so you know if we're doing\na dfs from the beginning\nhow do we know that we should be going\ndown this path\ndown to the b before we go down the c\npath\nwell the answer is we don't really have\na good way of knowing if we're doing\nthis with dfs\nbut there is a workaround solution to\nthat\nand the solution to that is going to be\ndoing a post\norder dfs so in reality\nyes we're going to be starting at this\nnode but we're not going to be\nadding it to our output yet we're going\nto be adding this to our output\nlast so okay we're here so now we're\ngonna get to c\nright now we're at c now we're gonna go\nfarther down see we see c does not have\nany children right\nso that's our base case so now since\nthis is post order\nnow we're gonna actually add c to the\noutput so now we're going to end up\npopping back to a\nright so we're now back at a so we're\ngoing to continue the dfs this is post\norder let's do all of our descendants\nbefore we process a so let's go to b\nokay b\nthat's and b has some neighbors down to\nc okay we see c\nhas already been processed no need to do\nthat again so b\ndoes not have any more descendants so\nnow we can process\nb let's add b to the output and now\nfinally we can process\na right so what you see is that the way\nwe did it now\nwas not ambiguous right we didn't end up\nwe made sure we ended up doing\nall the leaf nodes right the last nodes\nof first and then these nodes\nand then we finally did a last so what\nyou can see\nis that we actually built our result in\nreverse\norder which isn't bad because easily we\ncan take this and reverse it right so we\ncan\nwhen we get the output of this we're\ngoing to make sure to reverse it before\nwe return\nit so we're going to return abc so\nthat's the main idea of what i'm going\nto be doing when we're actually writing\nthe code that's kind of how topological\nsort is\ndone that's how i was taught to do it in\nschool so it's just a dfs\nexcept we're building the result in\nreverse order\nand there's one last thing we're going\nto have to keep track of what we're\ngoing to be doing for\nloop detection and really what we're\ngoing to be keeping track of is two\nthings\nsimilar to how i did it in the picture\nwe're going to be marking if a node has\nalready been visited meaning it's\nalready been let's say\nprocessed or whatever and in this case\nwe know that there weren't any loops\nwell actually one thing i want to say is\nfirst we saw that c was processed right\nthen we went back to a and then we went\nto b\nright when we went from b to c we saw\nthat c\nwas already processed but that doesn't\nnecessarily mean that we have a cycle\nin our graph because yes this was\nprocessed but it wasn't\ncurrently being visited if we went to c\nand then\nc went back to b right and then we got\nto b and then we tried to go\nto c again that would indicate a cycle\nbasically if this was\ncurrently being visited but once we once\nwe go from here\nsee it's a base case and then pop back\nto a\nthen we're saying this is no longer\nbeing visited so what we're going to be\nkeeping track of is two things\nwe want to know if a node has already\nbeen visited meaning it's you know\nalready been processed pretty much\nand we also want to know if a node is in\nour current\npath so we're gonna be doing that with a\ndictionary and\nif uh so every time we visit a node\nwe're gonna say it's added to the\ndictionary but we're gonna give it a\nfalse value in the dictionary and once\nit's it's actually in the current path\nthat we're traversing\nthen we're going to give it a value of\ntrue in the dictionary\nwith that being said we can now jump\ninto the code the overall time\ncomplexity is just going to be the\nnumber of characters that were given\nin the input because that's basically\ngoing to determine how big our graph can\nbe and of course we're going to have to\ntraverse the entire graph\nso it's the the time complexity is just\ngoing to depend on the number of\ncharacters\nso this is going to be a long one about\n30 lines of code so the first thing\nwe're going to want to do\nis going to create that adjacency list\nright basically based on the ordering of\nthe characters\nso for every single character in our\nentire list of words what we want to do\nis map it to\nlet's say a set we could do a list but a\nset\nis gonna make sure that we don't have\nduplicates so we're gonna go through\nfour\nevery word in our list of words and then\nfor every character\nin each word we want every character to\nbe mapped\nto a set and then we want to go through\nevery pair of words so for i\nin range the number of words that were\ngiven minus\none so that we would go through every\nsingle pair let's get\neach pair so word one and word two\nword one is going to be the word index i\nword two is gonna be the word at index\ni plus one so let's get the minimum\nlength of both of these two words so\nlet's get the minimum of the length of\neach of them\nand the first thing i'm going to check\nis basically that base case that edge\ncase that we first mentioned so\nmainly if the minimum length of each\nword\nis the exact same right meaning the\nprefix of the words is the exact same\nbut the first word is longer than the\nsecond word in which case we know that\nwe have an\ninvalid ordering right that's kind of\nthe edge case that they sp\nexplicitly mentioned so the length of\nword one\nis greater than the length of word two\nthey have the exact same prefix meaning\nthat it's an invalid ordering basically\nso in that case we would have to just\nreturn an empty string\nif that's not the case we want to go\nthrough every single character\nuh between these words so basically in\nrange\nmin length and our goal is to find the\nfirst\nuh differing character right so if the\ncharacters are the same we're not going\nto do anything but if the characters are\ndifferent so\nthe character at position j in word one\nis different from the character at\nposition j\nin word two other they're different not\nequal then we're gonna break but before\nwe break\nwe're breaking because we only want the\nfirst differing character so we don't\nwant to look at any subsequent\ncharacters but\nbefore we break we want to add this to\nour adjacency list so we want to say\nthat the character in word two comes\nafter the character in word one so we're\ngoing to indicate that by saying okay\nword one\nis the key at index j and to that we're\ngoing to be adding\nword to so that's our adjacency list is\ngoing to work out\nso once we do this we can actually start\ndoing our dfs and remember for our dfs\nwe're going to be making sure to keep\ntrack of visited nodes\nso we're going to use a hash map or\ndictionary and for each\nnode or each character we're going to be\nmapping it to two values\nfalse basically means that the character\nhas been visited\ntrue means visited and\nit's been it's in the current path right\nso\nclearly if it's in the current path that\nmeans it's been visited right so\nsaying it's visited is basically\nredundant but true\nindicates that it's in the current path\nif it's not added to the visit\ndictionary at all that means it hasn't\nbeen visited at all\nwe also want to maintain a result and\nremember we're going to be building this\nin reverse order so i'm actually going\nto make it a list\ninitially and then we're gonna join the\ncharacters in that list at the end\nin reverse order so we can define our\ndfs function all we need to do is pass\nin the current character or node that\nwe're visiting\nnow if character is already in visit\nthen we're just going to return\nnow what are we going to return we're\ngoing to return the value that's stored\nin visit so\nif it's already been visited then we're\njust going to return false if it's\nif it's in the current path then we're\ngoing to return true now if this dfs\never returns true that means we saw a a\ncharacter or\nnode that was already in this in the\ncurrent path\nand we saw it twice that means we\ndetected a loop so if this returns true\nthat's how you know we detected a loop\nif this\nif this is not the case then what we're\ngoing to say is okay visit\nto to visit at this character we're\ngoing to be adding true because not only\nhas it been visited\nit's also in the current path and then\nat the end\nbefore we return we're going to say okay\nvisit of c is now\nfalse meaning it's still been visited\nbut now it's false because it's no\nlonger in the current path that's what\nwe're gonna do right before we return\nbut\nbefore we do that we're gonna go through\na loop we're gonna go through every\nneighbor or descendant or\ncharacter that comes after this\ncharacter so basically from our\nadjacency list that we built earlier\nwe're going to go through every\ncharacter that's a neighbor of c\nand we're going to run dfs on that\nneighbor now if this returns false so if\nor rather if this returns\ntrue that's how you know that we have a\nloop so if this returns true then we are\ngoing to return true\nimmediately telling you know the\nrecursive call that we basically\ndetected a loop and we can return\nimmediately okay so that's pretty much\nall for our dfs but don't forget this\nwas a post order dfs so mainly\nafter we've done the recursive call\nthat's when we're finally gonna say okay\nto\nour result we can finally append this\ncharacter remember we're actually\nbuilding this in reverse order\nso once we've done the entire dfs we're\ngonna have to return the result in\nreverse\norder so now we defined our dfs so now\nlet's actually\ncall the dfs so for every single\ncharacter and we don't really need to\nactually\nstart at the beginning character of the\ngraphs we can actually start at any\nsingle character and it'll still\nwork out the same the reason being is\nbecause we're doing it in reverse order\nand if you don't believe me you can try\ndrawing out the picture and seeing what\nwould happen if we started it in the\nmiddle of the graph somewhere\nand it actually does surprisingly work\nout as long as you do mark the\ncharacters as visited once you actually\nvisit them so we go through every single\ncharacter in our adjacency list and then\nwe call dfs\non that character and if this returns\ntrue\nthen we are also going to return then\nimmediately we're going to turn the\nempty string meaning we detected a loop\nnow if that's not the case\nthat's when we're actually going to\nreturn the result but remember the\nresult is a list so what we're going to\ndo\nis actually join every single character\nin\nthat list in result but before we do\nthat we want to make sure we reverse\nthe result and then we perform that join\nand return\nso i hope this was helpful if it was\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully see\nyou pretty soon\n"
    },
    {
        "Name": "Cheapest Flights Within K Stops",
        "NcLink": "cheapest-flight-path/",
        "Pattern": "Advanced Graphs",
        "Description": "There are `n` airports, labeled from `0` to `n - 1`, which are connected by some flights. You are given an array `flights` where `flights[i] = [from_i, to_i, price_i]` represents a one-way flight from airport `from_i` to airport `to_i` with cost `price_i`. You may assume there are no duplicate flights and no flights from an airport to itself.\n\nYou are also given three integers `src`, `dst`, and `k` where:\n\n* `src` is the starting airport\n* `dst` is the destination airport\n* `src != dst`\n* `k` is the maximum number of stops you can make (not including `src` and `dst`)\n\nReturn **the cheapest price** from `src` to `dst` with at most `k` stops, or return `-1` if it is impossible.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e272e71f-c38b-4db8-3c4e-1158418d2a00/public)\n\n```java\nInput: n = 4, flights = [[0,1,200],[1,2,100],[1,3,300],[2,3,100]], src = 0, dst = 3, k = 1\n\nOutput: 500\n```\n\nExplanation:\nThe optimal path with at most 1 stop from airport 0 to 3 is shown in red, with total cost `200 + 300 = 500`.\nNote that the path `[0 -> 1 -> 2 -> 3]` costs only 400, and thus is cheaper, but it requires 2 stops, which is more than k.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/93e910ee-378d-4ac8-93e0-471df7ccf600/public)\n\n```java\nInput: n = 3, flights = [[1,0,100],[1,2,200],[0,2,100]], src = 1, dst = 2, k = 1\n\nOutput: 200\n```\n\nExplanation:\nThe optimal path with at most 1 stop from airport 1 to 2 is shown in red and has cost `200`.\n\n**Constraints:**\n* `1 <= n <= 100`\n* `fromi != toi`\n* `1 <= pricei <= 1000`\n* `0 <= src, dst, k < n`\n",
        "Difficulty": "Medium",
        "Video": "5eIK3zUdYmE",
        "PythonSolution": "class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        prices = [float(\"inf\")] * n\n        prices[src] = 0\n\n        for i in range(k + 1):\n            tmpPrices = prices.copy()\n\n            for s, d, p in flights:  # s=source, d=dest, p=price\n                if prices[s] == float(\"inf\"):\n                    continue\n                if prices[s] + p < tmpPrices[d]:\n                    tmpPrices[d] = prices[s] + p\n            prices = tmpPrices\n        return -1 if prices[dst] == float(\"inf\") else prices[dst]\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem cheapest flights\nwithin k stops i think this is a really\ngood interview question because there's\nso many different ways to solve this\nproblem and there's a lot of different\ntrade-offs that you can discuss the main\nway that i'm actually going to be\nsolving this problem is by using the\nbellman ford algorithm which is an\nalgorithm that we haven't really gone\nover on this channel before so i think\nthis is a good opportunity to go over it\nso to explain the problem this is\nobviously a graph problem as you can see\nfrom the picture where given a bunch of\nnodes each node represents a city and\neach edge in the graph represents\nobviously they are directed edges as you\ncan see from the arrow down here so each\nedge represents a flight that connects\ntwo cities together for example city\nzero and city one are connected together\nmeaning we can go from city zero down to\ncity one we can travel along this flight\nand the edge actually does have a weight\nso in this case it's a hundred so that\nrepresents the cost or the price to go\nfrom city zero to city one and we're\nasked a very simple question we're given\na source node in this case city 0 and a\ndestination node in this case city 2.\nwe're asked a simple question of what is\nthe cheapest price traveling from city\nzero to city 2 the only catch here is\nthat we can only do at most k stops so\nthat's really the catch of this problem\nbecause as you know we know an algorithm\nthat can calculate shortest paths right\neven with weighted edges this algorithm\ncan can calculate shortest paths and\nit's called jigstra's algorithm but we\ncan't use it easily in this problem\nbecause we're given a condition of at\nmost k stops so if we try to take that\nidea and then incorporate it into\ngixxer's algorithm it's not super\nefficient but it is still doable but\nthere's another algorithm that also\ncalculates shortest paths and that is\ncalled the bellman ford algorithm and\nwith this shortest path algorithm we can\nincorporate the idea of at most k stops\nand also do it efficiently the overall\ntime complexity is actually going to be\nlet's say e where e is the number of\nedges and k is the input parameter that\nwe're given at most k stops the way it's\ngoing to work is it's going to be\nsimilar to a breath first search\napproach in general though the bellman\nford algorithm actually runs an e times\nv time where v is the number of vertices\ne is the number of edges but in this\ncase we're given a condition of k so the\ntime complexity in this case is just\ngoing to be e times k and by the way\nlooking at this problem what is the\nsolution well obviously we have a direct\nedge linking zero to two obviously the\ncost is 500 in that case but we do have\na second path if we go all the way to\none costs a hundred and then we go from\none to two then another hundred so that\nin total is going to be 200 not too bad\nright this is shorter like i mean the\nprice is smaller and this does fit\nwithin our criteria obviously this path\nhow many stops did this path have you\nmight think it's two because we had we\ntraveled along two different edges but\nwhen we say stops we're just calculating\nwhat's the number of cities between the\nstarting point and the destination there\nwas only one city in between them so\nthat means we did fit the criteria of\ndown here we were given k equals one we\ncan only have one at most one stop in\nbetween the source uh and the\ndestination so we were we did fit that\ncriteria so in this case the result is\ngonna be 200 because this path is a\nvalid path so now let's try to\nunderstand how bellman ford algorithm\ncan actually help us so now let's try to\nunderstand the bellman ford algorithm\nand just to give you a little bit of a\nbackground on bellman ford it's actually\na pretty general algorithm there's\ndifferent implementations of it one of\nthe benefits of bellman ford is that it\ncan actually deal with the negative\nweights which is something jigstra's\nalgorithm can't deal with but in this\ncase obviously we don't have negative\nweights so what we're going to be\nfocusing on is what we actually need\nfrom the bellman ford algorithm to solve\nthis problem so we do have a source node\na in this case and we have a destination\nnode c in this case so the main idea\nwith this algorithm is to start at the\nsource node a so in this case this node\nand then slowly do a breath first search\nright so from a first we would look at\nwhat's the first layer of nodes that we\ncan reach within one stop right within\none stop okay we can reach\nb\nand c and then we'd continue that\nbreadth first search and say okay now\nwithin two stops how many different\nnodes can we reach well can't really go\nanywhere from here can't go anywhere\nfrom here but from here we can go to\nthis uh position c and in doing this\nbreadth first search we're going to\nsimultaneously be keeping track of for\neach node that we have visited or can\nvisit what is the minimum price that it\ntakes to reach that node because\nremember that's what we're trying to\nsolve we're trying to find from starting\nat a going to see what's the minimum\ncost it would take within k stops so\nthat's something i didn't mention yet in\nthis case we have k equals one right so\nsince k equals one what's the breadth\nfirst search going to be does that mean\nwe're only going to do one layer of\nbreadth first search no we're actually\ngoing to be doing k\nplus one layers of breadth first search\nand that's that has nothing to do with\nbellman ford that just has to do with\nhow this problem is defined they just\ndefine to us that we can do at most k\nstops between the starting position and\nthe destination right so this would be\none stop between these two nodes so\nyou're probably wondering why do i have\nthis second temporary array of prices\ni'll get more into that in a moment for\nnow i would just kind of focus on the\ngeneral idea of what we're doing so if\nwe're doing a breadth first search and\nwe're starting at a what's the cost the\nminimum cost from starting at a to reach\na well it's going to be zero of course\nright and so far if we've only reached a\nwhat's the minimum cost to reach b and c\nwe're just going to put that as infinity\nfor now so now we're going to do the\nbreadth first search portion but the\nthing about this breadth for search is\nit's not implemented how you would think\nwe're not just going to look at a and\nonly look at the neighbors of a we're\nactually going to go through every\nsingle edge in this graph so for example\nlet's go at the first edge okay this\nedge has a weight of 100 it connects a\nto node b so now the question is we can\nreach b along this edge did we find a\nnew minimum path to be able to reach\nthis node b\ndid we or did we not well as of right\nnow the value is infinity we found a way\nto reach node b with what's the cost to\nreach node b it's whatever the cost is\nto reach node a right which we already\nknow is zero right so we're gonna say\nzero plus whatever the weight of this\nedge is which is a hundreds right so the\noverall cost to reach node b is a\nhundred that's less than infinity which\nis what we have so we can get rid of\nthis infinity and then put a hundred\nbut when we update this value we're not\ngoing to update it in the original\nprices array we're going to update it in\nthe temporary prices array and then once\nwe've completely updated the temporary\nprices array we're going to go ahead and\nput all of the values in the new prices\narray so we went over this edge already\nnow let's look at another edge let's\ntake a look at this edge 500. it\nconnects a to c right so how much did it\ntake to reach node a we know that's\nalready zero right okay so going from\nnode a which costs 0 to get to plus 500\nwhich is this edge to get to c so it so\nwe found a way to get to node c with a\ncost of 500. is this smaller than the\ncurrent minimum that we have for c which\nis infinity yes it's smaller so we can\nreplace this with infinity but of course\nwe're going to do it in the temporary\nprices array next we're going to look at\nthis third and final edge even though\nthis edge is not connected to a right i\nsaid this was a breath for search but i\nguess it's not technically a breadth\nfirst search because we are looking at\nall edges but notice what's going to\nhappen when we look at this edge okay we\nfound a way to go from node b to get to\nnode c and it costs a hundred to do that\ndid we find a new minimum to get to node\nc well the first question is how what's\nthe cost to actually get to b to get to\nb is infinity it's not 100 100 is what\nwe determined but for now we're going to\nbe using this original value i'll\nexplain why in a moment it takes a\ninfinity to get to node b so to get to\nnode c takes infinity plus 100 that's\nnot smaller than infinity right so any\ntime we get to an infinity in the source\nnode right so we took a look at this\nedge right this is the source this is\nthe destination it took in it took\ninfinity to get to the source so we're\njust going to skip this edge all\ntogether right so it technically is a\nbreath first search because we're\nskipping edges that we haven't actually\ngotten to for the source node and\nthere's a lot of like technical\nquestions you could probably ask so why\nam i even you know implementing it this\nway why am i going through all the edges\nwhen i could just do a regular breath\nfor search the main reason is because\nthe time complexity is not actually\ngoing to change and doing it this way is\na lot easier to code you're going to be\nsurprised how short the code is when i\nactually show that to you and to be\nhonest since the overall time complexity\nis the same i think it's much better to\ngo with a readable solution rather than\na solution that saves you maybe 10 on\nthe runtime right so i think this is one\nof the cases where simplicity is much\nbetter than a slight improvement in\nperformance this is our temporary prices\narray and by the way we are going to\nhave this zero here so\nif we updated a value in this case we\ndid then we put the values here or the\noriginal values will still be there so\nwhat did we discover what does this\narray represent and what does this array\nrepresent basically before we started\nour breadth for search this is what we\nhad now we've done a breadth first\nsearch of one layer and this is what\nwe've determined for the sh for the\nsmallest price to pay to reach each of\nthese nodes this is what we've done so\nfar for one layer but how many layers\nare we going to do in this case k is one\ndoes that mean we're only going to do\none layer nope remember what i said\nwe're going to do k plus one layers i\nknow that's kind of confusing but it's\njust kind of how the problem is set up\nokay so now we're going to do our last\nlayer of the bfs by the way i replaced\nour prices with this and temp prices\nwill stay the same temp prices is always\njust going to be a copy of the regular\nprices and then when we update values\nwe're going to put the updated values\nhere then you know reassign them up here\nand then continue that kind of loop and\nof course we're going to do this k plus\n1 times right that's how the breadth for\nsearch is going to work we're going to\nupdate this entire array k plus 1 times\nso basically if the input value was k\nequals zero we have that result right\nwithin zero stops uh this would be the\nminimum cost to reach the destination\nnode c 500 but we know k is actually one\nso we can have one stop in between the\nsource and the destination so now once\nagain we're gonna do the exact same\nthing we're just gonna go through every\nsingle edge so let's look at this first\nedge okay we know that from going from a\nto b it takes a hundred right so how\nmuch does it take to get to a it takes\n0. so it takes 0 plus 100 to get to b is\nthat smaller than what we have for b no\nit's the exact same which is what we\nexpect right we know within one stop or\nwe know within zero stops in between it\ntakes 100 to get there so having an\nextra stop in between a and b doesn't\ndecrease that is what we found right if\nyou have two stops three stops four\nstops between a and b it doesn't reduce\nthe cost it's always going to be a\nhundred so this value will stay the same\nin temp prices let's look at the next\nedge this is going to be the exact same\nthing right 500 is just going to be the\nvowel that we put here it's already the\nsame increasing the number of stops does\nnot decrease the cost to get to c\nat least along this edge but now we're\ngoing to look at the third and final\nedge this edge and it takes from b to\nget to c takes 100 how much does it take\nto get to b it takes 100 to get to b\nright so 100 plus the value of this edge\n100 is 200 right 200 is what it takes to\nget to c now so is this 200 smaller than\nwhat we currently have for c yes it is\nthat means we can update the value in\ntemp prices for c we can change this 500\nto a 200 sorry if it's not readable i'd\nput it over here but 200 is the cost to\nreach c if we add an extra stop in\nbetween so now that we've gone through\nevery single edge again we're going to\ntake all of these put the values up here\nand we're actually done with the loop\nwe're done with the entire algorithm\nbecause we ran it k plus 1 times so\nsince this 200 since this 500 up here is\ngoing to be a 200 right that means 200\nis the value that we're going to return\nfor the entire result right within one\nstop in between a and c which is\nobviously this route over here it takes\n200 cost to get there uh just an fyi if\nwe were not actually able to reach this\nright like maybe within k stops we\nactually can't even go from a to the\ndestination c what would we return in\nthat case would we just return infinity\nno the way the problem is written they\njust want us to return negative one if\nthat's ever the case so i hope this\nalgorithm makes sense and i hope you can\nsee why the time complexity is e times k\nbecause the loop is going to run k times\nand every time we loop we're going to be\niterating through every single edge in\nthe graph which is e so this is where\nthe time complexity comes from you're\nprobably still wondering why exactly do\nwe have this temporary prices array if\nyou're not you can probably skip ahead a\nminute but if you are let me explain\nthat to you suppose we change the\nproblem slightly suppose instead of\nhaving k equals one we change it to k\nequals zero that means the loop is going\nto run k plus 1 times that means the\nloop is going to run exactly one time so\nlet's see what happens in that case what\nwould be the output in that case if we\ncould only have zero stops in between a\nand c what's going to be the cost to\nreach node c of course it's going to be\n500 right there's only one possible way\nwe can reach c from a if we have zero\nstops in between we can't go along this\npath on the left side because it has one\nstop in between we're only allowed zero\nstops in between so if we run the\nalgorithm and if we didn't have a\ntemporary prices array let me show you\nwhat would happen we're going to go\nthrough the first edge 100 right okay\nwe're going to figure out okay it takes\n100 to get to b right so we can replace\nthis infinity with a hundred sorry if\nit's not readable but this is 100. next\nwe're going to go to the second edge\nright another hundred what are we gonna\nsay we're gonna say okay how long does\nit take to reach b it takes infinity\nnope it takes a hundred right because we\nput that update simultaneously in the\nexact same prices that we're iterating\nthrough right we put a hundred here so\nnow what we're gonna say is okay how\nmany how much does it take to reach c a\nhundred plus a hundred that it took to\nreach node b so then we'd put a 200\nvalue in the c spot right we'd put 200\nover here but what we just did because\nwe updated the same prices we didn't\nhave a temporary prices what we did is\nwe instead used a path that had an extra\nnode along it and we weren't allowed to\ndo that look we had k equals zero so\nthat's the idea of why we have to use a\ntemporary prices array okay so now let's\ncode it up and the best part about\nwriting the code with my videos is i\nspend so much time explaining the\nsolution that now writing the code is\ngonna be pretty trivial i bet for most\nof you so we're going to initialize\nprices to be infinity right where how\nhow big is price is going to be it's\ngoing to be the number of nodes that\nwe're given that parameter is n and\nwe're going to initialize it to all\ninfinity except for the source node\nremember the source node we're going to\nsay it takes a price of 0 to get to the\nsource node and that's the only variable\nwe're going to need now we can actually\nstart iterating uh through the loop\nremember how many times are we going to\niterate through the loop we're going to\ndo k plus one time so k is the input\nparameter we can use that we can do this\nloop k plus one times and once we do\nthat we're gonna go through every single\nedge remember so uh edges are located in\nthe flights array so we're going to go\nthrough every flight each flight or edge\nhas three values a source which i'm\ngoing to say is s a destination which is\nd right going from s to d each edge is\ngoing to be directed each edge is also\ngoing to have a price so p is going to\nbe what price is so iterating through\nthis flights array let me just put a\ncomment to tell you uh what each of\nthose variables means and remember\nbefore we actually go through this loop\nwe do want to have a temporary prices\narray and what we're how we're going to\ninitialize this temporary prices is just\ngoing to be a copy of whatever prices\nhappens to be at this point in time so\njust create a copy of prices this\ntemporary prices is where our updates\nare going to go so there's only two\nconditions we're going to check for\nremember the one special case is if this\nsource node right we have an edge source\ndestination and price if this source\nnode\nis not even possible to reach meaning if\nthe price located at the source node\nhappens to be infinity that that means\nwe can't even reach this source node if\nit's equal to infinity so in that case\nwe're just going to continue the loop\nright we don't want to check these edges\nand the only other case that we're going\nto look for is if we found a new\nshortest path to the destination node d\nso if we want to know what's the price\nto actually reach the source node s so\nfar what's the minimum price to reach\nthe source node s we know it's\ndefinitely not going to be infinity\nbecause we just checked that up above so\nwhatever that price happens to be plus\nwhatever is the price of this particular\nedge that we're iterating through so the\nprice to reach s plus this edge\nconnecting s with d so if this is\nsmaller than whatever the minimum price\nis to reach the destination then we're\ngoing to update that weight or or rather\nwe're going to update that price and\nwe're not going to be checking this\nprices that way we're actually going to\nbe checking if it's smaller than the\ntemp prices array because it could be\npossible that through this single loop\nwe updated this value already once right\nthis temporary prices array so if we\nupdate it multiple times we want that\nupdate to be reflected we want to we\nwant to just make sure that we're\ngetting the minimum value is what i'm\ngetting at so if it's smaller than that\nthen we're going to be\nupdating this to\nbe\nthis new minimum that we just found\nright this happens to be smaller than\nthis so it's time to do an update so we\ncan just copy and paste this into uh\nthis line of code that's all for this\nfor loop so once we're done updating\nthose minimums uh the last thing we're\ngonna have to do is take temporary\nprices and then reassign it to be prices\nso prices can be updated to\nbe just like this and really that is the\nentire implementation of bellman ford at\nleast for the context of this problem we\ndon't need any min heaps or anything\nlike jigstr's algorithm and then finally\nwe can return the result what are we\ngoing to return we're going to return\nprices of d right we want to know the\nminimum price to reach a destination\nactually not d we're going to be using\ndest because that's the input parameter\nthat we're given up above over here but\nremember it could be infinity if it's\nequal to infinity so let's say if\nthis is equal to float of infinity then\nwe actually want to return negative one\nso return negative one if this condition\nis true if this condition is not true\nthen we can just return whatever the\nactual minimum price happens to be okay\nso now let's run it to make sure that it\nworks it doesn't have an amazing run\ntime on leak code so you can see that it\ndoes work and it's relatively efficient\nyou can make it slightly more efficient\ni think if you use like a hash map and\nstuff but i think for the most part and\nespecially for interviews that\ndefinitely won't be a factor so i really\nhope this was helpful i'm pretty sure\nthis is going to be a really long video\nand it's going to probably be a pain to\nedit so i do hope it was helpful if it\nwas please like and subscribe it\nsupports the channel a lot consider\nchecking out my patreon where you can\nfurther support the channel and\nhopefully i'll see you pretty soon\n"
    },
    {
        "Name": "Climbing Stairs",
        "NcLink": "climbing-stairs/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "You are given an integer `n` representing the number of steps to reach the top of a staircase. You can climb with either `1` or `2` steps at a time.\n    \nReturn the number of distinct ways to climb to the top of the staircase.   \n\n**Example 1:**\n\n```java\nInput: n = 2\n\nOutput: 2\n```\n\nExplanation:\n1. `1 + 1 = 2`\n2. `2 = 2`\n\n**Example 2:**\n\n```java\nInput: n = 3\n\nOutput: 3\n```\n\nExplanation:\n1. `1 + 1 + 1 = 3`\n2. `1 + 2 = 3`\n3. `2 + 1 = 3`\n\n**Constraints:**\n* `1 <= n <= 30`\n",
        "Difficulty": "Easy",
        "Video": "Y0lT9Fck7qI",
        "PythonSolution": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 3:\n            return n\n        n1, n2 = 2, 3\n\n        for i in range(4, n + 1):\n            temp = n1 + n2\n            n1 = n2\n            n2 = temp\n        return n2\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nclimbing stairs so this is going to be\nanother dynamic programming problem\nand this is definitely more on the easy\nside definitely compared to some of the\nreally hard\ndynamic programming problems that we've\nbeen solving recently but i still think\nthat this is a good problem to really\nunderstand the fundamentals understand\nyou know the brute force\nand taking that brute force you know\nusing memoization and then of course\ngetting the true dynamic programming\nsolution\nand by the way if you don't already know\nwe have been tracking a list of blind 75\nquestions on the spreadsheet so today\nwe're going to be solving this dynamic\nprogramming one\nthe climbing stairs problem so i will be\nadding the solution once this video is\nuploaded\nand the link will be in the description\nif you do want to take a look at this\nsheet\nso the problem statement is pretty\nsimple we're climbing a staircase and\nit's going to take us\nn steps to reach the top of the\nstaircase\nevery time we take a step we have two\nchoices of how we can take a step\nwe can either just take one single step\nor we can take\ntwo steps at once and all we want to\nknow is\nhow many different ways can we get to\nthe top of the staircase\nso let's look at the first example n\nequals two that means we need to climb\ntwo steps so we could draw the picture\nkind of like this right so\nlet's say we start over here right this\nis step\nzero basically when we haven't climbed\nanything and our goal is to get up here\nwhich clearly is\ntwo steps right so starting from here we\nknow we can make two choices right we\ncan take\none step and that would land us over\nhere or we could take\ntwo steps and that would land us over\nhere so already we're seeing\none way is to just take two steps right\nthat's what this path\nwould take us right that's one way we\ncould reach the goal right just taking\ntwo steps at once\nnow if we ended up taking one step then\nwe would be\nat this position so from here we would\nwe would have that same exact choice\nright we can take\none step or we can take two steps now\nclearly if we take two steps we've gone\ntoo far right we were\nonly trying to climb two steps total but\nif we you know end up over here\nthen you know that's not going to count\nas a path right so that would not count\nbut as you can see if we took one step\ninitially then we could take another\nsingle step and that would be another\nway so either\nthis is one way we could reach two steps\nor we could just take\na single double step right so clearly\nthere are two different ways we could\nclimb the staircase and that's also the\nresult\nof this problem and they basically\nexplain it over here\nso let's look at the second example\nwhich is basically if we're climbing\nthree steps instead of two right so\nlet's look at the drawing so once again\nwe're gonna do the exact same thing that\nwe did right from here we could take\none step or we could take two steps\nright\nand so so far we'd get here but remember\nour goal is to climb three steps so\nlet's continue\nso from here we could take one step\nwhich would land us at the result or we\ncould take\ntwo steps which would get us out of\nbounds right that's not what we want to\ndo\nso so far we have found one way to get\nus to the result\nbut let's continue that from over here\nagain we can take a single step which\nwould get us over here or we can take\ntwo steps which would get us at the\nresult so now we've found two different\nways we can get to the last step\nand lastly we still have a path to\ncontinue right we got here\nby taking one step and then taking\nanother single step so\nhere we have two choices take one step\nget to the result or take two steps and\nget out of bounds\nso in the end we see that there were\nthree different ways\nwe were able to get to this last step as\nyou can see this is getting really hard\nto visualize\nwith a single staircase a more easy way\nwould be\nto get a decision tree to visualize and\nat\nevery decision remember we can take one\nstep or we can take two steps so let's\ntry to visualize the problem like that\nand see if we can notice any patterns\nso let's say we're given n equals five\nwe're trying to climb\nfive steps so we can consider just like\nthe previous drawing that we're starting\nat step\nzero and our goal is to get to step five\nnow remember\nat every given point we have two\ndecisions to make\nwe can climb one step or we can climb\ntwo steps right and depending on the\ndecision that we make\neach of these is going to lead to a\ndifferent path we can take to get to the\nresult and remember\nall we're trying to do is count the\nnumber of ways we can get to that result\nso in this decision tree you know we're\ngonna keep making two decisions at every\nstep and at the end\nwe're gonna count how many different\nways were we\nable to get to five steps reached\nso we can get to step one and we can get\nto step two let's just continue drawing\nout the decision tree from here we can\nmake two more decisions\nwe can take one step which would get us\nto two we can take two steps get us to\nthree\nand similar here we can take one step\nget us to three\ntwo steps get us to four from here we\ncan also take one step\nget us to three two steps get us to four\none step get us to four two steps get us\nto five\nnow here we can see that we reached the\nresult right n equals five\nso this is our first path that we\ncould reach to get us to the result\nright you can see we took\none step then we took two steps then we\ntook another two steps so this is our\nresult\nonce we get to it that's our base case\nright we're gonna solve this recursively\nright that's pretty much what we're\ndoing this decision tree is basically\nrecursion\nand this is our base case we wouldn't\nwant to continue\nif we got here so here we would return\none we found one way to get to the\nresult but for the remaining paths let's\ncontinue so here we can take one step or\ntwo\nthat'd get us to four this would get us\nto five so you can see once again we\nfound\nanother way we can get to the results so\nso far we have two different paths that\ncan lead us to step five\nand here let's do the same thing if we\ntake one step we get to five that's the\nresult if we take two steps we get to\nsix\nthat means we overshot right we went too\nfar this is another base case\nif this number of steps ever exceeds\nfive then we're going to return\nzero right we found zero ways from this\npath that can reach\nthe result so now let's continue over\nhere again we take one step or two\nso we'll get to four or five another\npath that leads us to the result\nand here we can also take one step or\ntwo which would get us five\nor six similarly over here right this is\nanother\nfour so the exact same thing is going to\nhappen do you start to see\nwe're repeating the exact same problem\nmultiple times how can we better solve\nthis problem knowing that\nso now we have another four we're just\ngoing to repeat the exact same thing\nthat we just did before right take one\nstep or two we know we're gonna get to a\nfive and we know we're going to get to a\nsix\nso you can see every path led to the\nbase case except for this last one so\nlet's complete this we can take one\nstep which would get five or two steps\nsix okay so now our entire decision tree\nis complete so what's the result gonna\nbe remember red means we're gonna return\nzero green means we're gonna return one\nso let's just count the number of greens\none two three four five six seven eight\nso there were eight different paths from\nthe beginning that could reach step five\nbut remember since we started here we\nwere asking how many different ways\nstarting at zero can we get to five and\nthen we got to a\nsub problem we got to a sub problem of\nstarting at step\none how many ways can we reach five from\nthis decision tree alone we see that\nthere's one\ntwo three four five different ways we\ncan reach the result\nand down two if we're starting at step\ntwo\nthere's three different ways we can\nreach the result now if you solve the\nproblem like this\nbasically using recursion and you could\nprobably do it with depth first search\nbecause this is basically a tree and\nwhat would be the time complexity of\nthat well clearly we you can see that we\nhave two decisions each time so it's\ngoing to be 2 to the power of the height\nof this tree what's the height going to\nbe\nit's going to be roughly n equals 5\nright you can see that this is going to\nbe the longest path so that's roughly\nthe height so the overall time\ncomplexity is going to be 2 to the power\nof\nn that's not super efficient but you can\nsee here\nwe're repeating the same problem\nmultiple times right when we get over\nhere we're\nasking how many different ways starting\nfrom 2 can we get to five right\nand down in this decision tree we found\nyes there were three different ways\nright so then when we\nget over here why why do we have to\nrecompute the exact same thing\ntake a look at these two purple blocks i\njust drew\nnotice how this decision tree looks the\nexact same as this one\nbecause in both cases we're solving the\nexact\nsame sub problem and since we're doing\nit depth first search\nthis one is going to be solved first\nright so\nif we solve this entire problem what we\nsaid was\nokay we found out starting at step two\nthere were three different ways to get\nto step five so when we get here why\ndon't we just take\nthat result store it in memory store it\nin dp\nor basically this is a cache right we're\nwe're storing it in memory so then when\nwe get here we can just say we already\nknow the result of this\nmeaning that we don't need to draw out\nthe entire decision tree we're just\ngoing to skip that all together we're\nnot going to draw this\nwe're not going to draw that and we're\nnot going to draw any\nlevels of this tree so as you can see\ni'm eliminating\nall that repeated work by saving that\nsolution\nbut that's not all right we see over\nhere\nwe're asking a different sub problem\nstarting at step three how many\ndifferent ways can we get to n equals\nfive\nwell in this case it was two different\nways right notice how this decision tree\nis the exact same over here because\nhere we're asking that same question\nstarting at step three what's the number\nof ways and since we're doing the step\nfor search\nthis one is going to end up being\ncomputed before this one\nso when we get here we can just say we\nalready know the answer is\n2 so we don't need to run through the\nentire decision tree again\nso in this case as well we can eliminate\nthat repeated work so i'm just going to\ncross this entire thing out\nand we're not done yet see over here\nwe're asking starting at step four\nhow many ways can we get to five that\nsame problem is over here\nnotice how they have the exact same\ndecision tree this one is going to be\ncomputed first because we're doing debt\nfor search\nso once again let's eliminate this\nrepeated work\nso now you can see when we do eliminate\nall that repeated work\nthis is what our decision tree ends up\nlooking like and this\nis roughly o of n this is\nlinear time solution reason being we're\nonly solving each sub problem once right\nso we know that the first sub problem\nthe original problem is starting at zero\nthen we get a sub problem of\none two three four all the way to\nfive which is our base case right so\neach of these sub problems is just being\nsolved once\nn is five so overall the time complexity\nis big o of n\nand this is basically the the dynamic\nprogramming solution where we are\ncaching the result aka memoization\nso we're using memoization but this\nproblem can actually be solved with a\ntrue dynamic programming solution\nas you can see starting at the result\nthe the result\nof zero depends on the sub problem\nthis one right and this sub problem\ndepends on another sub problem\nwhich depends on another sub problem\nwhich depends on our base case so why\ndon't we\nstart at the bottom solve the base case\nand then work our way up to the original\nproblem\nat zero right why don't we start at the\nbottom work our way\nup this is called a bottom up this is\ncalled a bottom\nup dynamic programming approach so\nthat's what i'm going to show you we're\ngoing to start at the base case\nand then work our way up so remember\nwe're starting\nat position zero and our goal is to get\nto the fifth step\nright each time we can take one step or\nwe can take two steps right\nso i'm going to be storing our result in\nan array called dp\nso we're going to have a position in dp\nall the way from index\n0 all the way up to index n which is\ngoing to be our input value remember\nso remember we're we're at the base case\ninitially right what's the base case\ngonna be\nwell at the last step if we start here\nhow many different ways can we land here\nwell that's just gonna be\none right that's our default value so\nnow\nthat we solved that we are able to solve\nthis one right because remember this\nproblem depends on the sub problem of\nthis\nso from here let's say we're starting\nhere we can take\none step which lands us at the result we\ncan take\ntwo steps which lands us out of bounds\nright so how many different ways\nfrom here can we reach the goal again\nit's going to be one\nand do you notice how this is always\ngoing to be the case\neven if we had something like n equals a\nhundred so let's say this was actually a\nhundred and this was 99\nthis would always be one right this is\nalways gonna be one because\nit's at the goal and starting from here\nit's also always going to be\none because we can take one step which\nwould get us to the result or we could\ntake two steps which would get us out of\nbounds so no matter what the n\ne the input value n is this is always\ngoing to be the case\nit's always going to be uh 1 1.\nnext we're going to get to the\ninteresting part so then we want to know\nokay how many different ways from here\ncan we reach\nfive well this depends on two sub\nproblems which come\nafter it right so we can take one step\nover here or two steps over here right\nso and then we get to the sub problem\nright\nso from four we don't need to continue\nto figure out how many different ways\nfrom four can we get to five because we\njust computed that that's why we're\nusing dynamic programming that's why we\nhave this array because we already\ncomputed\nstarting at four how many different ways\ncan we reach five and we also\nstarting at five how many different ways\ncan we reach five that's also\none so what we're gonna do in this value\nis basically take\nthese next two values add them together\none plus one and then we're gonna get\ntwo over here and we're gonna do the\nexact same thing\nfor this position two so we know here we\ncould take one step\nor two steps right so what we wanna do\nfrom here three is find out how many\ndifferent ways can we reach five\nwe just computed that that's two and\nfrom 4 we want to know how many\ndifferent ways can we reach\n5 we also already computed that that's\none so what we can do is take\nthese two values add them together and\nthat's going to be\nwhat we put here so starting at 2 we can\nget to 5\nthree different ways and at this point i\nbet you probably get the idea we're\ngonna do the exact same thing over here\nso what value are we gonna put over here\njust take these\nnext two values add them together three\nplus two is gonna be\nfive and remember this is what we were\noriginally trying to compute this is\ngoing to be the result it depends on\nonly two sub problems\nwhich are listed right after it five\nplus three that's going to be eight so\nthat's the result\nif you're familiar with what the\nfibonacci sequence is the fibonacci\nnumbers\nthat's exactly what we're doing right\nnow we're starting at the base case of 1\n1\nadding these two values to get the next\nresult then we're adding these two\nvalues to get three\nthen we're adding these two values to\nget five then we're adding these two\nvalues to get a\nso you may or may not be familiar with\nit but that's what we're doing\nand you may have also noticed we're\nusing extra memory right we're having an\nentire array size equals n that's going\nto be o of n\nextra memory but is it actually needed\nto have an entire array\nnotice how each value such as this one\nonly depends on the two values that come\nafter it and this one only depended on\nthe two values that came\nafter it so in reality we don't need to\nhave an entire array we just need to\nhave\ntwo different variables let's initialize\nthe two variables like this\none is gonna be this position two\nis gonna be this position because\nstarting from here we wanna know how\nmany different ways could we reach the\nresult if we took\none step that's why this is called one\nand if we took two steps\nthat's why this is called two and we're\nbasically going to be computing this\nnext value right and once we compute\nthis next value we're gonna shift our\none variable over here\nand we're gonna shift our two variable\nover here and we're going to keep doing\nthat until we get to the result\nof zero and if we initialize two\ninitial variables one and two as values\none how many different\nvalues do we have to compute that come\nafter in this case you can see we have\nto compute\nfour values right so basically we\ncompute\nn minus one values we have to loop n\nminus one times and then when our one\nvariable\nends up getting in this position that's\nwhat we're going to return\nas the result so this was a really long\nexplanation because we did a lot of\nanalysis but when i actually show you\nthe code it's going to be really simple\nusing this idea of two variables being\nshifted\nn minus 1 times so as i said from the\ndrawing explanation we're gonna have two\nvariables one and two\nboth are going to be initialized as one\nand\nthen we're just gonna loop through n\nminus one time so for i in range\nn minus one and we're gonna continuously\nupdate these two variables one and two\nso the first thing i'm gonna do is\nupdate one\none is gonna be set to one plus two\nright because we're just adding the two\nprevious values\nand then getting the new result so one\nis being updated and we would also want\nto shift\ntwo to whatever the previous value of\none\nwas but you can see that we're updating\none before we actually shift two so what\nwe're actually going to do is store\none in a temporary variable before\nwe actually update it and then we're\ngoing to set two to the temporary\nvariable\nso that we don't end up setting it to\none plus two we do we just want it to be\nset to one so we're gonna set two equal\nto temp\nonce this loop goes through n minus 1\ntimes\nwe're going to end up just returning\nwhatever one happens to land on\nand that is the entire solution we went\nthrough so much headache just to get to\nthese five lines of code\nso i hope that this was helpful if it\nwas please like and subscribe it\nsupports the channel\na lot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Min Cost Climbing Stairs",
        "NcLink": "min-cost-climbing-stairs/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "You are given an array of integers `cost` where `cost[i]` is the cost of taking a step from the `ith` floor of a staircase. After paying the cost, you can step to either the `(i + 1)th` floor or the `(i + 2)th` floor.\n\nYou may choose to start at the index `0` or the index `1` floor.\n\nReturn the minimum cost to reach the top of the staircase, i.e. just past the last index in `cost`.\n\n**Example 1:**\n\n```java\nInput: cost = [1,2,3]\n\nOutput: 2\n```\n\nExplanation: We can start at index = `1` and pay the cost of `cost[1] = 2` and take two steps to reach the top. The total cost is `2`.\n\n**Example 2:**\n\n```java\nInput: cost = [1,2,1,2,1,1,1]\n\nOutput: 4\n```\n\nExplanation: Start at index = `0`.\n* Pay the cost of `cost[0] = 1` and take two steps to reach index = `2`.\n* Pay the cost of `cost[2] = 1` and take two steps to reach index = `4`.\n* Pay the cost of `cost[4] = 1` and take two steps to reach index = `6`.\n* Pay the cost of `cost[6] = 1` and take one step to reach the top.\n* The total cost is `4`.\n\n**Constraints:**\n* `2 <= cost.length <= 100`\n* `0 <= cost[i] <= 100`\n",
        "Difficulty": "Easy",
        "Video": "ktmzAZWkEZ0",
        "PythonSolution": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        for i in range(len(cost) - 3, -1, -1):\n            cost[i] += min(cost[i + 1], cost[i + 2])\n\n        return min(cost[0], cost[1])\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today today let's\nsolve minimum cost climbing stairs and\nthis problem is very similar to another\nproblem that we've solved that's called\nclimbing stairs and honestly i think\nthis is probably one of my best videos\nexplaining dynamic programming i really\nwalk through\nall the steps from recursion to\nmemorization to dynamic programming so i\nwill link this video somewhere on the\nscreen or somewhere on the description\nif you want to take a look it's very\nsimilar to the problem that we're\nsolving right now which is minimum cost\nclimbing stairs it's just a slight\nvariation of that other problem so we're\ngiven an integer array called cost where\ncost of i is the i step on the staircase\nand if we pay that cost at index i then\nwe can either climb one step or two\nsteps from index i so in this example\nover here we're given an array of 10 15\nand 20. what we're told is that if we\npay this cost if we're at this position\nright and we pay the cost of 10 from\nthis position we can either take one\nstep which will land us in this position\nor we can take two steps which will land\nus in this position and we only have to\npay a cost of 10 to do that and also we\nare told that we can actually either\nstart at index 0 or start at index 1. so\nwe can either start from this position\nor we can start from this position and\nour goal is to reach the top floor of\nthis staircase so you're probably\nthinking okay\nlet's just start at position uh index\nzero right take a jump of 2\nwhich costs 10 right because we're\ntaking two steps starting from here so\nthat costs 10 then we reach this spot\nand then we're done right we've reached\nthe top floor so therefore the answer is\n10 right well not quite and it's kind of\ntricky i think it's really their fault\nthat they word this problem kind of\npoorly in this case the answer is\nactually 15. why is it 15 well it's\npretty simple it's because this is the\nlast position in our cost array but this\nis not the top floor the position right\nafter that is considered the top floor\nwhich\nyeah they don't really specify that\nanywhere in the description which is\nkind of dumb but that's the thing so\nthe reason why the answer is 15 is\nbecause remember we can either start at\nthis index or we can start at this index\nif we start here then we can take a jump\nof 2 which will reach which will land us\nat the top of the staircase it only\ncosts us 15 to do that or we could start\nat 10 take a jump of 2 and then take a\njump of 1 which would cost us 30 or we\ncould from 10 jump to 15 and then take a\ndouble jump which would cost us 25 10\nplus 15\nso clearly the minimum was when we start\nat 15 and then just take a jump of two\nso then the result is 15. so then your\nnext idea might be let's just be greedy\nright why not always you know let's\nstart at one of the positions either\nthis one or this one and then always\ntake two steps right why exactly would\nwe ever want to take one step when we\ncould take two steps right and it costs\nus the same amount well there's an\nanswer to that question and let me show\nyou an example a counter example of why\nsometimes we would want to take one step\nrather than two the main reason is\nbecause maybe if we take two steps\nthere's a value over here something like\na thousand right a really big number and\nthen we'd have to either take one step\nor two step but either way we'd have to\ncut it would cost us a thousand if we\nland here or we could take maybe one\nstep and yeah we'd have to pay 15 and\nthen have to pay a 20 and then we could\nthough take two steps uh to maybe a\nvalue over here that's really small like\nfive which would skip us a value like\nover here which would be a thousand so\nyou can't really be greedy and actually\nthe second example down here is another\nreason\nis another counter example of why we\ncan't always take two steps\nso let's really try to understand how we\ncan at least brute force this problem\nbecause we've noticed that from every\nspot we have two decisions right take a\njump of one or take a jump of two and we\ncan't just be greedy and take a two jump\nevery single time so let's try every\nsingle possibility and if you've watched\nany of my videos you know that we like\nto do decision trees when we're brute\nforcing so\nsuppose we start here we start at index\n0 and we have you know 0 1 2 to this\nindex and this index is out of bounds\nand that's when we know we've reached\nthe goal and we can stop so initially we\nstart at zero right we can either jump\nto index one or index two and the cost\nif we jumped to index one would be ten\nthe cost if we jump to index 2 would\nalso be 10. now if from index 1 we can\neither jump once right meaning we jump\nto index 2 or we can do a double jump\nand jump to index 3. of course if we're\nat index 1 the cost to jump from there\nis going to be 15 whether we take a one\njump or if we take a double jump from\nindex two we actually only have one\nchoice we can take a single jump which\nwill land us at index three which is\nactually out of bounds if we take a\ndouble jump we'll get to index 4 which\ndoesn't really make any sense because\nthat's also out of bounds so in this\ncase\nthe cost from jumping from index 2 is 20\nso we can put that now just so you know\nonce we reach index 3 which we already\nhave done in two of our\npaths as you can see\nwe can't really go any farther from here\nright so what we're going to say is as\nwe've stopped here we want to know okay\nwe reached the end right we want to know\nwhat was the minimum cost to reach this\nposition so\none path if we jump like this the cost\nwas 10 plus 15 which is 25 right that's\nthe total cost to reach this\ntaking this path it was 10 plus 20 which\nis larger it took 30 to reach this spot\nbut we're not quite done yet we know we\ncan't go in this direction so you know\nwe're done here but there's still one\nnode in our decision tree that we can\ncontinue to traverse so from index 2 we\ncan take another single jump and then\nget to index three and of course that's\ngoing to cost 20 to do that and so the\ncost is 20. so you can already tell that\nthis is definitely not the solution this\ntook about what 45 to reach uh index\nthree so definitely not good you can see\nthere were three different ways for us\nto reach uh the goal\nand among all of these the minimum was\n25 but remember if we go back to the\nactual description the answer to this\nproblem was actually 15 so why didn't we\nend up with the correct answer and it's\npretty simple because remember we were\nallowed to start at index zero or\nallowed to start at index one but\nclearly in this decision tree we started\nat index zero so don't we have to draw\nanother entire decision tree starting at\nindex one well if you're clever and you\ntake a look at this picture you know\nstarting from index one don't we already\nhave that entire decision tree just look\nover here right we started at index one\nhere now we did do some work before we\ngot to index one but can't we just\npretend like that doesn't exist can't we\njust reuse this entire decision tree\nobviously we'd have to modify the\nnumbers a tiny bit right because\nwhen we\nstart from here the cost so far is not\n10 it's actually zero because we're\npretending like we actually started from\nhere right and that will be easy to\nhandle for us if we recursively\nimplement this solution uh so what i'm\nsaying is for us if we started at at one\nyou know we'd put a path over here on\nthe right and then get to three and the\ncost for that would be 15 not 25 as we\nhave down here and the other path where\nwe go left we go uh jump to position two\nand then jump to position three that\nwould cost us 15 plus 20 which means the\ntotal would be 35\nrather than 45 right so not 45 over here\nit would actually be 35. the main point\nof what i'm trying to show you is\nthere's repeated work here right if we\ntake this solution as it is it's\nexponential because it's a decision tree\neach node is going to have two branches\nright up to two branches and we're gonna\nkeep doing that until we get to the base\ncase right which is index three so\nwhat's the possible height the max\nheight of this tree well we could have a\npotential level for every single\nposition in the input array right so the\nheight of the tree is going to be n\nwhich is equal to the length of the cost\narray right so n is equal to the length\nof the cost array and we know that we\ncould have two branches for every single\nnode so the time complexity comes to two\nto the power of n but as we just showed\nthere's a lot of repeated work that\nwe're doing if we eliminate that\nrepeated work we can actually get this\ntime complexity down to big o of n\nbecause what we're noticing is to solve\nthe original problem which is what's the\nminimum cost if we start at index 0 to\nreach index 3. to solve this problem\nwe're asking a couple more questions\nwe're basically solving the sub problem\nwe're asking okay how about to solve\nthis problem we have to first figure out\nif we're starting at index one what's\nthe minimum cost of reaching index three\nand to solve this problem we're asking\nanother sub problem down here okay what\nabout if we start at index two then\nwhat's the minimum cost to arrive at\nindex three so if we cache this repeated\nwork\nwith a hash map or something so that we\ndon't repeat the same problem multiple\ntimes what i'm saying is over here you\ncan see that we start at index two and\nwe wanna know how what's the cost to\nreach index three well it turns out that\nit was twenty right from two to get to\nthree it costs twenty so then when we're\ntrying to solve that same sub problem\nover here starting at index two how much\ndoes it cost to get to index three well\nit was 20. we don't actually have to run\nthrough that because we already solved\nthat problem over here right so that's\nthe main idea of how we can get this to\nbig o of n the reason it's big o of n is\nbecause we have n sub problems we're\nasking okay from index zero how long\ndoes it take to get to three from index\none how long does it take to get to\nthree from index two how long does it\ntake to get to three so that will be an\no of one operation for each position in\nthe array which will be n time\ncomplexity it'll also be o of n memory\ncomplexity and if we take this idea of\ncaching the recursive solution we can\nactually get an iterative solution that\ni'm going to show you now which will\nhave the same time complexity and you\nknow pretty much the same memory\ncomplexity as well so now let's actually\ngo over the real dynamic programming\nsolution which will actually have a\nslightly better memory complexity\nbecause we can actually use the input\narray itself that we're given and we\ncould actually even just use two single\nvariables to do the dp solution let me\nshow you why so we noticed that to solve\nthe original problem right starting from\nindex 0 what's the minimum cost to reach\nthe out of bounds position or the top of\nthe staircase we first have to solve the\nsub problem of starting from one and\nstarting from two right so basically\nthis has a dependency of this and this\nbut we also learned that this has a\ndependency of this and this and\nbasically every one of these cells has\nthat dependency so how about we actually\nsolve this problem from right to left\nrather than from left to right let's\nsolve the sub problems first and then\nsolve the original problem okay so does\nthat mean we're gonna start from index\ntwo we wanna know how what's the cost\nfor this to reach index three well it\nhas two choices it can do one jump or\ntwo jumps the second jump doesn't do\nanything because it also goes out of\nbounds right the first jump will go out\nof bounds so that's enough for us and\nwhat's the cost to reach 3 well it's\ngoing to be just 20. yes that works so\nwe can just leave 20 here right so from\nindex 2 to reach out of bounds it takes\n20. but what about from index 1 now we\nkind of get into one of the more\ninteresting cases right from here we can\nalso do a single jump so then we're\nasking okay if we do a single jump it'll\nobviously cost us 15 to do that single\njump but also the value that should be\nin this position is from index two how\nlong does it take to reach index three\nbecause then what we can say is okay for\nindex one to reach index three we can\njust take 15 which was this jump and\nthen 20 which was the remainder right\nthe remainder to reach index three so we\ncan in this position we can put 15 plus\n20. but hold on because there's actually\ntwo paths right\nwe already handled the single jump case\nbut what if we do a double jump from\nindex one then what's the cost that we'd\nput here well we'd put 15 because that's\nthe cost of making the double jump but\nthen we'd want to also add the value\nthat goes here to that total result\nright because from index three how long\ndoes it take to reach index three it's\nkind of a weird question logically to\nactually ask but just to make the math\nwork out the easiest number we can put\nhere is zero right because if we're\nalready at index three it obviously\ndoesn't cost anything to to stay here so\nthat's the reason why we're putting a\ndefault value here of zero now now we\nactually have to look at two choices\nright because one possibility was we go\nhere make a single jump to two and then\ngo to three right the cost of that will\nbe 15 plus 20. another possibility is we\nstay we start here and then just do a\ndouble jump to this position right and\nthe cost for that is going to be 15 plus\n0 because there's a 0 here so we want to\ntake the minimum of both of these values\nwhat's smaller 35 or 15 of course 15 is\nsmaller so we're going to put the\nminimum of these two computations in\nthis position and the good thing is it's\nalready 15. and last we're gonna start\nfrom index zero we're going to see okay\n10 plus the cost you know 10 is the cost\nfor making one jump and then from here\nfrom index one what would be the cost to\nyou know do the remainder of reaching\nindex three it's just going to be the\nvalue that's here which is already 15 so\n10 plus 15 is 25 that's one possibility\nthe second possibility would be making a\ndouble jump so from here a double jump\n10 plus 20 which is the value here is 30\nright so we want to take the minimum of\nthose two values of course 25 is smaller\nthan 30 so we put 25 in this position so\nnow in this array every single index\nrepresents the entire cost it would take\nfrom this index to reach the end of the\narray or the top of the staircase from 2\nit would be 20 from index 1 it would be\n15 and from index 0 it would be 25 now\nwhat value do we actually want to return\nremember we can only start at index 0 or\nindex 1. we can't start at index 2 and\nwe definitely can't start at the top of\nthe staircase so what we're going to\nreturn is just going to be what's the\nminimum of the first two values in this\narray of course the minimum of these two\nis 15 so we can just return 15. as you\ncan see the the time complexity was\ndefinitely big o of n we just you know\niterated through the array in reverse\nand the memory complexity is uh\ntechnically big o of one because we're\nnot really we're just using the input\narray itself and you actually don't even\nneed to use the input array you don't\nneed to write over the input array\nbecause if you notice as we go in\nreverse\nyou know this value only depends on the\nnext two values and this only depends on\nthe next two values so really if you\nwanted to you could just keep two\nvariables in memory rather than even\nwriting over the entire array and then\nas you go in reverse order you could\nupdate those variables to you know the\ncorrect values but it's your choice of\nhow you want to code it up speaking of\ncode now we can finally jump into the\ncoding solution okay so now let's jump\ninto the code and this is the same\nexample that we were basically working\non and remember what we wanted was to\njust have another extra zero at the end\nof the array just to make the math work\nout easily for us so that's what we're\ngoing to do to this input array we're\njust going to append a zero value to it\nand then we want to iterate through this\narray in reverse order right so what\nindex are we going to start at well in\nthe drawing i started at this index but\nremember what we're going to be doing is\ntaking this and then looking at the next\ntwo values that come after it of course\nfor the last index or this index that\ni'm showing there aren't two values that\ncome after it so we should actually\nstart at this index and that makes sense\nfor us because we're not actually going\nto be updating this value because we're\njust going to take 20 add it with 0\nwhich doesn't change this value at all\nright so that's why we're going to be\nstarting at this index how we can get\nthis index is basically the entire\nlength of the array we know that the\nentire length of the array minus 1 will\ngive us the last position right length\nminus 1 will give us this position so\nreally we can do length minus 3 which\nwill give us this position which is\nwhere we want to actually start at so\nwe're going to do the length of the cost\narray minus three and this is just how\nyou do it in python at least with a for\nloop and we're gonna decrement uh we're\ngonna keep going all the way until we\nreach the beginning of the array and\nwe're gonna decrement by one each time\nif you're not familiar with python all\nwe're doing is just iterating starting\nat this position in reverse order from\nthis array so remember what we want to\ndo for cost at index i what we want to\nassign this to is really the minimum of\ncost of index i plus\ncost of index i plus one right because\nfrom here if we make a single jump we're\ngoing to land here so we want to add the\nvalue at that position that we land at\nto the original position the second\nchoice is if we make a double jump so\ni'm just going to copy and paste this\nbecause it's pretty similar if we make a\ndouble jump this is what\nthe computation will be like cost of i\nplus cost of i plus two but if you want\nto actually simplify this line of code\nyou can see that since both of these\ncomputations have cost of i as the first\nuh you know value we can actually just\nremove cost of i from both of these and\nactually just take the minimum of these\ntwo and add it to the original value so\nwe can just change this line to this\nright take the minimum of these two and\nadd it to cost of i yeah that's the\nentire code just iterate through it in\nreverse order do the computation and\nthen the only thing you have to return\nis the minimum of the first two values\nof cost of i so\ncost of zero and cost of index one and\nthe main reason that this works is\nbecause we're guaranteed that the cost\narray is going to have at least two\nvalues if we weren't guaranteed that\nthen we couldn't necessarily do this\nline over here but let's run it to make\nsure that it works let me just delete\nthis first line up above so we don't get\nany errors and as you can see on the\nleft yes the solution works and it's\npretty efficient so i hope that this was\nhelpful if it was please like and\nsubscribe it supports the channel a lot\nconsider checking out my patreon where\nyou can further support the channel if\nyou would like and hopefully i'll see\n"
    },
    {
        "Name": "House Robber",
        "NcLink": "house-robber/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "You are given an integer array `nums` where `nums[i]` represents the amount of money the `i`th house has. The houses are arranged in a straight line, i.e. the `i`th house is the neighbor of the `(i-1)`th and `(i+1)`th house.\n\nYou are planning to rob money from the houses, but you cannot rob **two adjacent houses** because the security system will automatically alert the police if two adjacent houses were *both* broken into.\n\nReturn the *maximum* amount of money you can rob **without** alerting the police.\n\n**Example 1:**\n\n```java\nInput: nums = [1,1,3,3]\n\nOutput: 4\n```\n\nExplanation: `nums[0] + nums[2] = 1 + 3 = 4`.\n\n**Example 2:**\n\n```java\nInput: nums = [2,9,8,3,6]\n\nOutput: 16\n```\n\nExplanation: `nums[0] + nums[2] + nums[4] = 2 + 8 + 6 = 16`.\n\n**Constraints:**\n* `1 <= nums.length <= 100`\n* `0 <= nums[i] <= 100`\n",
        "Difficulty": "Medium",
        "Video": "73r3KWiEvyk",
        "PythonSolution": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            temp = max(n + rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n        return rob2\n",
        "Transcript": "okay let's solve leak code 198 house\nrobber in my opinion this is such a good\nquestion to understand even though it's\njust an easy question you can learn so\nmuch about dynamic programming from this\nproblem and you might already know\nGoogle really loves asking dynamic\nprogramming problems and if you want to\nget started on that this is such a good\nquestion to understand\nso we're basically given an array of\nintegers like many problems and each\ninteger represents a house right so this\nis a house this is a house this is a\nhouse they're all houses and they're\nadjacent to each other so it's basically\na neighborhood we want to rob houses to\nmaximize the amount of money we can rob\nso why not just rob all of them right\nnope there's a restriction we can't rob\ntwo houses that are adjacent to each\nother so we can rob this house but then\nwe can't rob this house right so we have\nto rob this one next maybe right on the\nother hand if we rob this one we can't\nrob this one and we can't rob this one\nit has two neighbors this might sound\nreally difficult right so let's just\nstart out with the brute force approach\nlet's imagine if we were trying to get\nevery single combination okay so the\nfirst combination is where we pick the\nfirst house right so let's draw out what\nthe decision tree of that would look\nlike okay so our first decision was to\nrob the house with value one okay so\nnext we want to rob more houses right\nbut we can't rob this one so we can we\nhave to basically get the max we can Rob\nfrom these two so does that sound kind\nof like a sub problem yeah but we'll get\nthere in a minute so continuing on with\njust a brute-force right okay so now we\nwant to rob these two houses right well\nwe can't rob both of them because\nthey're right next to each other so we\ncan either rob house 3 or we can rob\nhouse 1 so this is the decision tree\nright and so along this path so if we\nwere to rob house 1 right let's say we\nwent along this path then we can either\nrob house 1 and 3 or we can rob house 1\nand 1 obviously we're gonna choose this\none because that gives us the total that\ngives us the maximum which is 4 okay but\nwhat if we didn't Rob the first house we\ndecided to rob the second\nso that would be our other decision in\nour decision tree right Rob house - okay\nnow we have not many choices right we\ncan't Rob house three so the only house\nleft is house one so we rob that one as\nwell\nso if we went along this pathway in our\ndecision tree we would get these two\nhouses robbed and that's a total of\nthree but we remember we found this\nwhich was a total of four which is\ngreater of course so that's going to be\nour result now this is a very\nbrute-force approach imagine if we had\nmore numbers here right maybe a three\nand a four then we'd have to have like\nmore paths in our decision tree this\ncould get very complex so how can we\nimprove it can we identify any\nsubproblem and the answer to that is yes\nlet's take a look at the subproblem so\nremember we have two choices we want to\nget the max that we can rob from this\nentire neighborhood so the first choice\nis we rob from the first house and then\nfind the maximum from the remaining\nhouses right imagine there's more houses\nhere there could be a three or four\nwhatever right this is the subproblem\nwe're finding the max of a sub array of\nthe entire array the second choice we\nhave is we skip this house right if we\nskip it then basically we're saying okay\nfind the maximum of the entire sub array\nnot including the first value so let's\nactually write out the relationship if\nit doesn't make sense yet so if we want\nto find the max we can Rob from the\nentire array we have two choices Rob in\nthis case indicates the max that we can\nRob from the entire array so in our\nfirst decision we decided that we were\ngonna Rob the first value so array of\nindex 0 plus Rob the remainder of this\nblue portion of the array so we're\nskipping index 1 we're gonna Rob the\nentire array from index 2 to the end so\nI'll say n is the end in this case so\nthat's our first decision if we decided\nto rob the first house then we're gonna\nbreak up the problem into a sub problem\nnow we got to Rob the remainder of that\narray\nskipping one of the values if we didn't\nrob the first house and then we simply\nonly have the sub-problem robbed every\nhouse skipping the first house so we\nstart at house one not house zero and go\nuntil the end of the array so this is\nthe recurrence relationship you might\nnot know exactly what that means but\nit's basically a way to break up dynamic\nprogramming problems notice the result\nof the entire problem depends on only\nthese two if we can compute these two\nthen we have our result\nbut notice each Rob can be broken up\ninto its own sub-problem just like we\ndid over here so let's actually solve\nthe subproblems now before we solve the\nentire problem now I could do this in\nreverse order right I could say let's\nfind the max of this sub array this sub\narray and so on but it's a little more\nconfusing to do that so I'm actually\ngoing to do it in order so let's start\nat the first house like we've been doing\nso if we rob this house that's basically\nour base case right so we can decide to\nrob this house in that case up until\nthis point we could Rob a total of 1 ok\nnow we get to the second house so what's\nthe max we can Rob up until this point\nwell we can decide to not rob this house\nand only rob this house if we wanted to\nor we can decide to not rob this house\nand only rob this house to is obviously\ngreater than 1 so I'm gonna decide only\nto rob this house next we get to house 3\nthis is where it gets interesting so\nwhat's the max amount we can Rob up\nuntil this point so we have two choices\nagain we can Rob house 3 and we can Rob\nhouse 1 or we can just Rob house to the\nmax is obviously if we Rob house 3 and 1\nand in that case we'd get a total of 4\nnow we get to the last value 1 so we can\ndecide to Rob house 1 and if we did Rob\nhouse 1 then we would want the max we\ncould Rob up until these two values\nmeaning we'd want 1 plus 2 because 2\ntells us what's the max we can Rob from\nthese first two elements we\ninclude this one because it's adjacent\nto one so one of our choices is one plus\ntwo that's choice one or we can decide\nto not even Rob house one we can just\nget the max of the entire first three\nelements not including this one in that\ncase we have what we would get from the\nfirst three elements right here we\nalready computed it it's four so our\nchoices are one plus two or four\nobviously four is greater so I'm gonna\nchoose four that means we put a four\nright here and this for this last four\nmeans that for the entire array the\nentire array the max value we could get\nis four if we wanted to rob houses so we\ncan put a 4 here but notice how we don't\nhave to look we don't even have to store\nthis entire blue portion for each value\nlike for this one for to compute this we\nonly need to look at the previous two\nresults that we computed and the reason\nfor that is because we could either\ndecide to rob this one and Rob the\nremainder portion of the array not\nincluding 3 and in which case we'd have\nthe value computed right here the other\ncases if we wanted the max we could Rob\nfrom the entire array we could decide to\nnot even include this and just get the\nmax from these three and in that case\nthe value would be stored here so now\nlet's look at the code since we only\nneed to maintain the last two maxes that\nwe could rob from we'll only need two\nvariables so I'll just name them Rob 1\nRob 2 we'll initialize them as zero\nbecause if we get an empty sub-array we\nwant to return zero anyway so let's\niterate through each of the houses we\ncan Rob and now we want to compute the\nmaximum that we can Rob up and tell this\nvalue n so I'm gonna compute that in a\ntemporary variable for now and you'll\nprobably see why so the max we can Rob\nup until now in my case I'm gonna say\nRob 1 or Rob 2 was the last house that\nwe robbed\nRob one was the one before\nthat so knowing that the max we could\nget would be n+ Rob one meaning there's\na gap between the current house and the\nprevious house or Rob two which includes\nthe previous house in case it's not\nclear this is basically let me just make\na comment to show what I mean by Rob 1\nand Rob - so Rob 1 is first\nRob 2 comes second and then we get some\nmore values and n plus 1 and so on so if\nI want a Rob n then I have to Rob Rob\none as well I can't use Rob 2\nbut if I want to do Rob - I can include\nn because it's right next to it so when\nwe iterate to the next position meaning\nwe get here we want to update Rob one to\nnow equal Rob - so let's do that\nand Rob 2 in this case wants to be\nupdated to n so Rob 2 can now equal our\ntemporary value that we just computed at\nthe end we want to return Rob 2 because\nby the time we get to the end Rob 2 will\nbe equal to the last value meaning that\nit will be the max we can rob from the\nentire neighborhood of houses this is a\nproblem you can learn so much from even\nthough it's an easy problem it might\ntake you a while to digest exactly\nwhat's going on and to understand all\nthe like importance of this problem so\nmany dynamic program programming\nproblems are built upon this one and let\nme know if you have any questions\nbecause I feel like I might not have\nexplained like the recurrence\nrelationship quite well enough but if\nthis was helpful thank you for watching\nleave a like and subscribe and let me\n"
    },
    {
        "Name": "House Robber II",
        "NcLink": "house-robber-ii/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "You are given an integer array `nums` where `nums[i]` represents the amount of money the `i`th house has. The houses are arranged in a circle, i.e. the first house and the last house are neighbors.\n\nYou are planning to rob money from the houses, but you cannot rob **two adjacent houses** because the security system will automatically alert the police if two adjacent houses were *both* broken into.\n    \nReturn the *maximum* amount of money you can rob **without** alerting the police.\n\n**Example 1:**\n\n```java\nInput: nums = [3,4,3]\n\nOutput: 4\n```\n\nExplanation: You cannot rob `nums[0] + nums[2] = 6` because `nums[0]` and `nums[2]` are adjacent houses. The maximum you can rob is `nums[1] = 4`.\n\n**Example 2:**\n\n```java\nInput: nums = [2,9,8,3,6]\n\nOutput: 15\n```\n\nExplanation: You cannot rob `nums[0] + nums[2] + nums[4] = 16` because `nums[0]` and `nums[4]` are adjacent houses. The maximum you can rob is `nums[1] + nums[4] = 15`.\n\n\n**Constraints:**\n* `1 <= nums.length <= 100`\n* `0 <= nums[i] <= 100`\n",
        "Difficulty": "Medium",
        "Video": "rWAJCfYYOvM",
        "PythonSolution": "class Solution:\n    \n    def rob(self, nums: List[int]) -> int:\n        return max(nums[0], self.helper(nums[1:]), self.helper(nums[:-1]))\n\n    def helper(self, nums):\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            newRob = max(rob1 + n, rob2)\n            rob1 = rob2\n            rob2 = newRob\n        return rob2\n",
        "Transcript": ""
    },
    {
        "Name": "Longest Palindromic Substring",
        "NcLink": "longest-palindromic-substring/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "Given a string `s`, return the longest substring of `s` that is a *palindrome*.\n\nA **palindrome** is a string that reads the same forward and backward.\n\nIf there are multiple palindromic substrings that have the same length, return any one of them.\n\n**Example 1:**\n\n```java\nInput: s = \"ababd\"\n\nOutput: \"bab\"\n```\n\nExplanation: Both \"aba\" and \"bab\" are valid answers.\n\n**Example 2:**\n\n```java\nInput: s = \"abbc\"\n\nOutput: \"bb\"\n```\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `s` contains only digits and English letters.\n",
        "Difficulty": "Medium",
        "Video": "XYQecbcd6_c",
        "PythonSolution": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        res = \"\"\n        resLen = 0\n\n        for i in range(len(s)):\n            # odd length\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    res = s[l : r + 1]\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n            # even length\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    res = s[l : r + 1]\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n        return res\n",
        "Transcript": "hey everyone let's solve another classic\nleak code problem today longest\npalindromic substring\nso we're given a string in this case\nb-a-b-a-d\nand we want to return the longest\npalindromic substring that exists\ninside of here in this case there's\nactually two\nb a b as well as a b\na so we could return either of these and\nthat would be perfectly fine\nnow what actually is a palindromic\nsubstring in the first place\nbasically it means that you know you\ntake b\na b if we wrote that in the reverse\norder which would be\nyou know b a b it's the exact same\nstring\nso like i usually do let's say you just\ndon't know how to solve\nthe problem well what's the most brute\nforce way you could do it\nwell you could say i'm just going to\ncheck every single substring\nin this original string and check if\nit's a palindrome and get the longest\none\nstarting at b so i would check this i\ncould check this\ni could check this this\nand this right so every substring\ncontaining this\noriginal b and i want to check for each\nof these\nis it a palindrome or not and i would\nrepeat\nthat process with every character right\nso for this a\ni'd get every substring\nand basically keep doing that now the\nquestion is\nfor a string for example b a b\nhow what's the time complexity to even\ncheck if it's a palindrome well we'd\nhave to scan\nthrough the entire string right so for\nany given sub string\nto check if it's a palindrome it's going\nto take\nlinear time complexity so let's say\nn right now how many sub strings\ndo we actually have to check\nn squared because we're checking every\nsingle substring containing every single\ncharacter\nso to check if a string is a palindrome\nwe have to do\nwe have to do a linear scan and we have\nto do that for every single substring\nso then that's going to mean that the\noverall time complexity of this brute\nforce approach is going to be big\no n cubed so the question is how can we\ndo\nbetter well it it actually involves\nunderstanding how to actually\ncheck if a substring is a palindrome or\nnot\nfor again let's look at bab we can check\nif it's a palindrome\nby starting at the outside and comparing\nthese characters\nand as long as they're equal we'll keep\ngoing until we get to the middle\nand then we'll check and then we'll know\nokay it's a palindrome but we could also\ndo it another way\nwe could start at the middle and then\nexpand outwards\nand and check if it's a palindrome that\nway so\nwhich one of these is going to help us\nmore well let's think about this\nlet's say i wanted to know for this b\nwhat's the longest palindrome where this\nb is the center of the palindrome\nwell there's no character to the left of\nit so it's just going to be this\ncharacter\nthis or this b itself right so it's just\none\nwhat about this a well let's let's start\nexpanding there is a character to the\nleft and there is a character to the\nright and they happen to be equal\nso the longest palindrome with this a at\nthe center\nis going to be a length 3 and it's going\nto be\nb a b notice how if we do it this way\nfor each character we're going to\nconsider it the center and we're going\nwe're going to take each character so\nthat's going to be n and to expand\noutwards for each character it's going\nto be n again\nso for this way the overall time\ncomplexity\nis going to be o of n squared so that's\nkind of\nclever right like a little a subtle\ndifference of how we check if it's a\npalindrome\ncan really improve the time complexity\nbut hold on\nthere's one edge case that we're missing\nwhen we take\none character and expand outwards from\nit like for this b\nwe're getting palindromes that are of\nodd\nlengths they've conveniently shown us\nthis example\nwhere the longest palindrome is actually\neven so how are we going to check\neven palindromes well that's just a\nslight edge case\nthat we can easily add to our solution\nso we just have to remember to handle\nthis edge case when we're implementing\nour code\nokay so let's get to everybody's\nfavorite part the code\nso i'm gonna initialize the result as an\nempty string because you know that's\njust a good default case\nwe'll get the the longest length\ninitially set to zero\nnow we're gonna go through every single\ncharacter or\nrather every single position in this\nstring\nconsidering it to be the center so first\nlet's check\nso i'm going to have a left and right\npointer these left and right pointers\nare going to be initialized\nto i which is our center position\nright now while my left and right\ninbound\nas well as while this is a palindrome so\ni want to check that the left and right\nare equal to each other\nremember we're starting in the middle\nso while this is the case we know it's a\npalindrome so we can potentially\nupdate our result so we'll check that\nthe length of this palindrome which we\ncan\ncompute by saying right minus left\nplus one is greater\nthan our current result length\nand we also have to not forget to update\nthe result length i usually forget to do\nthis\nand let's also not forget to expand our\npointers outward so our left pointer\nwill be shifted to the left\nour right corner will be shifted to the\nright so now let's check the even\nlength palindromes as well\nright now you can handle this a bunch of\ndifferent ways the way i'm going to do\nit is\nsetting the left pointer to\ni and setting the right pointer to i\nplus one so again we're basically copy\nand pasting the code that we just wrote\nabove\nmaybe we could write a function to do\nthis but that's\nso while it's a palindrome again we'll\ncheck that\nthe length is we'll check that it's the\nlongest palindrome that we've seen so\nfar basically\nand again we can expand our pointers\noutward\nand at the end all we have to do is\nreturn\nour result so i kind of made it look\neasy\nuh with the code but don't let it fool\nyou it took me a while to write this\nbefore i started recording this\num there's a lot of like edge cases that\ncan be kind of annoying\nwith this problem i think for me putting\nthe if statement\nuh checking that it's the longest\npalindrome inside of the while loop\nhelped i think if you put this outside\nthe while loop it kind of makes it\nharder\nbut i hope this at least gave you a\nlittle bit of the intuition behind the\nproblem\nwriting the code is not always easy but\nif this was helpful\nleave a like and subscribe and thank you\n"
    },
    {
        "Name": "Palindromic Substrings",
        "NcLink": "palindromic-substrings/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "Given a string `s`, return the number of substrings within `s` that are palindromes.\n\nA **palindrome** is a string that reads the same forward and backward.\n\n**Example 1:**\n\n```java\nInput: s = \"abc\"\n\nOutput: 3\n```\n\nExplanation: \"a\", \"b\", \"c\".\n\n**Example 2:**\n\n```java\nInput: s = \"aaa\"\n\nOutput: 6\n```\n\nExplanation: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". Note that different substrings are counted as different palindromes even if the string contents are the same.\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `s` consists of lowercase English letters.\n",
        "Difficulty": "Medium",
        "Video": "4RACzI5-du8",
        "PythonSolution": "class Solution:\n    \n    def countSubstrings(self, s: str) -> int:\n        res = 0\n\n        for i in range(len(s)):\n            res += self.countPali(s, i, i)\n            res += self.countPali(s, i, i + 1)\n        return res\n\n    def countPali(self, s, l, r):\n        res = 0\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\npalindromic substrings and this is\nanother problem from the leak code\nblind 75 list a list of 75 very good\nleak code problems to solve and this\ntime we will be doing palindromic\nsubstrings down here\nand so we are getting one step closer to\nfilling out this entire list and this\nproblem palindromic substrings is\nactually really similar to another\nproblem i've solved\nlongest palindromic substring so if you\nwould like to i'd recommend watching\nthis video as well longest palindromic\nsubstring i will probably link it in the\ndescription below\nso simply we are given a string s and we\njust want to return the total number of\npalindromic sub strings contained in the\nstring s\nand as you may know a palindromic\nsubstring\nis basically a string that can be read\nbackwards and it's the same string so\nyou know a\na if you read it backwards it's the\nexact same string right\na b a you know this is the same string\nreversed\nyou know because the first character is\nthe same as the last character\nand then in the middle we're just left\nwith one character and\nyou know basically that kind of pushes\nus towards a base case so\nas you may know there's two types of\npalindromic substrings\nstrings of odd length right so for\nexample just a single letter a\nthat's a palindrome right it's it's the\nsame backwards\nif we add a b to the beginning and a b\nto the end it's still a palindrome\nbecause now we\nexpanded it outwards with the exact same\ncharacter\nsimilarly we can do the same thing with\neven length sub strings as well if we\nhave two a's\nin the middle then of course this is a\npalindrome and then\nif we continue to expand outwards we add\na b at the beginning\nand we add a b at the end it's\ncontinuously\ngoing to be a palindrome because these\ncharacters are also matching now if we\ninstead of adding a b we added a\nc at the end the inside is a palindrome\nthis string of length\ntwo but now if we expand outwards this\nis not a palindrome right yeah this just\nit can't be read backwards c is not the\nsame as b it's not a palindrome\nso that's a little bit about palindromes\neven an odd length\nbut so how can we apply that to our\ninput\nso in this case we are given a string a\nb c now of course we have three\ndifferent\npalindromes because each character by\nitself is a substring of course\nand each of those by themselves is a\npalindrome as well so that's three now\nis any other substring for example a b\nthat's not a palindrome\nbc that's not a palindrome abc that's\nalso not a palindrome that's basically\nall the substrings available to us\nso we only find three so we're going to\nreturn three so let's\nunderstand how we can do the brute force\nsolution which is actually big o of n\ncubed and then we can actually optimize\nit a little bit understanding how even\nan odd palindromes work\nand then we can get a big o of n squared\ntime complexity solution\nso let's say we're given a string that\nlooks like this\nif we just start brute forcing it we\nwant to go through every single\nsubstring right so every single\nsubstring starting at this first\nposition would be something like this\nright\nthere's these substrings right then we'd\nwant to go through every single\nsubstring starting at this position\nwhich would look something like\nthis right in total there's going to be\nn squared sub strings right\nand for each substring for example you\nknow this\none we need to determine if it's a\npalindrome or not and we know it you\nknow that's not\na difficult algorithm to write we could\nhave two pointers one at the beginning\none at the end\nwe basically keep comparing the\ncharacters and making sure that they're\nthe same right so\nand for a substring like this we'd also\nhave two pointers right compare that\nokay these two\ncharacters are the same so then we can\nmove inward right we'd shift our\npointers here\nand then we'd see okay this character is\nalso the same and then you know we we go\nthrough every character so we determine\nyes that's a palindrome then we can\nincrement our count of palindromes right\nwe'll call that our result variable\nso then we'll add one to it right\nbecause that's ultimately what we're\ntrying to return the number of\npalindromic substrings inside of this\nstring s and clearly finding and\ndetermining that a string\nis a palindrome is also big o of n\nso since there are n squared substrings\nin the entire string\ns and for each of those substrings we\nhave to determine that it's a palindrome\nwe're going to multiply it by n so this\nis going to give us an\nn cubed time complexity now we can\nimprove this\nand it's going to require us to solve\nthis problem in a different\norder what we're instead going to do is\nwe're going to go through every single\nposition in\nthis right instead of finding for this\nposition all the substrings that\nstart at this position we're going to\nfind all the sub strings\nthat this position is the middle of so\ninstead of you know just going to the\nright we're actually going to expand in\nboth directions we're going to go\nthrough\nall sub strings where this position is\nthe middle position\nnow clearly this string itself is one\nstring right and\nthis is a palindrome so we're gonna have\nour left and right pointer just\ninitially at this position\nwe're gonna see that okay both of these\ncharacters are the same right so then we\ncan take our result\nadd one to it right so we found so we\ndid find one palindromic substring\nand then we're going to try to expand\noutward right our left pointer is going\nto go here our right pointer is going to\ngo here\nclearly we go out of bounds though to\nthe left right so\nso basically what we're saying is\nthere's only one substring where this is\nthe middle position of\nand then we're going to do the same\nthing for here so from this position we\nwant all sub strings where this\nis the middle of so we're going to have\nour left and right pointer initially\nhere\nyes this character you know our left and\nright pointer point at the same\ncharacter so we\nwe found one palindromic substring just\nthe single character itself\nthen we are going to take our left and\nright pointers and then shift them so\nleft is going to go over here\nright is going to go over here right so\nnow let's compare left character and\nright character\nsince we already know this middle\nportion\nis a palindrome right now we only have\nto compare the left and right characters\nthe new left and right characters if\nthey are equal right which they are a\nequals a\nright so therefore we found one\nadditional palindrome this palindrome of\nlength three\nwhere this character is still the middle\nposition right so now we found an\nadditional palindrome so i think our\ntotal number of palindromes is up to\nthree now\nand once again we're going to take our\nleft pointer shift it to the left\nright pointer and shift it to the right\nnow clearly once again our left pointer\ngoes out of bounds\nso you know this is we can't really find\nany more sub strings where this\nis the middle position but do you notice\nhow\nwhat we just did right we we cut down on\nrepeated work\nwe found that this is a substring and\nthen in another single operation we\nfound that this is a palindromic\nsubstring as well\nthat cuts down on the repeated work\nwhereas before we would have done\nsomething like okay\nyou know this is a polynomic substring\nthen we\nincrease it then we have to look at both\nof these and\nyou know if we continue to increase it\nif we go all the way here then we have\nto still\ncheck okay this is the same and now this\nis the same right we're\ncontinuing to do repeated work if we\nstart from the left and then expand to\nthe right but if we start in the middle\nand expand left and right then we\neliminate repeated work\nso let's do the same thing from here so\nthis is a palindromic substring right\nleft and right point at the same\ncharacter\nthen we expand once to the left once to\nthe right\nare these characters the same right are\na\nand b the same they're not the same so\nwe knew that the initial\nsubstring just in the middle over here\nthe one the single character\nwas a palindrome but when we add this\ncharacter and this character it's no\nlonger a palindrome this is not a\npalindrome so no matter what we do now\nif i expand one more to the left and\nexpand one more to the right\neven if these characters were the same\nassume we had an a in both positions\nit doesn't matter because the sub\nproblem the substring in the middle\nis not a palindrome so therefore no more\nsubstrings\nexpanded from the middle of this\nposition to the left and right\nnone of those additional substrings are\ngoing to be palindromes\nso so far our count of palindromes is at\nfour i believe so\nnow let's go to the last position so we\nwant to expand\nfrom this middle position so we're gonna\ngo so initially we're gonna say okay\nthis itself is a palindrome so we can\nchange our count of palindromes to five\nwe try to expand left and we try to\nexpand right but again we go out of\nbounds to the right side\nso we're done so in total we found five\ndifferent\npalindromes but it turns out we actually\nmissed a couple\nwe missed this palindrome of length two\nand we missed this palindrome of length\ntwo\nhow is it that we missed palindromes and\nhow is it that they're both\nlength two notice how we were starting\nat each middle position\nso this was a length of one right as we\nadd the adjacent positions then we're\nincreasing the palindrome\nto length three and then if we added a\ncouple more we'd increase it to length\nfive so we're only\ngetting palindromes of odd length if we\nwant to get\npalindromes of even lengths we have to\nstart\nat every single even position so we'd\nhave to start\nat here and then you know this is a\nproblem this is a substring of length\ntwo and then we'd expand\nby one more so then we'd get a\npalindrome of length four and etcetera\netcetera just keep increasing it by two\nso this is how we're going to get\npalindromes of even length\nso when we do this we're gonna have our\nleft pointer initialized here and\nin this case the right pointer is\nactually just gonna be left\nplus one before we were doing it as left\nand right both starting at the same\nposition in this case\nleft right is going to be left plus one\nand so in this case we see\nthese characters are equal therefore\nthey are palindromes so we can increase\nour count from five\nto six we expand outwards left and right\nbut we see left is going to be out of\nbounds\nso then we can stop so next we're gonna\nbasically do the same thing for every\npair of adjacent characters right to\nfind even length palindromes so here\nleft and right are once again the same\nso\nwe're gonna get our total to be seven\nwhen we expand to the left and right\nwe see we have an a and we have a b\nthese characters are not the same so we\ncan't continue to expand and we don't\nincrement our result so now we have\nseven palindromes this is the last even\nlength sub string that we're going to\nstart at and\nthe left and right characters are\nclearly not the same so we don't\ncontinue to expand and we don't\nincrement our result so\nwe're done with everything here we get a\nresult of seven\nand the overall time complexity of doing\nit like this\nit's going to be big o of n because for\nlet's say the odd lengths\nuh palindromes we're starting at every\nsingle position\nand potentially expanding outwards all\nthe way to the end of the string so\nthat's going to be\nan end time operation so since we're\ndoing it for every single character in\nthe array it's going to be big o\nn times n right so that's that's\nbasically how we're doing the odd length\npalindromes and the\nthe same time complexity is going to be\ntrue for even length right we're\nbasically going through every pair\nof characters which there are you know\nbig o of n of them and then we're still\nexpanding outwards\nso that's also going to be big o of n\ntimes n now if you add these together\nwe're still going to get a overall time\ncomplexity of big o\nn squared so that's the overall time\ncomplexity\nin this solution and coding it up is\npretty easy so let's get into that\nso let's keep track of a single result\nvariable and it's initially going to be\nzero it's going to be the count\nof the palindromic substrings so we want\nto go through every single position\nin the string s and expand from it right\nthat's going to give us the\nodd length palindromes so we're going to\ninitialize our left\nand right pointers both to be set to i\nbecause these are odd length palindromes\nand while\nleft is inbound so while left is greater\nthan or equal to zero\nand right is inbound so right is less\nthan the length of the string\nand this the position at left in our\nstring is equal to the position\nat right in our string that means we\nfound a palindrome so let's\nincrement our result by one let's shift\nour our left pointer to the left\nand let's shift our right pointer to the\nright and we're going to continue to do\nthat\nwhile the pointers are in bounds and the\ncharacters are the same then we're going\nto continue to increment the number of\npalindromes so that's going to give us\nthe palindromes of odd length we can we\ndon't have to do a separate for loop for\nthe even length palindromes let's just\ndo the exact same thing we've done up\nabove here\nexcept in this case we're going to\ninitialize left to be\ni which is what we did before but we're\ngoing to initialize\nright to be i plus 1\nwhich is going to give us the even\nlength palindromes\nand once we've done that we can\nliterally just copy and paste this for\nloop up above\ndown here and then that'll calculate the\neven length palindromes\nand then once that is done we can go\nahead and return our result\nnow as you can see this solution works\nthat's the entire thing\nit's very efficient but maybe your\ninterviewer will want you to\nyou know this is copy and paste and\nsometimes they don't like copy and paste\nwe can\nbasically take these two and condense\nthem down into a single function\nso i'm just going to do that even though\ni'm sure you could probably figure out\nhow to do it in this case it's not too\nbad so i'm going to make a function\ncalled count palindromes and we'll pass\ninto\nthis the string s and the left\nand right pointers that we are\ninitializing\nand so basically what i'm going to do\nhere is take this and just copy and\npaste it into here\nright and so you can see that we're\ngiving this function the information it\nneeds we're giving it the string s we're\ngiving it pointers left and right\nlet's just give it a variable here let's\ndeclare it result\nis initially going to be 0 and then this\nfunction is just going to return result\nwhich is the number of palindromes it\ncan count\nstarting at these left and right\npointers so now we can\nyou know change this so here we're\ntrying to count the odd length\npalindrome so\ninstead of doing this for loop we can\njust say let's add to the result\nthe whatever this function returns so\ncount pally\npassing in the string s passing in the\nleft pointer\nand passing in the right pointer which\nwe just declared up above here\nand getting rid of this while loop we\ncan do the same thing so\nadd to result whatever this function\nreturns count pali\npassing in s passing in left\nand passing in right and if we really\nwant we can take\nleft and replace it with i and right and\nreplace it with i\nplus one so then we can get rid of these\ntwo lines\nand up above do the same thing so\nreplace left and right with both\ni and then get rid of this line so this\nis a pretty condensed\nversion of this function so with this\nlittle helper function that we have we\ncan cut down on\nthat repeated code that we were writing\nand basically get the same result\nsame efficiency same everything so i\nhope that this was helpful\nif it was please like and subscribe it\nsupports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Decode Ways",
        "NcLink": "decode-ways/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "A string consisting of uppercase english characters can be encoded to a number using the following mapping:\n\n```java\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nTo **decode** a message, digits must be grouped and then mapped back into letters using the reverse of the mapping above. There may be multiple ways to decode a message. For example, `\"1012\"` can be mapped into:\n\n* `\"JAB\"` with the grouping `(10 1 2)`\n* `\"JL\"` with the grouping `(10 12)`\n\nThe grouping `(1 01 2)` is invalid because `01` cannot be mapped into a letter since it contains a leading zero.\n\nGiven a string `s` containing only digits, return the number of ways to **decode** it. You can assume that the answer fits in a **32-bit** integer.\n\n**Example 1:**\n\n```java\nInput: s = \"12\"\n\nOutput: 2\n\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n```\n\n**Example 2:**\n\n```java\nInput: s = \"01\"\n\nOutput: 0\n```\n\nExplanation: \"01\" cannot be decoded because \"01\" cannot be mapped into a letter.\n\n**Constraints:**\n* `1 <= s.length <= 100`\n* `s` consists of digits\n",
        "Difficulty": "Medium",
        "Video": "6aEyTjOwlJU",
        "PythonSolution": "# Memoization solution \nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = {len(s): 1}\n\n        def dfs(i):\n            if i in dp:\n                return dp[i]\n            if s[i] == \"0\":\n                return 0\n\n            res = dfs(i + 1)\n            if i + 1 < len(s) and (\n                s[i] == \"1\" or s[i] == \"2\" and s[i + 1] in \"0123456\"\n            ):\n                res += dfs(i + 2)\n            dp[i] = res\n            return res\n\n        return dfs(0)\n\n# Dynamic Programming solution\n# class Solution:\n#     def numDecodings(self, s: str) -> int:\n#         dp = {len(s): 1}\n#         for i in range(len(s) - 1, -1, -1):\n#             if s[i] == \"0\":\n#                 dp[i] = 0\n#             else:\n#                 dp[i] = dp[i + 1]\n\n#             if i + 1 < len(s) and (\n#                 s[i] == \"1\" or s[i] == \"2\" and s[i + 1] in \"0123456\"\n#             ):\n#                 dp[i] += dp[i + 2]\n#         return dp[0]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem decode ways so\nwe're basically given a string of\nintegers and we want to know with that\nstring of integers how many different\nways can we take that string of integers\nand decode it into a string of\ncharacters and we're given a specific\nmapping so we have 26 characters and\neach integer maps to a different\ncharacter so we have an integer 1 2 all\nthe way to 26 and each of these integers\nmaps to a different character now we\ndon't actually need to build that string\nthat we are mapping to we just have to\ncount the number of different ways we\ncan decode it so down here in the\nexample you can see a string like 12 can\nbe decoded in two different ways one way\nto decode it is just one and two because\none maps to a\ntwo maps to b so that's one string but\nremember we can have double digit values\nso 12 actually maps to its own character\n12 itself maps to 11. so there are two\ndifferent ways that this string this\nstring of integers could be mapped to a\nstring of characters so we return two in\nthe output now as you can see it would\nbe very simple if we just had numbers\none through nine that map to characters\nright the problem comes from double\ndigits right from 10 10 a string like\nthis can be taken in two different ways\nright 1 0 or just 10 right so that's\nwhere the complexity is going to come\nfrom from a string like this we could\nhave two different decisions so we're\ngoing to be using a decision tree to\nkind of figure out all the possibilities\nwith this at least that's going to be\nthe brute force approach the only\nproblem is that there's going to be a\nfew different edge cases we have to\nworry about for example we could have a\nstring like this we could have a string\nlike zero\nsix right how what what exactly does\nthis map to well zero is not even in our\nour input right basically zero itself\ndoes not map to any character right six\ncould map to a character but zero does\nnot so if we ever get a zero you know a\nstring starting with zero that's invalid\nso we have to return zero in that case\nthis cannot be mapped to any uh this\ncannot be decoded in any way so we\nreturn zero okay let's try to figure out\nthe brute force approach to solving this\nproblem and in doing that we'll try to\nfigure out some of the edge cases that\nwe're gonna have to deal with suppose we\nhave a string like this one two one how\nmany different ways can this be decoded\nwell let's say we start at the beginning\nright we could take one by itself right\nthat's going to be some character right\nwe don't really care what it is but it's\ngoing to be some character now we could\nalso take the first two characters by\nthemselves 12 by itself right because\nthat's valid right so that's another\ndecision starting from here we could\ntake one or we could take 12. and by the\nway if this was a zero we definitely\ncould not take it then we'd have to just\nstop immediately right because we can't\nstart with a string starting at zero but\nif we had something like one zero right\na ten maybe then we can take it because\nit's okay if a zero comes after a one\nand so basically any any integer by\nitself right one two three four five any\ninteger by itself except for zero can be\ntaken right so basically we can create\nany string of one\nyou know one number from one through\nnine except zero right we're just not\nincluding zero it cannot be taken by\nitself but any from one through nine are\nokay right so what we're gonna see here\nis okay if we went down this path where\nwe chose a one then the next character\nwe're gonna be at is the two right of\ncourse two can be taken by itself right\nany number except for zero can be taken\nby itself it can be decoded in that way\nso when we're at this one or one when\nwe're at this position we can take two\nby itself or we can take 21 right 21 is\nalso some character i don't know what it\nis but remember we had values from 1\nthrough 26 right so having a 20 21 is\ncompletely fine that will decode to its\nown character right now of course if we\nhad something like a 27 over here then\nwe could not go down this path right\nthen we just would not go down this path\nbecause 27 does not map to any character\nright so we're kind of learning that you\nknow anything the integers have to be\nwithin 1 through 26 right and this 27 is\nnot okay and so down this path we reach\nthe end right we had a 1 and we had a 21\nright so there's no more characters to\nchoose from here so basically this was\none way that we could decode this input\nso when we reach the end we're gonna\ncount that as a one right that means we\nfound a single way to decode this input\nso this was a good base case where we\nreturn one and from here let's continue\nthis one so we left off at two then we\nget to one can one be taken by itself of\ncourse again it's not a zero so we can\ntake it by itself and so then we reach\nthe end of the string again so this is\nanother good base case one two one is a\nvalid way to decode this string so if we\nstarted with one you know over here we\ncould decode this in two different ways\nif we start with 12 how many ways can we\ndecode it well if we start with 12 then\nwe just have one character left the one\ncharacter\nso that can be decoded another way so\nthis is another good base case so\nbasically we saw that we have three\ndifferent ways that we can decode this\nstring now just to kind of add a couple\nvalues to the string what if we had\nsomething like 31 after it so then you\nknow let's say we left off over here you\nknow we can choose the three by itself\nright because any character except for\nzero can be taken by itself could we\ntake 31 we could not right the same\nreason we can't take 27 we can't take 31\nbecause it's it's greater than 26 right\nhow are we going to determine that in\nthe code you can do it a lot of\ndifferent ways what i'm just going to\nsay is we can only take double digit\nvalues if the the first digit starts\nwith a one\nbecause if it starts with a one then for\nthe second digit we can take anything\nfrom zero to nine right anything from\nzero to nine because then you know this\nthis this double digit value will either\nbe between 10 to 19 right and this value\nis less than 26 so that's perfectly fine\nbut if we start with a two digit\nif we start with a two digit then the\nsecond digit has to be between zero and\nsix because 26 is going to be less than\nor equal to 26 but if this became too\nlarge if it became a 27 that's not less\nthan or equal to 26 so we can't do that\nthat's how i'm going to decide it now\nwhat if the first digit started with a 3\nyou know or or a four or a five or\nanything that's never going to work\nbecause if we're going to have some\nother second digit here it's never going\nto be less than or equal to 26 right\nit just won't be so we're only gonna\nhave uh two decisions right we're only\ngonna have two branches if our first\ndigit is a one or if it is a two so this\nis kind of the brute force approach that\ni'm showing you but it might not be\nsuper efficient because we could have\ntwo decisions at every single every\nsingle position then our time complexity\nwould be something like 2 to the power\nof n where n is the length of the input\nstring so how can we kind of do a little\nbit better well notice the sub problem\nthat we're doing for example when we\ntake when we take just 1 by itself and\nconsider okay this is just going to be\none way that we decode it then we're\nasking okay how many different ways can\nwe decode the remaining of the string\nright that's the sub problem over here\nwe're asking how many different ways can\nwe decode 21 when we take the first two\ncharacters 12 then we're asking how many\ndifferent ways can we decode the string\none right so that's kind of how the sub\nproblem is going to work the sub problem\nis just going to be some portion of the\nstring you know for example you know\nstarting from\nfrom here all the way to the end of the\nstring how many ways can we decode this\nor how many ways can we decode this or\nhow many ways can we decode the entire\nthing right to to be able to solve this\nproblem how many ways can we decode this\nwe have to solve the sub problem how\nmany ways can we decode everything\nexcept the beginning and so basically\nyou know how many different ways can we\ncache it well we're going to have some\nindex i which could either be here or it\ncould be here or it could be here it's\njust going to designate starting from\nhere and taking the remaining portion of\nthe string how many ways can we decode\nit so basically the dimension of our\ncache is going to be n right so that's\nkind of that's also going to be the time\ncomplexity because every time we get to\na position i at most we have two\ndifferent decisions to make right so\nthat's going to be an o of one operation\nmaking those two decisions it's not like\nwe're gonna have to run through a loop\nor anything like that we're not gonna\nhave any loops and you'll see that when\ni write out the code if this is the size\nof our cache this is also going to be\nthe size of our time complexity and this\nis also going to be the size of our\nmemory this is because it's the size of\nthe cache now just so you know i think\nthis problem actually can be solved when\nwe write out the actual dynamic\nprogramming solution not using a cache\nnot doing it recursively but natural\ndynamic programming it can be solved\nwith of one memory because one thing you\nmight notice okay when we want to know\nhow many ways can we decode this entire\nstring well you know when we're at a\npointer i we can either take this\ncharacter by itself in which case then\nwe're going to shift i by one over here\nand ask you know what's the result of\nthis sub problem or if we take the first\ntwo characters 12 then we're gonna ask\nokay what's the result of this sub\nproblem right so we're either gonna so\nbasically you know it's a set dp of i\nwe're either gonna ask dp of i plus one\nor i plus two right those are the only\nones that we would need to look at right\nto compute a value like this we'd only\nneed to at most look at two different\npositions that come after it so you know\nwhen we have our dp cache we actually\ndon't need a full array to solve this\nproblem we could do it with two just two\nvariables similar to like a house robber\nproblem approach to dynamic programming\nor like a fibonacci sequence problem\nright but with that being said i think\nwe're ready to get into the code now now\nlet's write the code so the first way\ni'm going to show you the solution is\nbasically the recursive caching solution\nthe o of n time and memory solution so\nwe're going to initialize our cache we\nare going to put a single value in here\nbasically the entire length of the\nstring is going to map to one because if\nwe get an empty string we want to return\none in that case that's just kind of our\ngood base case right and then we're\nready to write out the recursive\nfunction i'm just going to call it dfs\npass in a single variable i basically i\nis the position that we're at in our\nstring s now one base case is if i is in\nour dp neither meaning either it's\nalready been cached or i is the last\nposition in the string in which case\nthat's our base case right and then we\nwould just return dp of i so that's you\nknow our good base case it's either been\ncached or you know it's just the end of\nthe string our bad base case is going to\nbe if it's not the end of the string\nthen we have to check what character it\nis if the character is starting with\nzero right if the string is starting\nwith zero then it's invalid right\nthere's no ways to decode a string that\nstarts with zero so then we have to\nreturn zero so that's like our bad base\ncase so so these are the two main base\ncases that we have but remember if it's\nnot zero that means it's between one\nthrough nine in which case uh we know we\ncan take this value as a single digit\nright so then the sub problem becomes\ndfs of i plus one right so that's what\nthe result is going to be we're just\ngoing to call dfs on i plus 1 because we\ntook the character at i as a single\ndigit right but we know that there are\nsome cases where we can also call i plus\n2. now what's a good way that we can\nwrite out that case well first\nlet's this is one of the ways you can do\nit i'm sure there are better ways but\nbasically if i plus 1 is less than the\nlength of the string basically if we do\nhave a second character that comes after\nthe current one right because we're\nlooking for a double digit character so\nif i plus one is in bounds and either\nthe character s of i starts with a one\nright s of i is a one because if it\nstarts with a one and there is a second\ndigit that means that definitely we can\ntake a double digit value right because\nanything between 10 all the way to 19 is\na double digit value right so if as long\nas it starts with one we know we can\nmake a double digit value or the other\ncase is basically i'm trying to figure\nout a good way to format this in a\nreadable way but basically or if s of i\nis equal to two right it starts with a\ntwo but if it does start with a two then\nthe second digit right s of i plus one\nmust be between zero and six right how\ncan we check that in python at least we\ncan check okay if this uh character\nhappens to be in this substring one two\nthree four five six right basically\nwe're saying is that second digit any\nvalue between zero through six at least\nthis is a clean ish way to write it so i\nencourage you to reread this uh\ncondition if you don't fully understand\nit but it's basically what i mentioned\nin the drawing explanation we're\nbasically checking if this double digit\nvalue is between 10 to 26 so then we can\nactually take it as a double digit value\nif we can do that then to our result\nwe're going to add\ndfs of i plus two right it makes sense\nwe're doing i plus two because this is a\ndouble digit value the sub problem\nbecomes i plus two and then once we're\ndone with that we can just go ahead and\nreturn the result but before we do don't\nforget to cache it so dp of i is going\nto be equal to result we're caching it\nand then we're going to return the\nresult and then uh you know when we\nactually want to return the result in\nthe outer function we can just return\ndfs of zero because we want to know how\nmany ways can we decode the string\nstarting at index zero and i ran it and\nas you can see it works and it's pretty\nefficient let me just copy and paste the\nactual dynamic programming solution i\ndon't want to waste too much time to\nwrite it out because it is very similar\nand i think if you can come up with the\nrecursive approach the logic for the\ndynamic programming solution is also\npretty simple we have the exact same\ncache the only thing is we're doing this\nbottom up so we're starting at the end\nof the string iterating in reverse order\nwe have the same base cases basically if\ns of i starts with zero then the dp is\ngoing to be zero right and basically you\nknow this is the same as these two lines\nof code where where we just return zero\nelse meaning you know that means it's a\ndigit between one through nine then we\ncan call dp of i plus one that's the\nsame as when down here when we call dfs\nof i plus 1. now this bottom part is the\nexact same as the if statement we had\ndown below right you can see the logic\nis the exact same you know the condition\nis the exact same only difference is\nhere we're saying dp of i plus two is\nadded down here instead of using dp of i\nplus two we actually called the\nrecursive function dfs so this the logic\nis definitely pretty similar and in this\nsolution at least the memory is o of n\nbut i do think that you can instead of\nhaving an entire cache or array or\nwhatever you're using you can just have\ntwo variables so i hope that this was\nhelpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Coin Change",
        "NcLink": "coin-change/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "You are given an integer array `coins` representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer `amount` representing a target amount of money.\n\nReturn the fewest number of coins that you need to make up the *exact* target amount. If it is impossible to make up the amount, return `-1`.\n\nYou may assume that you have an unlimited number of each coin.\n\n**Example 1:**\n\n```java\nInput: coins = [1,5,10], amount = 12\n\nOutput: 3\n```\n\nExplanation: 12 = 10 + 1 + 1. Note that we do not have to use every kind coin available.\n\n**Example 2:**\n\n```java\nInput: coins = [2], amount = 3\n\nOutput: -1\n```\n\nExplanation: The amount of 3 cannot be made up with coins of 2.\n\n**Example 3:**\n\n```java\nInput: coins = [1], amount = 0\n\nOutput: 0\n```\n\nExplanation: Choosing 0 coins is a valid way to make up 0.\n\n**Constraints:**\n* `1 <= coins.length <= 10`\n* `1 <= coins[i] <= 2^31 - 1`\n* `0 <= amount <= 10000`\n",
        "Difficulty": "Medium",
        "Video": "H9bfqozjoqs",
        "PythonSolution": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n\n        for a in range(1, amount + 1):\n            for c in coins:\n                if a - c >= 0:\n                    dp[a] = min(dp[a], 1 + dp[a - c])\n        return dp[amount] if dp[amount] != amount + 1 else -1\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today today\nlet's solve another\nclassic dynamic programming problem coin\nchange\nand we get a pretty simple uh\ndescription so we're given a list of\ncoins\nof different values and we're also given\na total amount\nof money that we want to sum up to but\nwe\nwant to use the fewest number of coins\npossible to make up or to sum up to that\namount\nand it's possible that that amount of\nmoney cannot be made up\nwith any combination of the coins that\nwe have\nand then we want to return negative one\nif that's the case and\nluckily for us we're actually given an\ninfinite number of each coin so\nin the first example we have coins of\nvalue 1\n2 and 5 and we have infinite quantities\nof these coins the amount that we want\nto sum up to\nis 11 and basically you know just look\nat this\nwhat's the fewest number of coins we\ncould do well\nof course we want to use a five because\nit's the biggest one we can use another\nfive\nand then we just need a one left if we\nwant to sum up to 11.\nso in this case you can see we only\nneeded three coins\nthese this is the fewest number of coins\nwe needed so we can return\nthree in the second example we have a\ncoin of value two\nbut we want to sum up to three we can\ntry two plus two but we know that's\nfour so we went over three so there's no\nway to\npossibly sum up to three so we return\nnegative one there's no possible\nsolution\nso your first idea might be can we just\nbe\ngreedy is the problem that easy can we\njust\nbe greedy and let's look at this example\nso let's say these are our coins one\nthree\nfour five and we want to sum up to seven\nso when i say greedy i mean okay we\nwanna sum up to seven let's just start\nat the biggest coin we have\nso let's start at five so now let's look\nat the biggest coin again\nfive if we add a five here we know we're\ngoing over\nwe're going over the total amount seven\nright so we don't add another five\nwell let's look at the four well we know\nfive plus 4 is\nalso going to be more than 7 5 plus\n3 is going to be more than 7. okay but\nwe found a 1. luckily we have a 1. so\nlet's add 1 to it now we're at\n6. so let's add a second one\nnow we got to the sum seven so we\nbasically went down\nfrom the biggest smallest coin values\nright that's what i mean when i say\ngreedy let's pick the biggest one\npossible\nfirst so notice that this took us\nthree coin values right so our result in\nthis case would be three but\nis that the minimum amount of coins the\nanswer is\nno because you know just looking at it\nwe can tell\nwe got a three and we have a\nfour three plus four is seven\nthat means the minimum amount of coins\nis actually\ntwo so this is a counter example we\ncannot be\ngreedy if we want to solve it so the\nnext thing you might try is like a brute\nforce solution right so to do the brute\nforce solution we need to implement\nsome kind of depth first search or\nbacktracking solution\nright so let's look at the same example\none three four\nfive and amount sum to seven so what\nwould a backtracking solution\neven look like for this problem well\nit's gonna be brute force right so\nso we have four coin values so that\nmeans in our decision tree we have four\npossible choices\nwe can choose a one we can choose a\nthree\nwe can choose a four or we can choose a\nfive\nin this case the remaining amount would\nbe six\nbecause seven minus one is six in this\ncase the remaining amount that we have\nto compute\nwould be four because we're taking seven\nminus three which is the coin that we\nchose\nso we get four as the remaining amount\nright\nin this case we would have a three and\nin this case we would have a remaining\namount of\ntwo so since none of these are zero\nonce we get to zero we know that that\nwe've computed\nthe total amount that we want but right\nnow we have to continue going right we\nhave to continue doing the brute force\napproach\nlet's start at this side right now so we\nstill have\nfour coins right we have unlimited\nquantity so we can choose\nthe coin one we can choose a three we\ncan choose a four\nor we can choose a five if we choose a\none we'll have a remaining amount of\none if we choose a three we're going to\nget a\nnegative one what does that tell us that\ntells us\nif we chose a five coin and we chose a\nthree coin\nthen we get to a negative value that\nmeans\nfive plus three cannot be the amount\nso we don't have to keep searching here\nwe can stop right we got to a negative\nvalue\nif we keep adding values to it it's just\ngoing to become more and more\nnegative right and you can probably\nnotice that\nsince these values are even greater 2\nminus 4 is going to be negative 2\n2 minus 5 is going to be negative 3. so\nwe can't go down these paths either we\ndon't have to\nsearch them anymore and so now here\nwe're gonna see\nokay we can choose a one coin of course\nwe can choose a\nthree four and five but we can see from\nhere\nthat that's not gonna work that's gonna\nlead us to a negative\nvalue anyway if we choose a one\nover here then we know we're going to\nfinally get to a zero\nso this is what we want right we took a\nfive\nfrom up here we took a one from over\nhere\nand we took a third one right so then if\nwe\ncount how many coins we chose\ndown this path we know we get three\ncoins right\nand we get to a zero so of course we\ndon't have to keep searching anymore\nso we found one possible way where we\ncan\nsum up to the amount seven we know it\nhas three coins which\nyou know from the previous example we\nknow that that's not the minimum amount\nof coins\nbut we found an algorithm that at least\ntells us\na possible solution so we can kind of\nkeep track of that the minimum coins\nwe can set to three so now i'm gonna\nshow you what happens when we go down\nthis tree path\neven though we know that the solution is\nactually three plus four which is two\ncoins\nwhich either of these is gonna get us to\nthe correct solution i'm gonna show you\nwhat happens when we go down\nthis one anyway so we can choose a coin\none\nthree four or five so if we go down this\npath\nwe will have a remaining amount of five\nhere we'll have a remaining amount of\nthree\nhere we'll have a remaining amount of\ntwo here we'll have a remaining amount\nof 1. do you kind of see how we're\ntaking\nthe original problem which is 7\nand then breaking it down into sub\nproblems\nlike 6 and then breaking it down even\nfurther into five and not only that we\nhave sub problems yes\nbut do you also see that these sub\nproblems are repeating themselves here\nwe have a remaining amount of\none here we also have a remaining amount\nof one\nso do we even have to compute this path\nbecause we already know if we have an\namount one\nit takes only a single coin\nfor us to be able to reduce it to the\namount\nzero which is what we're looking for so\nsince\nthis sub problem repeats i don't have to\ncompute it\ni can just borrow from over here\nso in that case we see the same thing\nhappened though\nwe use a coin one and we get zero and we\nsee that okay it took\nthree coins for us to get to zero right\nwe took a one\na five and another one from over here so\nbasically we got the same thing that\nhappened\nover here just in a different order and\njust to make this a little less messy\ni'm just gonna tell you that none of\nthese are going to lead us to the\noptimal solution\nso now let's look at this case we have a\nremaining amount of four\nhow many coins does it take for us to\nget an amount for well let's brute force\nit let's check\nevery possible combination here we'll\nget a\none here we'll get the value we're\nlooking for zero that's great but let's\njust look at this last one\nwith five we'll get a negative one\nmeaning we can stop\nsearching so this is awesome we got a\nzero and let's count how many coins did\nit take us to\nget to this zero we took one four and we\ntook a\nthree so this path is only\ntwo coins long we see our minimum is\ncurrently\nthree but we can actually replace this\nnow with a\ntwo because two is the minimum number of\ncoins\nneeded to total to amount seven\nso we know this is the correct answer\nbut let's just see what happens with the\nremaining stuff\nso first let me just look at this one we\nsee we actually\nalready solved this sub problem over\nhere\nso we don't really need to solve it\nagain we know it takes\none coin for us to go from one to zero\nand what about this three okay well we\ncan do\nthe same thing right one three four\nfive and i'll just tell you from here\nwe're not going to find the optimal\nsolution going from\nfour to three and more that's going to\nobviously be more\nthan the current minimum of coins that\nwe have which is two right now\nso this is not going to lead us to the\ncorrect solution\nbut you see that once we compute\nthis stuff then we have one last\nsubtree over here right this original\nthree\nbut once we already solved the sub\nproblems of this\ndo we really have to solve the sub\nproblems here\nno if we store it in memory if we have\nlike a cache\nor you can call it dp we do not have to\nrepeat these sub\nproblems so the way i just solved this\nwas called top down or top down\nmemoization\nbecause we're doing it recursively but\nyou can actually solve this\nwith a true dynamic programming solution\nwhich\nis bottom up and it means exactly what\nit says so\nbottom up basically instead of\nsolving the original problem where the\namount is seven we\nsolve it in reverse order we start at\nthe smallest one which is\nzero right this zero over here so we\nwanna know what's the minimum number of\ncoins\nwe can call it dp of zero so\nfor amount equals zero what's the\nminimum number of coins\nfor us to sum to zero\nwell we know it just takes zero coins\nright\nwhat about if we wanna know what's the\nminimum number of coins\nfor summing to one well we can\nlook at our coins we got a one a three a\nfour and a five\nthese will all cause it to be greater\nthan one but we just want a\none so we can take just this meaning it\nonly takes us\none coin to sum to 1. and then we can\njust repeat that process right so for\na dp of 2 so we want how many coins\ndoes it take for us to sum to 2 well\nwe got 4 coins right these 3 will cause\nit to be greater than two so we don't\nuse those\nbut what about this one okay we get a\none\nso it takes one coin to sum to one but\nthat's something we already\nknew so if we want to compute dp\nof two we can take one\nplus dp of one\nbecause we know these three coins are\ngoing to be too\nbig but we have a one over here\nthat's value one and we also know\nthat that's not enough right two minus\none\nstill leaves us with a remaining amount\nof one but we just computed that\nup here we know for us to get the\nminimum number of coins\nto get a value one it only takes\none coin so that means that if we want\nto get amount two it takes at least two\ncoins\nand let's say we repeat this process for\nall values for all amounts from\nfrom all the way starting at zero all\nthe way\nto seven over here so i computed it from\nall the way from zero to six but the\nlast one we really\nreally want is amount equals seven so\nlet's compute that\ndp of seven how do we get it\nwell we still kind of have to check\nevery single coin so\nwhat happens if we get coin one\nthen we are com then we take the result\nof one meaning that's how many coins we\nuse not the value one\nbecause we needed one coin with a value\none and now we have a remaining amount\nof\nsix right dp of six so how many coins\ndid it take\nfor us to compute dp of six well we\nalready computed that it took\ntwo so we get one plus two\nequals three so that's one possible\nsolution but is it the minimal solution\nwell let's look at if we use the coin\nvalue three over here well it takes us\none coin so we take one plus\ndp of four because that's the remaining\namount we have to use\nif we take a coin value of three and\nlucky luckily we already computed dp\nof four it is one so then we get one\nplus\none equals two and we know that\nthis is the real result that we want\nbut even before we know that we would\nrepeat this\nprocess so technically if we do the\nbottom-up\ndynamic programming solution we are\ngoing to repeat this for the remaining\ntwo coins so for four we would get one\nso we'd have one plus dp of three\nbecause four\nminor because seven minus four would\nleave us with a remaining amount of\nthree\nand in that case we know dp of three is\none so we would have the total of two\nagain so we see that there are actually\ntwo solutions\nand we know we have one last coin that\nwe technically have to check\ncoin five so we'd use one coin for value\nfive\nand then the remaining amount we'd wanna\ncompute is dp of 2\nand we know that dp of 2 is value 2 so\nthis would result in a\n3 which is not what we want right so\nfrom these 4 values that we computed\nwe want to take the minimum which we\nknow is 2\nso we can return 2 in this case\nso that took us forever but luckily the\ncode is a lot shorter so just like we\nshowed i'm gonna have a dp array and\ni'm gonna initialize this to be\nlength of amount plus one because\nwe are going from zero\nall the way to amount and the default\nvalue i'm gonna give each uh element in\nthis array is amount\nplus one or you can do like\ninfinity or whatever the max in is like\nmath.max integer or whatever\nin your language but amount plus one is\nbasically a max value\nanyway and we know that the base case\nfor this\nis a dp of zero meaning if we want to\ncompute\namount zero that it only takes zero\ncoins\nand now we're going to start computing\nevery value in dp\nso for every amount a in\nrange and we're going to do this in\nreverse order not\nor rather bottom up so we're gonna go\nfrom one\nall the way to the amount and we\ntechnically\nare still doing it in a brute force way\nso we\nare gonna go through every coin so for\ncoin\nin our list of coins so we're trying to\ncompute\nthis a amount so we're gonna take\na and subtract the current coin that\nwe're looking at\nif this is non-negative\nso if it's greater than or equal to zero\nthat means we can\nkind of continue searching right so this\nmeans\nwe possibly found a solution for our dp\nso for this amount a we're going to set\nit to the minimum\nof itself and 1\nplus dp of a\nminus c so this 1 comes\nfrom this current coin that we're using\nc and dp of\na minus c comes from for example\nlet's say our coin value was four\nand our amount that we're trying to\ncompute a is\nseven basically we're saying dp of\nseven is equal to one\nplus dp of\nthree because seven minus four\nis three so we're saying that this is a\npossible solution\nand actually that's the only thing that\nwe have to do\nthis is basically it this is like what's\ncalled the recurrence relation\nand so now the only thing we have to do\nis return what we're looking for so dp\nof amount so this is what we have to\nreturn but\nwe remember one last edge case if we\ncould not compute the amount\nmeaning if so we can only return this\nif if the value that's stored\nis not the default value so if it's\nnot equal to amount plus one right which\nwas the default value that we\ngave it so we'll return this if it's not\nthe default value\notherwise we're gonna have to return\nnegative one meaning we could not\ncompute this amount with the given coins\nso this solution does work and even\nthough\nit's pretty efficient the time\ncomplexity is actually\nbig o the amount that we're given\nmultiplied the number of\ncoins that we're given and the memory\ncomplexity is\nbig o amount because we see we have a dp\narray that we're having a potential\nvalue for every single\namount so i hope this was helpful if you\nenjoyed\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Maximum Product Subarray",
        "NcLink": "maximum-product-subarray/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "Given an integer array `nums`, find a **subarray** that has the largest product within the array and return it.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\nYou can assume the output will fit into a **32-bit** integer.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,-3,4]\n\nOutput: 4\n```\n\n**Example 2:**\n\n```java\nInput: nums = [-2,-1]\n\nOutput: 2\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-10 <= nums[i] <= 10`\n",
        "Difficulty": "Medium",
        "Video": "lXVy6YWFcRM",
        "PythonSolution": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        res = nums[0]\n        curMin, curMax = 1, 1\n\n        for n in nums:\n            tmp = curMax * n\n            curMax = max(n * curMax, n * curMin, n)\n            curMin = min(tmp, n * curMin, n)\n            res = max(res, curMax)\n        return res\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today let's look at\nmaximum product subarray and this is\nactually a\ndynamic programming problem and i'm\ngoing to show you how to\nsolve this problem easily so we're given\nan integer array of numbers\nand we want to find the contiguous\nsubarray\nthat contains at least num one number\nand\nhas the largest product so in this case\nwe have a 2 a 3 a negative 2 and a 4\nand the largest continuous product we\ncan make is 2 and 3 because\n2 times 3 is 6. that\nis the largest product we can't really\nmake it bigger because there's a\nnegative 2 if we multiply this by\nnegative 2 it's going to be\nnegative 12 that's not bigger than\n6. so what's like your first idea how to\nsolve this problem maybe\nbrute force right is there a brute force\nsolution to this\nwell we want to find a subarray right so\nwhy don't we just try\nevery single subarray so let's say all\nsub arrays starting at two we got one\nsub array\ntwo sub arrays three four right\nand for each of these let's just\ncalculate the product right like the\nfirst one is two the next one is two\ntimes three\nthe next one is two times three times\nnegative two\nthe last one is two times three times\nnegative two\ntimes four and we end up saying that so\nfar the biggest\nis this but we're technically not done\nyet all of these sub-arrays contain\ntwo so now let's look at all sub-arrays\ncontaining three so we got\none right just three then we got three\ntimes negative two then we got three\ntimes negative two\ntimes 4 and basically we repeat this\nprocess\nnow you can tell that this is not super\nefficient\nthe time complexity is big o n\nsquared for each of these numbers we're\ngoing to end up having\nn sub arrays and we see that the total\nnumber of elements we have is also\nn right it's n elements in the array so\nwe're going to get\nn times n is n squared so my question is\ncan we do better and how can we do\nbetter maybe there's some\npatterns to this problem that we can use\nto our advantage to find a better\nsolution than\nn squared so let's look at one example\ndo you notice anything about this\nsubarray well\nall elements are positive so what does\nthat end up\ndoing like this is all positive so we\ngot a one\nokay and next we want to check this sub\narray okay multiply it by two\nwe want to go even farther check the\nthree\nokay multiply it by three and what if we\nkept having positive elements four\nfive multiply by four multiply by five\ndo you notice something up until this\npoint our product is going to be a one\nup until this point it's going to be a\ntwo up until this point it's going to be\na six\nup until this point it's going to be a\n24 up until this point is going to be\n120.\nif we have positive numbers no matter\nwhat\nhappens they're going to keep increasing\nright\nso this is the simple case if we get all\npositive numbers\nthen our product is always going to be\nincreasing\nso now let's actually look at the\nopposite scenario what if we had\nall negative numbers because all\npositives is easy you just multiply\nall of them and you get the max product\nbut with negative numbers it's a lot\nmore tricky\nso let's look at the first number so up\nuntil here the max product is just\nnegative one and then we we add\na second element a negative two and then\nwhat do we get we get\nnegative one times negative two and\nwe know that the product of that is\ntwo right positive two now the last sub\narray we check\nfrom all the way from negative one to\nnegative\nthree so we introduce one more value a\nnegative\nthree and now if we multiply all three\nof these\nnumbers together we see that our product\nactually got\nsmaller now it's negative six and what's\ngoing to happen\nif we had a another element over here\nwhat if we had a negative four\nthen we multiply by negative 4\nand now we see that our product is going\nto be\n24. so you see that when you have\nnegatives consecutively the sign is\nalternating so when you want the maximum\nit makes it kind of tricky to have\nnegatives but we also see that\neven though we got a negative six over\nhere\nthere's actually a subarray that has a\nbetter solution if you just take\nthese two numbers negative two times\nnegative three we get a\npositive six so why did we get a\nnegative six over here\nhow can we find the real maximum which\nis\npositive six so even though we're\nlooking for the max\nproduct sub array we're actually also\ngoing to need to keep track of the\nminimum as well and i'm going to show\nyou why\nso first do you at least agree with me\nthat\nif we want to find the max product array\nsub array of this of the of the entire\nthing\nit might be helpful for us to at least\nsolve the sub\nproblem which is the max product\nsubarray of just the first two elements\nfirst and then use that to get\nthe entire one okay that makes sense\nwe know that the max product subarray of\nthis\nis two now if we had a positive three\nover here\nthen we would say okay if i can get the\nmax sub array of the first two elements\nand multiply it by\nthree i'm gonna get two times three it\nworks when these are positive numbers\nbut we actually have a negative 3 over\nhere\nso i'm gonna say get the max product sub\narray which is positive 2\nbut let's also get the the minimum\nproduct sub array of these two as well\nand what do we know about the minimum\nwhat's the\nminimum product sub array of these two\nit's going to be\nnegative two so i'm going to keep track\nof both positive and negative\nso we have a positive 2 and a negative\n2.\nwe keep the max and we keep\nthe minimum so now when we want to\ncompute the max product subarray\nwhen we include this 3 then\nwe can compute that we can compute that\nusing\nboth of these values so we know that\nwhen we take the maximum 2 we get\nnegative\n3 times 2 which is negative 6\nand we know when we take the minimum we\nget we get\nnegative 3 times negative\n2 and that gives us a result\nof positive six so we know the maximum\nis positive six and the minimum is\nnegative six so we take positive six\nand put it over here and we can take\nnegative six\nand put it over here and hypothetically\nmaybe we get another element\nand this time and this time whether it's\npositive\nor negative right so in this case let's\nsay it's negative 4\nwe will be able to find the solution\nbecause the\nminimum or rather we're looking for the\nmax product sub array\nand we know if we take negative four\nmultiply it by\nthe current minimum which is a negative\nnumber\nnegative six we will end up getting 24\nwhich is what we're looking for but if\nyou reverse it what if we had a\npositive 4 here instead well in that\ncase we can say okay\npositive 4 multiplied by our\nmaximum right our maximum which is\npositive 6. so 4 times positive 6\nwe get 24. we still get it right so this\nif we maintain the maximum and the\nminimum\nwe have all the information we need as\nwe continue to add more\nelements to our array so now let's just\nlook at\none edge case so we're talking about\npositive numbers and negative numbers\nbut we know that one last\nedge case exists the dreaded zero value\nright so what if we had a zero value and\nthen maybe some other numbers three\nfive our zero is gonna kind of\nkill us right it's gonna kill our streak\nlike look what's going to happen\nto our min and max if we take 6\nmultiplied by 0\nwe get 0 if we take negative 6\nmultiplied by 0 we get 0 again\nright x times 0 equals zero\nand then if we try taking this zero and\nmaking it a product of maybe three and\nfive\nit's going to continue being zero right\nbecause any number times\nzero is going to be zero so i'm gonna\ndecide to handle this\nin a different way so anytime we get a\nzero value\ni'm going to reset our max to zero or\nrather to one and i'm also going to\nreset\nour minimum to 1\nand the reason i'm gonna do this is\nbecause i don't want to\nkill our product right i'm just going to\nsay that\nzeros are ignored we don't really care\nabout zeros and the reason i'm setting\nthis to\none is because then when we start\nintroducing new values like\n3 it's just going to be 1 times 3 right\nwhich is\ngoing to end up being 3 so 1 is like a\nneutral value for us\nso those are the main things we want to\nmaintain the max\nand minimum of our product and we want\nto handle the\nzero case by resetting everything\nto a neutral value like one okay so now\nlet's code it out\ni'm going to say our result is initially\njust going to be set to the max value\ncontained in nums because we at least\nhave to set it to some value\nwe can't just initialize it to 0 because\nwhat if we had an array with just one\nnumber and it happened to be negative\none right\nin that case this is our max product\nwhich is\neven less than zero so zero is not a\ngood\ndefault case and i'm going to maintain\nthe current\nmin and the current max and i'm gonna\ninitialize these\nto one e because we know one is like a\nneutral value\nand then we're just gonna start\niterating through\nevery single number in our input array\nwe know that if we ever get to a zero\nwe do not want to handle that we don't\nwant to add that\nas a part of our product so we don't\nwant to mess up our current min and max\nby multiplying it by zero\nbecause then it's going to stay zero\nforever so instead what we're going to\ndo\nis we're going to reset our min and\nour max to one each\nand we're just going to continue to the\nnext iteration of the loop\nif this doesn't execute that's when\nwe're going to actually\ndo our code and recompute the current\nmin\nand current max so our current max how\nare we actually going to compute it well\nin python it's really convenient for us\nbecause we can say okay the current max\ncould potentially be\nthe the new number that we just found\nmultiplied by the current max\nif the current max happens to be\npositive and n is positive\nit could also end up being the\nthe input value n multiplied by the\ncurrent\nminimum right what if n is negative and\ncurrent minimum is negative then\nthis could end up being a positive\nnumber which could be our current\nmaximum\nthe third option is n itself\nbecause what if we had an input such as\nnegative one\nand eight well in that case the current\nmin and max is going to end up being\nnegative 1 and either of those numbers\nmultiplied by\n8 which could be our hypothetical n\nvalue\nit's going to end up being negative 8 so\n8 it's by itself\nwhich is n is the maximum and\nthe fun thing about python is that look\nwe just put\nthree values into our max function some\nlanguages don't allow for this but\nthere's obviously ways to get around it\nand so now that we have our current max\nwe can\ndo the exact same thing for our current\nmin\nso min so we can actually take all three\nof these values\ncopy and paste them and then put them in\nthe min because\nwe want whatever the min containing n is\nand it could be anything it could be\nn times current max n times current min\nor\nn itself so an example would be negative\none\nand negative eight if we multiply\nthese together we get a positive eight\nbut we don't want that we want\nthe minimum which could be just negative\neight by itself which would be\nthis third case but this is where i\nalways end up with a bug\nso do you see how we actually recomputed\nthe current max but we want to use the\nold current max so i'm actually going to\nhave a temporary variable\nup here temp and before we end up\nreassigning current max i'm just going\nto compute\ncurrent max times n and then save it in\ntemp so then we can use it\ndown here so we're going to replace this\nwith temp\nso this way we're always keeping track\nof what the current max is\nand what the current minimum is and so\nwe can\nupdate our result after each iteration\nof the loop\nand we want the max product so we can\ntake the maximum\nof result itself because result could\nstill be the max\ncurrent max and current minimum so\nthat's actually it like we've done it\nand we can\nnow just return what our result and so\nthis is actually not\nthat much code and it's not even like\nwhen you\nlook at it it's hard to recognize that\nit's even a dynamic programming problem\nbecause it's not like we're storing an\nentire array like dp\nand then having an array we're just\nmaintaining two values\ncurrent min and current max and what\nthey tell us\nis for let's say for example\nwe were at this value n then we're going\nto have\nthe current maximum of this subarray\nand the current minimum product of this\nsubarray\nand then when our n gets shifted to the\nnext value\nwe're going to have the current maximum\nof these three\nand the current minimum product of these\nthree and then by the time\nour n value is out of bounds we will\nhave the current max\nand the current minimum of the entire\narray computed\nso it runs efficiently and that's\nbecause we're\nonly iterating through the input so\ninstead of being n squared\nthe time complexity is just big o of n\nthe memory complexity is big o of one\nbecause we are not using an array we're\njust using\nuh single variables i hope this was\nhelpful\nif you enjoyed please like and subscribe\nit supports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Word Break",
        "NcLink": "word-break/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of dictionary words.\n\nYou are allowed to reuse words in the dictionary an unlimited number of times. You may assume all dictionary words are unique.\n\n**Example 1:**\n\n```java\nInput: s = \"neetcode\", wordDict = [\"neet\",\"code\"]\n\nOutput: true\n```\n\nExplanation: Return true because \"neetcode\" can be split into \"neet\" and \"code\".\n\n**Example 2:**\n\n```java\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\",\"ape\"]\n\nOutput: true\n```\n\nExplanation: Return true because \"applepenapple\" can be split into \"apple\", \"pen\" and \"apple\". Notice that we can reuse words and also not use all the words.\n\n**Example 3:**\n\n```java\nInput: s = \"catsincars\", wordDict = [\"cats\",\"cat\",\"sin\",\"in\",\"car\"]\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= s.length <= 200`\n* `1 <= wordDict.length <= 100`\n* `1 <= wordDict[i].length <= 20`\n* `s` and `wordDict[i]` consist of only lowercase English letters.\n",
        "Difficulty": "Medium",
        "Video": "Sx9NNgInc3A",
        "PythonSolution": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n\n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n\n        return dp[0]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem\nword break so we're given an input\nstring\nand a dictionary of strings called word\ndict and we want to return true\nif and only if s can be broken\nup into separate strings such that every\nseparate string in s is also\nfound inside of our word dict and we\nare allowed to use words from the word\ndict multiple times\nso for example let's say we're given an\ninput string leak code\nand we're given a word dictionary of\nwords called\nleat and code so obviously in this case\nwe could split this string right into\nseparate strings lee\nright break it down in this middle\nposition and then the sep\nthe second string would be code right so\nclearly this can be broken up into words\nthat are found in the word dictionary so\ntherefore we are going to return true\nnow what if we took code outside of our\nword dictionary\nwell then in that case this portion is a\nword right but we have no matching word\nin our dictionary for the remainder code\nso in that case we would have to return\nfalse and you know let's say we had an\ninput string instead\ncalled lea and li again right so two\nleads in a row would\nwould we return true yes because we're\nallowed to use this word from our\ndictionary multiple times right clearly\nit matches this\nand it also matches the first portion\nnow let's start off with the brute force\napproach\nhow would we even structure a brute\nforce solution well there's actually\ntwo ways to do it but one of them\nhappens to be more efficient and i'll\ntell you why\nso one thing we could try for an input\nstring like this one we could check okay\nthe first character\nright basically the first prefix of the\nstring l\nby itself right is this a word that's\nfound in our word dictionary it's not\nright\nso let's try maybe the first two\ncharacters together are a word right\nthat's not it either\nwe would try the first three right\nbasically we would try every single\nportion from the beginning until we\nfound a\nmatching word that does exist in our\nword dictionary\nand we know that we are gonna find one\nlike this right the first\nfour characters of the string are\na word right so once we found that what\nare we gonna do\nclearly we have a sub problem right we\nfound a matching word for this portion\nbut now we want to know can we break up\nthe rest of this string\nwith words from our dictionary so that's\nkind of how uh we're going to\ndo it right that's what's going to be\nthe sub problem basically so instead of\nstarting from the first position in the\nstring we would start\nat this position in the string and try\nto word break it\nnow in this approach what we're going to\nbasically be doing potentially is from\nevery single starting position right\nwe're going to check every prefix right\nso\nfrom the first starting position we\nmight also get if you know this happened\nto be a word then we would\nstart at this position and then do the\nsame thing for this right every\nword starting here so basically we're\ngoing to try every word how many\ndifferent words are we going to end up\ntrying we're going to try\nlet's say n is the size of our string n\nand we're going to try basically from\nevery single starting position to the\nend\nso that's going to basically be n times\nn now\nwe could also do it a different way\ninstead of trying\nevery single possible you know prefix\nlet's\njust check every word in our word\ndictionary and see if that matches\nfor example this first word is four\ncharacters\nlong right so what we're going to do is\nwe're going to check the first\nfour characters in our string does this\nmatch this word clearly it does right\nso what does that tell us that tells us\nnow you know we have the same sub\nproblem as before\nwe're going to start from these this\nnext position now right and check\nand from here we're basically going to\nbe doing the same thing right so we're\ngoing to check\nis elite basically you know the first\nfour characters does that match lee\nthis does not match lee right so now\nlet's check the next word in our word\ndictionary and check does that match\nuh the characters over here it does\nright we found\ncode so this is basically another way to\ndo this problem instead of checking\nevery single possible prefix right of\nany length what we're going to be doing\nis we're going to be checking every\nsingle word in our word\ndictionary as the prefix so instead of\nbeing\no of n times n we're going to be doing o\nof n\nbecause potentially we are going to be\ngoing through every single starting\nposition but we're going to be\nmultiplying\nby the number of words in our word\ndictionary which is let's call it\nm and the reason why we're going to be\ndoing this approach\nis because it's going to be a little bit\nmore efficient and the reason is they\nthey tell us below in the problem\nstatement that the max size of word\ndictionary\nis going to be smaller than the max size\nof the string so this is overall\nprobably going to be more efficient\nnow this isn't going to be the overall\ntime complexity we are actually going to\nmultiply it by another\nn because when we're checking for\nexample you know this brief\nthis string when we're checking does\nthat match the first four characters\nhere\nthat's also a end time operation because\nit could you know potentially be the\nsize of the input string s\nso this is basically going to be the\noverall time complexity n squared\nmultiplied by m so i'm just going to\nbasically show you the same formula that\ni usually do i'm going to give you a\nquick illustration of what the decision\ntree would look like then we're going to\nunderstand how we could\ncache that to eliminate repeated work\nand then by understanding that we're\ngoing to go to the optimal\ndynamic programming solution the bottom\nup approach and then we're going to code\nthat up usually the dp solution\nis a lot less code than caching so we're\ngoing to be looking at our input string\nneat code\nso i think that's a little bit better\nthan neat code wouldn't you say so\nwhat the decision tree is gonna be is\nwe're gonna start at the first position\nright for example i\nequals zero we're gonna be keeping track\nof whatever index we're at right because\nwe know that if we can find a word\nyou know that matches neat for example\nthen the sub problem is gonna be\nyou know finding words that can match\nthe remainder of the string for example\nif we did that\nour i instead of starting at index zero\nwould basically be starting at\nindex four right so that's kind of what\nthis that's what the sub problem is\ngoing to be\nso really we're only going to have one\nvariable that we're keeping track of\nin this backtracking solution and so\nremember we mentioned\nwe're not going to be doing it like this\nwe're not going to check every single\nprefix\nwe're going to have decisions in our\ndecision tree based on the number of\nwords that are in the word dictionary so\nwe're going to have a decision for neat\nwe're going to have a decision for elite\nand we're going to have a decision for\ncode now what we're going to notice is\nwhen we try elite on here\nright basically is four characters\ntherefore we're going to check the first\nfour characters of here\ncompare it does that match lee it does\nnot right we're just one character off\nthat first one so basically that means\nwe're not going to continue down this\npath now let's try code does code match\nthe first four characters definitely not\nso we're not even gonna\ncontinue down this path either of course\nneat\ndoes match this so we are gonna continue\ndown here\nwe're gonna do three more decisions\nbasically one for\nevery single word in our word dictionary\nnow one thing though\nis when we are starting here we know we\nmatch the first four characters so by\nthis point we are now going to be\nat i equals four meaning we're going to\nbe looking at this\npart of the string so as we can see\nchecking neat that's four characters\nlong so let's check\nfour characters starting from here\nthat's not matching of course so then\nwe're not going to continue here lee\ndoes that match over here nope we're not\ncontinue down this path\ncode does code match this portion yes it\nexactly matches\nso therefore we are going to update our\ni pointer again since we matched four\nmore characters\nwe're just gonna take i and add four to\nit now\nso now i is going to be at eight\nand eight happens to be that exact\nposition\nright after the end of the string right\nthis is where index\n8 is therefore we basically know that we\nwere able to\nmatch the entire string therefore we\nknow we can return true right once we\nfind a single true\nthat means we just terminate we end the\nfunction we can just call\nwe can just return true and the function\nis done now from this example it might\nnot be super intuitive why we would use\na cache but let's say we had another\npath in our decision tree that led us to\nfor example\nindex i equals five right and let's say\nwe had we used all three decisions\nin that path and let's say none of them\nyielded\nthe correct result meaning we were not\nable to word break this string\nfrom starting at index five so then we\nwould return false from this\npath right and we would want to cache\nthat we would want to say\nthat let's say dp of index five right we\nwould want to set that to\nfalse basically what we're saying is if\nwe ever\nreached this same function call if we\never tried it again maybe you know this\ndecision tree could be really big maybe\nthere would be another path\nfrom you know somewhere over here where\nwe tried index i equals 5 again\nin that case we would want to return\nfalse immediately because we saw\nfrom here there was no possible way to\nbreak it down therefore we don't need to\nredo\nall of that work if we you know try the\nsame exact thing\nso we discovered that our base case is\ngoing to be dp\nof 8 because a is the length of the\nstring basically is going to be\ntrue right if we can ever get to that\nlast index we're going to return true\nso what we're going to do is now do the\nbottom up approach right we're going to\ngo through every single\nindex in reverse order right so we would\nstart at the last character which is\nposition\nseven right and see can we word break\nthe remainder\nof this string you know and we would try\nevery single word right like neat does\nneat match this string well they're not\neven the same size right if we tried to\nmatch\nneat on four characters starting from\nhere we would go\nout of bounds of this string right\nthere's not enough character so of\ncourse this is going to be\nfalse right it wouldn't match neat it\nwouldn't match the other two\nwords in our dictionary either and\nthat's obviously going to be true for dp\nof 6\ndp of 5 as well so both of these are\nalso going to be\nfalse right basically if we started from\n6 or if we started from 5\nwe would not be able to match any of the\nwords in our dictionary\nbut now if we start here index 4 so\nwe're now trying to figure out dp of 4\nis that true\nwell yes it is right it doesn't match\nneat it doesn't match elite but it does\nmatch\ncode so we are going to set dp of 4\nequal to true\nso now let's keep doing it until we get\nto the first character so now we're\ngoing to be trying from dp\nof 3 right so starting from this\ncharacter are we going to be able to\nmatch any of these well none of these\nwords even start with a t\nso of course we're not going to be able\nto match so dp of 3 is going to be false\nwhat's dp of 2 gonna be it's also going\nto be false because\nif we were to start at this character\nthis e\nwould we be able to match any of the\nwords in our word dictionary of course\nwe would not and\nwhat about this position if we started\nhere would we be able to match any of\nthe words\nin our word dictionary again not so dpf3\ndpf2\nand dp of 1 are going to be false\nmeaning we cannot word break this string\nif we start at any of these first any of\nthese three positions basically\nnow we're finally at the result that we\nwere looking for dp\nof zero is dp of zero gonna be true\nwell let's take a look so we're starting\nat\nthe first character in the string can we\nmatch any of the strings we can't match\nlead we can't match code but\nneat it does match this portion of the\nstring\nstarting at index zero so then the\nquestion becomes\nwe're asking can we break the entire\nstring starting at\nindex zero so now since we did match the\nfirst\nfour characters we want to know were we\nable to match the remainder of the\nstring right so we want to know\nstarting from here were we able to match\nthis string to words in our word\ndictionary now this is why we computed\nthis bottom up right because\nthis is index 4 right notice how we\nalready computed\nindex 4 over here right it's the one\nthat's highlighted in green\nbecause it was true we were able to do\nit so\nbasically the equation that we would use\nfor this is going to be\ndp of 0 plus\nthe length of the word that we were able\nto match with\nand we know the length of the word\nlength of the word\nneat is going to be 4 so basically we\ncan replace this length of the word with\nfour so zero plus four is just dp of\nfour we know that was true\nso we can set dp of zero equal to true\nso this is basically uh the result right\nthis is how we're going to compute\nit and this is what we're going to\nassign dp of 0 to and once we've done\nthat we've computed the result\nwe know we can return true for the\noverall function\nso with that being said let's jump into\nthe code so our cache is going to be\nlet's say a one-dimensional array right\nbecause for every position i\nin the string s we are going to have a\nvalue so we're going to initialize this\nto false it's going to be the length of\nthe string s\nplus 1 for our base case and we are\ngoing to initialize our base case we\nknow that it's the last position\nbasically the position\nthe position out of bounds of the string\nso the length of\ns and we know that's going to be set to\ntrue that's our base case\nso now we're going to go through every\nposition i in\nthe length of the string starting at the\nlast index and working our way to the\nbeginning so that's why i'm using the\ndecrementer of negative one\nand we're going to go up until the\nbeginning of the string\nand for each position i we want to try\nevery single word in our word dictionary\nand see if the word\nmatches this portion so first we have to\nsee if\nstarting at position i the string s even\nhas enough\ncharacters for w to be compared to it so\nwhat we're going to do is we're going to\ncheck\ni plus the length of w and we want to\nknow is it less than or\nequal to the length of s if that's the\ncase\nthen that means there are enough\ncharacters in\ns for us to compare them so that's what\nexactly what we're going to do we're\ngoing\nif this is true then let's compare so we\nwant to know if that's true\nand if s starting at index i\ngoing up until i plus the length\nof w so basically let's say\nw was three characters then we want to\nknow the first three characters in\ns starting at index i are they exactly\nequal\nif they are equal then we wanna know\nokay so dp of\ni is going to be set to dp\nof i plus the length of w right that was\nthe relationship we got\ni plus the length of whatever the word\nhappens to be\nnow if we got a single a way to word\nbreak this\nstarting at index i that means we can\nbasically stop this loop right we don't\nhave to look at every single word in the\ndictionary if we found at least\none way we were able to word break it\nthen we're gonna stop so basically if dp\nof i\nis true then we can break out of this\nfor loop and then move on to the next\nindex so we're going to start basically\nat the last index\nkeep going until we've gotten to index 0\nand then once we've done that we know we\ncan actually return that\nand that's going to be stored in dp of\nzero so believe it or not\nthat is the entire code about 10 lines i\nthink and\nthis is a pretty efficient solution as\nyou can see so i hope that this was\nhelpful\nif it was please like and subscribe it\nsupports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Longest Increasing Subsequence",
        "NcLink": "longest-increasing-subsequence/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "Given an integer array `nums`, return the *length* of the longest strictly *increasing* subsequence.\n\nA **subsequence** is a sequence that can be derived from the given sequence by deleting some or no elements  without changing the relative order of the remaining characters.\n\n* For example, `\"cat\"` is a subsequence of `\"crabt\"`.\n\n**Example 1:**\n\n```java\nInput: nums = [9,1,4,2,3,3,7]\n\nOutput: 4\n```\n\nExplanation: The longest increasing subsequence is [1,2,3,7], which has a length of 4.\n\n**Example 2:**\n\n```java\nInput: nums = [0,3,1,3,2,3]\n\nOutput: 4\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "cjWnW0hdF1Y",
        "PythonSolution": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        LIS = [1] * len(nums)\n\n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] < nums[j]:\n                    LIS[i] = max(LIS[i], 1 + LIS[j])\n        return max(LIS)\n",
        "Transcript": "everyone welcome back let's solve\nanother problem today\nlongest increasing subsequence and this\nis another tricky dynamic programming\nproblem\nand i'm going to show you how to go from\nthe recursive solution\nto the dynamic programming solution so\nwe're given\nan array of numbers and we just want to\nreturn the length of the longest\nincreasing subsequence\nand if you don't know what a subsequence\nis it's basically\nlike let's say this is our input array\nwe're basically taking a\nsubarray but that subarray does not have\nto be\ncontiguous so like we have from here so\nuh subsequence is three six two seven\nbasically we took this subarray\nand we removed one two from it and we\nremoved a one from it and now it's three\nsix two seven but you notice about this\nsubsequence\nit's not an increasing order right we\nhave six and then we have two that's not\nincreasing order so this is not a\nincreasing subsequence so in this\nexample we're given\nabout nine elements and we want the\nlongest increasing subsequence\nwhich we see is this and so how did we\nget that subsequence well you go from 2\nall the way to 101 but you notice\nthat unfortunately this is not an\nincreasing\norder we have a 5 and then we get a 3\nright after so we actually have two\nchoices\nif we remove the three we have an\nincreasing\nsubsequence if we remove the five we\nalso have an increasing subsequence but\nwe just care about the length\nwhich in this case is four so we return\nfour\nso the first idea you might have is\nbrute force\nusing depth first search so let's say\nthat\nthis is our input array so we have six\nelements for if we wanna know the brute\nforce meaning we want to generate\nevery possible subsequence we have a\nchoice for each value right so for the\nfirst\n0 we have a choice are we going to\ninclude this\n0 in our subsequence or are we not going\nto include it in our subsequence\nso in reality for each value we have\ntwo choices now when we get to the next\nvalue we\nalso have a choice are we including it\nor not\nso again we have two choices if we want\nto generate\nevery possible subsequence so we do that\nfor every single value\nand then we see that there are actually\n2 to the power of\nn possible subsequences where n is the\nnumber of values\ngiven in our input array so already you\ncan see the time complexity is not going\nto be\ngreat but can we take this brute force\napproach and then somehow modify it\nto get a better solution like n squared\nso let's look at another example and\nthis time we're going to do depth first\nsearch\nwith caching and we're going to see how\nthat improves our time complexity so\nwe have an example of four elements so\nit's kind of obvious that this is our\nlongest increasing subsequence so the\nresult is going to be\nthree three elements but how can we do\nthis with an algorithm that's efficient\nwell let's start out with the brute\nforce approach\nlet's check all subsequences starting at\nindex 0 and then repeat that starting at\nindex\none starting at index two and starting\nat index\nthree right so these are the indices so\nwe take\none decision to start at index\nzero we take one decision to start at\nindex one\none decision to start at index two and\none decision to start at\nindex three so in these cases\nthese are going to be the subsequences\nwe have so far so we know index zero has\nvalue 1\nindex 1 has value 2 index 2 has value\n4 index 3 has value 3.\nso now let's go along the first path so\nindex 0 so we know if we start at index\nzero\nwe have three values that come after it\nso we can try\nall three of these possible decisions\nso we can go along index one index\ntwo and index three and we see that\nall three are possibly valid because all\nthree of these values are greater than\none\nso we can continue these subsequences so\nwe know index one has value two\nindex two has value four so we can add a\nfour\nindex three has value three so we can\nadd a\nthree to our subsequence that originally\nwas just\none so now we took index\nzero and index one so for here we only\nhave\ntwo indices that come after these two\nvalues\nso let's continue our decisions we see\nthat both\nfour and three are greater than the\nthe last value in our subsequence which\nis two\nso we can choose both of these decisions\nso if we take index 2 then we can add a\n4 to our subsequence if we take index 3\nwe can add a\n3 to our subsequence so now let's\ncontinue here we have\nthree values so far in our subsequence\nand there's one\nindex that comes after two index three\nit has a value three\nso can we add a three to our subsequence\nwe'll get one two four and then 3\nbut this 3 is not greater\nthan the last value in our subsequence\nso we technically\ncannot make this decision so we cannot\ncontinue\nto increase the subsequence anymore\nso we can mark this as reaching its\nlimit we cannot continue it anymore what\nabout\nthis one well it stopped at index three\nwhich was over here\nso are there any elements that come\nafter it now\nno there's not any elements so this\nsubsequence\nhas also reached its limit so we cannot\nincrease it\nanymore but so now let's focus on this\ncaching part\nwhat kind of repeated work have we\neliminated well let's just\ndo this out of order instead of doing\nthese first let me show you what happens\nif we try to extend the three now\nwe try to get another element right we\nstarted at index\nthree but we know that no values come\nafter index three so this one cannot be\ncontinued\nbut what do we know about index three\nif we start at index three and we want\nthe longest increasing\nsubsequence we just get a single three\nso that tells us that lis starting at\nindex three is one we don't need to\nrepeat this work\nand isn't that what we just learned over\nhere\neven though this subsequence is length\n3 we are talking about starting at the 3\nand we noticed we could add a 3 to it\nright\nthis was the element that we added but\nas soon as we added that three we\ncould not add we could not increase this\nsubsequence anymore right that's what\nthis\nx tells us we were only able to add\none element if we start at index three\nand that's exactly what this two told us\nas well if we start at index two\nwe can add a four but this three that\ncomes after it cannot be\nadded we cannot include that and there\naren't any more elements to add\nso as soon as we finish this and we\nfound this x meaning we could not go any\nlower\nwe knew we knew that the\nlongest increasing subsequence starting\nat index\ntwo is also one so\ntherefore if we start at index two\nwe cannot go any lower we cannot\ncontinue this\nand we don't even have to attempt to do\nthat and what about\nthis branch so if we chose if we\nstarted at index one we would start with\nthe\nsubsequence of two right that's what\nthis tells us\nand so now i'm gonna repeat i'm gonna\ndo some more stuff right i'm gonna\nchoose the next indices\ntwo and three but wait a minute do i\nactually have to do that\nbecause look over here\nwe started with index one and we already\ndid that so when we started with index\none\nwe saw we had two choices a two or a\nthree index right we could choose this\nor we could choose that we saw both of\nthem\nended right we could not continue either\nof them\nso if you want the longest increasing\nsubsequence\nthat starts at index 1 over here\nno matter what you choose the\nsubsequence\nis gonna be length two either way right\nbecause\nif we start with a two then we can add a\nfour\nor we can add a three but we cannot add\nboth of them so we can mark the longest\nincreasing subsequence\nstarting at index one to be length\ntwo so we actually don't even have to\ngo down this path once we already\ngo down here because it's just gonna be\nrepeated work\nand we also see for these two trees that\nwe have not finished yet\nonce we add a four the longest\nincreasing\nsubsequence at index two which is where\nfour is at is going to be 1 so we cannot\ncontinue this\nanymore similarly once we add a 3\nwe know no values come after it the\nlongest increasing substituent starting\nat index 3 is just\n1 we cannot increase this anymore so\nwhen we finally in our depth first\nsearch get back to the root\nwe're gonna see that the longest path is\none of these right either that or of\ncourse you could\ngo down this direction but either way\nthe longest\nincreasing subsequence starting at index\nzero\nis going to be three and so when you\nlook\nat these four right because these are\nour subsequences these are the longest\nsubsequences starting at each index the\ngreatest\none is three and so therefore the result\nis three but now if you actually wanna\ndo the dynamic\nprogramming solution you might notice\nhow we're doing this recursively we're\nkind of starting at the last\nindex right three and then working our\nway\nup backwards to zero so then going back\nhere so can we use that to do dynamic\nprogramming\nso now let me show you the dynamic\nprogramming solution and it's actually\neasier than you might think so we're\ngoing to work we're going to start at\nthe last index 3 and then\nwork our way backward so we know this is\nkind of the base case right\nno values come after it so the longest\nincreasing subsequence we could make\nfrom here is just going to be\nlength one anyway so we can say the lis\nstarting at index three is just one\nthat's the max\nlength now how do we get the longest\nincreasing subsequence\nstarting at index two which is\njust one shifted to the left well\none possibility is just four by itself\nright so that's one possibility it could\njust\nbe one or it could be\none plus the longest increasing\nsubsequence starting at position three\nand what this means is if we take\nboth of these right because lis of three\nis just\none right so three by itself but we're\nonly\nallowed to do this if the value\nnums at index 2 which we know is 4\nis less than nums at index\n3 which we know is 3. is this\ntrue this is not true so we are\nnot allowed to do this so normally we\nwould take the max of these two values\nbut we know that the condition\nto take the max of this does not satisfy\nso we only have one choice\none so the lis of this is going to be\none i'll put it over\nhere like in the corner so again we're\ngonna work our way backwards so let's\nget the longest increasing subsequence\none index back at index one so we're\ngoing to do the similar\nthing that we just did so we know we\ncould take a subsequence\ntwo by itself right that's one choice\none is a choice length one we also have\na choice\none plus the longest increasing\nsubsequence starting at four\nand we're allowed to do this because two\nis less than four so it\nis increasing the subsequence is\nincreasing\nso another choice is one plus\nlis of two and another choice is\nl i s starting at index three because\ntwo\nis less than three right two is less\nthan three so the subsequence is in\nincreasing order so one plus l i s\nof three now we know that this is two\nand this is two so it doesn't really\nmatter which one we do\nthe lis of one is\ngoing to be equal to two regardless\nso now we want the longest increasing\nsubsequence starting at index zero and\nwe're just going to repeat what we just\ndid so\nwe could take one by itself which is\njust one\nor we could take one add it with the\nlongest increasing subsequence starting\nat two\nor this longest increasing substitution\nstarting at\nat this index or this index so we know\nwe're going to get\n1 plus 1 from here we're going to get 1\nplus 1\nfrom here and we're going to get 1 plus\n2 from here and we're allowed to do all\nof these because you notice\n2 is greater than 1 4 is greater than 1\nand 3 is greater than 1 so they're an\nincrease\nso they are an increasing order so then\nwe know that the longest increasing\nsubsequence of this\nis going to be equal to 3 which is what\nwe want\nso this is a much better solution the\ndynamic programming solution is much\nbetter than brute force\nbecause the time complexity is o of n\nsquared but why is it o of n squared\nwell you see we're working backwards we\nstart at three\nand then we check every position\nafterwards which is not\ntoo bad right so then we iterate through\nbasically every value here\nwhen we start at four we have to look at\nevery value that comes\nafter it there's only one value that's\ngood for us\nso we iterate through these two values\nwhen we start at two we have to check\nthese subsequences starting at these two\nvalues\nso then we have to end up iterating\nthrough two\nand every value that comes after and we\ndo the same\nthing for one so we iterate through one\nand\nevery value that comes after so you can\ntell by looking at this\nthis pattern is similar to an n squared\npattern so now let's finally write the\ncode so we know we're going to do this\ndynamic programming style so let's have\na\ncache or a list it's initially going to\nbe set to\n1 every value is going to be set to 1\nit's going to be the length of the input\narray that we're given\nso every longest increasing subsequence\nstarting at every value or every index\nis initially just set to one we're going\nto try to find what the max is\nso we want to iterate through every\nindex\nin the range of our input array\nand we want to do it in reverse order so\nthat's what i'm going to do in python\nit if you're not familiar with python\nthis might look a little weird but\nbasically what i'm doing is starting at\nthe last index\nand then going all the way to zero and\njust like i showed in the example\nwe're going to start at index i like\nthis could be i and then we want to\niterate through\nevery subsequence that came after it so\ni'm going to have another nested loop\nfor j\nin range so starting at i plus 1\nand then going to the end of the input\narray\nand before we can update lis\nwe want to know is the value\nat i actually less than the value\nat j because j comes after it if we want\nthis to be an\nincreasing subsequence this condition\nhas to\nbe true and only then are we allowed\nto update the longest increasing\nsubsequence\nat index i and we can set it to the max\nof itself and or the max\nof 1 plus the lis\nstarting at j because we know for sure\nj is going to be in increasing order\nwith i\nand literally that is it we made sure to\nevaluate that it's an increasing order\nwe did it backwards we made sure to\ncache the repeated work\nwhat do we have left to do well we want\nto return what the max is how can we do\nthat well\nin python you can just take the max of a\nlist so whatever\nuh the long whatever the greatest value\nis in here\nis going to be returned and they're\nactually so this is\no of n squared and there actually is a\nbetter solution\nbig o of n log n but i really\ndoubt your interviewer is going to\nexpect you to get this on your own\nwithout a hint\nif they do i would personally just walk\nout of the room\nbut i hope this was helpful if you\nenjoyed please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Partition Equal Subset Sum",
        "NcLink": "partition-equal-subset-sum/",
        "Pattern": "1-D Dynamic Programming",
        "Description": "You are given an array of positive integers `nums`.\n    \nReturn `true` if you can partition the array into two subsets, `subset1` and `subset2` where `sum(subset1) == sum(subset2)`. Otherwise, return `false`.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3,4]\n\nOutput: true\n```\n\nExplanation: The array can be partitioned as `[1, 4]` and `[2, 3]`.\n\n**Example 2:**\n\n```java\nInput: nums = [1,2,3,4,5]\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 50`\n",
        "Difficulty": "Medium",
        "Video": "IsvocB5BJhw",
        "PythonSolution": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        if sum(nums) % 2:\n            return False\n\n        dp = set()\n        dp.add(0)\n        target = sum(nums) // 2\n\n        for i in range(len(nums) - 1, -1, -1):\n            nextDP = set()\n            for t in dp:\n                if (t + nums[i]) == target:\n                    return True\n                nextDP.add(t + nums[i])\n                nextDP.add(t)\n            dp = nextDP\n        return False\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve partition\nequal subset sum so this is a pretty\ninteresting problem so we're given a\nnon-empty array of nums containing\nonly positive integers we want to know\nif the array can be partitioned into two\ndifferent subsets such that the sum of\neach of the subsets\nis exactly equal notice how that's\nbasically saying\nif we can take one subset of the array\nwhich is going to equal\nhalf of the sum of the entire array\nright because\nif we partition it into two equal halves\nright let's say the total sum was 22\nif we partitioned it into equal halves\nthen each of the halves would be exactly\n11 right\naka one of the partitions is going to be\nhalf that of the total sum\nso for example in this problem the sum\nis exactly 22. so we want to know can we\nget a partition or can we get a\nsubset of this array basically we can\nchoose\nany of the values and can we get a\nsubset such that it sums\nup to 11. in this case the answer is yes\nit's true because we can take you know\nthe single 11 that sums up to 11 right\nand obviously if there's one way to get\nhalf of the\nsum of the total array then the\nremaining elements are going to\nbasically equal 11 as well right so you\ncan see that 1\nplus 5 plus another 5 is going to be\nequal to 11 right basically these are\nthe two partitions\nso as with many problems let's just try\nto figure out what the brute force\nsolution would be so basically let's\nstart at the first\nelement right and for every single\nelement that we visit we have two\nchoices right we can either include this\nin our sum\nor we cannot include it in our sum and\nwe want to basically determine\nevery single sum that we can make with\nany single subset from this given array\nand we want to know does that sum\never equal 11 because 11 is our target\nright if we sum this\nup divide it by 2 we get 11. so we want\nto know if that's\npossible so let's brute force it right\nso the first choice we can either choose\na\n1 or choose nothing right basically\nskipping that so either our sum will be\n1 or our sum will be zero because\ninitially our sum\nis zero so the next value is five right\nso basically for each of these\nuh paths we can choose five or not\nchoose five if we do choose five here\nwe'll get a six if we don't we'll\nstay at one otherwise on this path if we\nchoose the five we'll get a five\nbecause we started at zero so if we skip\nthe five we'll stay at zero\nnext we get a we get an 11 so basically\ncontinuing that right so i don't know if\ni'm going to have enough room for this\nokay\n11 plus 6 is going to give us 17 on this\npath\nclearly we went over so we would\nprobably not want to continue down this\npath\nbut over here if we skip the 11 we'll\nget a 6 still\nif we take 11 here we're going to get 12\nif\nwe skip it we'll get one and etc etc\nwe'll get 16 here skip we'll get five\nif we take 11 here we'll get 11 skip get\nzero but clearly we found our target\nthat we were looking for we\nwe don't really have to continue anymore\nright so basically we can skip this last\nelement\nwe found our target we're gonna return\ntrue and we're gonna go\nback up so as you can tell since every\nlevel of our decision tree we're having\ntwo choices right and what's the height\nof this decision tree gonna be basically\nfor every single element\nright we're going to have a decision so\nlet's say the input size of the array is\nn so basically our time complexity is\ngoing to be 2 to the power of\nn if we do a brute force method so let's\ngo back to the first step\nbasically the first element that we were\nat and let's see if there's any repeated\nwork that we can cut down on\nso initially our index or our eye\npointer is at the first element right\nso basically we're at the beginning of\nthe array we can go down the entire\narray we can choose any elements from\nhere but and we want to know can we\nsum up to the target 11. now once we\ntake our two paths right\nwe're basically going to say i is now\ngoing to be shifted to the next element\nfive right\nand we had two choices we could have\neither chosen the one or we could have\nskipped the one\nbut clearly now we have a new sub\nproblem\nwe already have a one so from the\nperspective of this decision\nwe're not looking for a target of 11\nanymore right we're looking for a target\nof 10. we're looking for a target of 10\nand not\nonly that but our initially our eye\npointer was here meaning we could have\nwe could have done the entire array but\nnow our eye pointer is over here\nso we're not even looking at the entire\narray anymore we're looking at a\nsubarray basically the remaining\nelements of the array\nminus this first one so if we were to\ncache this\nour new sub problem would be target of\n10 that we're trying to solve and i\nis not at zero anymore index is at\none similarly over here we can see since\nwe're at zero the target is still 11\nright we are trying to sum up\nall the way to 11 but the index that\nwe're starting at\nin this case as well is one now right\nbecause\nwe basically said we were skipping this\nelement down this path right so now we\nwant to know is there a way\nthat we can sum up to 11 basically just\nfrom this subarray right\nand every time we made a decision we\nwould continue to update these values\ntarget and i right so\nas you can see what are the dimensions\nof our cache going to be if these are\nthe two\nvariables of our cache what are the\ndimensions going to be well clearly\nclearly i could be\nany value in the input array so the\ndimensions of our cache are going to be\nn where basically n is the size of the\ninput array right because i could be at\nany value from zero to\nn minus one and what about the target\nwell the target is basically the sum of\nthe entire array divided by two right so\nbasically\nsum of nums divided by two\nor you know the constants usually don't\nmatter in time complexity so basically\nthis is going to be\nthe big o time complexity now this is\ntechnically\nbetter than 2 to the power of n\nbecause they do give us a pretty good\nlimitation like the values in this input\narray are usually going to be i think\nless than or equal to 200. now if they\nwere really big like if this could have\nbeen a million\nclearly that would not be very efficient\nbecause our sum could have potentially\nbeen\nsuper large but this is basically the\nbest way that we can optimize it\nso basically if we did a depth-first\nsearch solution with a\ncache like a backtracking solution with\na cache this would be the time\ncomplexity and this would also be the\nmemory complexity because this would be\nthe dimensions of our cache\nbut it's actually possible to improve\nthe memory complexity\na little bit with dynamic programming\nand\nthe time complexity is mainly going to\nstay the same as this but the overall\nmemory complexity can be improved and\nlet me show you why that's the case\nso suppose we were starting at this\nfirst value right and let's say we\nalready knew all the possible sums that\nany given subset from the remainder of\nthis\narray like basically what we could do is\nsay\nfor every single one of those sums we we\nwould add\none to it right so for every t let's\njust call it t for now\nin that subarray we're going to be\nbasically be checking two things right\neither\nif t is equal to target right like some\npossible sum from this sub rate totaled\nup to the target then we would return\ntrue right\nevery possible sum that we could create\nfrom any subset in this subarray\nand if it total basically that that's\nwhat t would be and if that t\nhappened to be equal to the target\ntarget 11 then we would return true\nright\nor if we took every single sum we could\ncreate from the subarray\nand added one to it basically one\nbecause that's the only value\nleft over here right one plus t\nequal to target if that was also equal\nto 11\nthen we would return true as well right\nso basically this is the recurrence\nrelation that i'm trying to show you\nand so this is basically the idea we're\ngonna use for the bottom up solution so\ninstead of starting here we're gonna\nwork our way backwards so we're gonna\nstart here so\nand this is very simple right so how\nmany possible sums\ncould we create from this sub array well\nthere's only one value here right we\neither take it or we don't so\nthe amount of sums we can create is\ngoing to be zero\nor five and what i'm gonna do is i'm\ngonna be storing these values in a\nset so let's say this is our set so so\nfar we have zero and\nfive next what i'm gonna do is i'm gonna\ni'm gonna go to 11\nright we're going to work our way\nbackwards i'm going to start at 11\nand i'm going to iterate through every\nsingle one of these and i'm basically\ngoing to\nadd 11 to them right so for 0 let's add\n11 to it that's going to be 11 i'm going\nto add that to our set\nlet's look at 5 that's going to be 11.\ni'm going to add that\n11 plus 5 is 16. i'm going to add that\nto our set right clearly we can see we\nalready\nfound the target value so we could\nreturn but let's just keep going to see\nall the possible targets we could create\nwith this input array\nso we we were done visiting 11. now\nlet's go to five right so basically\nwe're going to iterate through every\nsingle one of these\nadd 5 to them and then see if that's a\nnew value if it's already a value that\nexists\nthen we wouldn't do anything like in\nthis case we can see see 5\nplus 0 is just going to be five right so\ni'm not going to add a second\nfive to this because we already have a\nfive this is a set it's gonna\nwant only unique values so we're not\ngonna end up adding a second five\nbut if we add five plus five that's\ngonna be a ten if we add five plus 11\nthat's going to be a 16. we already have\na 16. if we add 5 plus 16 that's going\nto be 21.\nand basically i'm going to do the exact\nsame thing with one so\nyou know we would add a 1 here we'd add\na 6\n5 plus 1 is six one plus eleven\nis twelve one plus sixteen is\nseventeen and one plus ten is eleven we\nalready have\neleven one plus twenty one is twenty two\nso basically\nthis is the entire list of sums we could\npossibly create\nfrom our given input array as long as\nthis\nset contains 11 we return true if it\ndoesn't contain 11\nthat means it's impossible to sum up to\nthis target\nso we would return false now i think in\npractice the size of the set is probably\ngoing to be about the same size as the\ncache that we would use in the\nmemoization\ntechnique but technically the size of\nthis\nthis cache is going to be limited to the\nsize of the target which is basically\nuh limited by the sum of the nums input\narray so this is going to be the memory\ncomplexity in this case\ntechnically the time complexity is going\nto be the same\nbut i think this this solution is\ndefinitely easier to code\nit's just a little bit tricky to\nactually arrive to the solution\ni think going through the brute force to\nthe caching\nto the dynamic programming solution is\nthe best thought process to arrive\nto this optimal solution so now let's\njump into the code\nso one thing i didn't mention is that if\nthe sum\nof our input array is odd then it's\nobviously going to be impossible to\npartition it into an equal half right so\nbasically if the sum\nof this modded by two is one then we're\ngoing to return\nfalse also i'm going to have a dp set as\ni mentioned because this is going to be\nthe most optimal solution\nto the dp set i'm just going to add a\nbase case of zero basically\nwe're guaranteed that we can add up to a\nsum of zero right if we just don't\nchoose any elements from the input array\nnums\nand the target that we're trying to sum\nup to is of course the sum\nof nums divided by two\nso with that being said let's iterate\nthrough every single value\nin nums in reverse order you could do it\nin regular order but i'm just gonna do\nreverse order because i'm used to it so\nso we're gonna go through every target\nor every total value that's already\nin our dp set for every t and dp\nand what we want to do is 2dp add\na value right we basically want to add t\nplus nums of i right because i is the\ncurrent index that we're at\nwe want to add it for every single t\nthat's already in dp we want to add\nnumbers of i to it right but we can't\nupdate this dp set while we're iterating\nthrough it so what i'm going to do is\ncreate a new dp\nset basically next dp it's going to be\nthe dp set that we iterate through over\nthe\nyou know the next time we execute the\nloop so instead of adding to dp what i'm\ngoing to do is add to next\ndp but we also don't want to lose all\nthe original values that are\nin dp so what i'm also going to do is to\nnext\ndp i'm going to add the t value\nas well whatever the t value happened to\nbe now if i really wanted to i could\nprobably skip this line if i just took\ndp and\ncloned it and then set that to next dp\nbut\nyou know whatever you prefer basically\nwhat i'm doing is taking\ni'm setting next dp i'm taking every\nvalue in dp adding it to next dp\nand also adding this t plus nums of i\nto nextdp and once this loop is done\nexecuting we're basically going to\nupdate\nreassign dp to the next dp\nset and this is going to keep executing\nit's going to keep executing i is going\nto start at the end it's gonna\nit's gonna go all the way to zero so\nthen we're gonna have gone through every\nsingle one\nand at the end we can return true if and\nonly if the target happens to exist\nin dp else we have to return false\nand yeah so this is the entire code and\nit runs\nfairly efficiently so this is about 50\nnow i think it would probably be a\nlittle bit faster if you know the first\ntime we find the target value if we just\nreturned it\nactually let me just you know you can\nprobably stop watching at this point\nthat was the entire solution but let me\njust see if this actually does speed it\nup so let's say\nif i happens to be equal to the target\nwe can immediately return true\nlet me see if that does speed it up okay\nso that actually did so it's about\ntwice as fast i think the old one was 14\nmilliseconds so this is 600 milliseconds\nso this might be an optimization that\nyour interviewer would like\nbut the overall time complexity is still\nthe same but i hope that this was\nhelpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Unique Paths",
        "NcLink": "count-paths/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "There is an `m x n` grid where you are allowed to move either down or to the right at any point in time.\n\nGiven the two integers `m` and `n`, return the number of possible unique paths that can be taken from the top-left corner of the grid (`grid[0][0]`) to the bottom-right corner (`grid[m - 1][n - 1]`).\n\nYou may assume the output will fit in a **32-bit** integer.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7eddce4e-2fc4-4c3a-bb0f-9d1060243500/public)\n\n```java\nInput: m = 3, n = 6\n\nOutput: 21\n```\n\n**Example 2:**\n\n```java\nInput: m = 3, n = 3\n\nOutput: 6\n```\n\n**Constraints:**\n* `1 <= m, n <= 100`\n",
        "Difficulty": "Medium",
        "Video": "IlEsdxuD4lY",
        "PythonSolution": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n\n        for i in range(m - 1):\n            newRow = [1] * n\n            for j in range(n - 2, -1, -1):\n                newRow[j] = newRow[j + 1] + row[j]\n            row = newRow\n        return row[0]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today\nso today let's look at unique paths so\nthis is a dynamic programming problem\nand it's a relatively straightforward\none compared to a lot of more difficult\ndynamic programming problems\nwe are given a m by n grid\nand so the top left in the grid is\nalways going to be our start value and\nso\nfrom our start value it's like a game we\nhave two choices no matter what position\nwe're at we\ncan only move right or we can move\ndown those are our only choices we can't\ngo diagonal\nwe can't go up and we definitely can't\ngo left so our\ngoal is to reach the end position or the\nfinished\nposition that's always going to be the\nbottom right so we start at the top\nleft but we want to go to the bottom\nright and the only question\nis how many unique paths are there to\nget to the end position\nso at first this kind of seems like a\nrecursive problem right so\nwe have two choices right we can go down\nor we can go\nright and then that's a sub problem one\nthing to notice is see how from this\nstart position\nwe are actually able to move to any\nposition\nin the entire grid but if we move\nright from this position what are the\npossible spots we can go to well we can\ngo\nright and we can go down so we can\nactually go to any spot\nhere but notice we will never be able to\nreach these two elements if we\nstart from here and similarly if we go\ndown\nfrom here then what positions can we\nreach we can reach any position to the\nright or below but we'll never be able\nto reach any of these\npositions and another thing to notice is\nliterally any spot in the entire grid\nuh the nature of this grid and since we\ncan go down and we can go right\nany spot in this grid will be able to\nreach our destination\nso we don't have to worry about not\nbeing able to reach\nthe destination so yeah you might try\nthis problem recursively right so we\nhave two decisions go down\nor go right and that's great right so\nnow from here we also have two choices\ngo\ndown or go right from here we have two\nchoices\ngo down or go right\nyou kind of notice though there's some\nrepeated work\nobviously we can get to this position\ntwo different ways so\nin that case we're gonna end up doing\nrepeated work right from\nthis uh way that we got here we're gonna\nwe can go down and we can go\nright and we're gonna repeat that over\nhere right go\ndown or go right so if we're doing depth\nfirst search recursively\none thing we can do is have a cache so\nfor every row column\nposition so for example in this\nposition we cache the result so if we\never\nreach this spot multiple times we will\nbe able to store that and we won't have\nto run\ndebt for search again because debt for\nsearch is pretty expensive\nand so what is this value even going to\nstore well\nthis is recursive so for each position\nwe're actually calculating the number of\nways\nwe can reach the destination right and\nif we can compute that for\nevery single like square then\nwe can compute that for the original\nsquare\nright basically what i'm saying is the\nresult that we're looking for\nis actually equal so let's say we call\nthis spot\nr we call this spot down right so this\nis r\nfor right this is d for down the result\nthat we're looking for is actually the\nsum of r plus d right but then you might\nask well how do we compute\nr and how do we compute d well r is just\ngonna be\nr has a value to the right of it and it\nhas a value below it right\nso if we want to compute this value\nwe can just take the right and down\nvalues\nand get them right but so what's the\nwhat ends up being the base case\nso with all that in mind what ends up\nactually being the base case well\nso this is the ending position right so\nhow many ways\nfrom the ending position are there how\nmany unique paths are there to\nget to itself well we can choose\nto define that as one so if we've\ndefined that value as one we'll notice\nthat things actually work out pretty\nnicely\nbecause let's let's take a look at this\ncell right we want to take the bottom\nvalue\nand the right value and then add them up\nand then that's what we're going to put\nin this spot\nbut we see that there's nothing below it\nright that's out of bounds\nwhat we can say is well we'll just\ndefine that to be 0 right\nwe'll define every value out of bounds\nto be zero so if we ever need them well\nwe can just say\nthat they're zero so then what becomes\nthe value that we place in the cell well\nwe can take\nthe right value which is one and the\nbottom value which is zero add them\ntogether and then we get\none so we can just put a one over here\nright and\nyou might notice well what if we want to\ncompute the value in this position\nwell the exact same thing will take\nplace right the value below is zero the\nvalue to the right is one\nso we can say that there's one way from\nthis position\nto reach the end result and now what's\nwhat actually is that\npath well we can we can't move down\nright that's out of bounds so we can\nonly choose to move\nright and then right and then we'll be\nable to get to the result\nand you can see that's true for every\nposition in the bottom row so we're just\ngoing to fill\nthese to be one and you might be able to\nsee how\nwe are going to arrive at the dynamic\nprogramming solution now\nso the first thing for us to do is to\ncompute this bottom row now let's start\ndoing the next\nrow right because our ultimate goal is\nto be able to do this value we can work\nour way\nfrom the bottom to the left and then\nfrom here\nto the left and then keep doing that and\neventually we'll\narrive at the result so what about this\nposition\nwell it has a zero to the right of it\nbecause the right is out of bounds it\nhas a one\nbelow it so we'll take zero plus one\nagain we get\none now what about this spot this spot\nactually has a value below it\nand a value to the right of it and those\nvalues are one and one respectively so\nthe sum is gonna be two and that makes\nsense right because if you\nstart here there's one path going to the\nright and then going down right that's\none path to get to the result\nand there's another path going down and\ngoing\nright that lets us get to the result so\nit makes sense that this would be\ntwo unique paths to get to the result\nand from here on out it's basic addition\nright so down is one\nright is two add those together we get\nthree here we get one plus three that's\ngoing to be\nfour add this together with this that's\ngonna be five\nadd these two together that's gonna be\nsix add these two together that's gonna\nbe seven\nand so you notice now we have filled in\nthe second row it looks a little bit\ndifferent than the first row right\nthe bottom was all ones and now the only\nthing for us to do is to get this\nlast row so we look down and we look\nright that's one plus zero so we're\ngoing to get a one\nnotice how the entire first column is\none\nthat's actually always going to be true\nright because think about it from any\nposition\nin the rightmost column the only\ndecision we can do is move\ndown so there's only going to be one\npath\nto the result so this is going to be two\nplus\none this is going to be three plus three\nthis is going to be four plus six this\nis going to be five plus ten\nthis is going to be six plus fifteen and\nso finally\nwe are at our start position so we can\ntake the bottom and right values\n7 plus 21 add them together we get 28\nso that tells us if we start here there\nare\n28 different paths we can use\nto get to the result 28 unique paths\nand when you look at the picture it\nactually looks more like a math problem\nthan a coding problem right and that's\nbecause it is you can actually\ncalculate the number of ways from the\ntop left i think in constant time if you\nhave like a\nmath equation but i don't know a ton\nabout it i'm just going to stick to the\ndynamic programming solution\nso let's do what we just did in the\npicture so i'm going to have\na row and this is initially going to be\nthe bottom row it's going to be\nthe length of the number of rows that we\nhave which is\nn but since it's a grid you could\nprobably use either m\nor n and so since we know the bottom row\nis going to be all ones we can start\ngoing through the other rows\nso we can go through all of the other\nrows except for the last one so\nm minus one and for each row we're going\nto compute\na new row so this new row is going to be\nabove\nthe old row and so it's going to be the\nsame dimensions of course\nwe'll initialize it to all ones and to\navoid\nthe edge case of having to check out of\nbounds what i'm going to do\nis go through every position every\ncolumn except\nthe rightmost column and we can do that\nlike this because we know the rightmost\ncolumn\nor the last value in every single row is\nalways going to be\none right i showed that in the drawing\nand so we're going to\nstart at the second to last position\nkeep going until we get to the beginning\nand go\nin reverse order so we're going from\nright to left\nand we know that the new row so if we're\ncomputing new row of\nj it's going to be new\nrow of j plus 1 so the\nthis is the right value and the value\nbelow is just going to be\nthe old row at index j and so with this\nloop we'll be able to compute the new\nrow and so after we do that we can\nupdate the row so the old row is now\ngoing to be set to the\nnew row and so it's going to keep doing\nthat until we\nend up getting the last or rather the\nfirst row the top\nrow that we actually want to compute so\nafter this has been executed that's\nwhat's going to happen and what we\nactually want to return though\nis in that first row which will be in\nthis variable\nwe want the first value so at index 0\nthat's what we're going to return\nso now we can run our code and by the\nway\nso it is pretty efficient because we did\nthis in o\nof n times n time and the memory\ncomplexity is just the\nbig o of n because that's the length of\na\nrow so i hope this was helpful if you\nenjoyed\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Longest Common Subsequence",
        "NcLink": "longest-common-subsequence/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "Given two strings `text1` and `text2`, return the length of the *longest common subsequence* between the two strings if one exists, otherwise return `0`.\n\nA **subsequence** is a sequence that can be derived from the given sequence by deleting some or no elements  without changing the relative order of the remaining characters.\n\n* For example, `\"cat\"` is a subsequence of `\"crabt\"`.\n\nA **common subsequence** of two strings is a subsequence that exists in both strings.\n\n**Example 1:**\n\n```java\nInput: text1 = \"cat\", text2 = \"crabt\" \n\nOutput: 3 \n```\n\nExplanation: The longest common subsequence is \"cat\" which has a length of 3.\n\n**Example 2:**\n\n```java\nInput: text1 = \"abcd\", text2 = \"abcd\"\n\nOutput: 4\n```\n\n**Example 3:**\n\n```java\nInput: text1 = \"abcd\", text2 = \"efgh\"\n\nOutput: 0\n```\n\n**Constraints:**\n* `1 <= text1.length, text2.length <= 1000`\n* `text1` and `text2` consist of only lowercase English characters.\n",
        "Difficulty": "Medium",
        "Video": "Ua0GhsJSlWM",
        "PythonSolution": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)]\n\n        for i in range(len(text1) - 1, -1, -1):\n            for j in range(len(text2) - 1, -1, -1):\n                if text1[i] == text2[j]:\n                    dp[i][j] = 1 + dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = max(dp[i][j + 1], dp[i + 1][j])\n\n        return dp[0][0]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nlongest common subsequence a dynamic\nprogramming problem\nand this is pretty much one of the most\npopular dynamic programming problems so\nwe are given\ntwo strings text 1 and text 2\nand we just want to return the length of\nthe longest\ncommon subsequence between these\ntwo strings and you might remember from\nmy last video where we\nlearned basically what a sub sequence is\nit's basically\nuh you take a string right like this\nstring a b c d e\nand you just you know you choose a few\ncharacters from it\nwhile you maintain the order so one sub\nsequence from this string could be a b\nright you take the first two characters\nfrom and you can take any characters you\ncan choose to remove any characters you\ncan do whatever you want\nand so we're looking for the longest\ncommon subsequence\nso a subsequence that is in both\nof the strings so in this example we\nhave two strings right a b\nc d e and a c e so what is the longest\ncommon subsequence between these well\nwhen you take a look at the first string\nyou see that hey they both have an a\nright they both have an a in the first\nspot so that's good\nso now let's look at the second\ncharacter b and c\nwell this has a b but the second string\ndoes not have a b\nbut the second string does have a c and\nwe also have a c over here\nbut the second string does not have a d\nright so we can't include the d from the\nfirst string but then we see the last\ncharacter is an e the last character and\nthe other string is also an e so\nwe get the longest common subsequence to\njust be\nthe original second string right ace\nbecause ace\ncan be found in the first string all we\nhave to do is remove\na couple characters right remove the b\nand remove the d\nthen we get a subsequence that matches\nthe second string so the length of the\nlongest common subsequence\nis three so how can we solve this\nproblem well as i mentioned dynamic\nprogramming\nis the most efficient way to solve this\nproblem but before we even get into the\ndynamic programming solution\nwhich is going to be a two dimensional\ndynamic programming solution\nbefore we get into that let's just\nnotice one thing\ndo you so let's say these are our two\nstrings right string one and string two\ndoes it at least make sense to you that\nokay\nlike we would want to start let's say at\nthe beginning of both strings right like\nwe're looking for the longest common sub\nsequence\nit might just be that both of the\nstrings are actually equal right that\ncould be a possible way so let's\nlook at the first character in each\nstring and in this case\nthey match each other right they're the\nsame character\nso does it at least make sense to you\nthat if\nboth of the characters match each other\nright the first characters\nthat the longest common subsequence then\nwe can break it into a sub problem right\nnow\nthe new problem we're looking at is\nfinding the longest common subsequence\nbetween the remainder of both strings\nright\nplus one plus one\nbecause we see that the first two\ncharacters\nare equal right that's where our one\ncomes from right\nbecause we know that the longest common\nsubsequence is at least\ngoing to be one because we found a\nmatching\npair of characters right and then we\nhave a\nsub problem right and you you might know\nthat\nthat's what dynamic programming is all\nabout finding the\nsub problem now what if this character\nwas a b right and this is an\na so clearly they're not the same\ncharacter what would we do\nthen well we can't do what we just did\nwe can't add one and then find\nthe longest common subsequence between\nuh the\nthe remainder of the two strings we\ncan't do that but\nbut we can break it into a different sub\nproblem we can say well\nit's possible that the longest common\nsubsequence could be between\nthese two strings right or it could be\nbetween\nthis string and this string so this is\njust\na little bit of an explanation before i\nshow you the actual dynamic programming\nsolution right\nbasically what we found out is that\nbased on\ncomparing the first two characters\nwhether they're equal or not equal we\ncan break up\nthe problem into sub problems and then\nsolve those sub\nproblems so take a look what i just did\ni took the\ntwo input strings right string one and\nstring two\nand i wrote them in a different way\nright i\nsaid that this is a two dimensional\ndynamic programming problem\nand you might know that a grid a 2d\ngrid like this is commonly used to solve\nthese types of dynamic programming\nproblems\nso notice that for each character in\nboth\nstrings there's a square right a\nposition\na cell that we can put a value in we're\ngoing to put a value in each of these\ncells and so let's just start at the\nbeginning like we\ndid right so let's start at the first\ncharacters right\nwhat we're trying to do is for these\nstrings find the longest common\nsubsequence\nbetween the entire strings right so what\nwe're going to do is put that value\nright here that's what's going to be the\nentire\nlongest common subsequence so we want to\ncompute the value that goes here but\nwhat you're going to find is\nto do that we need to solve some sub\nproblems\nand then you know continue to do that\nand then work our way back\nup to this position so what do we notice\nwe let's look at these two characters\nright they're\nequal a and a right so okay so now we\nwant to find the value that goes here\nhow can we find that value\nwell like i mentioned right now we're\ntrying to solve a sub problem we want to\nfind the longest common subsequence\nbetween these two substrings\nright we don't have to check these a's\nanymore because we know they match each\nother\nso now i want to find this new\nsub problem right and so basically what\ni'm saying is i'm going to go\nhere i'm i want to solve the sub problem\nthat goes here\nso now we're here right we're comparing\nthis b\nwith this c we see that they're not\nequal this time\nright that means we're not going to be\ngoing diagonally we're not going to look\nat this sub problem we're going to look\nat a different sub problem\nsince these characters do not equal each\nother\nwe have to check two different sub\nproblems\nit means that the longest common\nsubsurface between\nthese two substrings is going to be\nfound\nin either of these two positions right\nso let's look at this position first\nwith this position tells us we're trying\nto find the longest common subsequence\nbetween this string\nand this string right so basically we're\nnot looking at this c\nanymore right and this position tells us\nthat we're looking at the longest common\nsubsequence between this string\nand this string so basically when we\nremove this\nb right and just by looking at it right\nyou can tell that this\nis going to these two strings are going\nto lead to a longest common subsequence\nof one just by looking at it right\nbecause you can see that this has one\ncharacter it's an e it only matches\nthis e so that's going to be a one but\nwhen you look at\nthis string and this string right\ncorresponding to this position\nwe see that this has a ce this has a ce\nso this is n\nthis is going to end up being a two but\nlet me actually solve\nthe rest of it a little bit so mainly\nlooking at these two strings right\nin this position we see that the c's\nmatch each other right so since\nremember when the characters match each\nother the first characters of both\nstrings match each other that's when we\ngo diagonally\nand the reason we go diagonally is\nbecause then we know we can look at the\nremainder of both of the strings right\nwe\nwe know that this c matches this c so we\nwant to look diagonally we want to look\nat these two substrings\nso what's the longest common substring\nbetween these two\nokay so what are we gonna do let's\ncompare the first character right so\nd and and e so these characters are\nnot equal so remember what we do when\nthe first characters are\nnot equal then we can't go diagonally so\nwhat do we decide to do we go to the\nright and we go\ndown and we take whatever the max of\nthese two\nis and then put it in this value that's\nwhat we're gonna do\nso first let's check this right position\nso what does this right position even\nmean it means we're taking\nthis substring and finding the longest\ncommon subsequence with this substring\nbut this is an\nempty string so what's going to be in\nthis\ncell remember this is actually out of\nbounds\nanyway right so what default value are\nwe gonna give ourselves if we go out of\nbounds to the right\nclearly the the longest come sub\nsequence between a string and an empty\nstring like this\nis gonna be zero right so really what\nwe're gonna initialize is we're gonna\nsay\nevery value in this column is going to\nbe 0.\nsimilarly this is an empty substring if\nit were to\nif we were trying to find the lcs the\nlongest common subsequence between this\nand an empty substring\nwe would also get zero so what we're\ngonna do is put a zero\nin these positions right that's just how\nwe're gonna initialize our 2d matrix\nwhen we start the problem okay so\nremember what we were doing we were at\nthis position we were going right and we\nwere going down trying to find the\nmaximum value well\nclearly to the right we get a zero so\nthat's not the max\nso let's go down okay now we're down so\nwhat are we doing we're\nfinding the lcs between this substring\nand\nthis substring well they're the exact\nsame right e matches\ne okay great and remember when\ncharacters match each other\nthat's when we look diagonally right so\nwe came down here and now we're looking\ndiagonally\nclearly we get a zero here right so\nzero plus one the reason we're doing a\nplus\none here is because we found matching\ncharacters when characters match\nwe add one because clearly the lcs\nbetween these is going to at least be\none right at least one of these\ncharacters matches\nso now i'm basically gonna go here and\nthen take us\nback along the path that we came from\nand then show you what the solution\nis so we had a one here right and so\nfrom this position we went\ndown so since we were going down that\nmeans that this character and this\ncharacter did not match each other so\nwhat we're gonna do is just\ntake the one and put it up here right so\nthere's gonna be a one here\nbecause the lcs between these two is one\nbut now we're gonna go back over here\ndiagonally right\ndiagonally means that this character\nmatched this character right\nso we're going to take the value that we\ngot up here put it over here\nand add one because remember these match\neach other so we're adding one\nthat means we're going to end up putting\na two in this position\nand now we're we we're going up right\nwe're going up\nbecause that's where we came from and\nremember when you go up that means the\ncharacters did not match each other the\nc\nand the b don't match each other so\nwe're going to put a 2 here right we're\njust taking this 2\nand putting it over here and lastly\nwe're going back\nhere that's where we came from right\ndiagonally that means the characters\nwere matching each other so we can add\nat least\none character so two plus one that's\ngoing to be\nthree this is how we got the result\nright so we got a\nthree meaning that the lcs between these\ntwo strings is three right and that's\nwhat we learned from the problem\nexplanation so right what we're going to\ndo is return\n3 that's our result but you can see that\nthe way\ni did it was basically intuitive right i\nused this picture and basically solved\nthis problem by hand\nusing a little intuition and stuff right\nbut the way we're gonna have to solve\nthis with\ncode is gonna be brute force ish right\nso it's dynamic programming\nbut what we're gonna have to do is for\nevery value\nin this cell right so we are gonna\ninitialize these\nzeros right but with this matrix right\nthis 2d matrix\nwe want the value that goes up here\nright and to do that we have to compute\nthe value\nthat goes here that goes here that goes\nhere and basically for\nall these and then finally we'll be able\nto have the value that goes here which\nis the result that we're going to return\nand so basically what i'm saying is this\nis going to be a bottom\nup dynamic programming solution right\nbottom\nup meaning we're going gonna solve it in\nreverse order we're gonna first\nget every value we're gonna get the\nvalue that goes here and then work our\nway\nup until we get to the result and you\nmight have noticed see i have an i that\ntells us\nthe column i have a j that tells us\nactually the column and the i tells us\nwhat the row is\nand so when we're working our way\nstarting at the bottom and then working\nour way up\nhow are we going to determine what value\ngoes in each cell\nbasically what i went over earlier right\nso we're going to look at the characters\nand if they match each other what we're\ngoing to do is say\none plus the value that's diagonal right\nand we know\nwhen we go out of bounds there's a zero\nright there's an implicit\nzero when we go out of bounds and we're\ngoing to do that with\nevery single cell right so when you look\nat these two we get an e\nand a c right and when characters don't\nmatch each other right\nthat's important what we're going to do\nis we're going to look down\nright we see a zero down here and we're\ngonna go right\nright to the right side and we see a one\nhere on the right side\nand what we're gonna do is take the max\nof those two values\nand we see that the max is of course one\nright one is bigger than zero and then\nwe're going to put that max value in\nthe cell so that's really it there are\ntwo choices right\nif the characters don't match each other\nright in this case\nor if their characters do match each\nother in this case\nright that's basically how we're going\nto solve this problem it'll make a\nlittle more sense when i show you the\ncode\nso remember we're going to have a 2d\ngrid so i'm going to call that dp for\ndynamic programming it's going to be a\n2d grid and what i'm initially going to\ndo\nis set it to all zeros right so and i'm\njust gonna do a little bit of\nuh python stuff so list comprehension in\npython\nso we're gonna go through every single\nvalue\nin the length of text two\nplus one right plus one because we\nwe know that we need at least one more\ncolumn to have all the zeros in it\nand so we're remember we're gonna put a\nzero for every\nvalue in that so length plus\none and we're going to have this row for\nevery value in the length\nof string one so text one plus\none as well right so we're basically uh\nif you're not familiar with python this\nlooks complicated but basically we're\ngetting a 2d grid of dimensions length 2\nplus 1 times a length string 1 plus 1\nand initializing it to\nall zeros and then we're just going to\nhave a\nnested loop and what we're going to do\nis\niterate through this 2d grid in reverse\norder\nso in python you can do it like this and\nbasically what i'm doing is\nstarting at the bottom right of the\nmatrix and then working our way up\nso this is how you do it in python\nnegative one negative one\nand let's do the same thing for text\ntwo and so remember so we're going\nthrough every cell\nin our 2d grid and remember there were\ntwo conditions one condition\nis if the characters in both strings\nmatch each other so if text one of i\nmatches text two at position\nj if they match each other we're going\nto do something and if they\ndon't match each other we're going to do\nsomething different so remember if they\ndo match each other then what we can say\nis at this position\ndp of i j because remember we're trying\nto fill in\nevery single cell what we can do is then\njust simply take one plus\nthe diagonal how do we find the diagonal\nwell we can say\ni plus one and j plus one right that\ngives us the diagonal\nand remember we're adding one to it\nbecause these characters match that\nmeans we add a one\nand if they don't match that's the else\ncase right so we're doing something\ndifferent here\nwe're going to put a different value for\ndp of ij\nand in this case what we're doing is\nwe're finding the maximum of\ntwo values what are the two values the\nvalue to the right\nof this position so we can say dp of i j\nplus one we can say that's the right\nvalue and the\nvalue below the bottom value so we can\nsay\ni plus one and j for that\nright so we're finding the maximum of\nthese two we're not adding one\nwe're not adding one because the\ncharacters did not match each other\nbut basically literally these are the\ntwo cases\nwe're just filling in a different value\ndepending on what the case\nis and that's it so literally with these\ntwo nested loops and with these two\nconditions\nwe're filling in the entire dp matrix\nand so once that matrix is filled in we\nknow that the result is going to be at\nthe top\nleft of that matrix so the dp the matrix\nat index\n0 0. that's going to have our result so\nall we have to do now is return\nthe result and clearly you can see that\nthe\ntime complexity of this is the length of\nthe strings\nmultiplied by each other so if the\nlength of string one was n\nand the length of string two was m we'd\njust multiply them together so this\nwould be the time complexity\nthat's also the memory complexity\nbecause we need extra memory for our 2d\ndynamic programming grid oops i had just\none little bug i added\none to the inside of that function but i\nneeded to add one here\nbut other than that you can see that the\ncode\ndoes work and it is pretty efficient\nbecause the dynamic programming solution\nis the most efficient for this problem\nso i hope that this\nwas helpful if it was please like and\nsubscribe it supports the channel\na lot and i'll hopefully see you pretty\nsoon\n"
    },
    {
        "Name": "Best Time to Buy And Sell Stock With Cooldown",
        "NcLink": "buy-and-sell-crypto-with-cooldown/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.\n\nYou may buy and sell one NeetCoin multiple times with the following restrictions:\n* After you sell your NeetCoin, you cannot buy another one on the next day (i.e., there is a cooldown period of one day).\n* You may only own at most one NeetCoin at a time.\n\nYou may complete as many transactions as you like.\n\nReturn the **maximum profit** you can achieve. \n\n**Example 1:**\n\n```java\nInput: prices = [1,3,4,0,4]\n\nOutput: 6\n```\n\nExplanation: Buy on day 0 (price = 1) and sell on day 1 (price = 3), profit = 3-1 = 2. Then buy on day 3 (price = 0) and sell on day 4 (price = 4), profit = 4-0 = 4. Total profit is 2 + 4 = 6.\n\n**Example 2:**\n\n```java\nInput: prices = [1]\n\nOutput: 0\n```\n\n**Constraints:**\n* `1 <= prices.length <= 5000`\n* `0 <= prices[i] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "I7j0F7AHpb8",
        "PythonSolution": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        dp = {}  # key=(i, buying) val=max_profit\n\n        def dfs(i, buying):\n            if i >= len(prices):\n                return 0\n            if (i, buying) in dp:\n                return dp[(i, buying)]\n\n            cooldown = dfs(i + 1, buying)\n            if buying:\n                buy = dfs(i + 1, not buying) - prices[i]\n                dp[(i, buying)] = max(buy, cooldown)\n            else:\n                sell = dfs(i + 2, not buying) + prices[i]\n                dp[(i, buying)] = max(sell, cooldown)\n            return dp[(i, buying)]\n\n        return dfs(0, True)\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve best time to buy and sell a stock\nwith a cool down and this is actually a\nvery interesting problem and a very\nchallenging problem but honestly i'm\ngonna make this problem look like a joke\ntoday and that's not because i'm really\nsmart it's honestly only because i know\nhow to draw a picture i'm sure you guys\nknow how much i like drawing pictures\nfor leak code problems and how helpful\nthey are and this problem is a perfect\nexample of why exactly that is so let's\nget into it we are given an array of\nprices the price at index i just\nrepresents the price of a given stock on\nthe ith day and our goal is to maximize\nthe profit that we can achieve and the\ncomplicated part is that actually we can\nmake as many transactions as we like we\ncan buy a stock and then sell a stock\nbut there are a couple restrictions the\nmain restriction here is that we can't\nbuy a stock and then sell the stock on\nthe next day we have to have at least\none day in between called the cool down\nday now we could have one cool down day\nbut we could actually have multiple cool\ndown days if we really want to right\nbecause we have a choice of how many\ntransactions we can complete and the\nother restriction here is that if we buy\nthe stock let's say on index zero right\nwe buy it for price one we can't just\nbuy it the next day as well right we\ncan't just have uh infinitely many we\ncan only have one share at a time\nbasically that's what they're trying to\nget at right we can't buy and then buy\nand then buy we have to buy and then\nsell and then rebuy so in this example\nwith this array of prices the result\nhappened to be three three is the max\nprofit we could get and these are the\ndecisions we would make to result in the\noutput three we buy on the first day we\nbuy for one we sell for two that's a\nprofit of one so so far we have a profit\nof one we cool down on day three so we\ncool down we buy it for zero the next\nday and then sell it for two so that's a\nprofit of two so the total profit was\nthree so not too bad but the real uh\ncomplicated part about this problem is\nthat we have so many choices that we\ncould make and that can get really\ncomplicated unless of course you draw a\npicture so let me show you how with\ndrawing a picture we can solve this\nproblem in linear time so like i said\nthere's a lot of decisions to make so\nlet's try to draw out those decisions\nthe first main thing here is we can\neither buy or we can sell and we can\nonly sell if we have already bought the\nstock before so when we start out\nat this array right we start at day zero\nat this point at the beginning of the\narray are we buying or are we selling of\ncourse we're buying because we don't own\nthe stock yet so we can't sell it so\nthat's one part of the state that we\nhave to kind of keep track of are we\nbuying or are we selling and it's not\ntoo hard because it's just a boolean\nright it's true or false and initially\nwe're buying so you know we have a\nchoice at index one right we can buy so\nof course one decision is buy if we buy\nthe stock on day zero it costs one so if\nwe do buy what's our total profit so far\nwell buying costs money so our total\nprofit so far if we buy is gonna be\nnegative one now are there any other\ndecisions we can make other than buying\nwell we definitely can't sell yet we\ndon't own anything but we can definitely\ndo a cool down now if we do a cool down\nthen our profit is going to be zero so\nfar and by the way let me just draw a\nlittle zero up here because when we\ninitially started our profit was also\nzero okay now on the left path of the\ndecision tree what choices can we make\nnow can we also buy and do a cooldown\nwell we already bought we can't buy\nagain we have to sell now technically we\ndon't have to sell but that definitely\nis one of our choices the other choice\nof course is cool down so as you can\nkind of tell now\nwe always have a choice of cooling down\nright the the main choice that we're\ngoing to be determining is are we buying\nor are we selling the other choice can\nalways be cool down we don't have to do\nanything but if we do sell on the second\nday you can see on the second day the\nprice is two so uh by selling we're\nbasically doing a plus two operation\nright initially we had negative one\nwe're doing a plus two so that means our\ntotal profit if we sell so far is going\nto be positive one so that's pretty good\nnow of course if we cool down the profit\nis going to stay the same meaning\nnegative one now let's quickly draw the\ndecisions on the right side of the tree\nif we cool down\nthen we can't sell because we haven't\nbought anything yet so the same\ndecisions will be present as you know\nthe original decisions basically buying\ncooldown over here and the other\ndecision is going to be buying so here\nif we buy we saw that initially we had\nzero as the total profit but if we buy\non the second day that'll be a minus two\noperation so our total profit so far\nwill be minus two if we cool down of\ncourse it'll just stay zero so now we\nget to a kind of interesting case\nuh after we have already sold then what\nare our decisions can we buy and then\nalso have a cool down well the answer is\nno and the reason is because remember\nafter selling we are forced to have at\nleast one cool down day right after\nselling so basically just pretend like\nwe skipped a day right we had a forced\ncooldown day right that's our uh one\ndecision and we we can't make any other\ndecisions here right this is our\ndecision we're forced to do a cool down\nafter selling but after doing that uh we\nknow our profit is going to stay the\nexact same plus one after doing that\nthough then we do have a choice of\nbuying or having another cool down day\nso we can buy or we can have another\nconsecutive cool down day if we have\nanother cool down day of course our\nprofit is going to stay the exact same\nplus one but if we buy well first what\nday is it it's the fourth day now it's\nuh the price is zero so if we buy it's\ngoing gonna cost us zero i wish i could\nbuy stocks for a zero price but in this\ncase of course if it costs zero then our\ntotal profit is just going to stay the\nsame so we can stay at plus one now\nlet's continue on this path last\ndecision we can make is either selling\nor having another cool down day of\ncourse if we sold well\nwe're on the fifth day the last day it\ncosts the prices to so we'll make a\nprofit of plus two we were already at\nplus one so one plus two is going to be\nthree that's going to be our total\nprofit if we took this chain of\ndecisions right if we bought sold had a\ncool down then bought and sold again\nthis is what the profit would be of\ncourse every path in this decision tree\nis going to have a different number\nright for the total profit so far and of\ncourse we want to return the maximum and\nby the way if we had the cooldown day\ninstead on the last day then our profit\nwould stay the same it would be plus one\nas opposed to plus three and just\nimagine that you know every leaf node of\nthis tree has some different number and\namong all of those we want to return the\nmaximum so among these two decisions\nbetween three and one of course the\nvalue we are going to return when we\nimplement the solution recursively the\nvalue we're going to return is going to\nbe the plus three we're just going to\ntake the maximum of these two and return\nthe max so i really hope looking at this\npicture makes the solution\nunderstandable for you the downside to\nthe solution though is the time\ncomplexity you can see that the height\nof the tree that we're making is going\nto be n where n is the size of the\nprice's array and the number of\ndecisions at every point we can make is\nup to two decisions so the overall time\ncomplexity is going to be 2 to the power\nof n but we can actually use a very\nsimple dynamic programming technique\ncalled caching in this case and by doing\nthat we can reduce the time complexity\nto big o of n the reason why is because\nthe key for the caching that i'm going\nto be doing is one going to be the index\nright the index of what position we're\nat in the price is array the second\nkey i'm going to be using is a boolean\nfor buy or sell i want to know if we're\nbuying or are we selling it's a binary\ndecision so we can just use a boolean\nfor that right if we take this key value\nhow many possible values could it be\nwell the index i there's n different\npossible values for it this uh by or\ncell state is going to be two different\nstates for it because it's just a\nboolean right so if we take n times two\nuh we basically get two times n\nright which we know is just can reduce\nto big o of n so\nin this case if we use caching the time\ncomplexity will be big o of n the memory\ncomplexity will also be big o of n\nbecause we are caching if you're not\nfamiliar with caching i'll be explaining\nit right now as i go into the coding\nsolution okay so now let's write out the\ncode you can see i already wrote out a\nfew things one is just a comment kind of\nexplaining what we're going to be doing\nwe're going to keep tracking of the\nstate whether we're buying or we're\nselling if we buy we're just going to\nincrement the index by one if we sell\nwe're going to increment the index by\ntwo reason is because we remember we\nhave to take a cool down day after we\nsell and remember we are going to be\nusing caching a dynamic programming\ntechnique so the easiest way to do a\ncache is just use a hashmap so that's\nwhat i'm doing here with python and just\na comment what i'm going to be using as\nthe key value of this hashgraph is going\nto be the index i that we're at in our\nprices array and a boolean which is\ncalled buying it's going to be true if\nwe're in a buying state and it's going\nto be false if we're in a selling state\nand the value of the hashmap is just\ngoing to be the max profit associated\nwith this key value so now let's get\ninto it i'm going to be writing out a\nrecursive function dfs i'm going to be\nwriting the function inside of our root\nfunction\nbecause it's just easier that way we\ndon't have to pass in every single\nparameter we don't have to pass in the\nprices array we don't have to pass in\nour dp cash we only have to pass in\nour index and whether we're buying or\nwe're selling so\nfirst thing with recursive functions i\nlike to do is just write out the base\ncase so we know that the main base case\nis going to be if index goes out of\nbounds so basically if index is greater\nthan or equal to the length of the\nprices array i didn't really cover this\nbase case in the drawing explanation but\ni think it's pretty self-explanatory if\nwe go out of bounds basically if we have\nan empty array of prices what are we\ngoing to return well we can't make any\nprofit off of that so we're going to\nreturn zero okay so that's great and the\nother base case i just want to quickly\nmention is the case that if this pair of\nvalues this i and buying pair has\nalready been computed before so\nbasically if this is in our dp hash map\ninitially our dp hash map is empty but\nif this is in our dp hash map then we\nassume that the max profit associated\nwith this key has already been stored so\nthen we can return that right so in dp\nwe can just use this key value and then\nreturn whatever that max profit we\nstored was okay so now for the actual\ndecision that we can make and remember\nthat decision that we make is going to\ndepend on only one thing what state are\nwe in are we buying or are we selling so\nit's a binary estate right so if else so\nlet's start with the buying so we know\nin the buying state we can do two things\nwe can buy or we can have a cool down\nday right what's going to be the profit\nthe max profit associated with each of\nthese well if we buy we're going to\nrecursively call dfs at index i plus 1.\nand what's the state going to be are we\ngonna leave buying as the same of course\nnot because if we just bought then we're\nin the opposite state we're in the not\nbuying state so in python this will\nliterally just take that boolean value\nand negate it or in other languages you\ncould just do like the exclamation mark\nbut i'll leave this as is so that's how\nthe recursive call is gonna work pretty\nstraightforward but the only thing is if\nwe bought doesn't that affect our profit\nso far remember that's what i was\nkeeping track of so if we bought we have\nto subtract the price of what we just\nbought we bought the index on\nday i so that's what we have to subtract\nfrom the total this will tell us what\nthe max profit we can get from the\nremaining array starting at the not\nbuying state and this will tell us how\nmuch it actually costed us to get to\nthis state in the first place similarly\nwe'll do the cool down state which is\nslightly easier because all we have to\ndo is do i plus one and in this case the\nbuying state actually stays the exact\nsame because we did not buy so we're\nwe're still in a buying state and we\ndon't have to subtract anything because\nwe didn't spend any money and last but\nnot least don't forget to cash the\nresults so now we have our result so i'm\ngoing to use our key value i and buying\nand remember we took two decisions among\nthese two decisions what do we want to\nknow we want to know which one created\nthe max profit for us so let's just take\nthe max of buy and cool down and then\nassign that to dp so this is where we\nare actually caching so if we cache the\nsolution and then we try to recompute\nthat solution up above then we're going\nto end up returning it instantly rather\nthan going through all the recursive\ncalls over again okay so that's really\nthe bulk of the problem last thing we\nhave to do is handle the sell case so if\nwe\nsell then we're going to do dfs\nand remember if we sell we're actually\ngoing to increment the index by two\nbecause we have to take a cool down day\nand if we sell we also have to negate\nthe value of the boolean and you know\nyou can do what's readable for you if\nyou want to change this to you know set\nthe buying state to true now uh you know\nwhatever is readable for you i prefer\njust setting it to the negation um but\ninstead of subtracting the price like we\ndid with buying we want to actually add\nthe price because if we sold that means\nwe made some money so we can\nyou know add the profit of this uh\nnotice i forgot the s up above um and\nyeah so that's one decision and the\nother decision is just the cooldown\ndecision which we can literally just\ncopy and paste from up above because the\ncooldown is just skipping the day and\nit'll be the same in both cases and i'm\ngoing to copy the dp assignment up above\nbecause the only difference uh if we\nsold is we're going to take the max of\nsell and the cool down day and if you\nwant to save like one line of code here\nyou can probably just take one of the\ncool down functions\nmove it outside of the if else statement\nand then delete the other cooldown which\ni guess i'll do for you but i don't\nthink it's really that important but\nyeah once that's done what do we want to\nreturn we want to return whatever the\nmax profit was we luckily stored that in\nour dp so we can just return uh just\nlike this and believe it or not that\nreally is the entire function but we\ndon't have to we don't want to forget to\nactually call that function so let's\ncall our dfs starting at index zero and\ninitially the buying state is true\nbecause we are buying when we start out\nso let's run this to make sure that it\nworks and as you can see on the left yes\nit works and it is pretty efficient so i\nreally hope that this was helpful if it\nwas please like and subscribe it really\nsupports the channel a lot consider\nchecking out my patreon where you can\nfurther support the channel and\nhopefully i'll see you pretty soon\n"
    },
    {
        "Name": "Coin Change II",
        "NcLink": "coin-change-ii/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "You are given an integer array `coins` representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer `amount` representing a target amount of money.\n\nReturn the number of distinct combinations that total up to `amount`. If it's impossible to make up the amount, return `0`.\n\nYou may assume that you have an unlimited number of each coin and that each value in `coins` is unique.\n\n**Example 1:**\n\n```java\nInput: amount = 4, coins = [1,2,3]\n\nOutput: 4\n```\n\nExplanation:\n* 1+1+1+1 = 4\n* 1+1+2 = 4\n* 2+2 = 4\n* 1+3 = 4\n\n**Example 2:**\n\n```java\nInput: amount = 7, coins = [2,4]\n\nOutput: 0\n```\n\n\n**Constraints:**\n* `1 <= coins.length <= 100`\n* `1 <= coins[i] <= 1000`\n* `0 <= amount <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "Mjy4hd2xgrs",
        "PythonSolution": "class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for i in range(len(coins) - 1, -1, -1):\n            nextDP = [0] * (amount + 1)\n            nextDP[0] = 1\n\n            for a in range(1, amount + 1):\n                nextDP[a] = dp[a]\n                if a - coins[i] >= 0:\n                    nextDP[a] += nextDP[a - coins[i]]\n            dp = nextDP\n        return dp[amount]\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem coin change2 we\nalready solved the first one and i'll\nlink that somewhere on the top right of\nthe screen or somewhere in the\ndescription if you want to watch that\nvideo you don't have to solve it before\nsolving this problem but it'll probably\nbe easier to solve this problem if you\ndo so similarly we're given a list of\ncoins each representing a different\namount right a different denomination\nand we're given a second parameter an\ninteger amount and this is the amount\nthat we want to sum up to it's a total\namount of money that we want to sum up\nto given these coins and specifically we\nwant to know with these coins and this\nparticular amount how many different\ncombinations are there that we can sum\nup to this amount of course if we can't\never sum up to that amount we can just\nreturn zero and we can assume that we\nhave an infinite number of each type of\ncoin so\nthat kind of hints to you that this is\nan unbounded knapsack problem which i\ntalk about that category of problem in\none of my videos i think it's called top\nfive dynamic programming patterns if you\nwant to watch that video and so this is\nkind of one example that they give us\nand you can go ahead and read it if you\nwant there's four different ways to sum\nup to the amount five if we're given\nthree coins one two and five now when we\nsay number of combinations we can't\nreuse the same combination right so if\nwe get two to one uh two two one these\nthree coins sum up to five we can't just\nchange the order and then call that a\ndifferent combination the order doesn't\nreally matter so now let's kind of get\ninto the explanation let's talk about\nthe brute force explanation which is\ngoing to be exponential with uh c to the\npower of n whereas c is let's say the\nnumber of coins that we have and n is\nthe total amount that we want to sum up\nto that's the exponential solution we\ncan uh use memoization on that decision\ntree to actually get the time complexity\nto be big o of uh c times n i'm actually\njust gonna replace the variable c with m\nso let's call it m to the power of n\nthat can be reduced to m times n uh this\ntime complexity that's the best time\ncomplexity we can do but there is one\noptimization with memory complexity\nthat's pretty difficult to come up with\nbut i'll kind of explain it to you so\nlet's get into that so same example\nwe're trying to get the amount five with\nthese three coins let's just think about\nthe brute force so\ninitially we have a sum of zero right\nwe'll put that in a node and we have\ndecisions we can make right we're just\ngonna\nmake three decisions right we could\neither choose a coin of one that that\nwould give our sum to be one uh we can\neither choose a coin of two that would\ngive our sum to be two we could choose\nanother coin to be five\nthat would put our sum to be five right\nand then we can continue this approach\nthe only thing is how do we guarantee\nthat we don't have duplicates\nright because if i go down this path and\ni choose another two and and then i\nchoose another two right here we have a\none two two that gives us a sum of five\nso that gives us the amount that we\nwanted here we could do the same thing\ncouldn't we we could get a one and then\nwe could get a two this is the same uh\ncombination of coins just a different\norder right we don't want to get into\nthis case so how can we guarantee with\nthis decision tree that we won't ever\nget something like that well how about\nevery time we make a decision\nright we made three decisions in this\ncase we put some rules on that decision\nhow about\nwhen we go down this path we are allowed\nto choose we chose a one right we chose\nthe coin one and we're allowed to choose\nany coin that we want right down this\npath we can continue to choose a one we\ncan choose a two we can choose a five if\nwe want but we want to make sure that\nthis never gets any duplicates as this\none so how can we guarantee that how\nabout this path can never\nchoose a one how about we just don't let\nus choose ones anymore down this path to\nmake sure that we never have duplicates\non the other side of the decision tree\nright we're free to choose any twos and\nany fives that we want but we just can't\nchoose once hopefully it makes sense why\nthat guarantees that we won't have\nduplicates right because this path has\nat least one one right and this path\nwill never have any one so obviously\nneither both of these paths will never\nhave the same combination i hope that\nmakes sense and similarly over here when\nwe choose a five we're gonna we're gonna\nsay that okay we're not allowed to\nchoose anything except fives right we\ncan't choose ones or two that'll\nguarantee that these two are not the\nsame right because we have a two here\nand we'll never have any twos down this\npath so they'll never be the same so\nthat's the main idea of how i'm going to\neliminate duplicates so now we've gotten\nto the point where we have the m to the\npower of n solution right the base case\nis going to be if we get to the amount\nso you can see on this path we already\nreached the amount right we have a total\nof five that's exactly the target that\nwe're trying to get to\nnow let's say we chose a five over here\nright we chose a coin of five that would\nput our total at seven if we go over the\ntotal amount then we're going to stop\nright then we're just going to return 0\nand then stop going down that decision\nso those are the main base cases and by\nthe way how are we going to implement\nthat idea of if we chose a 1 or chose a\n2 we're not allowed to choose any other\ncertain coins right we're gonna be\nmaintaining a pointer uh let's call it i\nit's gonna point at some index of coins\nright so if we chose a coin of one then\nour index is going to be here right at\nthe coin one and if we chose a coin of\ntwo then our index i is gonna be at this\ncoin two and what when when our index is\nat a coin then it basically means that\nwe're not allowed to choose any coins\nwith an index less than it so basically\nanything on the left side of this coins\narray on the left side of our pointer i\nwe're not allowed to choose those coins\nright so that's how i'm going to\nimplement it in the code and this is\nimportant because now that we actually\nmove into the memoization solution the\nmemoization solution where we're going\nto be caching the repeated work because\nwhen you look at this decision tree it's\ngoing to be pretty inefficient right\nlike i said it's going to be m to the\npower of n where m is the number of\ndecisions we can make in other words\nit's the number of coins that we have n\nis the total amount right because the\namount is what's going to determine the\nheight of the tree so when we implement\nthis recursively let's call it dfs we're\ngoing to pass in two parameters one\nparameter is going to be i which is\ngoing to tell us what index we're at in\ncoins it could be you know any of these\nuh positions\nand we're going to pass in a second\nparameter let's call it a which is\nwhatever the current amount happens to\nbe remember if the amount ever goes over\nfive which is you know the target that\nwe're trying to do then we're going to\nstop right so basically the total number\nof about possible values a could be is\ngoing to be whatever that target value\nis so when you look at this right how\nmany different combinations could this\ndfs be called basically the total number\nof coins that we have right let's call\nthat m and the total amount that we're\ntrying to sum up to let's call that n so\nthe total possible number of ways this\ndfs could be called is m times n so if\nwe cache the repeated work right if we\ncall it with the same values we don't\nwanna have to recalculate the same thing\nif we call dfs let's say uh on index one\nand let's say our amount happens to be\ntwo and we call this multiple times we\ndon't wanna have to recalculate all that\nwork so we can do caching with that so\nthat's basically memorization we're\ngoing to be putting that in memory and\nthen we won't have to redo that work so\nat this point we've gotten to a solution\nthat will pass on leak code the time\ncomplexity will be m times n and the\nmemory complexity will be the same but\nnow i'm going to show you the dynamic\nprogramming solution which will actually\nhave the exact same time and space\ncomplexity and then i'm going to show\nyou a slightly more advanced dynamic\nprogramming solution which will actually\nreduce the memory to instead of being o\nof m times n it'll actually be o of n\nthis is one of the reasons why dynamic\nprogramming is important because\nsometimes the dynamic programming\nsolution can actually be more efficient\nthan the recursive memorization solution\nso if you want to check that out\ncontinue so now let's do the dynamic\nprogramming solution you can see i drew\na 2d grid where we have one dimension\nbeing the amount the you know zero from\nzero all the way to up to five and one\ndimension being the coin we had three\ndifferent coins one two three and we\nknow the base case is if the amount is\nzero right and what value are we gonna\nput in here when the amount is zero how\nmany different combinations is it that\nwe can sum up to zero well the base\ncases let's just put it as one right\nbecause that's what's gonna make the\nmath work out and it kind of makes sense\nright how many ways can you sum up to\nzero just one right regardless of which\ncoin we start at so what does this\nposition mean it means that if we could\nonly choose from this single coin five\nhow many different ways could we sum up\nto zero it's going to be one different\nway right and this position is going to\nmean if we had two coins available to us\ntwo and five how many ways could we sum\nup to the amount zero it's going to be\none right and so on and so on for an\narbitrary position like this the\nquestion is uh how many different ways\ncan we sum up to the amount three using\nthese two coins from here it would be\nusing these three coins right so what\norder would it make sense to uh compute\nthese values probably bottom up right\nthat's why they call this bottom-up\ndynamic programming we're going to start\nhere and compute the value that goes\nhere then we're going to compute the\nvalue that goes here and then here and\nthen start from here and then do the\nsame and looking at it since we're doing\nit in this order you're probably\nthinking i probably should have you know\nrotated this instead i should have put\nthe amount over here and the coins over\nhere because then we can actually\ncompute it like\nthis and you're right but there's\nactually a way that we can compute it\nlike this\nthat i'm going to show you and actually\nthis way if we do it in this order is\ngoing to be better memory complexity let\nme show you why that's the case though\nso let's say starting from this position\nright we're trying to sum up to the\namount one if we use a coin we can only\nchoose one coin that's available to us\nright we can choose a five coin what\nhappens if we use a five coin uh then\nour amount that we're trying to sum up\nto is gonna be one minus five right\nthat's going to put us at negative four\nso from here i'm gonna go to negative\nfour now that's out of bounds right so\nthat kind of tells us that there's zero\nways to sum up to the amount one if we\nonly have a single five coin available\nto us next let's compute the value that\nwould go here so we have two choices in\nthis case actually because now we have\ntwo coins available to us so we can\nchoose to use the two coin what happens\nif we use the two coin well then our\namount one is going to be one minus two\nwhich is going to be negative one right\nso you know if we're trying to get the\nvalue here then you know our arrow is\ngoing to go over here out of bounds\nwhich is negative right so that doesn't\nwork and that's if we choose the two\ncoin if we choose the five coin what\nwhat are we going to do well then we're\njust going to look directly below us\nbecause we're still solving the same\nproblem amount equals one but in this\ncase we're choosing not to use the two\ncoin we're just gonna use the five coin\nbut we see that that's a zero value down\nhere so in the end we'll also end up\nputting a zero here and from here we're\ngoing to do the same thing we in this\ncase we have three coins available to us\nif we use a one coin what is that going\nto put us well we started at we're\ntrying to get to the amount one if we\nuse a one coin we'll do one minus one\nequals zero so okay then from here we're\ngonna you know go to the to the spot\nthat has a value of zero right that's\ndirectly to the right of us right that's\nwhere zero is so then we're gonna take\nthis value add it to this position right\nso one is gonna be added here but we\ndon't have to choose this one coin right\nwe could actually choose the two coin we\ncould ask okay instead of choosing one\nwhat happens if we try to sum up to the\nvalue one with two coins available to us\nin that case we look directly below us\nand we see that there's a zero there and\nwe add zero to this position one plus\nzero will just be one so we can leave a\none in this spot so and then you can\nkind of just continue doing the dynamic\nprogramming just like this one thing you\nmight notice though let's assume for an\narbitrary position like this one if we\nuse the two coin that'll put us amount\nis four we'll move two spots to the\nright where amount is two right so we're\nlooking all the way to the right we\ncould also say okay we're not going to\nuse the two coin right we're gonna use\nall the other coins in that case we'd\nhave to look directly below us right\nthat's perfectly fine this this\nperfectly works but one thing you're\nnoticing for a arbitrary position like\nthis one we have to look both to the\nright and we have to look below what\ndoes that mean that means potentially we\nhave to have the entire uh\ntwo-dimensional array in memory because\nwhen we're looking directly to the right\nof us we're not just looking one spot we\ncould be looking two spots three spots\nfive spots right depending on what coin\nvalue we have so in that case we're\ngoing to have to have this entire\ntwo-dimensional grid in memory there's\nactually a different way we can do this\nproblem if we uh compute this in this\norder right from here in that way we\nwon't have to have the entire grid in\nmemory we will only have to have up to\ntwo rows uh two rows like these we'll\nonly have to have up to two rows in\nmemory and a row will only be as large\nas whatever the max amount happens to be\nwhich means the overall memory\ncomplexity in that case will be big o of\nn now you probably don't need this\nsolution to pass your interview unless\nit's like a super hard interview and\nyour interviewer is looking for it but\ni'll show you both of the solutions\nanyway i'll show you the code for this\nsolution and the code for the memory\nsolution of o of m by n okay so in this\nspot we're asking the same question\nif we only have one coin available to us\ncan we sum up to the amount one we can't\nwrite because then we go out of bounds\nso in this case let's just put a zero\nokay ask the next question if we're\nsumming up to amount two with just one\ncoin available to us can we sum up to\nthat amount no of course we can't right\nso and that's gonna be true for this\nposition right can't sum up to three\ncan't sum up to four either but once we\nfinally get to five with a single coin\nof five well what's going to happen okay\nwe use our coin of five right so that\nmeans we look five spots all the way to\nthe right and over here in this spot we\nfind a one is waiting for us right\nthat's our base case that's where amount\nis equal to zero so we take that one and\nthen we add it in this spot right so now\nwe've done that so there's one way to\ncompute the the amount of five if we\nonly have a single coin available to us\nbut remember the actual problem that\nwe're trying to solve is all the way in\nthe top left corner if we had all three\ncoins available to us because we do we\nhave an unlimited supply of all three\ncoins available to us so how many\ncombinations can we do to get to this\namount five well let's continue row by\nrow just like i mentioned right so now\nwe will need to keep this row in memory\nfor us to be able to compute this row\nbut once we're computing this row we\nactually won't need this bottom row in\nmemory anymore and i'll show you why\nthat's the case so now if we had two\ncoins available to us how many ways\ncould we sum up to the amount one well\nif we use a two coin we'll go two spots\nto the right which is out of bounds so\nwe don't put anything right so far it's\nwe're at zero so if we choose not to use\nthe two coin and we say okay we're just\ngoing to use all the remaining coins\nthen we look directly below us again we\nfind a zero so in this spot we say that\nthere are zero ways to sum up to the\namount one if we have these two coins\navailable to us which makes sense right\nthere's no way you can get a one if you\nhave a two and a five available to you\nnow let's do it in this spot so if we\nuse the two coin in this spot we'll move\ntwo spots to the right which will we\nfind a one here right so we can add a\none here uh if we choose not to use the\ntwo coin we look directly below us which\nis a zero so we don't do anything in\nthat case right so we leave a one here\nthere's one way to sum up to the amount\ntwo with uh these two coins available to\nus\nin now i'm going to start going fast\nbecause i don't want to waste too much\nyour time so in this spot we're gonna\nlook directly two spots to the right\nwhich is a zero or we're going to look\ndirectly down and that's a zero so we'll\nstill put zero here notice how we're\nlooking multiple spots to the right but\nthat's okay because we have this row in\nmemory but when we look down we're never\ngoing to look multiple spots down that's\nthe key that's why we only need o of n\nextra memory so let's continue so from\namount four uh we're going to look two\nspots to the right there's a one or\nwe'll look down that's a zero so we put\none plus zero one here here again two\nspots to the right that's a zero or one\nspot down that's a one so one plus zero\nwe get a one let's continue so from here\nwe'll look once uh spot directly to the\nright that's one we'll look down that's\nzero so\nwe'll put a 1 here again from here we'll\nlook one spot to the right that's a 1\nwe'll look one spot down now we get a 2\nright because we're adding these two\nvalues together that makes sense right\nbecause amount 2 how many different ways\ncould we sum up to this amount too if we\nhad all three coins available to us\nthere are two ways right and from here\nwe'll look directly to the right by one\ntwo plus directly below that's zero so\nwe'll put a two here from here again\ndirectly to the right directly below 1\nplus 2 that's going to be 3 and from\nhere again directly to the right and\ndirectly below that's going to be 4. so\nwe get a solution of 4. is that correct\nwell when you come back and look at the\nproblem description with that example\nyeah that's what the amount was that's\ngood now we're ready to dive into the\ncode okay so now let's jump into the\ncode and since this video is probably\nalready too long i don't want to spend\ntoo much time coding it up so let me\njust show you the code and it will be in\nthe description this time if you want to\ncopy and paste it or take a look at it\nso this is the recursive solution the\ntime and space complexity is big o of n\ntimes m just like i mentioned in the\nexplanation you can see that we have a\ncache in this case the cache is the hash\nmap the base case is just as i mentioned\nright so one is if we actually get to\nthe target amount that we're looking for\nremember we're passing in two variables\nthe index and the amount a if we get to\nthe target amount then we're going to\nreturn one if we go over the target\namount that's that means we cannot\npossibly sum up to the amount we return\nzero if we go out of bounds meaning i is\nout of bounds right that basically means\nnow we we decided that we don't have any\ncoins available to us uh that's going to\nbe we're going to return zero as well in\nthat case uh and the fourth base case is\nif we've already computed this if we've\nalready computed it we can take it\ndirectly from our cache and then return\nit the other case is now this is the\nbase case or not the base case this is\nthe recursive case right you can see i'm\ncalling dfs twice one is where i'm\ncalling dfs is where we are choosing the\ncoin that is at index i in that case we\nleave i just as it is and then we say\nokay the new amount that we have is a\nwhatever the amount that we previously\nhad plus whatever coin happens to be at\nindex i right so we're choosing the coin\nat index i that's one decision the\nsecond decision is if we skip the coin\nat index i in that case the amount stays\nthe same right we skipped a coin so we\ndon't change the amount but we do have\nto increment our index i because we're\nskipping this coin right now we're going\nto choose the next coin so that's the\nmain logic behind this and then whatever\nthe result of this happens to be we're\ngoing to go ahead and throw it into our\ncache and then return the value from the\ncache and so that's the entire dfs all\nyou have to do is call the dfs starting\nat index zero starting with our amount\nbeing zero and then we can just return\nthat result right up above now i've copy\nand pasted the dynamic programming\nsolution where we had to use two\ndimensions of memory so this is the same\nmemory complexity big o of n multiplied\nby m right this is the one that was\nsub-optimal for dynamic programming so\nyou can see i'm using two dimensions for\nthe dp cache and then the logic of this\nis pretty much the same as i showed\nright we're going to be going from\nstarting at amount equals one uh we're\ngoing to see how many different ways can\nwe sum up to that amount right and then\nour index i\nis uh going to be at the last coin so\nlength of the coins -1 where we only\nhave one coin available to us right i is\ngonna be uh decremented each time\nbecause we're gonna be adding more and\nmore available coins each time but so\nsuppose we had uh this many coins\navailable to us that's what i says and a\nwe're trying to sum up to this\nparticular amount what what is that\ngoing to be well one decision is if we\nskip the coin at index i which is just\ngoing to be dp of a uh with i plus one\nyou can see that this line of code is\nthe exact same if you look below this\ndfs is the exact same as this line of\ncode right you can see the parameters\nare the exact same right all i'm doing\nis passing in a i plus 1 here same thing\nhere right a i plus 1. now the other\ncase is going to be\nwith if we actually do use the coin at\nindex i right so we're going to take a\nminus uh coins of i\nwhy are we doing minus here instead of\nplus down here well you could do it you\ncan implement it how you want i did it\nlike this because\na is the target amount if we use this\ncoin then we have a certain amount left\nover now we're confirming that whatever\nthat amount left over is greater than or\nequal to zero because if it's negative\nthat means we went over right that means\nwe use too many coins so if this is\ngreater than or equal to zero then this\nline of code is just is completely\nanalogous to this dfs down here if you\ncan see it this dfs where we pass in i\nuh a plus coins of i you can see that\ninstead of passing a plus coins of i'm\ndoing a minus coins of i\nright but this is uh if you get confused\nby this i would recommend going back to\nthat two-dimensional grid that i was\nshowing you because this is exactly the\nsame as that now last but not least i\nhave went ahead and copy and pasted my\ncode for the solution where the memory\ncomplexity is actually just big o of n\nthe time complexity is the same as the\nabove solution but the memory complexity\nis less you can see that that's exactly\nwhat i'm doing here right we're not\nactually using the full\nmemory we're not using two dimensions of\nmemory we just have one dimension and\nyou can see just like in the\ntwo-dimensional matrix that i showed the\nmain difference between the above\nsolution and the below solution is just\nthe order that we're computing the uh\nthe two-dimensional grid right you can\nsee in this case the outer loop is we're\niterating through the amount and the\ninner loop is where we're iterating\nthrough the coins in the other case the\nouter loop is iterating through the\ncoins and the inner loop is iterating\nthrough the amount but other than that\nthe entire solution is pretty similar\nright like here you can see i'm pretty\nmuch just i have one row that i'm\nmaintaining out here and then i'm i'm\nusing next dp to be the next row that\nwe're computing and then at the end i'm\njust reassigning dp to be next dp right\nat any given point we're only going to\nhave two rows in memory we're not going\nto have an entire two-dimensional grid\nso i know this was really confusing and\nthis is probably a long video i wasn't\nable to spend as much time on the code\nas i would like but i hope that the\ndrawing explanation was able to help you\nout this code will be in the description\nif you want to take a look i guess let\nme just run it and prove to you that it\nworks so i'll run the code that is below\nwhich is the most optimal solution that\ni was able to come up with the time\ncomplexity is n by m and the memory\ncomplexity is of n you can see on the\nleft that it does work and it's pretty\nefficient so i hope that this was\nhelpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Target Sum",
        "NcLink": "target-sum/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "You are given an array of integers `nums` and an integer `target`.\n\nFor each number in the array, you can choose to either add or subtract it to a total sum. \n\n* For example, if `nums = [1, 2]`, one possible sum would be `\"+1-2=-1\"`.\n\nIf `nums=[1,1]`, there are **two different ways** to sum the input numbers to get a sum of `0`: `\"+1-1\"` and `\"-1+1\"`.\n\nReturn the number of **different ways** that you can build the expression such that the total sum equals `target`.\n\n**Example 1:**\n\n```java\nInput: nums = [2,2,2], target = 2\n\nOutput: 3\n```\nExplanation: There are 3 different ways to sum the input numbers to get a sum of 2.\n`+2 +2 -2 = 2`\n`+2 -2 +2 = 2`\n`-2 +2 +2 = 2`\n\n**Constraints:**\n* `1 <= nums.length <= 20`\n* `0 <= nums[i] <= 1000`\n* `-1000 <= target <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "g0npyaQtAQM",
        "PythonSolution": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        dp = {}  # (index, total) -> # of ways\n\n        def backtrack(i, total):\n            if i == len(nums):\n                return 1 if total == target else 0\n            if (i, total) in dp:\n                return dp[(i, total)]\n\n            dp[(i, total)] = backtrack(i + 1, total + nums[i]) + backtrack(\n                i + 1, total - nums[i]\n            )\n            return dp[(i, total)]\n\n        return backtrack(0, 0)\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem target sum we're given\nan array of integers called nums and\nwe're also given a single integer called\ntarget and basically for every single\nnumber in the array nums we can either\nchoose to add that number or subtract\nthat number and we must do that for\nevery single number we have to either\nchoose to add it or subtract it and then\nusing that we will have some\ntotal or some sum at the end of our\nyou know computation and basically we\nwant to know does that computation that\nsum that we have that total is it equal\nto the target value that we were given\nat the beginning right and not only that\nbut we want to count the number of ways\nthat we can get a sum from this array\nnums that will equal this target value\nand then we want to return how many ways\nwe were able to do that so in this\nexample you can see we're given an array\nnumbers of five consecutive ones and a\ntarget value of three and you can see\nall the different ways that we can sum\nup to that total value of three there\nare five different ways to do that right\nyou can see the first one if we subtract\nthe first one add the next one add the\nnext one add the next one and add the\nnext one we're able to get to three\nright basically four positive and one\nnegative that will give us a sum of\nthree you can see that the next example\nthe next way that we were able to do\nthat basically we subtracted the second\none added the first and then added the\nnext three the main thing though to note\nis that the order that you do these does\nmatter so if we can change the order of\nthe plus and minus symbols you know that\ncounts as a different way that we are\nable to total up to the target right so\nbasically we're we're counting\npermutations so this can be a complex\nproblem if you're not familiar with it\nso let's start off with the brute force\nsolution which is going to be 2 to the\npower of n and then let's see how we can\nactually optimize that into a more\nefficient solution so suppose we're\ngiven that same example that we just\ntalked about target of three and five\nones in the input remember for every\nsingle one of the values we have a\nchoice right we can either add it or\nsubtract it right and the best way to\nvisualize this for me is always using a\ndecision tree right so if we want to\nknow all possible ways we could you know\nenumerate this and all possible totals\nwe could get from this array a decision\ntree is the most helpful initially we\nstart at the index right we're keeping\ntrack of what index we're at right\ninitially we're going to be at the\nzeroth index we're going to keep moving\non and on as we make choices right to\nthe second third fourth index until we\nof course reach the end of the array\nanother thing we're going to be keeping\ntrack of what is our total so far right\nof course we want to know what our total\nis so far because by the time we reach\nthe end of the array we want to know is\nour total equal to the target value or\nnot so using this pair of values as our\nparameter to our recursive function\nwe'll get a decision tree that looks\nsomething like this initially we'll be\nat zero zero right index zero and our\ntotal will initially be set to zero we\ncan make a choice right we're at this\none over here right at the top left we\ncan either make a choice to add that one\nright plus one or\nminus one if we add the one then our\nindex is going to be at 1 because we're\ngoing to move to the next position right\nwe're going to be at this position now\nwhich is at index 1. and our total write\nthe second value we're keeping track of\nis also going to be 1 because we added a\n1. now if we did the opposite choice we\nwould still end up at index 1 but our\ntotal would be negative one right that's\nour second value over here and this\ndecision tree is actually going to be\npretty simple for us because all of the\nvalues in the input are one so basically\nevery single decision is going to look\nexactly like this one let me just kind\nof quickly draw it out to give you an\nidea okay so we kind of ran out of room\nso i won't draw the entire tree but just\nto show you a path a single path that\nwill lead us to the target so initially\nwe start at the the first spot right we\nadd the first one right so this is a\npositive right we're at one so far then\nwe go down this path where we said we\nminus one right then our total is at\nzero so minus one then we add one again\nwe're at index three total of one so\nplus one here then we add another one\nwe're at index four total of two\nand then we add a last one right the\nfifth one we add this as well that\nleaves our total exactly at three which\nis good and it puts us at index five\nwell index zero is here one here two\nhere three four five is exactly out of\nbounds so as soon as we go out of bounds\nwe're done right we've reached our base\ncase now we want to know is our total so\nfar which right now happens to be three\nis it equal to the target yes it's\nexactly equal to the target so now we're\ndone we found a single way that we could\nreach the target value right of course\nthere's going to be other dis there\nother paths in our decision tree that\nalso lead to the result but there's also\ngoing to be some paths that may be sum\nup to you know possibly one right if we\nsubtract two of them and then add three\nof them that'll leave us with a positive\none which is not equal to our target so\nin that case we won't count that but\nultimately we're going to count how many\ndifferent paths were able to lead us to\nthat target value now this is the brute\nforce of course this tree could have a\nheight of n and we obviously have two\nbranches each time uh right two\ndifferent paths for every single node so\nthat will put the time complexity at two\nto the power of n how can we optimize\nthis well the trick is going to be in\nthe parameters that we're passing into\nour recursive function right the index\nwhich we're maintaining and the total\nsum that we have as well using these we\ncan actually optimize this solution so\nwe can use the idea of caching to\noptimize this problem as with most\ndynamic programming problems so take a\nlook at the parameters we have the index\nwhich we're passing in and the total now\nhow many possible values could we pass\nin for the index value of course\nyou know the size of nums right so\nthat's how many would n is how many\npossibilities we could have for this\nindex how many different possible values\ncould we pass in for the total that's\ndefinitely a little bit harder to\ndetermine and the simple solution to\nthat is what's the the maximum total\nthat we could have from this array of\nnums in this case just add up all the\nnums it's 5 right 5 is the biggest\nnumber we could pass in for total and\nsince 5 is the biggest number we could\npossibly also you know if we subtract\nevery value we could get you know\npassing a negative 5 here right and\npotentially every value in between\npositive five and negative five not\nnecessarily though but possibly that's\nthe big idea here right since we're\ngoing for worst case time complexity\nwhich is big o time complexity we have\nto think about the worst case and\npossibly we could pass in every value\nbetween positive five and negative five\nso overall uh the way to think about how\nmany different values we could pass in\nfor the total is basically the total sum\nof the nums array right and let's just\ncall that t for simplicity so\nt\nuh n times t where t is the total number\nof values we could pass in or rather the\nsum of the entire array that's going to\nbe the overall time complexity if we\nperform caching using this pair of\nvalues so it's pretty easy to implement\ncaching once you have coded up the\nrecursive solution so we can now jump\ninto the code okay so now let's write\nthe code it's actually not too bad so\nremember we are going to be using a\ncache i'm going to call that dp it's\njust going to be a hash map in this case\nand we're going to be mapping a pair of\nvalues which is the index and\nthe total so far we're going to be\nmapping this pair of values to the\nnumber of ways that we can actually get\nto the target value if we start at this\nindex with this particular total value\nnow we can actually write out our\nrecursive function i'm just going to\ncall it backtracking and i'm going to\ndefine it in\nthis\nfunction let's just call it backtrack\ni'm going to define it nested inside of\nthis outer function so that we don't\nhave to pass in every parameter like dp\nlike nums and target into this function\nwe only have to pass an index and the\ncurrent total so far not too bad now\nremember\ni always like to start out with our base\ncase what's our base case is it it's if\nwe reach the end of the array so if i is\nequal to length of nums let me remain\nrename index to i just to keep things a\nlittle bit shorter so if we've reached\nthe end of the array then what are we\ngoing to do well we want to return 1 if\nour total is equal to the target value\nright if this is true then we can return\n1. if it's not true then we have to\nreturn 0 meaning that this is not a way\nto reach the target value so in python\nit's pretty easy to do that but you can\nuse a ternary operator in your language\nof choice and the other base case is\ngoing to be if we've already seen this\nbefore we've already seen this pair of\nindex total before then that means it\nmust exist in our cache because that's\nwhat we're going to be doing as we\ncompute these we're going to be caching\nthem so if it exists in our cache well\nwhich we can check like this if it's in\ndp then we can just return\ndp at index i and this total value if\neither of those base cases does not\nevaluate to true then we get to the fun\npart the recursive part which is\nactually going to be pretty easy because\nwe don't need any loops or anything like\nthat we can just you know determine the\nanswer for this uh pair of values this\nindex total and how are we going to do\nthat we're going to of course call our\nrecursive function backtrack and\nremember we really had two choices that\nwe could make uh one choice was to add\nthe value at index i right if we do that\nthen the or the next index we're going\nto be passing is just going to be i plus\n1 right we're going to be doing that no\nmatter what regardless of whether we add\nor subtract the value but this for the\nsecond parameter for the total parameter\nwe're going to pass in the current total\nplus nums of i that's if we're adding\nthis now we could do the exact same\nthing if we're subtracting it so let's\ndo that on the next line i'm going to do\na plus sign because then when we go to\nthe next line we want to put the\nopposite instead of adding this we're\ngoing to be subtracting nums of i the\nindex though stays the same i plus 1. so\nif we take these two function calls add\nthe results together that will tell us\nhow many possible ways starting at index\ni and with this total that we could sum\nup to the target value right if we add\nthese together then we can store them in\nour cache and then we can just return\nthe result turn dp of index i\nand total so then we're good to go we\nhave a completed our recursive function\nit really is that simple you just have\nto worry about the base cases and the\nrecursive case which in our case was\nsimple it's just two decisions pretty\nsimple then we of course have to\nremember to actually call our\nbacktracking function i always forget\nthat so we're going to start at index\nequals 0 and our total initially is also\ngoing to be zero\nthen we can return the result of this\nfunction in our outer function and then\nwe're done right this is the answer they\nwere looking for we returned it let's\nrun it to make sure that the code works\nand as you can see on the left yes it\ndoes work and it's pretty efficient so i\nreally hope that this was helpful if it\nwas please like and subscribe it\nsupports the channel a lot consider\nchecking out my patreon where you can\nfurther support the channel if you'd\nlike and hopefully i'll see you pretty\n"
    },
    {
        "Name": "Interleaving String",
        "NcLink": "interleaving-string/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "You are given three strings `s1`, `s2`, and `s3`. Return `true` if `s3` is formed by **interleaving** `s1` and `s2` together or `false` otherwise.\n\n**Interleaving** two strings `s` and `t` is done by dividing `s` and `t` into `n` and `m` substrings respectively, where the following conditions are met\n\n* `|n - m| <= 1`, i.e. the difference between the number of substrings of `s` and `t` is at most `1`.\n* `s = s1 + s2 + ... + sn`\n* `t = t1 + t2 + ... + tm`\n* **Interleaving** `s` and `t` is  `s1 + t1 + s2 + t2 + ...` or `t1 + s1 + t2 + s2 + ...`\n\nYou may assume that `s1`, `s2` and `s3` consist of lowercase English letters.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fc30feb8-d898-4b9f-3667-4e2c98a1a900/public)\n\n```java\nInput: s1 = \"aaaa\", s2 = \"bbbb\", s3 = \"aabbbbaa\"\n\nOutput: true\n```\n\nExplanation: We can split `s1` into `[\"aa\", \"aa\"]`, `s2` can remain as `\"bbbb\"` and `s3` is formed by interleaving `[\"aa\", \"aa\"]` and `\"bbbb\"`.\n\n**Example 2:**\n\n```java\nInput: s1 = \"\", s2 = \"\", s3 = \"\"\n\nOutput: true\n```\n\n**Example 3:**\n\n```java\nInput: s1 = \"abc\", s2 = \"xyz\", s3 = \"abxzcy\"\n\nOutput: false\n```\n\nExplanation: We can't split `s3` into `[\"ab\", \"xz\", \"cy\"]` as the order of characters is not maintained.\n\n\n**Constraints:**\n* `0 <= s1.length, s2.length <= 50`\n* `0 <= s3.length <= 100`\n",
        "Difficulty": "Medium",
        "Video": "3Rw3p9LrgvE",
        "PythonSolution": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for i in range(len(s1) + 1)]\n        dp[len(s1)][len(s2)] = True\n\n        for i in range(len(s1), -1, -1):\n            for j in range(len(s2), -1, -1):\n                if i < len(s1) and s1[i] == s3[i + j] and dp[i + 1][j]:\n                    dp[i][j] = True\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\n                    dp[i][j] = True\n        return dp[0][0]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve interleaving string so in\nthis problem we're given a list of three\nstrings well not really a list but we're\ngiven three strings s1 s2 and s3 and we\njust want to know a simple question can\nwe form the string s3 by interleaving\nthe strings s1 and s2 an interleaving\nstring is basically when you take two\nstrings and split them up into you know\nsub strings and then you add them\ntogether now they have a description\nover here but i kind of feel like this\ndescription actually just made things\nmore complicated for me like with the\nabsolute value difference being at most\none you know taking these strings\nforming them together basically what\nwe're saying is can we take\nthe string\none and string two split them into sub\nstrings like you can see a string one is\nsplit into this one this one and this\none and notice how the relative order of\nthese three is maintained that's very\nimportant and this other string was also\nsplit into two portions this one and\nthis one and the relative order of the\ncharacters was maintained you can see\nthat this\ndbc goes in the front and the a goes at\nthe end so the relative order is\nimportant but that's it we can split the\nstrings in any way that we want and then\nadd them together and we just want to\nknow doing that can we form the third\nstring so the first thing you might\nnotice is well if we're taking the\nstring splitting them of course the\ntotal number of characters has to match\nthe total number of characters in string\nthree and yes that's true it will have\nto match and in this case it does we\nhave ten characters and the output in\neach of these strings is five five plus\nfive equals ten so once you kind of\nunderstand what an interleaving string\nactually is the logic of this problem\nisn't too complicated right for example\nwe see that the first character in\nstring three is a right so for sure we\nneed at least one of the characters from\ns1 or s2 to start with an a right\nbecause we can't just take an a from the\nmiddle of one of these strings and then\nsay okay we'll put that at the beginning\nbecause remember the relative order of\neach of these strings has to be\nmaintained so at least one of them has\nto start with an a and we can see that\nthe first string over here does start\nwith an a right so it's kind of brute\nforce we're just comparing the first\npositions of each of the charac of the\ninput strings right so now we have a d\nand we can choose between an a and a d\nin either of the strings but we're\nlooking for an a in the target string so\nwe're going to again pick from the first\nstring and we can cross that out so now\nwe have another sub problem we have the\nremaining portion of this and the and\nthe entire portion of this string right\nso and we're kind of just brute forcing\nit obviously if we got to a character\nsuch you know let's say at this position\nwe had a z but you know when you look at\nboth of the strings that we have neither\nof them have a z in that case it would\nbasically mean it's impossible for us to\ncontinue at this point but what if we\nhad the opposite what if we had a b over\nhere and you can see that this position\nis also a b right and let's say we were\nlooking for a b right so then which one\nof these are we gonna take are we gonna\ntake the b from string two or the b from\nstring one that's the back tracking or\nthe brute force portion right we could\ntake either of them so we pretty much\nhave to make a decision in our decision\ntree that we are gonna choose both we're\ngoing to see if we do it either of these\nways is it possible for us to take these\ntwo strings interleave them together to\nbuild the output string right because\nmaybe one of the ways works but the\nother way doesn't we do have to try both\nof the ways but it turns out we can use\na dynamic programming technique called\ncaching where we can eliminate a bunch\nof repeated work so therefore the time\ncomplexity of the solution can actually\nbe broken down to m times n where m is\nthe size of one string and n is the size\nof the other string and you can actually\ninstead of doing caching you can\nactually do a true dynamic programming\nsolution that will also give you this\ntime complexity i'll explain a little\nbit about both of those so let me just\nkind of show you what the decision tree\nfor this problem would look like and\nthen how we're actually going to do the\ncaching so notice how we're going to\nstart at the beginning of both of the\nstrings and we're also going to start at\nthe beginning of the third string right\nwe're looking for this character can we\nget it from either of string one or\nstring two right so that's kind of how\nour decision tree is gonna work we're\ngonna have one pointer let's call it i1\nwhich is going to represent what\nposition we're at in s1 and we're gonna\nhave another pointer let's call it i two\nit's a little bit messy but i2 is gonna\nrepresent the position we're at in\nstring two and we're gonna have a third\npointer over here let's call it i3 right\nbut do you notice that this pointer is\nalways going to be the addition of i1\nand i2 if we add these pointers together\nwe're always going to get this one right\nbecause notice how you know they're both\ninitially at zero right zero plus zero\nis going to equal zero which is the\nfirst one here if we increment one of\nthem right if we take this pointer and\nshift it over here this is gonna be one\nso we're gonna take one plus zero add it\ntogether and we're gonna get at the\nposition one which is gonna be over here\nand that makes sense because if we use a\ncharacter from here that's gonna take up\nthe character that's over here so that's\nkind of how the math works out so in\nreality we just have to keep track of\ntwo pointers the third pointer can be\ncalculated for the position of this\nstring so we start at the position zero\nzero the first zero indicates what\nposition we're at over here second\npointer indicates where we're at over\nhere\nand we're going to compare so does this\nequal this character of course it does\nwrite d does not equal a but a equals a\nso we can shift our pointer over here\nand shift our pointer over here so in\nthis case we didn't have to make two\ndecisions we just had an easy job we\njust had to make one decision so let's\ncall that uh one zero because we shifted\nour first pointer to the position one\nand now i'm going to go kind of fast\nbecause i think you probably get what\nwe're going to do so once again this is\nthe character\nthat matches in string three so we can\nshift both of our pointers to the next\nposition and once again we incremented\nthe first pointer so we're going to be\nat two\nzero and in this case b does not match d\nbut this character does so once again\nlet's shift our pointers by one and in\nthis case we shifted the second pointer\nso let's call that two\none i don't really know why i'm drawing\nthe decision tree like this but let's\ncontinue so in this case you can see\nwe're looking for a b and we can get a b\nfrom this one or from this one right so\nthat's gonna be two different decisions\nwe finally have two different decisions\nwe can either do three one or we can do\ntwo\ntwo depending on how we do it so this is\nkind of where the complexity is going to\ncome right and the worst case would be\nthat we could make two decisions every\nsingle time so you can see that if we\ncontinue drawing this out the worst case\ntime complexity for a particular uh\ndecision tree could be 2 to the power of\nn plus m basically the total number of\ncharacters that we have but you can see\nthat we might be repeating the same sub\nproblem multiple times right how many\ndifferent possible pairs of values could\nwe even have like this well we could\nonly have n different values in the\nfirst position we could have m different\nvalues in the second position that's\nwhere the time complexity n by m comes\nfrom so we can do this by caching i'm\ngoing to show you how we can do that in\nthe coding portion so this will make\nsure that we have this many sub problems\nand if we repeat the same sum problem we\ncan just do it in o of one time because\nwe're going to be caching the result of\nthat now what exactly is the value that\nwe're going to be caching well for any\nparticular sub problem like for either\nof these branches we want to know\nultimately from here are we actually\nable to form the remaining portion of\nthe result string so either it's going\nto be true or false right we're not\nstoring a value like a number or\nanything we're going to be storing true\nor false for any of these and actually\nif we find a single true then we don't\nhave to cache it because if we find a\nsingle true that means we are able to\nform the result string and then we can\nimmediately return true by going back up\nto the root that we called this\nrecursive function from so we discussed\nthe memoization solution but let's go\nover the true dynamic programming\nsolution which is going to be pretty\nsimilar to what we just talked about so\njust to quickly go over what was the\nbase case in our recursive solution that\nwe went over well what what would happen\nif let's say the the last uh pointer in\nthe first string reached this position\nout of bounds and the pointer of string2\nreached this position that would mean if\nwe added them together we would get to\nthe out of bounds position in s3 right\nso basically if both of the pointers\nbecome out of bound that's how you know\nwe have reached the base case and in\nthat case that means we built the\nresulting string and we can return true\nso when we go over to the dynamic\nprogramming solution take a look at this\ngrid that i've drawn you might recognize\nthis as a regular dynamic programming\ngrid this is string one this is string\ntwo we multiplied them together because\nremember it's m by n that's what our\ncache is going to look like so i'm\nbasically drawing what the cache looks\nlike but you can see that this is the\ndimensions but i have one extra layer\nout here which is important in this\nproblem remember what i just said if\nthis if we're out of bounds in this\nstring and we're out of bounds in this\nstring that's going to lead us to this\nposition so that's our base case we want\nto initialize this with a t for true and\na particular value in this grid for\nexample this one means that let's say we\nhad this remaining portion of the string\nand we had this remaining portion of the\nstring you can see that both of these\ntogether form a str form two different\ncharacters right two characters in total\nso what we're asking is if you look at\nthe last two characters in our resulting\nstring we want to know can these two\ncharacters a and c form this string\na c right that's the target string that\nwe're looking for can these two\ncharacters form it of course by looking\nat them you can tell yes they can form\nthis string right but that's basically\nwhat we're going to be computing we're\ngoing to be doing that for every single\ncell in this 2d grid and yes we're even\ngonna have to calculate these out of\nbounds positions why is it that we have\nto do that because they're actually\nvalid positions take a look at this\nposition this means if we had zero\ncharacters from string one but we had a\nsingle character from string two meaning\nyou know the character a can we form the\nlast character of the target string well\nthe last character on the target string\nis c\nthis character is a so therefore we\ncan't do that right so we have to put a\nfalse over here and similarly from this\nposition we're looking at just these\nlast two characters c a using these\ncharacters can we form the target string\na c you might think yes but no we can't\nbecause remember the relative order of\nthese characters has to match this first\ncharacter c has to match this character\nbut it doesn't so this is also going to\nbe a false right and of course we would\ndo the same thing for this position\nright computing this if we had a c from\nhere but we had nothing from here in\nthat case this is actually going to be a\ntrue because we have a value here for an\narbitrary position like this let me just\nshow you what's going to happen\nobviously this mat this is a b here and\nwe have a b in this portion as well so\nif we take the indices of these which is\ntwo plus two we get to index four in our\ntarget string which is this target\ncharacter right we're looking for a b\nnow notice how either of these can get\nthere if we used the b from\nthis position\nlike this b what would we do in that\ncase well then we'd want to know okay we\nif we were able to get a b now does the\nresult in the bottom position equal true\nwhy are we looking in the bottom\nposition because we just used this b so\nwe can't use it again we have to use\nthese last two characters but we can use\nthis first b if we want to because we\ndidn't use it yet so in that case we\nwould go down in the opposite case if we\nused this b we cross it out we can still\nuse this one but we can only use two\ncharacters from here so in that case we\nwould go to the right now if either of\nthese in this case we can go in both\ndirections if either the bottom neighbor\nis true or the right neighbor is true\nthen we can put true in this position if\nthey were both false then we can't put\nfalse if only then we can't put true if\nonly one of them was true then we can\nalso put true now let's dive into the\ncoding portion so in the interest of\ntime i'm just going to skip and show you\nwhat the memoization recursive solution\nlooks like and then we're going to code\nup the dynamic programming solution so\nwe do have a cache in this case it's\ngoing to be a hashmap and you can see\nwe're passing in two pointers into our\nfunction just like we did in the drawing\nright and our base case is yes if i and\nj are out of bounds then we can return\ntrue that's one base case another base\ncase is if this position has already\nbeen computed meaning it's already in\nthe dynamic programming cache then we\ncan just return the result now if that's\nnot the case then we have to go into our\nrecursive case you might not be able to\ntell but yes this is recursion because\nwe're checking if i is still in bounds\nright because technically one of the\nstrings could be out of bounds so if i\nis in bounds then we're gonna check does\nthe character in string one i basically\nis the pointer for string one does that\ncharacter match the target position\nwe're looking at in string three like i\nsaid we're taking i plus j the two\npointers adding them together to find\nthe target character in string three so\nif the characters match then we're gonna\ntake i and increment it by one right\nwe're incrementing it by one because\nwe're saying we just used the character\nfrom string one now the next two lines\nof code are the exact opposite if the\nstring if the character if the pointer\nin string two is inbounds and that\ncharacter in string two matches the\ntarget character then we're gonna take\ndfs and increment j by one saying we\njust used the character in string two\nand if that returns true then we can\nreturn true in either of these cases we\ndon't have to cache that because if we\nfind one valid result then we can\nimmediately return true from the root\nfunction if neither of them return true\nthen we have to dp cache this as false\nand then return false because we don't\nhave to repeat the work again so that's\nthe entire function i bet it's a little\nbit easier than you expected and then\nall we have to do is call dfs starting\nat the beginning of both strings 0 0. so\nnow let's do the dp portion and the\nfirst thing i'm going to do is just make\nsure that the length of the strings add\nup to the length of the target string so\nif length of string two and string three\nadd up to the length of string one then\nwe can return\nfalse if they don't add up let me make\nthat correction if they don't add up\nthen we return false otherwise we can\ncontinue so otherwise we can actually uh\nbasically so otherwise we can initialize\nour dp two-dimensional array i'm just\ngoing to copy paste that in the interest\nof time so remember we're just gonna\ninitialize this as basically empty in\nother words we're gonna initialize\neverything as false and the dimensions\nare going to be basically the length of\nstring one and string two plus one\nremember because we do need that outside\nlayer so that's just what this is doing\nyou could do this differently in other\nlanguages and for the out of bounds\nposition like the out of bounds position\nin both strings string one and string\ntwo we want to initialize that corner\nvalue as true remember just like in the\ndrawing position the drawing picture and\ni don't know if i mentioned this in the\ndrawing but we are going to start at the\nbottom right corner and then work our\nway to the left and then work our way up\nrow by row so that's what these two are\nuh these two for loops are indicating\nit's a nested loop we're starting at the\nbottom right working our way to the top\nleft now the rest of this code is\nactually going to be very much borrowed\nfrom what we just did in the recursive\nsolution so i'm actually just going to\ncopy and paste these two lines to show\nyou it's actually very similar to the\nrecursive solution so what exactly do we\nneed to change the same thing is true if\ni is in bounds because remember one of\nthese strings could be one of these\npointers could be out of bounds because\nwe are uh computing some of those\nout-of-bound corner positions right so\nif i is still in bounds then we want to\ncheck okay does that character equal to\nthe target character we're looking for\nif it does we don't want to compute dfs\nright but we want to know if the result\nof this is true but we can do that from\nour dp right we're not doing recursion\nwe're just using our dp value and since\nwe're computing this bottom up we know\nthat the result of this will already be\ncomputed so instead of saying dfs let's\nchange this to dp of i plus 1\nand j\nso if this happens to be true then what\nare we going to do we're not going to\nreturn true right because we're not\ndoing this recursively we're going to\nset dp of i and j whatever we're\ncurrently at in this for loop and then\nset it equal to true right again for\nthese bottom two lines we're going to do\nthe exact same so instead of calling dfs\nif j is still in bounds and the\ncharacter at j equals the character\nwe're looking for we're not going to\ncall dfs we want to know is dp of these\ntwo pointers still\ntrue so we're going to say i dp of i and\ndp of j plus 1. if that's true then we\ncan set our dp position to true it's\npossible that both of these if\nstatements will execute that isn't a\nproblem for us right we'll set it to\ntrue either way now if neither of these\nif statements executes we want to set\nour dp position equal to false but\nnotice how we already initialized the\nentire 2d grid to false right so we\nactually don't need to do that third\ncondition\nand i know i kind of pretty much just\ncheated by copy and pasting a bunch of\nthis but that's the entire code i'm not\nkidding so once you do that\nnested for loop we can just return the\nresult of dp at position zero zero\nthat's the entire code so yes this\nsolution works it's efficient and we\njust and i just showed you how to solve\nit in two different ways so i hope this\nwas helpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Longest Increasing Path In a Matrix",
        "NcLink": "longest-increasing-path-in-matrix/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "You are given a 2-D grid of integers `matrix`, where each integer is greater than or equal to `0`. \n    \nReturn the length of the longest strictly increasing path within `matrix`.\n\nFrom each cell within the path, you can move either horizontally or vertically. You **may not** move **diagonally**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c302dea2-1695-4edb-e1b3-91e96d9bb700/public)\n\n```java\nInput: matrix = [[5,5,3],[2,3,6],[1,1,1]]\n\nOutput: 4\n```\n\nExplanation: The longest increasing path is `[1, 2, 3, 6]` or `[1, 2, 3, 5]`.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/72004ec9-6f68-464c-93c1-0ba0b384c700/public)\n\n```java\nInput: matrix = [[1,2,3],[2,1,4],[7,6,5]]\n\nOutput: 7\n```\n\nExplanation: The longest increasing path is `[1, 2, 3, 4, 5, 6, 7]`.\n\n**Constraints:**\n* `1 <= matrix.length, matrix[i].length <= 100`\n",
        "Difficulty": "Hard",
        "Video": "wCc_nd-GiEc",
        "PythonSolution": "class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        dp = {}  # (r, c) -> LIP\n\n        def dfs(r, c, prevVal):\n            if r < 0 or r == ROWS or c < 0 or c == COLS or matrix[r][c] <= prevVal:\n                return 0\n            if (r, c) in dp:\n                return dp[(r, c)]\n\n            res = 1\n            res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))\n            res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))\n            res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))\n            res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))\n            dp[(r, c)] = res\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, -1)\n        return max(dp.values())\n",
        "Transcript": "welcome back and let's write some more\nneat code today so today let's solve the\nproblem longest increasing path in a\nmatrix and while this is a hard problem\ni would definitely say it's one of the\nmore doable hard problems there's\nnothing crazy involved but it is\nsomewhat difficult we're given an m by n\nmatrix\nthat is filled with integers and the\nintegers are going to be i believe zero\nor greater than zero so mostly positive\nintegers and we want to return the\nlength of the longest increasing path in\nthis matrix and we are allowed to move\nonly in four directions left right up or\ndown we're not allowed to move\ndiagonally and of course we can't go\noutside of the boundaries so let's just\nstart with some observations first of\nall this is an example and you can see\nthat this is the path that is the\nlongest it's of length four and it's in\nincreasing order obviously we can start\nwith pretty much any value right and\npretty much starting at any position we\ncan create a path of at least length one\nright this is a path of length one this\nis a path of length one uh but you know\nstarting from here then the next\nposition that we go to is a two it has\nto be greater than one which it is and\nthen the next one is six that's greater\nand then nine that's also greater but\nfrom here uh we can't really go anywhere\nelse right we're allowed to move here uh\nbut this one is not greater than nine\nit's just exactly nine so that's the\nlongest path now one thing you might be\nwondering is can we you know reuse the\nsame value multiple times right what if\nwe have a loop of some kind well just\nthink about it for a second if this is\nan increasing path of course we can't\nreuse any values because take a look at\nour path right you know the value that\nwe get to is going to be greater than\nall the previous values anyway so how\ncould we possibly reuse any of the\nvalues in our path we're not allowed to\nnow they don't state that in the problem\nstatement but that's an observation that\nyou have to make on your own and in this\ncase you know that's true and another\nobservation we can make without even\ntrying to understand you know what's the\nalgorithm we'd use for this problem just\nby looking at this example we can make a\nvery important observation and that is\nthat if this is the longest increasing\npath and it's of length four that means\nthe longest increasing path starting at\nthis position is going to be of length\nfour but what about the longest\nincreasing path starting at this\nposition over here what is it going to\nbe in this case we can see that there is\na path right now starting from it that's\nincreasing that's of length three is\nthere going to be any paths starting\nfrom this position that are gonna be\nlarger than three of course not because\nif there were wouldn't this entire path\nbe longer than four if we found a path\nan increasing path starting from this\nposition that was not three but it was\nactually four then you know let's say it\nlooks something like this right uh then\nof course the longest increasing path\nfrom here would be five now what i'm\nsaying might not make sense to you just\nyet but now let's actually understand\nhow we can approach the solution to this\nproblem and then i bet it will make\nsense now let's think about this what's\nthe most basic brute force way that we\ncould find the longest increasing path\nwell we could basically start at every\nsingle position and say maybe the\nlongest increasing path will start here\nmaybe it'll start here maybe it'll start\nhere right who knows\nthey don't tell us where we have to\nstart so we pretty much have to try\nevery single position that's the brute\nforce and let's say we you know record\nthat in a grid that's the same size as\nthe grid we have here i'm going to call\nit lip for longest increasing path and\nonce we do that once we've filled up\nevery value in here we can just take the\nmaximum of them and then return that\nthat'll be the length of the longest\nincreasing path okay so for any\nparticular position how do we find the\nlongest length well the brute force\nagain is just going to be a simple dfs i\nhope you're familiar with the dfs\nalgorithm it's a pretty standard graph\nalgorithm and you definitely will need\nit for hard level problems we're going\nto run a dfs starting from this position\ngoing in four directions right up down\nleft right of course if we go out of\nbounds to the top or to the left or any\nother direction we're not going to\ncontinue there of course okay so we\ncan't go out of bounds let's try going\nright starting from here are we allowed\nto go here well we have to compare the\nvalues right we have to look at this\nvalue is it greater than the previous\nvalue it's not greater than the previous\nvalue so we can't go here right we're\nnot allowed to go there starting from\nhere okay let's try going down that's\nthe only position left that we have it's\na six that's also not greater than nine\nso we can't go there either uh so we're\npretty much uh not allowed to go\nanywhere so what's the length uh from\nhere it's one because remember\none is basically like the default value\nwe can always have a length of one\nstarting at any position okay so we did\nthat now let's go to the next position\nsimilarly we're not allowed to go in any\nof the four directions because none of\nthem have a greater value so we'll also\nput a one here okay now let's try the\nfour and this is where things are going\nto get interesting so pay attention we\ncan't go up we can't go to the right but\nwe can go to the left\nand finally we see a value that's\ngreater than the original 9 is greater\nthan 4 so we are allowed to go here\nthat's awesome\nbut now\nwe're doing dfs does that mean\nrecursively we're going to run dfs on\nthis position again well we don't have\nto because we already ran dfs on this\nposition and we already found the\nlongest increasing path starting from\nthat position the length of it is one so\nwe don't have to repeat that work\nbecause we stored the repeated work\ninside of this matrix so we know that\nstarting from four we can go to this\nnine and that's a path of length two\nthat's at least one path that we can\ncreate okay we do have one more\ndirection to try though we can from four\nwe can go\ndown to the a we haven't ran dfs on this\nposition yet so we're gonna have to do\nthat now dfs okay let's go to the right\nthat's out of bounds okay let's go up\nshould we even go up well in reality we\nshouldn't but if our algorithm is\nprogrammed to try going up it'll still\nwork for us because of course we came\nfrom the 4 so we know that the value up\nabove is less than eight so if we try\ngoing up it's not going to work anyway\nso it's okay to leave that in the code\nbecause it's not going to break anything\nso that's good for us because it keeps\nour dfs pretty simple okay now let's try\ngoing down we can't go down because one\nis less than eight we want it to be\ngreater than eight let's try going to\nthe left okay six is also less than\neight we want it to be greater than\neight okay so we couldn't go anywhere\nbut we'd still uh\nof the two paths both of them were the\nsame length so we can put a two here uh\nstarting from this position the longest\nincreasing path is length two but did we\ndo anything else well we started at the\neight we ran dfs from this position so\nnot only did we determine that the the\nlip from here is two but we also\ndetermined that the lip from eight is\none because we couldn't go anywhere\nstarting from eight are you starting to\nsee how this algorithm itself even the\ndfs brute force is not inefficient\nbecause we're caching the work we're\nstoring the work in a matrix so this\nisn't even a brute force solution as\nlong as you implement it correctly it's\nactually very efficient as long as we\ndon't repeat the work so now when we\nwe're not we're not quite at the eight\nyet right because we're going in order\nin our uh matrix but once we get to the\neight we'll know we already ran dfs on\nit and we won't have to repeat that work\nso now that you're probably starting to\nget the idea i'm going to start fast\nforwarding through this explanation so\nnow let's run dfs starting from the six\nwe try going left can't we try going\nright we can't we try going down we also\ncan't do that we try going up okay we\ncan do that and we know that we already\ncomputed the lip from here it's one so\nwe can say the lips from starting at six\nis going to be two now let's go to the\nsecond six we can't go left it's less\nthan six we can't go down it's also less\nthan six we can go to the right uh we\nalready computed the lip from here so we\nknow that this will be a path of length\ntwo we know that because uh we're just\ngoing to take the value here that we\ncomputed and just add it to uh you know\none from here so\nthat's uh one possibility we could also\ngo up we already computed the lip from\nup it's also one so basically we have a\ntie right and that tie is going to be of\nlength two so we can put a two in this\nposition and then when we get to the 8\nwe're going to try running dfs on it but\nbefore we do we're going to see we've\nalready computed it so we don't repeat\nthat work uh starting from 2 we only\nhave two possibilities can't go to the\nright but we can go up above and up\nabove we're not going to rerun dfs on\nthis position because we already\ncomputed it over here it's length two so\nwe can say the lip starting from this\nposition is one plus the two value\nthat's above it so it's going to be\nthree and same here we can try going up\nuh which will be one plus two because\nthe value up above it is two we can try\ngoing to the right that's not gonna work\nwe can we can't go down but we can go to\nthe left and that's gonna be one plus\nthree of course one plus three is\ngreater than one plus two so uh the\nvalue we're going to put here uh in our\nlip is gonna be four and uh fast\nforwarding this i think this is gonna\nlook up above and then that's just gonna\nbe one plus one so we're gonna put a two\nhere and then we're going to take the\nmax from our lip which is of course 4\nand we're going to return 4. we don't\nactually have to return the path itself\njust the length of it in this case which\nis 4. okay so that's the solution and\nit's pretty efficient but how do we know\nit's efficient what's the time\ncomplexity of course the memory\ncomplexity is big o n times m those are\nthe dimensions of the matrix because\nwe're using extra space here but what's\nthe time complexity it's also big o of n\ntimes m now how do i know that i don't\nknow how quickly i can give you like a\nformal proof of it but let's just think\nabout the intuition behind it let's say\nour matrix was in such a way that when\nwe ran dfs at the first position we you\nknow had a path such like this and then\nwe went here and then we went there then\nhere then here then here basically we\nvisit the entire matrix in one dfs\nthat's going to take big o of n times m\nto run that dfs but the good thing about\nthat is going to be after we've done\nthat we're going to have computed every\nlip from every single position right and\nthen when we visit the remainder\nremaining values of the matrix each of\nthose is going to be computed in big o\nof one time so you know having done the\nrepeated work at the beginning wasn't\nsuch a big deal because the remainder is\ngoing to be very easy or in the worst\ncase maybe starting from each position\nlet's say they're all the same exact\nvalue right let's say each of them was\nexactly nine in that case we wouldn't\nreally run dfs on any of them well we\nwould try to but we'd see that we can't\ngo in any of the four directions so for\neach of these in that case as well the\ntime complexity would be big o of one\nwhich means the overall time complexity\nwould be n times m once again so i hope\nyou're kind of getting the intuition\nbehind why this is an efficient solution\num and with that being said let's\nfinally jump into the code okay so now\nlet's code it up and i'm sure you know\nthat i like to write these kind of\ntwo-dimensional graph problems uh matrix\nproblems in a very formulaic way and\ni've done it so many times that actually\ndon't even have to think about it i\nalways do this i always take the\ndimensions of the matrix put it in some\nstatic variables rows and columns\nbecause we know we're going to run dfs\non this so we're going to need to know\nthose dimensions in this case we're\ngonna have a two-dimensional matrix or\ncache i'm gonna call it dp and i'm\nactually gonna set it to be a hash map\nbecause it's pretty easy to do that in\npython uh we can use two values to\naccess this right and those the key\nvalue is basically going to be row\ncolumn which is going to map to the lip\nthe longest increasing path now of\ncourse you could just use a\ntwo-dimensional matrix if you're doing\nthis in java or whatever if you want and\nmaybe i honestly should do that as well\nbut i'm really used to doing it this way\nbecause you can kind of just turn your\nbrain off\nand next we're going to use\ndfs we have a function inside of a\nfunction so we don't have to pass in\nevery variable such as these three that\ni defined up above but we are going to\npass in the position that we're\ncurrently visiting which is the row\ncolumn coordinate and we want to make\nsure that the pass the path is an\nincreasing order so we are going to pass\nin what the previous value ends up being\nand then with all uh you know graph\ntraversals the first thing you want to\ncheck is did we go out of bounds is the\nrow less than zero or is the row exactly\nequal to the number of rows which means\nit's too big um or\nsame exact thing with the column is\ncolumn less than zero or is column equal\nto the number of columns because that\nmeans it's too big and the last\ncondition in this case is going to be is\nthe path not increasing how do we know\nthat well the value that we're currently\nvisiting which is the matrix at the row\ncolumn position is\nless than or equal to the previous value\nthat means it's not increasing and if\nit's not increasing then we are just\ngoing to return we can return zero just\nto say that the increasing path was just\nzero okay so that's one base case and\nthe second base case is a little bit\neasier that's if we already computed the\nlip at this position rc and if this and\nwe know that because if this is in our\ndp hash map as a key value then we can\nreturn whatever the length of it was\nthat we computed and ended up storing in\nour dp cache so there we go okay now to\nactually compute the length we're just\ngoing to call it result and initially\nset it to 1 because we know it's at\nleast going to be one that's the minimum\nit could possibly be and now we could\nuse a loop to go through all four of the\ndirections but i don't think it's really\nnecessary we can just kind of copy and\npaste the same line like four times i\nprefer doing that rather than doing a\nloop but you can do what you prefer so\none we know we're going to\nrun dfs right we're going to run dfs on\none of the neighboring positions one of\nthem could be r plus one\nand then the column is the same and what\nis going to be the previous value that\nwe passed and of course it's going to be\nthe current value right now so row\ncolumn and we only want to update the\nresult if this is greater than the\nresult so what we want to do is set this\nequal or actually this alone is not\ngoing to be the length because this is\ngoing to tell us the longest increasing\npath starting at row plus one and if\nthat's the case what we actually want\nthe length to be is from this position\nthat we're currently at so we're going\nto take this\nand add 1 to it 1 plus that similar to\nhow i was doing it or i was talking\nabout it in the drawing explanation okay\nso once we have that then we want to\ntake the max of the current\nmaximum result maximum length and the\nmax of this and then you know update it\naccordingly and this is where we copy\nand paste uh four times because we want\nto go in all four of the directions so r\nplus one r minus one\nalso column plus one and column minus\none okay and when we're done with that\nthe last thing we have to do is now that\nwe've actually computed the lip starting\nat this position we want to make sure to\nactually throw it into our dp cache so\nlet's do that before we end up returning\nso let's store that and then once we've\nstored it we can go ahead and return it\nso then the next time if we ever call\ndfs starting from the same position\nwe'll end up returning it from our cache\nrather than redoing the dfs so that's\nwhere we're saving our time now that\nwe've defined our dfs all that's left is\nto actually call it and remember we want\nto run dfs starting from pretty much\nevery single position in the grid so we\ncan do a nested for loop to do that so\ngo through every row go through every\nsingle column when we do that we also\nwant to run dfs on every\ncoordinate and what's the previous value\nthat we're going to pass in for that\nwell we know that every value in the\nmatrix is going to be\nzero or greater than zero so a default\nvalue we can pass in for the previous\nvalue uh is negative one because we\nnever want this to return if we're\nlooking at like the first value right\nand so if we pass in negative one this\nuh comparison will never evaluate to\ntrue right none of these values is ever\ngoing to be less than negative one\nthat's good so that's why we're doing it\nlike this\nso\nonce we've done that\nwe're good to go the last thing we have\nto do is just return whatever the\nmaximum was so we can just take our dp\nvalues which will return a list of all\nthe values and just take the maximum of\nthat now we probably don't need to do it\nlike this like we could have just\nmaintained another variable over here\nmaybe i've just called it lip longest\nincreasing path and then just\ncontinuously updated it based on the\nmaximum that was returned you can do it\nhowever you want the time complexity is\nthe same even though we're iterating\nover the entire you know matrix again\npretty much by doing this that's the\nidea let's just run this to make sure\nthat it works and as you can see on the\nleft yes it does work and it's about as\nefficient as you can get for this\nproblem so i really hope that this was\nhelpful if it was please like and\nsubscribe it really supports the channel\na lot consider checking out my patreon\nwhere you can further support the\nchannel and hopefully i'll see you\n"
    },
    {
        "Name": "Distinct Subsequences",
        "NcLink": "count-subsequences/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "You are given two strings `s` and `t`, both consisting of english letters.\n    \nReturn the number of distinct **subsequences** of `s` which are equal to `t`.\n\n**Example 1:**\n\n```java\nInput: s = \"caaat\", t = \"cat\"\n\nOutput: 3\n```\n\nExplanation: Rhere are 3 ways you can generate `\"cat\"` from `s`.\n* (c)aa(at)\n* (c)a(a)a(t)\n* (ca)aa(t)\n\n**Example 2:**\n\n```java\nInput: s = \"xxyxy\", t = \"xy\"\n\nOutput: 5\n```\n\nExplanation: There are 5 ways you can generate `\"xy\"` from `s`.\n* (x)x(y)xy\n* (x)xyx(y)\n* x(x)(y)xy\n* x(x)yx(y)\n* xxy(x)(y)\n\n\n**Constraints:**\n* `1 <= s.length, t.length <= 1000`\n* `s` and `t` consist of English letters.\n",
        "Difficulty": "Hard",
        "Video": "-RDzMJ33nx8",
        "PythonSolution": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        cache = {}\n\n        for i in range(len(s) + 1):\n            cache[(i, len(t))] = 1\n        for j in range(len(t)):\n            cache[(len(s), j)] = 0\n\n        for i in range(len(s) - 1, -1, -1):\n            for j in range(len(t) - 1, -1, -1):\n                if s[i] == t[j]:\n                    cache[(i, j)] = cache[(i + 1, j + 1)] + cache[(i + 1, j)]\n                else:\n                    cache[(i, j)] = cache[(i + 1, j)]\n        return cache[(0, 0)]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve distinct subsequences this\nis another hard problem and this is\nactually going to be solved with dynamic\nprogramming it's very similar to some\nother dynamic programming problems\ninvolving subsequences particularly\nlongest common subsequence\nwhich is a problem that i've solved on\nthis channel before so if you struggle\nwith this problem\ni would recommend solving this one or\nwatching that video before\nso we're given two strings s and t and\nwe want to return\nthe total number of distinct\nsubsequences\nof s which equal t so basically what\nwe're doing is we're looking for\nsubsequences\nof s that happen to match the entire\nstring t and if you don't remember what\na subsequence is\nbasically for let's say this string a\nsubsequence is just a subset\nof some particular characters so\nbasically maybe we don't want to include\nthe b\nwe don't want to include the d so this\nhappens to be a subsequence ace right a\nc e this one is not a subsequence\nbecause it's not in the correct\norder of these you can't change the\nrelative order of characters in the\nsubsequence\nso we're given an example s and t so\nbasically these are both\nrapid just spelled a little bit\ndifferently right this one has an extra\nb\nin it so how many different sub\nsequences of this string s\ncan we take that exactly match this\nstring t\nwell let's look character by character\nso let's start at the first character of\nthis the first character of this\nthey exactly match each other right so\nokay that's good so now we're going to\nlook at the sub problem right we found\nthese two match exactly now how many\ndifferent ways can these sub sequences\nmatch each other\nnow how many ways can we get this string\nhow many sub sequences of it can we get\nthat match now the remainder of this\nstring\nnow we see again both of these\ncharacters are a so so far they're\nexactly matching each other that's good\nand we get to a b these b's match each\nother that's also good so so far we're\ngetting pretty close\nto getting a subsequence of this to\nexactly match this right we only have to\nmatch three more characters\nwe see another b that's good but now we\nsee we're looking for an i right we need\nan i\nand a t so that we can create an exact\nsubsequence of this but\nso far we have a b right so what are we\ngoing to do in this case\nso far what we've been doing is we've\nbeen basically evaluating this we've\nseen that at the i\npointer which is corresponding to the\nstring s and the j pointers\ncorresponding to string t\nif the characters at those corresponding\npositions match each other\nwe're basically just incrementing both\nindices right because we're just trying\nto match that string t\nright so if both of the characters match\nwe can continue to move on right\nso this is going to be the else\ncondition where we just got to right now\nright we're looking at\nb in the string s and i in the string t\nright they don't match each other so\nwhat we're going to do is we're going to\ntake\ni and increment it by one we're going to\ntake the i pointer\nand then shift it to this next character\nover here\nright why are we leaving j the same\nthough basically our j pointer is over\nhere and it's going to stay at this\ncharacter\nwhy is it staying here because it's\nrequired for us to\nmatch every single character in string t\nright that's what the goal of this\nproblem is we need all sub sequences\nfrom s\nthat exactly match t so what we're doing\nis so for now we're just saying this b\nwe're skipping it right now we're going\nto look at the next character maybe\nthere's some ways that we can match the\nremainder of this string\nto this string okay so now our eye\npointer is at this\ncharacter i our j pointers at this\ncharacter i so in this case the\ncharacters do match each other so what\nare we going to do\nsimilarly to what we did before we're\ngoing to increment both indices by one\nwe can move to the next position so\nwe're at this character now in s we're\nat this character now\nin t once again these characters exactly\nmatch each other\nright so once again we're going to take\nboth pointers and shift them by one\nnow we get to a base case right both\nstrings are\nempty so what are we going to return in\nthat case basically that tells us we\nwent through every single character in t\nright and we matched every single\ncharacter now there's no characters\nremaining right so what would the count\nbe in that case\nhow many subsequences of an empty string\ncan we match\nto another empty string basically just\none right that's our base case we're\nreturning one now\nbut my question to you is hold on a\nminute we're returning\none right so our result happens to be\none but in this problem description they\nreturn to three\nwhy is that how did they get three\ndifferent ways when our current\nalgorithm\nthat i've shown you these two conditions\nonly gave us a single one\nso what did we end up missing well let's\ntake a look at their explanation over\nhere they say there's three different\nways why is that\nwell when you take a look at the b\ncharacters right what we\nsaid what we originally said is this b\nis gonna match this b for sure and\nthat's the only way that we\ndid it but we and then basically we took\nlike over here you can see we took our\npointers and incremented them both by\none then we went to the next b\nbut that doesn't necessarily have to be\nthe case isn't it possible\njust because these characters match\ndoesn't mean\nwe have to require them to match we can\nsay hey\nlet's just skip this b even though it\nmatches this b maybe there's another b\nover here that can also match this b so\nwhat i'm saying here is if these\ncharacters match each other right if the\nwith this if condition we this is one\nway we can do it but we can\nalso do another thing which is we can\ntake our i pointer\nincrement it by one and take our j\npointer and leave it the same\nbasically we're doing over here what we\ndid down here so in in\nin this if case we're going to take both\nof these results\nbasically counting the number of ways\nthat we can compute subsequences\nwith both of these and totaling them up\nand that's what we're going to end up\nreturning\nso what would happen if we ended up\nskipping this b and then let's say we\ntook\nthis b and matched it with this previous\nb right then what would we get well\nthen we'd get to these pointers right\nand again we can say okay these b's are\nnow going to match each other\nright and then these two i characters\nare going to match each other and then\nthe t's are going to match each other so\nthat's an additional\none way that we could we could take a\nsubsequence of\ns and turn it into t so that's another\nway so far our total\nis two so what's the third way that we\ncould do it well once again\nwe see that this b matches this b but it\ndoesn't have to be that way\nin another way we could say okay these\nb's match each other we're gonna now\nskip the second b and we're gonna say\nokay these two b's are gonna match each\nother\nso that is what the third way would be\nand then of course we'd have our eyes\nmatch and we'd have our t's match\nso this covers exactly what we're going\nto do if the characters match each other\nand this is what we're going to do if\nthe characters don't match each other\nwe're going to do this recursively with\ndepth first search\nor backtracking whatever you want to\ncall it and we we noticed that we're\nprobably going to be doing a lot of\nrepeated work meaning our\nwhen we're calling that function we\nmight be passing in the same i\nvalue and same j value into that\nfunction so we're going to use a cache\nso that we don't repeat the same work\ntwice and so how big is that cache going\nto be well how many possible ways could\nwe call our depth first search function\nwe could call\nan i value for basically the length of\nour string\ns and we could call a j value for the\nlength\nof our string t so basically the number\nof times we could call it is going to be\nthe length of both strings multiplied by\neach other let's just say that's big\no of n times m so that's going to be the\nmemory as well\nas the run time of this algorithm\nbecause we're going to be caching it\ni've solved a lot of dp problems with\nthe bottom up approach so this time i am\ngoing to be using the recursive approach\nwhich is top\ndown but there's one last thing i want\nto cover before we jump into the code\nlet's look at two more base cases so\nlet's say our string s\nhad a single value a and let's say our\nstring t\nwas empty right so it's an empty string\nhow many subsequences of our string s\ncan we take that convert\nexactly to t well only a single one\nright so\nbasically if we just take this entire\nstring and just don't take any\ncharacters from it that counts as a\nsubsequence\nso this is gonna return one so basically\nif our string t\nis empty because we remember the\nprevious case where let's say\nstring t and string s were empty right\nif they're both\nempty strings then in that case we're\nalso ending up returning one so\nbasically the condition is if our string\nt\nis empty we return one as the base case\nwhat about the opposite case where our\nstring\nt is non-empty we have an a here but\nmaybe our string\ns is empty now once again the question\nis how many\nsubsequences of this string s can we\ntake that\nexactly match the string t we're looking\nto exactly match the string t\nwell since this is empty there's no\ncharacters in it we can't possibly get\nan\na from this so we can't possibly match\nthis a\ncharacter so therefore in this base case\nwe're going to end up returning\nzero there's no subsequences of the\nstring s\nthat match string t so that's all that\nwe need to cover we have our base cases\nhandled and we have this logic that we\nare going to be using\nso now let's get into the code so as i\nmentioned we are going to be using a\ncache you could use a two-dimensional\narray for this but i prefer using a hash\nmap or dictionary in python\nbecause it just is a little bit easier\nfor me so we're going to be passing two\nparameters i\nand j which tell us the corresponding\npositions of string s\nand string t that we're currently at we\nknow that one base case is if\nj has reached the end of the string that\nmeans\nstring t is empty that means we can\nreturn one as the base case as we\npreviously discussed\nthe other base case is if we reach the\nend of string\ns and that means we can't possibly match\nthe string t\nanymore so we're going to return 0 in\nthat case last base case\nis if this ij pair has already been\ncomputed\nin our cache if that's the case then we\ncan return\nthe value that is stored in our cache so\nthen we remember there's two cases for\nthe logic that we have to cover so if s\nof i matches exactly t of j\nthen we know we're gonna be running\ndepth first search we're gonna be doing\nit two different ways we're gonna be\nlooking at the remainder of string s\nand the remainder of string t and we're\ngoing to also be calling depth for\nsearch\nwith the remainder of string s but the\nentirety of string t so we're going to\nbe incrementing i\nbut not incrementing j in this case and\nwe're going to call both of these\nand total up the result and then once\nthat has been totaled we can return it\nbut before we return it we want to make\nsure that we cache it\nso let's put it in the cache at position\ni j\nthe else condition is basically the same\nthing\nas this except i'm gonna copy paste it\nso except this portion right since these\ncharacters don't match\nwe have to only shift our eye pointer we\nstill have to look for\na character that matches the character\nat position j\nand once either of these has been\ncomputed then we can return whatever\nvalue\nwe ended up storing in our cache and\nthis is the entirety of the depth first\nsearch function pretty short because we\ndidn't have to pass in a lot of\nvariables into it because i defined this\nfunction inside of another function that\njust makes things easier for me\nso now all we have to do is call it so\nlet's call debt for search\nstarting at 0 0 for both of the\nbeginning of the strings\nand then we return the result so this is\ngoing to be big o\nn times m basically multiplying the\nlength of the strings together\ntime and memory complexity i hope that\nthis was helpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Edit Distance",
        "NcLink": "edit-distance/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "You are given two strings `word1` and `word2`, each consisting of lowercase English letters.\n\nYou are allowed to perform three operations on `word1` an unlimited number of times:\n\n* Insert a character at any position\n* Delete a character at any position\n* Replace a character at any position\n\nReturn the minimum number of operations to make `word1` equal `word2`.\n\n**Example 1:**\n\n```java\nInput: word1 = \"monkeys\", word2 = \"money\"\n\nOutput: 2\n```\n\nExplanation: \n`monkeys` -> `monkey` (remove `s`)\n`monkey` -> `monkey`  (remove `k`)\n\n**Example 2:**\n\n```java\nInput: word1 = \"neatcdee\", word2 = \"neetcode\"\n\nOutput: 3\n```\n\nExplanation: \n`neatcdee` -> `neetcdee`  (replace `a` with `e`)\n`neetcdee` -> `neetcde`   (remove last `e`)\n`neetcde`  -> `neetcode`  (insert `o`)\n\n**Constraints:**\n* `0 <= word1.length, word2.length <= 100`\n* `word1` and `word2` consist of lowercase English letters.\n",
        "Difficulty": "Medium",
        "Video": "XYi2-LPrwm4",
        "PythonSolution": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        dp = [[float(\"inf\")] * (len(word2) + 1) for i in range(len(word1) + 1)]\n\n        for j in range(len(word2) + 1):\n            dp[len(word1)][j] = len(word2) - j\n        for i in range(len(word1) + 1):\n            dp[i][len(word2)] = len(word1) - i\n\n        for i in range(len(word1) - 1, -1, -1):\n            for j in range(len(word2) - 1, -1, -1):\n                if word1[i] == word2[j]:\n                    dp[i][j] = dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])\n        return dp[0][0]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nedit distance so this is a dynamic\nprogramming problem and this is\nvery similar to the problem longest\ncommon subsequence which is a problem\ni've solved on this channel so\nthis problem is basically an extension\nof that problem\nso we're given two strings word one and\nword two\nand our goal is to return the minimum\nnumber of\noperations required to take word one\nand convert it into word two and we only\nhave\nthree operations available to us\ninserting a character\ninto word one right remember because\nwe're trying to take word one and\nconvert it\ninto word two we can't change word two\nwe can delete a character\nfrom word one because we can't change\nword two and we can replace a character\nin word one and so replacing a character\nis basically changing\none character into another so in this\ncase\nthere's three operations it would take\nto take horse and turn it into\nthis string of course we'd want to get\nrid of the\nh right but we would do that by\nreplacing the h with an\nr so this is going to be an r and then\nwe have\ntwo r's right so we'd get rid of this r\nso we\ncan get rid of that and lastly we see we\nhave\nr o s we have an extra e so we're going\nto get\nrid of the e as well so we did that in\nthree operations\nso we can return three so first of all\nlet's analyze some simple cases\nwhat if we had the case where word one\nand word two were both\njust empty strings how many operations\ndoes it take then to take word one and\nconvert it into word two\nobviously zero right we don't have to do\nanything they're already the same\nsimilarly if word one was let's say abc\nand word two\nis also a b c we also\ndon't have to do anything right we'd\nlook at the first character see oh\nthey're the same right\nsince they're the same of course we\ndon't have to consider them anymore\nright\nthen all we have to do is compare the\nremainder of each string right but then\nwe see again hey b\nis the same good c is also the same\ngood and look perfectly timed there's no\ncharacters left in word one and there's\nno characters left in word two\ntherefore zero operations were needed\nright\nwhat if word one was abc\nand word two was empty then what would\nwe do is it even possible to take this\nword and then convert it into an\nempty of course it is in this problem\nit's\nalways going to be possible to take word\none and convert it into word two right\nbecause we can insert a character we can\ndelete a character\nor we can replace a character so it's\nalways going to be possible\nbecause in the worst case right this is\nwhat we could do\nwe could take every single character in\nword one and just delete it\ndelete that delete that because none of\nthese show up in word two\njust delete all of them if there was\nsome character maybe there's a z over\nhere\nthen we could just copy every character\nafter we've deleted these\nand then copy it over here right add\nthat z but no we don't need to\nso my question to you is if word two is\nempty\nand word one is not empty then what's\nthis is a base case\nhow many operations is it gonna take is\nalways going to take the length of word\none whatever the length happens to be\nbecause we're gonna have to delete\nevery single character right so that's\none base case word two is empty\nwhat about the opposite case what if\nword two was abc\nand word one was empty is this possible\nis it possible to take word one and\nconvert it to word two\nof course it is right because we're\nallowed to insert characters in here so\nbasically we could just read character\nby character a\nadd that here b add that here c add that\nhere\nas well right so we can just copy every\ncharacter so my question to you is in\nin this case the opposite case where\nword two is\nnon-empty but word one is empty how many\noperations is it gonna take well we're\njust gonna\ncopy each character in here right so in\nthis case it's gonna take the length\nof word two that's how many operations\nit's going to take right so basically\nwhat i'm getting at is if\nword one is empty and word two is\nnon-empty\nthen we're gonna return the length of\nthis as the minimum number of operations\nif the opposite was true right maybe\nthis is empty but this is not empty then\nwe'd return the length of the non-empty\none if one of them is empty we're going\nto return the length of the non-empty\nstring that's going to be the minimum\nnumber of operations\nthis is important because this is our\nbase case so now let's try to brute\nforce this\nhow are we going to handle it well we're\ngoing to have two pointers right we're\ngoing to have one pointer\npointing at a character in word one and\na second pointer pointing at a character\nin word two we're going to compare\ncharacter by character\nso the the one case is what if they're\nexactly equal\nthen what what is the sub problem then\nright because we don't have to consider\nthese characters anymore\nnow we're dealing with the sub problem\nof the remainder of the\nof those strings so basically if i'm\ncalling the pointer in word one i and\ni'm calling the pointer in word to j\nif these characters are equal that means\nwe can basically say i plus one is the\nnew problem and\nj plus one is the is the new problem in\nword two right so\nwe're just shifting our pointers like\nthat so basically to summarize\nif these characters are equal right at\nthe i and j\npointer basically what i'm saying the\ncharacters are equal then we're just\ngoing to increment i by 1\nand increment j by 1. the number of\noperations we had to do was exactly\nzero right we didn't have to do anything\nthey were already equal we didn't have\nto\nmodify word one at all to the next\ncharacter so our i\npointer is going to be over here our j\npointer is going to be here because we\nincremented both of them by one so now\nlet's compare the characters\nc and b are not equal right so now our\nelse condition condition is going to\nexecute and we don't know\nwe know we have three options we can\ninsert a character\ndelete a character or replace a\ncharacter from word one\nbut we don't know which one to do right\nso let's just try\nall three what happens if we insert\na character what character are we gonna\nwanna insert over here\nobviously we'd wanna insert the\ncharacter from word two we don't know if\nthat's going to end up making word one\nexactly into word two in the minimum\nnumber of operations but let's just try\nit and see what happens\nright so what would we do if we inserted\na c over here right we're not deleting a\ncharacter all we're doing is inserting a\nc\nover here in that case our i pointer is\nstill going to be pointing at this b\nright\nbut since we inserted a c over here it's\nhard to read\nbut let's say i inserted a c in between\nover here\nthat means we took care of the c from\nword two right so\nbasically we don't need to find a\nmatching c for it anymore we do need to\nfind a matching b\nsomewhere over here right so we're gonna\nleave our i\npointer where it is but we're gonna take\nour j pointer and then shift it to the\nnext position\nin word two that's what we would do if\nwe inserted a character\nso as you can see when we insert a\ncharacter\nwe are taking one operation right so\nwe're gonna have to add a one to the\nnumber of operations we did\nbut when we when we shift our pointers\nthe i\npointer stays the exact same but j\nis incremented by one so that's one\npossibility\nanother possibility is we delete a\ncharacter so we're allowed to delete\ncharacters from\nour word one right so what would happen\nif i just deleted this character what\nwe're saying is\nokay i can't find a matching c in this\nposition right\nand we and we don't have a b\ncorresponding to that position so i'm\njust going to ignore this guy\nand hopefully the remainder of the\nstrings can match up right so what i'm\nsaying is i'm going to take our\neye pointer and yes i am going to shift\nit to the next position because i just i\nwant to pretend like this character\nnever existed but it does take one\noperation to complete that but since we\ndid not\nfind a matching c yet right we have to\nleave our j pointer here right we have\nto keep searching until we find a\nmatching c\nultimately we want word one to match\nword two\nso in this case for the delete operation\nwhat we're saying is i is going to be\nshifted but j is going to stay the exact\nsame so i plus 1 but j stays the same\nas you can see this is you know kind of\na pattern we're starting to see a\npattern right\nand the last thing that we can do is\nreplace\na character from word one that shows up\nin word two right obviously if we're\nreplacing a character from word\none right we're gonna want the character\nthat's matching\nin word two right so what we'd wanna do\nis take this b\nand replace it with a c character right\nif we did that clearly these two\ncharacters match right we\nmade them match we forced these\ncharacters to match\nso in that case we we know that the c\nhas a matching c\nup here so we can take this i pointer\nand shift it and we can take our j\npointer and shift it to the next\nposition right so\nthe replace actually ends up doing the\nexact same thing as\nif the characters were equal and that\nmakes sense because what we're doing is\nwe're\nforcing them to be equal with the\nreplace operation\nthe difference between the replace and\nand if they were already originally\nequal\nis that the replace does take a single\noperation if they were already equal\nthe number of operations it takes is\nzero right\nso it does come with a cost even though\nreplace is pretty powerful\nas i said with replace what we're going\nto do is increment i\nand increment j so let's just go with\nthe replace operation because that's\nactually going to end up\nbeing the minimum solution so now we\nshifted our pointers to the next\nposition we see\nd and d they match each other so this is\nthe statement that's going to execute\nand we know that takes 0\noperations right so we're going to\nincrement both pointers by 1.\nj is going to be over here now i is\ngoing to be over here notice now how we\nhave two\nempty strings remember the base case if\nboth strings are empty\nwe can return 0 because it takes zero\noperations to make them\nequal right they're already equal so\nwe're done we return\nzero how many operations did it take by\nthe way if we\nif you were counting we did have to\nexecute a single replace\noperation that took one operation so the\nresult is\none so we are noticing that the sub\nproblems\nare good to solve before we try to solve\nthe original\nproblem of comparing the entire lists\nlet me reformat this\ninto the dynamic programming explanation\nso you may have seen something like this\nbefore this is going to be a\ntwo-dimensional dynamic programming\nproblem\nit's good to visualize it kind of like\nthis so what we're doing here is we are\ncomparing these two strings\nand for this position this is what we\nwant to calculate\nin this position what we're going to do\nis we're going to store\nthe basically the minimum number of\noperations for\nthese two strings starting at this\ncharacter for word two\nstarting at this character for word one\nso basically the entire strings\nis going to be stored here what would be\nstored in this position basically\ncorresponding to here so we're comparing\nthese two\nbasically the remainder of this string\nand from here\nthe remainder of this string so in this\nposition what we would store\nis the minimum number of operations it\nwould take to make this\nsub problem these two sub strings how\nmany\nminimum operations it would take to make\nthem equal\nokay so that makes sense so far but then\nwhy do i have this\nextra layer over here the this\nportion is for our base case what would\nbe over here\nright so clearly we see that there's an\nempty string over here there's an empty\nstring over here what value should i put\nover here obviously zero right two empty\nstrings take\nzero operations to make equal what about\nin\nthis position what does this position\ntell us well we have an empty string\nfrom word two\nbut over here we have the entire string\nfrom word one\nso how many minimum operations would\nthat take remember we went over that at\nthe beginning\nand it would just be the length of the\nnon-empty string so here we can see the\nlength of the non-empty string\nis three what about in this position\nsimilarly\nword two is empty word one has a length\nof\ntwo so we'd put two and basically\ncontinuing\nto one and then down to zero right so\nsimilarly over here\nwe have an empty string from word one\nword two is completely\nfull and the length of it is three so\nwe're going to put three here\nand then continue just counting down\nthree two\none right so in what order are we going\nto solve this\nif we start at the beginning then we're\ngoing to notice something\nnotice okay well we're comparing these\ntwo characters in this position right\nthey're both\nequal right so then we're going to\nexecute this statement right so we're\ngoing to take\ni plus 1 and j plus 1. what does that\ntell us that tells us that the result of\nthis value\ndepends on this value right\nso okay then let's take a look at this\nvalue well in this case they're\nnot equal b and c are not equal\nso then what are we going to do remember\nif they're not equal we have to brute\nforce it we have to take a look at all\nthree operations and remember i\ncorresponds to word one\nj corresponds to or two so in the insert\noperation what we're going to do is look\nin this spot\nin the delete operation what we're going\nto do increment i by 1 in this case so\nwe're going to look in this spot\nand for the replace operation we're\nincrementing both of them so then we're\ngoing diagonal\nagain from this since we have three\nvalues that we're looking at what we're\ngoing to do is we want to know which one\nof these three\nleads us to the minimum number of\noperations right so what in reality\nwhat we're going to do is since we're\nnoticing that\nit depends on the lower values let's do\nthis\nbottom up this is called bottom up\ndynamic programming we're going to start\nat the bottom\ncompute this value compute this value\ncompute this value\nand then so on and so on and then work\nour way backwards until we finally\nget to the result and notice if we do\nstart\nin this position we already have the\nvalues that it could possibly depend on\nbecause those are our base cases over\nhere\ndiagonally and below right and so notice\nd and d are equal so what we're going to\ndo is from here we're going to look at\nthe diagonal value\nright because this this statement is\ngoing to execute we're going to see it's\nzero\nso that's what we're going to put over\nhere and then eventually we would end\nwe would compute these and then\neventually we would get up over\nhere right and we'd compute the value\nfrom that\nand then eventually we'd get all the way\nup here and we would compute the value\nfrom here you would see that we'd end up\nputting a 1 over here we'd end up\nputting a 1\nover here so what would the value over\nhere end up being well let's look at the\ntwo characters d\nand c they're not equal so what we're\ngoing to do is we're going to look down\nwe're going to look\ndiagonal and we're going to look to the\nright which one of those values is\nminimum\nit's over here so that's 0 but we do\nhave to add 1 because\nin this case we do need to do a single\noperation so we add 1\nand similarly is what we would do for\nevery single position\nyou know we'd compare the characters and\nthen we'd execute this statement or we'd\nexecute\nthis statement so i'm not going to run\nthrough that but i think this is simple\nenough that if you want to you can get a\npiece of paper out\nand then try it for yourself and you'll\nprobably come to the same conclusion\nso that being said let's jump into the\ncode this is exactly what i'm going to\ndo with the code i'm going to have a two\ndimensional\narray and i'm going to execute these\nexact statements\nso i'm going to call our two-dimensional\narray our cache\nand so basically i'm going to initialize\nit to\ninitial values of just max integer or\nfloat infinity in python\nand you can probably initialize this any\nway that you'd like in your own language\nthere's probably\na different ways that you'd want to do\nthat but i'm going to use\na list comprehension so basically i'm\ncreating a list\nfl with float infinite as the value of\nlength\nword two plus one remember because we do\nneed to make\nour two dimensional array a little bit\nbigger to handle those base cases\nfor this list i'm gonna have one of\nthese lists basically for every\ncharacter\nin the range of the length of\nword one so this probably looks\nconfusing if you're not familiar with\npython but basically i'm just creating a\ntwo-dimensional array\nwith these dimensions actually word one\nthe length of board one plus one\nbecause remember we are worrying about\nthe base case but basically yeah\na two dimensional array so now i wanna\nfill up\nour bottom row of the two-dimensional\ngrid\nso what i'm gonna do is for our cache\ni'm going to go to the bottom row what's\nthe bottom row it's going to be the\nlength of the word\n1 and that's going to be the bottom row\nand we're going to go through every\nvalue of it so for\nevery j of that remember where it's\ngoing to be basically\nin descending order so what i'm going to\ndo is and it's going to initially start\nat the length of what word two happens\nto be\nbecause remember the base case is if one\nstring is empty and the other string\nisn't so word two and it's going to\nbasically be decrementing by one each\ntime so what i can just do is just say\nlength of word two dec subtracted by\nj and actually i keep forgetting the\nbottom row is actually not just going to\nbe the length of word tube that's going\nto be length of word two plus\none so i want to make sure to add that\nplus one and similarly what we're gonna\ndo is and for that right most column\nwhat we're gonna do is go through every\nposition in it so length of word one\nplus one and for every work every\nposition in\nthe last column and the last column can\nbe\nfound like this basically for every i\nin the last column which is going to be\nlength of word\n2 in this case and what we're going to\ndo is similar to what we did\nup here take what the original length of\nword one is\nand each time subtract it by an\nadditional value\nbasically we can use i in this case so\nthis might be a little bit confusing\nyou can do this a bunch of different\nways if this is confusing to you you can\nprobably find your own way to do it\nbasically we're just initializing the\nbase case of our two dimensional array\nbut so now let's actually get into the\ndynamic programming portion so remember\nthis is going to be bottom\nup so we're going to work our way\nbackwards from the length of\nword one minus one and the reason we're\nminusing one is we know we already\nfilled up our base case\nportion so now we actually want to get\nto the actual dimensions of our two\nstrings\nand we're going to do this in\ndecrementing order until we get\nto the beginning until we get to the\nzeroth index which is when this is going\nto end up stopping\nand similarly let's work our way\nbackwards from the length\nof word to so we're going to start at\nthe bottom row and work our way\nbackwards and then keep doing that until\nwe end up getting to the top\nrow and remember we had two cases either\nword one\nat index i is equal to word two at\nindex j basically with the characters\nthat we're comparing are equal or\nthey're not equal remember if they are\nequal\nthen that's really easy for us right\nbecause then we can just say okay\ncache of position i j what we're doing\nhere is computing what's the minimum\nnumber of operations it would take\nto get the sub string starting at i and\nthe substring starting at j for these\nrespective words\ncompute the minimum number of operations\nso we can get that in this case since\nthe characters are equal just by saying\ncache of i plus one cache of j plus\none and the else case is where we have\nto check all three directions\nand then take the minimum of those so\nwhat i'm gonna do is say one\nplus the minimum of those three uh\ndirections so cache of\ni plus 1 and leave j the same\nand also we want to take the minimum of\ncash\nof i left the same but j plus 1\nand last but not least we want to take\nthe minimum of cash of i plus 1\nand j plus one so this is a long line\nbut i'm going to leave it as it is\nbut yeah basically this is taking care\nof insert delete\nas well as replace and it's taking the\nminimum of whatever\nthose were adding one to it because we\nare having to do at least one operation\nwhichever one of those it is and then\nstoring that minimum\nhere and once we have done that once\nwe've filled up our entire\ntwo-dimensional array\nwe want to return the value at index\n0 0 of our cache because that tells us\nwhat's the minimum number of operations\nfor the beginning of both strings so\nbasically the entirety\nof both strings so this is definitely a\ndoozy of a problem it's not a ton of\ncode but it does take some thought to\nget to here\nand it's definitely an extension of\nlongest common subsequence\nso i recommend solving that problem if\nyou haven't already\nbut i do hope that this was helpful it's\na tough dynamic programming problem\nif it was helpful please like and\nsubscribe it supports the channel\na lot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Burst Balloons",
        "NcLink": "burst-balloons/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "You are given an array of integers `nums` of size `n`. The `ith` element represents a balloon with an integer value of `nums[i]`. You must burst all of the balloons.\n\nIf you burst the `ith` balloon, you will receive `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then assume the out of bounds value is 1.\n\nReturn the maximum number of coins you can receive by bursting all of the balloons.\n\n**Example 1:**\n\n```java\nInput: nums = [4,2,3,7]\n\nOutput: 167\n\nExplanation:\nnums = [4,2,3,7] --> [4,3,7] --> [4,7] --> [7] --> []\ncoins =  4*2*3    +   4*3*7   +  1*4*7  + 1*7*1 = 143\n```\n\n**Constraints:**\n* `n == nums.length`\n* `1 <= n <= 300`\n* `0 <= nums[i] <= 100`\n",
        "Difficulty": "Hard",
        "Video": "VFskby7lUbw",
        "PythonSolution": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        cache = {}\n        nums = [1] + nums + [1]\n\n        for offset in range(2, len(nums)):\n            for left in range(len(nums) - offset):\n                right = left + offset\n                for pivot in range(left + 1, right):\n                    coins = nums[left] * nums[pivot] * nums[right]\n                    coins += cache.get((left, pivot), 0) + cache.get((pivot, right), 0)\n                    cache[(left, right)] = max(coins, cache.get((left, right), 0))\n        return cache.get((0, len(nums) - 1), 0)\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nburst balloons and this problem has\nreally earned that category of being a\nhard\nproblem so this is going to be another\ndynamic programming problem and\nwe're going to solve it with the optimal\nsolution which is going to be big o\nof n cubed time complexity and i believe\nbig o of n squared memory complexity\nand i'm going to try my best to explain\nthe intuition of this problem and kind\nof walk through my thought process but\nif your question\nis if you saw this problem for the first\ntime in an interview\nhow would you be able to solve it that's\na good question and honestly i don't\nhave the answer to that unless your\ninterviewer\ngave you a couple of hints that kind of\npointed you in the right\ndirection because this problem requires\na couple tricks to get it to work\nefficiently\nso the description is pretty simple\nwe're given n balloons\nindexed from position zero to position n\nminus one\neach balloon is painted with a\nparticular number on it\nso basically we're given an input array\nof nums or other words balloons\nand we're asked to burst all of the\nballoons now when we burst a particular\nballoon\ni we are going to add to the total we're\nbasically going to get a total number of\ncoins from popping that balloon\nwe're going to the total that we're\ngoing to get is basically the number\nthat was painted on that balloon\nmultiplied by the two adjacent balloons\nto that balloon at that particular time\nand of course we might have a balloon\nthat's on the boundary or on the edge of\nour input array so if that's the case\nfor example if i minus 1 or i plus 1\nare out of bounds of the input array\nthen we're basically going to assume\nthat there's\nyou know a couple balloons with one\npainted on them on the edge\nbasically there's gonna be some implicit\nones so for example if this is our input\narray we're assuming there's a one over\nhere and there's one over here the\nreason why is let's say we were given an\ninput array of one number let's say that\nvalue was five right if we pop this\nwe're going to assume that there's ones\non the edge right so if we pop five what\nare we going to get we're gonna get five\ntimes the right neighbor which is one\ntimes the left neighbor which is one\nright so basically these are just\nneutral values so the total number of\ncoins we're going to get from a single\nballoon\nis just going to be that value right 5.\nthat makes sense that's why we're doing\nthis\nso in this example the total number of\nmaximum coins we can get is 167\nand that is if we first pop this one\nvalue\nand then we get three times one times\nfive because three and five are the\nneighbors\nsince we pop that next what we're going\nto pop is the\nfive now since we're popping this five\nwell we need to get its neighbors right\nit's right neighbor is obviously\na since we popped this one its its left\nneighbor now is going to be\nthe 3 that's over here so we're going to\ndo 3 times 5 times 8\nso after we pop the 5 we now have 2\nremaining\nwe're going to pop the 3 first and\nthat's going to give us 3\ntimes 8 and the left neighbor of course\nremember we\ntalked about the beginning is implied to\nbe a 1 so then we're going to get 1\ntimes 3 times 8.\nnow the 3 has been popped last one left\nis just the eight\nright so the neighbors of that\nimplicitly are just one and one so eight\ntimes one times one\nwe add that up to our total we get 167.\nnow\nthese implicit extra ones on our input\narray for example\nthose are not actually going to be\npopped right so we need to remember that\nbecause obviously if we did pop them\nright we pop a one we'd add one to our\ntotal and if we pop the other one we'll\nadd another one but that's not actually\ngoing to be the case right we don't want\nto pop these extras\nso even if you can't get the dynamic\nprogramming solution at the very least\nwe know that there's a brute force\napproach right we could choose to pop\nthree first we could choose to pop one\nfirst we could choose to pop\nfive we could choose to pop eight right\nand then we could continue\ndown this decision tree right that's the\nbrute force right\nsomething like a backtracking approach\nbut in that case\nobviously we have n choices roughly at\neach layer\nand the height of the tree is going to\nbe n so basically the time complexity is\ngoing to be something like\nn to the power of n now that's not super\nefficient\nand in this case we actually can do\nbetter but it's not easy to\narrive to that solution so now let me\nexplain a little bit of the thought\nprocess\nto get us there and then i'm going to\njump into the code in this case the code\nis actually not too bad once you see\nthe couple of tricks that we need in\nthis problem so we know the brute force\napproach but can we identify\nany sub-problems your first idea might\nbe something like this okay so let's say\ni pop\nthe fifth element right we popped this\nballoon now we have a new sub problem\nright we have\nthis entire array minus this value as\nthe sub problem right\nor for example maybe i popped one now we\nwould get this entire array\nexcept the one as a sub problem right\nnow if i continue popping for example i\npop 1\nnext i pop 8 now we have a different sub\nproblem\nso if i keep going like this how many\nsub problems are we gonna have well\nbasically what we're doing as we pop\nelements we're basically getting every\nsingle\nsubsequence right now how many sub\nsequences\nfor an input array are there well for\neach value we could choose to include it\nor not\ninclude it right so for each value we\nhave two choices two times two\ntimes two right we're basically going to\ndo this for the size of the input array\nwhich is let's say n so we're going to\nhave 2 to the power of\nn sub sequences so basically what i'm\ngetting at here\nis this is not the correct sub problem\nthat we're looking for we need to look\nfor an even more\nsimple sub problem because if we have\nthis many sub problems that's not going\nto help us\ncaching something like this is not going\nto make the\nthe solution more efficient we want to\nget something like n cubed\nand squared et cetera right this is what\ni'm aiming for let's try to see if we\ncan get it\nso let's say i pop the five now is there\nan even more simple sub problem well we\nnotice\nnow we actually have two subarrays right\nwe have one sub array over here\nand one sub array over here now these\nsub arrays are contiguous they're not\nsubsequences that's pretty good\nbecause we know that at most for an\ninput array of size\nn there could be at most there could be\nat most\nn squared sub array so that's something\nwe can work with to make an\nefficient solution so now you might\nthink well can i take each of these sub\narrays right\nbasically by popping this we got\nsomething like one times five\ntimes eight now we wanna know\nindependently what the each of these sub\narrays\ncould get us like how many maximum coins\ncould this subreddit and this subarray\nget us right independently\nbut what we're gonna notice is we can't\njust look at this subarray independently\nright because independently a three\ntimes one right\nthe max we could get is we first pop the\none right\nin that case we get one times three and\nyou know the right neighbor is nothing\nso once we pop that and then we pop this\nthree right then we'll get\nthree times basically just three by\nitself right so\nwe pop this then we add the second\nballoon that we pop so we'd get a total\nof six right just independently\nif we had this sub subarray 3 and 1. but\nwe\nknow that in reality this 3 and 1 is now\ngoing to be connected\nto this 8 right and independently what\nthis 8 would get us\nis 8 by itself right because it doesn't\nhave any neighbors so in total if we\ntook a\nlook at both of these independently we'd\nget something like 6 plus 8\nso in total 14 right but in reality\nwhen we look at 3 1 8 what's the max we\ncould possibly get in this case\nwell we'd pop the 1 first right then\nwe'd get\nthree times one times eight now that's\n24 that already by itself\nwent over the total that we would get if\nwe did these independently so basically\nwhat i'm getting at is\nwe can't break the problem up like this\nright\nwe can't look at these arrays separately\nbecause in reality we know that they're\ngoing to be connected to each other\nokay so that's not going to work now\nthis is the part where you have to be\nkind of\nclever we said what happens if we pop\nthis one\nfirst and then try to do the remaining\narray let's reverse our\nthinking instead of popping this first\nlet's say we pop this value last\nso what happens if we pop this value\nlast\nmeaning we pop this entire subarray\nand before right before we pop this and\nwe pop\nthis entire subarray before we pop this\nwhat's going to happen then well we know\nif this is the last value that we pop\nmeaning we popped everything here we\npopped everything here its left and\nright neighbors\nare both going to be 1 right there's\ngoing to be a 1 over here and there's\ngoing to be a 1 over here so we're going\nto get 1 times 5\ntimes 1. but what's the remaining amount\nthat we\nget from popping these two subarrays now\nbecause in this case since we're popping\nthis value\nlast that means these two subarrays are\nnever going to be connected to each\nother\never not at any point because this is\nbeing popped\nlast so since these two subarrays are\nnot going to be connected that means we\ncan now pop them independently so let's\ntake a look now let's\npop this 3-1 independently what's going\nto happen\nwell we remember when we pop this\nindependently we're basically going to\nget 1 times 3 plus 3 right\nthat's going to total up to 6 once again\nright but that's not\nactually what we're looking for because\nremember this\nsub array is not independent we are it's\ntrue we're going to pop this before we\npop the five\nbut we can't just forget about the five\nright there is\na five right next to this three one so\nin reality when i pop the one\ni'm gonna get three times one times five\nand then when i pop the three because we\nknow we're not gonna put we're popping\nthis last right so we are popping these\ntwo first\nbut then when i pop the three i'm gonna\nget one times three\ntimes five right because there's an\nimplicit one over here\nso how can i handle that what i'm saying\nis\nour array hasn't actually changed there\nis\nthe five still over here but we want to\npop all of these elements before we pop\nthis five how can i handle that well\nit's actually not\ntoo different than what we went over at\nthe beginning remember we said that\nlet's say we had a single element in our\ninput array let's say it's a three right\nwe're assuming even for this input array\nthere's gonna be an implicit\none on the left and there's going to be\nan implicit one on the right\nthese two values are not going to be\npopped when we're popping this\narray but we're still assuming that\nthey're there for that computation that\nwe're going to be doing\nthat's exactly the same rule that we're\ngoing to follow\nso when we go from up here to down here\nright\nthis is our sub problem so we we have we\nhave identified what the sub problem is\ngoing to be it's going to be this\nsub array the only thing we have to\nremember is just like at the beginning\nhow there's going to be an\nimplicit 1 on the left now there's going\nto be an\nimplicit 5 on the right so\nfor the sub array that we're doing the\nleft boundary\nis going to be at this value the right\nboundary is going to be\nat this value but these values are not\ngoing to go away\nwe are going to leave this in the input\narray and\nwe are going to make sure that we have\nan implicit 1 at the beginning of the\ninput array\nand similarly when we want to solve this\nsubarray we are going to assume that\nyeah there's just a single eight right\nso the left boundary is going to be here\nas well as the right boundary both\nboundaries are going to be here but\nwe're going to assume that there's an\nimplicit 1 at the right\nand this 5 is not going away the 5 is\ngoing to be here as well we're not going\nto pop it because take a look at our\nboundary our boundary tells us just to\npop\nthis subarray before we end up doing\nanything else so this is going to stay\nhere we're not going to pop it\nbut it is going to contribute to the\ntotal number of coins for example when\nwe pop eight\nwe're gonna get five times eight times\none that's going to be the total number\nof coins we get\nonce we pop this entire sub-array so\nusing\nsub-arrays using this technique where\nfor every value we're going to identify\nwell what if we popped this value\nlast that allows us to actually get a\nsub problem that we can cache now in our\ncache it's going to be\nlet's say we call it dp this is our\ncache it's going to be a two dimensional\ncache because we are going to be using\nthe left value as the first index and\nthe right value as the\nsecond index these left and right values\nare basically just going to tell us\nwhat the sub array is from the original\narray right left is going to be the left\nboundary\nr is going to be the right boundary with\nthat being said let me just give you a\nquick\nhigh level run through of the algorithm\nand then we're going to dive into the\ncode\nso we remember in the brute force we\nstarted out with okay what happens if we\npop this first what happens if we pop\nthis\nfirst right so that's going to give us a\ndecision tree now we're going to do it a\nlittle bit differently our decision tree\nnow is going to be what happens if we\npop\nthis last what happens if we pop this\nlast\nwhat happens if we pop this last which\none of those paths\nis going to lead us to the maximum\nnumber of coins right\nso we are still going to brute force it\nkind of we are going to have that exact\nsame decision tree\nonly thing is we're going to use a cache\nwe're going to take that sub problem and\ncache them so for example let's say we\npop this value last what am i going to\ndo\nand we actually are going to modify the\ninput array so we are gonna add that\nimplicit one at the beginning and at the\nend\nbut our boundary is gonna be left is\ngonna be from here and right is gonna be\nfrom here that's ultimately\nthese are the values that we're actually\ngonna be popping we're not actually\ngonna be popping these\nagain the brute force what happens if we\npop this last\nif we pop this last our left subarray\nbecomes\nempty right there's nothing there in the\nleft sub-array\nbut our right sub-array is going to have\nthis entire portion right\nso since currently our boundary our left\nboundaries here in our right boundaries\nhere if we pop\nthis value last this is what our total\nis gonna be we're gonna get\nso if we pop this last we know it's\ngonna\nwe're gonna end up popping everything\nhere before that right so when we pop\nthis value we're gonna get\nthree times one times one right so what\ni'm gonna say is three\ntimes nums of right which is over here\nplus\none and nums of left which is over here\nminus one that's going to give us once\nwe pop this\nplus we want the remaining number of\ncoins that we get\nfrom popping the remaining portion of\nthe left sub array we see that there's\nnothing here right\nremember we're not actually popping this\nvalue there's no other values in between\nso there is no left sub array what about\nthe right sub array we're going to take\nour left pointer shift it by\none that's going to put left over here\nso the right sub array is going to be\nall of these elements right so you can\nsee we're going to get that total amount\ncomputed from our dp\nright we're going to get it from our dp\nif that's already been computed as a sub\nproblem if it hasn't been computed then\nwe're just going to do that\nbrute force depth first search passing\nin these same parameters right\nl plus one and right now let's look at\nit for a more general\ncase if we were popping let's say a\nmiddle value as the last value where we\nactually do have both a left sub array\nand a right sub array what's the\nequation going to look like then\nso we were looking at if we popped this\nvalue last next we're going to look at\nif we pop this value\nlast we're also then going to look at\nthis and this right that's basically the\nbrute force right so basically we're\ngoing to have an i right it's going to\nstart here\nit's going to run all the way through\nthe end of the input array but now if we\npop\nthis last we know that if if this was\npopped last we'd end up popping all of\nthis first and we'd pop this first so\nthen once we popped this its left would\nbe the one\nits right would be the one right so\nthat's where we're getting this from\nright\nr plus one's here left minus one is over\nhere\nmultiplied by the value at index i which\nis one right\nbut then what's our right sub array\ngoing to be clearly this is what the\nright sub array remaining sub array is\nright how much could we get from\ndoing that well again in our dp or if\nit's not already computed in our dp\nwe're basically going to call our depth\nsearch clearly you can see that the left\nboundary now is i\nplus one right basically we're taking\nthis i moving it over here our right\nboundary remains\nunchanged right this is the sub array\nthat's what i'm saying here\nwhat about our left sub array over here\nwell the left boundary didn't change\nbut the right boundary was decremented\nby one that makes sense right\nso that's basically the idea now my\nquestion is we know why the memory\ncomplexity is big o of n squared right\nthe\ncache is basically going to be from\nevery single subarray right\nand it's two dimensional so that makes\nsense i think why it's\nthe memory is n squared but why is the\ntime complexity big o\nn cubed well we know we're going to be\nbreaking this problem down\ninto sub problems of every single\nsubarray we know that there's\nn squared number of sub arrays right so\nfor once we have a sub array right like\nlet's consider the entire input array\nwas a sub array right\nwe know that for every subway we're\nbasically going to be iterating through\nevery value right this is the first this\nis the second this is the\nand so on and so on right and\nconsidering if this was the last value\npopped so\nit's basically taking the total number\nof sub arrays which we know is n squared\nand multiplying it by another n because\nwe're having to iterate through every\nsingle\nvalue for a given subarray with that\nbeing said let's jump into the code once\nyou actually know these tricks and\nespecially once you know\nthis formula the algorithm is actually\npretty easy with\nrecursion so like i mentioned we are\ngoing to be\nupdating the input array we're basically\ngoing to be adding a 1 at the beginning\nand then adding a 1 at the end we're\nalso going to be having\na cache i'm going to call it dp because\nit's short and then we can start with\nour\ndepth first search function so let's\ndefine it we know that we're just going\nto have left\nand right boundaries right so basically\nleft and right are going to be indices\nof the input array but let's call that\ndepth first search function we know\nwe're just going to be end up calling it\nand then returning the results so let's\ndo that before we actually define the\nfunction\nnow what am i going to pass in as a left\nand right boundary zero\nand you know the last index no right\nbecause we don't want to actually\ninclude\nthis one and we don't want to include\nthis one so i'm going to be passing in\nzero plus one which is one and basically\npassing in\nthe length of the entire empire numbs\nminus two because we know\nthis minus one would give us the last\nvalue minus 2 is going to be 1\nless than that so because remember we're\nnot actually popping these\nand these okay so now what are actually\nthe base cases for this algorithm well\nif left equaled right that means we have\nonly one\nballoon left to pop so that's actually\nokay but if left\npast the right pointer so if left became\ngreater than right\nthat's when we know we've ran out and\nthat's when we know we're gonna\nwe're gonna return zero meaning there's\nnothing left to pop\notherwise maybe we've already computed\nthis before and it's already in our\ncache\nright this left and right pair is\nalready in dp in that case we're just\ngoing to return dp\nof left and right otherwise\nwe know that it hasn't been computed so\nnow it's our time to actually compute it\nso let's set it initially to zero\nand now we're going to determine what is\nthe max number of coins we could get\nfor this pair so remember we're going to\nbe iterating through every i\nconsidering if at index i that balloon\nwas the last balloon we popped so let's\ngo through every index from\nleft all the way to right and let's\ncompute the number of coins\nwe could get from that so we know that\nif\nthis numbs of i was popped last we'd get\nnumbs\nof i multiplied by nums\nof right plus 1 multiplied\nnumbs of left minus one right and now to\ncoins we're going to\nadd the additional coins that we would\nget from the left and right\nsub arrays right so we're going to be\ncalling our depth first search function\nthe left boundary stays the same and\nwe're gonna do i\nminus one and we're also going to be\ncalling it for the right subarray which\nwe know we can get\nwith i plus one as a left boundary and\nour right boundary is going to stay the\nsame so now we've computed the total\nnumber of coins right it makes sense why\nwe're doing this\nand then calling our debt for search\nfunction so now we can potentially\nupdate the result which we know we're\nstoring here in dp\nof left and right so we're going to\nupdate it to the max of potentially what\nit already\nis and the max of what we just computed\nthe total number of coins that we just\ncomputed and so we're basically going to\nbe running through the entire loop\ndoing that i hope that this kind of\nmakes it a little more obvious of why\nthis is n cubed we know that this debt\nfor search function\nthe maximum possible number of ways it\ncould be called is\nn squared right every pair of the left\nand right indices could be n squared\ntimes\ne and then if we actually if it's\nalready been cached then we're going to\nreturn it in big o\nof one time if it hasn't been cached\nmeaning it's the first time we're\ncomputing this\nwe're going to have to run through a\nlinear time loop\nand for each of these pairs we are going\nto have to run through a loop at least\nonce so that's what's going to give us\nthe n cubed\ntime complexity but yeah once this has\nbeen computed we know\nyou know we can just go ahead and return\nit from this recursive function\nand that is the entire thing so\nyou know we defined a function inside of\na function but once you know\nyou know the trick which is not so\nobvious we do have to do this\nand then we do have that relationship of\nyou know we're popping this\nthis balloon last it's not super\nintuitive but once you do have it\nhopefully your interviewer gives you\nthat hint\nbut and if you do get that the code is\nactually not too bad as you can see when\nyou do\nrecursion so i hope that this was\nhelpful if it was\nplease like and subscribe it supports\nthe channel a lot and i'll hopefully\n"
    },
    {
        "Name": "Regular Expression Matching",
        "NcLink": "regular-expression-matching/",
        "Pattern": "2-D Dynamic Programming",
        "Description": "You are given an input string `s` consisting of lowercase english letters, and a pattern `p` consisting of lowercase english letters, as well as `'.'`, and `'*'` characters.\n    \nReturn `true` if the pattern matches the **entire** input string, otherwise return `false`.\n\n* `'.'` Matches any single character\n* `'*'` Matches zero or more of the preceding element.\n\n**Example 1:**\n\n```java\nInput: s = \"aa\", p = \".b\"\n\nOutput: false\n```\n\nExplanation: Regardless of which character we choose for the `'.'` in the pattern, we cannot match the second character in the input string.\n\n**Example 2:**\n\n```java\nInput: s = \"nnn\", p = \"n*\"\n\nOutput: true\n```\n\nExplanation: `'*'` means zero or more of the preceding element, `'n'`. We choose `'n'` to repeat three times.\n\n**Example 3:**\n\n```java\nInput: s = \"xyz\", p = \".*z\"\n\nOutput: true\n```\n\nExplanation: The pattern `\".*\"` means zero or more of any character, so we choose `\"..\"` to match `\"xy\"` and `\"z\"` to match `\"z\"`.\n\n**Constraints:**\n* `1 <= s.length <= 20`\n* `1 <= p.length <= 20`\n* Each appearance of `'*'`, will be preceded by a valid character or `'.'`.\n",
        "Difficulty": "Hard",
        "Video": "HAA8mgxlov8",
        "PythonSolution": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        cache = [[False] * (len(p) + 1) for i in range(len(s) + 1)]\n        cache[len(s)][len(p)] = True\n\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n\n                if (j + 1) < len(p) and p[j + 1] == \"*\":\n                    cache[i][j] = cache[i][j + 2]\n                    if match:\n                        cache[i][j] = cache[i + 1][j] or cache[i][j]\n                elif match:\n                    cache[i][j] = cache[i + 1][j + 1]\n\n        return cache[0][0]\n",
        "Transcript": "hey everyone welcome back now let's\nwrite some more neat code today so today\nlet's solve a pretty hard problem\nregular expression matching so we are\ngiven an\ninput string s and a pattern or a\nregular expression\np and we want to implement regular\nexpression matching\nand these are the two special characters\nthat we're gonna have to worry about\na period and a star so the stars or so\nthe period will match\nto any particular character and the star\nbasically means that any character that\ncomes before it can be repeated\nzero times or it can be repeated\ninfinite times right so it can be\nrepeated as many times as it needs to be\nand the match or the pattern has to\ncover the entire input string so it has\nto match\nthe full input string so one example\nis let's say so these are the special\ncharacters we worry about right the\nperiod\nand the star if we don't have either of\nthem then it's basically\nstring matching right so we see in this\nexample we have\ntwo a's right that's one input string\nand a single a so basically do these\nstrings match each other they\ndon't match each other so we have to\nreturn false\nmeaning that the input string s does not\nmatch this regular expression\nand remember it's only going to be a\nregular expression which possibly has\nthe star\nor possibly has the period now imagine\ninstead if our pattern\nwas a period so in that case\nwe would compare it to the string double\na and we would see that yes they do\nmatch because remember the period can be\nany character so we could\nsay okay we'll given this pattern this\ncould be double a so\nit would match this input string what if\nwe were checking does it match\nthis input string a b in that case it\nwould also match because this period\ncould then turn into a b\nso it would be a b and these two match\neach other\nbut of course if we had a period period\nchecking if it matches double a it\ndoesn't because they're not even the\nsame length this has\nthree this has two there's no way we\ncould put any characters for these two\nperiods that would match\ndouble a and what about this second\nexample let's say the input string\nis double a and the pattern is a star\nso what this star means is a star\nso a star basically means that the\nelement that comes before\nthis a could be repeated multiple times\nor zero times so\nthe possible strings that this pattern\ncould match to could be\nan empty string because this character\ncould be repeated\nzero times right so empty string this\ncharacter could be repeated once\nso a single a this character could be\nrepeated twice\nso double a this character could be\nrepeated three times so\naaa and so on and so on right we could\nrepeat this a infinite number of times\nbut if you take a look at our input\nstring we're only checking does it match\ndouble a of course it does right we just\nrepeat the a\ntwice so in this case we return true\na third example so let's say our input\nstring is a b\nand we're checking does it match the\npattern dot star\nso basically what this dot star means is\nwe could have\na string that's empty right repeating\nthe dot zero time so empty string\nuh we could repeat the dot once so dot\nwe could repeat it twice double dot\nright and so on and so on and\nso let's say this right double dot is\nwhat we're looking for we're checking\ndoes\nthis match a b well one of the dots\ncould be\na and one of the dots could be b so that\nmatches\ndouble dot so this would return true\nso as you can see that there's probably\ngoing to be a few edge cases we have to\ndeal with right\nthe complexity really mainly comes from\nthe star the dot isn't so difficult\nright\nbut the star makes things interesting so\nlet's just try to brute force this let's\nlook at one example\nthis example let's say this is our\nstring s and\nthis is our pattern a star so as you\nknow the star\nis really where the complexity comes\nfrom so let's make a decision tree let's\nbrute force this\nso this is the string we're trying to\nmatch to this is our pattern a star\nwe know so we're first gonna look at the\nfirst a\nand then we're gonna look at the first\ncharacter of this now\nthis isn't just an ordinary character\nthere's a star that comes after it so\nthis could be repeated\nzero times or more times right so let's\nbrute force this\nwe know we have a choice are we gonna\nrepeat the a\nat least once or are we gonna repeat it\nzero times if we repeat it zero times\nthen we\nend up with an empty string right if we\nrepeat it once\nwe end up with a single a now clearly we\nwant the single\na because it matches this right\nand if we decided to to have an empty\nstring meaning we want this star to\nor and this character a to repeat zero\ntimes then we would have to\nmove to this position right and there\nclearly\nisn't any character here maybe there\nwould be a b maybe there would be\nan a but there's clearly nothing there\nso this is this\ndecision is going to stop right we\ncannot go any farther\nall we can do here is an empty string\nbut it's okay because we ended up\nmatching with this a when we were on\nthis\npath right so now the character we're\nlooking to match in the input string is\nthis\nsingle a so now again we have a choice\nare we gonna repeat the star like in\nthis\nspot we repeated the star and this we\ndidn't repeat the star\nnow again we have that choice are we\ngoing to repeat the star or are we\nnot going to repeat the star if we don't\nrepeat the star we're going to end up\nwith a\nsingle a and then we're gonna have to be\nshifted over to this position meaning we\ncannot use the star anymore\nso we're gonna stop right this is going\nto be our string a single a\nbut you can see in our input our input\nstring was a double a\nso really our other decision where we do\nrepeat the star at least one more time\nis gonna lead us to\ndouble a and that's good because now we\nhave the second a meaning we matched\nthis second a right so now in reality we\nhave matched\nthe input string but just to show you in\ntheory we could\nkeep going we could decide not to use\nthe star anymore right we would be\nshifted to that position\nand in which case our ending string\nwould just be double a or we could use\nthe star\none more time meaning we'd get triple a\nbut then of course you can see we're\neven bigger than the input string that\nwe wanted to match so we stop\nbut we see that we did end up finding\nthe results since we\nfound the result right we found the\ninput string\nthat means that these do match right so\nwe would return\ntrue because the input string matches\nthe regular expression but as you can\nsee\nwe're doing a decision tree this is not\nexactly going to be super efficient\nright\nhow many decisions are we going to have\nwell any time we get to a star\nwe're going to have two different\ndecisions how many times can we repeat\nthat decision it's going to be\nn where n is the input string\ns so clearly you can tell this is not\nsuper efficient\nbut in case you haven't noticed this is\na dynamic programming problem and if we\ntake this\nand we implement a cache then we can get\nthis time complexity down\nto n squared or in other words really\nwe're getting it down to\nn times m where n is the length\nof the input string and m is the length\nof\nthe pattern and this is if we do the top\ndown\nmemoization with a cache we can also do\nthe actual\nbottom up dynamic programming solution\nso the bottom up dynamic programming\nsolution\nand both of these actually have the same\ntime time complexity so i'm going to\nshow you the top down coding solution\nbut once you know the top down solution\ngetting the bottom up full dynamic\nprogram solution\nis not usually impossible but before\nthat let's look at one more example\nso the index i'm going to use so let's\nsay this\nis our input string s and this is our\npattern p so i'm going to use two\nvariables to keep track of where we are\nin each of the strings i'm going to use\ni to tell us where we're at in the input\nstring i'm going to use\nj to tell us where we're at in the\npattern so\nremember whenever we reach a character\nthat has a star that comes after\nwe have two choices so i'm going gonna\ndraw our decision tree\nwe have a choice to use the star\nor we have a choice to not use the star\nso in this case if we use the star\nmeaning we use the character at least\nonce we're gonna get a c right we're\ngonna repeat the c\njust once if we don't do that we're\ngonna\nget an empty string so i'll just draw\nthis dash for empty string now you can\nsee we have a c\nbut the first character of our input\nstring is a\nso really what we want to do is not use\nthis c any times meaning we do not want\nto use the star we don't want\nto repeat c even a single time\nso the decision we want is not this\ndecision but this\nis the path that's going to lead us to\nthe correct answer\nso what am i going to do with this j\npointer i'm going to shift\nj so i'm going to shift j over here\nright so notice what we just did in this\npath where we do not use the\nstar right we didn't use the star what\ndid we do\nwe ended up shifting j by two so we\ntook j and then added two to it that's\nvery important because any time we\nchoose\nnot to use the star we're gonna take our\npointer where it's at and then shift it\ntwice because we're shifting one to get\nto the next character but also look at\nthe star we don't want to land\non the star we want to land at the next\ncharacter\nand what about pointer i are we going to\nshift that well since we didn't use the\nstar that means we weren't\nable to match with the character a right\nso actually i\nis going to stay exactly where it is\nso in this decision what we did is we\nleft i\nthe exact same and then we took j and\nadded\n2 to it and this is very important\nbecause this is exactly what i'm going\nto do\nin the code so i remains the same j\nplus 2. okay so now we're still at this\na but our j is over here so notice how\nj right after j is a star that means\nthis character a can\ncan be repeated zero times or it can be\nrepeated one or more times\nso again we have a decision to make so\none decision is we use the star at least\nonce the other decision is we do not use\nthe star at all\nso if we use the star once we'll get a\nstring of\na if we don't use the star again we'll\nend up with an\nempty list or an empty string so\nremember when we used the star over here\nwe got a c that didn't match the a but\nnow we actually have\nan a that exactly matches the character\nover here right\nbut what about this path right right now\nwe have an empty string\nis this path gonna lead us to the\ncorrect answer well the only way to find\nout would be to continue on this\ndecision tree right making decisions\nand stuff but i'm not going to show that\nbecause it's going to get pretty messy\nand you can tell by looking at the\nstring since we chose this path we would\nhave to\nleave i as it is and we'd have to add 2\nto j\nso i would stay here j would be moved\nover here and then you see the pattern\nleft at this point is just b does that\nmatch the input string s it definitely\ndoes not\nright so clearly this decision is not\ngoing to lead us to the correct answer\nbut let's look at this this is promising\nlet's continue on this path so\nso if we end up using the star as we did\nright now how are we going to update our\npointers well take a look at i\nwe matched a exactly what we wanted to\ndo\nright so what are we going to do with i\nwell we're allowed to shift it by 1 now\nso we're going to take i and move it\nover here right we already matched\nthis character we don't really need to\nmatch it again\nbut we do need to match the remaining\nstring of s\na and b what about j well j\ncan stay the same because we use the\nstar once we repeated this\na once now we can continue to repeat it\nor we can repeat it zero times\nand we can make that decision by rem by\nleaving\nj exactly where it is so when we go down\nthis path\nwhen we actually use the star what we're\ngoing to do is add one to i\nbut leave j exactly as it is and this is\nimportant too\nthese two things are important because\nthis is exactly what i'm going to do\nwhen i write the code\nso since we're still at j and there's\nstill is a star\nthat comes after it we again have two\nchoices so we can choose again\nto repeat this a or we can choose\nto not repeat the a so if we repeat the\na\nthen we're gonna get the string double a\nright\nand if we choose not to repeat a then\nwe're gonna have a single\na and then meaning we're not gonna use\nthis anymore and then we're gonna have a\nb that comes\nafter right and you can tell a b by\nitself\ndoes not match the entire input string\nright so clearly\nthis is not going to be the solution but\nyou can see that the new character we\njust added the single a\nit matches exactly what we were looking\nfor another\na right so that means we can repeat what\nwe just did\nup here we can take this i and shift it\nby one\nand we can leave j exactly where it is\nso now i is at the last character in s\nand i was shifted by one and j remained\nthe same\nokay i'm starting to run out of space\nbut let's see if we can finish this\nagain we're at this position where star\ncomes after right j\nis over there so we have two choices we\ncan\nuse the star or we can not use the star\nif we use the star we're going to get\ntriple a\nright and see the third a it does not\nmatch the character that we're currently\nat b so clearly\nthis is not going to be the decision we\ngo down\nif we don't match the a then we're going\nto end up\nwith a double a right exactly what we\nhad before\nright but in this case as we usually do\nwhen we\ndon't use the star what we're going to\nend up doing is taking i\nleaving it where it is because we know\nwe didn't match this character right now\nbut we're going to take\nj and add 2 to it and since\nwe add 2 to j that means we have to\nshift it by two so now j\nis going to be at the last character in\np at the b\nand notice how j now the character after\nthere's no\nstar that comes after right so we\nactually don't have a\nchoice right now we are only checking\ndoes the character at j this b\ndoes it match the character at i this\nother b\nwe don't have a choice because there's\nno star we're not allowed to repeat this\nb\nzero times or one time or three times we\nhave to use it\nonly a single time right we must use it\nwe're required to use this b\nbut lucky for us we have a b right here\nright so we don't have a choice right\nnow\nwe're just checking do they match and\nthey do so\nwhat we're going to do now is see that\nour string that we created with our\nregular expression\nis now a a and\nb right and that matches what we wanted\nto\nin the input string but it's important\nto note\nwhen we do not have a star we're\nstrictly checking do the characters\nequal we're checking does s of i\nequal p of\nj and if they do equal what we're gonna\ndo\nhow are we gonna update our pointers i\nand j we're gonna take\ni add one to it and take\nj add one to it we're going to do this\nin the code\nso now when you see if we take our i and\nthen\nshift it over here so i'm just going to\nmake a barrier between these two and if\nwe take our j\nand shift it by one you see both of\nthese\nare out of bounds right i is out of\nbounds\nand j is out of bounds that's how you\nknow we have\nperfectly matched so really when we say\nthat\ni is greater than or equal to the length\nof s meaning it's out of bounds and\nj is greater than or equal to\nthe length of p that's how you know they\nhave matched exactly perfectly\nbut my question is what if i wasn't\nwas i was still in bounds but what if j\nwas out of bounds what if j was greater\nthan or equal to the length of\np so an example would be this let's say\nour input string was\na a right that's our input string our\npattern\nis a is just a single a right let's say\nour\nour index of i was here let's say our\nindex of\nj was over here right clearly this does\nnot match this is our string s this is\nour pattern p\nthis does not match this right\nso basically if only j is out of bounds\nthen they do not match because we still\nhave some string\nin the input that hasn't been matched\nbut\nwhat if the opposite was true what if i\nwas out of bounds right i\nis out of bounds so i is greater than\nthe length of\ns but j was still in bounds what does\nthat look like\nan example would be this let's say we\nhad an input of\na and let's say our pattern was\na star and b star\nso let's say our index of i was shifted\nby one so our i\nis over here and we took our j starting\nover here\nwe matched the a a single time then we\nshifted our j\nto be at this b character so basically\ni'm asking so with our i over here and\nour j\nover here do these two strings match\neach other\ntechnically yes right because this b\ncould be repeated\nzero times and still match\nthe input a so just because i is out of\nbounds\ndoesn't mean we have to return false but\nas i just showed a second ago\nif the j happens to be out of bounds so\nif the j\nis out of bounds then we must return\nfalse i know this is probably a little\nconfusing with these edge cases\nbut i hope the examples make it clearer\nand i hope the code that i'm about to\nshow you makes it even more clear\nso again i'm going to do the top down\nmemoization dynamic programming solution\nnot the bottom\nup i think the top down is easier to\nunderstand when you're first starting\nthis problem just doing the bottom up\nsolution\nis more confusing in my opinion but we\nare going to do this\nrecursively so i'm going to do a nested\nfunction depth first search inside\nof our uh is match function i guess you\ncould call this backtracking or you\ncould call it\nuh whatever else you wanted i'm just\ngoing to call it dfs\nand we're passing in i and j which are\ngoing to tell us what position we're at\nin the input string s for i and j is\ngoing to tell us where we're at in the\ninput string p\nso as always with recursive functions\nlet's start with the base case i just\nshowed you that if\ni is out of bounds and j is out of\nbounds that means we have found\nour solution that means we were able to\nmatch the pattern to the string so we\ncan return true\nbut as i showed you if i is not out of\nbounds but\nj is out of bounds we have some string\nin s\nthat we haven't matched and there's no\nway we're going to be able to match it\nso we have to return\nfalse so these are our two base cases\nnotice\nthat given these two cases it's still\npossible that\ni could be out of bounds right i\ntechnically could be out of bounds\nand neither of these return statements\nwould execute right because\nthis needs i and j to be out of bounds\nso\nwe would pass this and we would pass\nthis and i could still be out of bounds\nbut i'm going to show you how i'm going\nto handle that right now\nso the first thing we want to check is\nis there a match\nbetween the first character so\nis there a match between s of i\nand p of j and the other thing we could\ncheck\ntechnically right p of j could have\na period in that position meaning the\nperiod matches to\nany character right so we have to check\nthis or check this\nand since we know i could technically be\nout of bounds before we even\ncheck this we have to confirm that i is\ninbound so i is less than the length of\ns so strictly less than not less than\nequal so\nif these conditions are satisfied that\nmeans the first character\nof each string matches exactly the\nreason i'm putting this in a variable is\nwe're gonna have to repeat it a couple\ntimes in the following code\nso the first thing i want to check is\ndoes the\nfollowing character in uh the pattern\nstring so p\nof j plus one does it match the star\nis it a star and the reason i'm checking\nthis first is because the star has the\nhighest precedence and i'm checking j\nplus one because we know the pattern the\nfirst character in the pattern string is\nnever going to be a star and since i'm\nchecking p\nof j plus one i have to first check that\nj plus one\nis inbound so i have to check that it's\nless than the length of\np so if this is true that means we're\ngonna have to\nwe're gonna have to take care of this\nstar right and\nwe remember when we encounter a star we\nhave two choices so i'm going to do a\nrecursive call right\nthat first search the first choice we\nhave\nis don't use the star right if we\ndon't use the star we leave i as it is\nand we take\nj and add two to it right that's one\nnow we know we have two choices if\neither of them evaluates to true\nthen we can return true right we're\nbrute forcing this right now\nso the other decision we have is the\nother decision we have\nis use the star right so if we use the\nstar\nthat means we can take i and add one to\nit\nand we can leave j where it is but\nremember we can\nonly use the star if there's a match\nbetween\nthe first character right the first two\ncharacters right because we only want to\nuse the star if there happens to be a\nmatch\nso really here we're checking if there's\na match\nand this whole thing about this\nrecursive call evaluates to true right\nso i'm going to wrap this\nin parentheses so basically what i'm\nsaying\nis these are our two choices this is one\nrecursive call and this is another\nrecursive call if either of these\nevaluates to true then we can return\ntrue and that's what i'm doing basically\nby putting these\non the same line so i don't know the\nbest way to format this\nmaybe this is somewhat readable\nso if either of these is true we're\ngoing to end up returning true if\nneither of them is true we're going to\nreturn false so this\nby itself this these three lines of code\nhandles\nthat star for us now if this isn't true\nmeaning we don't have a star\ncharacter then we're looking just for a\nsimple match right so we can just\ncheck if match if the two characters\nmatch\nthen what are we gonna do well remember\nwe can then\nincrement i by one and we can increment\nj\nby one and return the result of that\nnow if there's not a star and the\ncharacters don't match\nin that case it's simple right then we\ncan just return false meaning that this\nstring will never match the pattern so\nthen we return false\nand this is the brute force solution\nit's actually as simple\nas that so let's let's return it and let\nme show you how\ninefficient it is right now so we can\ncall our debt for search\nstarting at zero in both of the strings\noops i had a syntax error so we had\ndouble equal over here we have to put\ndouble\nequal over here oops and one last thing\nwhen you have multi-line stuff in python\nyou have to wrap it all in parentheses\nso i'm just going to wrap this entire\nthing in parentheses\nhopefully it's still readable and a\nthird bug so i don't know why i checked\nif j\nis out of bounds of string s when j\nrefers to the\nindex of string p so sorry about these\nbugs\nbut okay so this time it finally worked\nyou can see it's not\nsuper efficient right it took about i\nthink this is 1.3 seconds\nand it was 11 so we did the top we did\nthe brute force solution but look i\nforgot to do the memoization right so\nlet's\nactually do the caching now and make\nthis efficient so i'm going to create a\ncache\nit's going to be a hash map so before we\ndo anything\nwhenever we call this function we're\nfirst going to check if i\nif the pair i j has already been added\nto our cache\nif it has then we can return it right so\nthis is going to\nbasically not have to is basically going\nto take care of repeated work for us if\nwe\nexecute this we're not going to have to\ndo all the repeated work but now we\nactually have to use this cache so\ninstead of returning this right away you\ncan see down here i'm going to actually\ntake this and add it\nto the cache so at index ij\ni'm going to put the value that this\nreturns to\nand after that after we add it to the\ncache\nthen i'm going to return it and i'm\ngoing to do the exact same thing\ndown here so adding this\nto the cache and then we can take this\nand return it so we're all we're doing\nright now is caching\nthe work that we do so we don't have to\nrepeat it lastly down here we can\nsay in the cache add\nfalse and then return false so basically\nby just adding what\nlike four or five lines of code we've\nadded the caching element to this\nfunction it was pretty easy so taking\nthe brute force to the\noptimal solution was actually pretty\neasy and look at the result\nlook how much faster this is 44\nmilliseconds\n81 so we actually didn't even\nneed to do the bottom up dynamic\nprogramming solution right\nand this i will be honest with you is\nnot the prettiest way to write this code\ni've seen solutions that are a lot\nbetter than this but i really hope that\nyou\nat least were able to understand what\nwe're doing right\nthe the meat of the work is done\nin this call right basically these\ntwo lines of code are the work that\nwe're doing right this is where we're\nhandling the star\ncase and you can see it's actually not\nthat difficult right\nall we're doing is i stays the same j\nadded two\nor i plus one j stays the same right and\nyou\nunderstand why we're doing it like that\nfrom the picture that i drew\nbut i encourage you to do the dynamic\nprogramming solution i'll probably\nlink the code for that in the\ndescription and i hope this was helpful\nif you enjoyed please like and subscribe\nit supports the channel a lot\n"
    },
    {
        "Name": "Maximum Subarray",
        "NcLink": "maximum-subarray/",
        "Pattern": "Greedy",
        "Description": "Given an array of integers `nums`, find the subarray with the largest sum and return the sum.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n**Example 1:**\n\n```java\nInput: nums = [2,-3,4,-2,2,1,-1,4]\n\nOutput: 8\n```\n\nExplanation: The subarray [4,-2,2,1,-1,4] has the largest sum 8.\n\n**Example 2:**\n\n```java\nInput: nums = [-1]\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "5WZl3MMT0Eg",
        "PythonSolution": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        res = nums[0]\n\n        total = 0\n        for n in nums:\n            total += n\n            res = max(res, total)\n            if total < 0:\n                total = 0\n        return res\n",
        "Transcript": "let's all leak code 53 maximum sub-array\nso we're given an integer array of\ngnomes and we want to find the\ncontiguous sub array containing at least\none number which has the largest sum and\nthen we want to return only the sum so\nthis array has in positive numbers and\nit has negative numbers so that's what\nwe have to keep in mind in this case the\nlargest sum is 6 and it's just this\nmiddle portion of the array so the first\nthing you might try is just compute\nevery single sub array right so let's\nfirst compute every single subarray\nstarting at negative 2 there's one sub\narray there's 2 sub arrays there's 3 sub\narrays and then we keep doing that until\nwe got to the end right and then we\ncould repeat the process for the second\nnumber so the sub array starting at 1\nhere another sub array starting at 1\nhere all the way until the end\nnow we could repeat that same process\nfor every number in the array so let's\njust write the pseudocode to see what\nthat what kind of complexity this would\nyield so let's say we're starting the\neye is gonna represent the starting\nvalue it's gonna be it's gonna range\nfrom zero all the way to the last number\nn minus 1 or the last index and minus 1\nand then we want to get the ending index\nso I'm going to use J for the end of\nthis sub array so we're gonna start at I\nand we're going to keep going until the\nend of the sub array or until the end of\nthe entire array and minus 1 so this\nrepresents the start I represents the\nstart J represents the end now we\nactually want to compute the sum of this\nsub array so we're gonna have a third\nloop for that right let's use KK is\ngonna range all the way from I to J\nright because that's what represents the\nsub array and then in here we'd compute\nthe sum right now obviously this is\nreally inefficient right the time\ncomplexity is n cubed it's obvious\nbecause we have 3 for loops so let's try\nto expand upon this let's see if we can\nmake any shortcuts to improve it so the\nmost obvious thing you'll probably\nnotice is that we can save time when\nwe're computing a sub array so if let's\nsay we computed this sub array right and\nwe want to compute the next sub-array\nwas just one added element well we can\nsave the result of this right and say\nit's our current summer or whatever and\nthen to compute this sub array we just\nhave to add this number over here right\nso we can just say current sum plus\nnegative 1 and so this can save us time\nlet's take a look at the time complexity\nof this solution so we're going to have\nanother for loop which is going to\nrepresent the start so start is going to\nrange from 0 all the way to n minus 1\nand we're gonna have another loop for\nthe end of the sub array\nJ is going to range from I 2 the last\nindex n minus 1 and then inside of the\nloop we're going to maintain our current\nsum and simply just add the number J\neach iteration of the loop right so this\nis a little more efficient o of N\nsquared it's a pretty easy optimization\nto make and it improves your solution a\nlot but can we do even better than this\nso now the question you should ask\nyourself is do we have to compute every\nsub array starting at every single value\nin the array right do we have to start\nat every single value and compute every\nsub array that comes after it I don't\nthink we do remember we're trying to\nfind the maximum sub array we can use\nthat knowledge to help us make a\nshortcut so let's take a look at this we\nhave a negative 2 right so when we're\nstarting here that's gonna be our max\nsum so far then we get to negative 2\nplus 1 so this is negative 1 so far\nright do we actually need this negative\nnumber the negative numbers don't\ncontribute anything in this case right\nso we can disk we can basically ignore\nthat value right once we get here we can\nbasically say this negative value this\nnegative prefix that came before\npositive 1 isn't gonna help us at all so\nlet's not even consider it\nso next do we get to this negative 3 now\nup until here our total sum is negative\n2 right so then we get to this 4 this is\na negative prefix that came before\nnegative too right so we can say up\nuntil this point we're not even gonna\nconsider what came before so this one\nand negative three aren't gonna help us\nat all just ignore them now we get to a\nnegative one so the prefix that came\nbefore this was a positive four so we're\ngonna not delete it from our list we're\ngonna keep that positive four and add it\nto this negative one so now we're gonna\nbe a three so far now we get to a\npositive two right even though there's a\nnegative one that came before it well\nthere was a positive forward that came\nbefore that so if we get rid of this\nnegative one we also have to get rid of\nthe positive four which we don't want to\ndo remember we have to keep the\nsub-array contiguous so I'm not gonna\nchop this portion off I'm gonna keep it\nnow now we're gonna add two to it so now\nwe're gonna be at five then we're gonna\nget this one we're gonna add it and get\nour sub array of six and this is the\nresult so far but let's keep going and\nsee what happens next will have a\nnegative five right so minus five now\nwe're at one so obviously we decreased\nour sub array but we know this negative\nfive is not going to be deleted because\nwe had a positive six portion comprised\nof these four elements that were that\ncame before that\nlastly we get a positive four again add\nthat our sum is still five so we see\nthat the max of our a was this portion\nof these four elements which totaled to\nsix now this was a linear time algorithm\nit's kind of like a sliding window right\nwe keep incrementing our right pointer\nas we go as we go through the array\nright but our left pointer keeps getting\nshifted if we ever have a negative\nprefix like this negative two or this\nnegative two portion comprised of these\ntwo elements so anytime we get a\nnegative prefix we remove it and for me\nit kind of helps it kind of helps me to\nthink about this as like a sliding\nwindow and since it's a linear time\nalgorithm the overall time complexity is\nBig O of n we didn't need any extra\nmemory we just had to go through the\narray removing any negative prefix as we\ncomputed the total sum okay so now let's\ncode it\nso we can initialize our Max sub-array\nto the first value in the array that's\nlike the default value that we're going\nto give it because we have to give it\nsomething and it can't be zero because\nwe know we have negative values in this\narray and we know the array is non empty\nso the zeroth value of the array is\nalways going to exist and we're going to\nbe constantly computing our current sum\nso I'm going to initialize that to zero\nnow remember if we had a negative prefix\nwe're going to remove that portion from\nour current sum so the way that we can\ncheck this is just check if current sum\nis at any point negative if it's less\nthan zero we're just going to reset it\nback to zero and then after that we can\nadd our current number to this this will\nmake sure that we're always computing\nthe maximum that we can now this current\nsum could be the possible maximum so\nwe're just going to update our max sub\narray to the maximum of itself as well\nas the max that we just computed after\nwe're done with that we'll return\nwhatever we computed as the max sub\narray I hope this helps show you kind of\nthe intuition behind the solution of\nthis problem if it was helpful\nleave a like and subscribe and thank you\n"
    },
    {
        "Name": "Jump Game",
        "NcLink": "jump-game/",
        "Pattern": "Greedy",
        "Description": "You are given an integer array `nums` where each element `nums[i]` indicates your maximum jump length at that position.\n\nReturn `true` if you can reach the last index starting from index `0`, or `false` otherwise.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,0,1,0]\n\nOutput: true\n```\n\nExplanation: First jump from index 0 to 1, then from index 1 to 3, and lastly from index 3 to 4.\n\n**Example 2:**\n\n```java\nInput: nums = [1,2,1,0,1]\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `0 <= nums[i] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "Yan0cv2cLy8",
        "PythonSolution": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        goal = len(nums) - 1\n\n        for i in range(len(nums) - 2, -1, -1):\n            if i + nums[i] >= goal:\n                goal = i\n        return goal == 0\n",
        "Transcript": "I have one more Compact jeita Monica\nToday Of Love is very popular problem\nand problem on my page from about time\nat some Cash service is very popular and\nanimate pro Gaming Chrom American\nauspicious engg Where and Honor soluble\nsolution and get Gold of tradition and\nis very  little card To The girls band\nTogether for the first day of interest\nearned Mendeleev not number sofun Evil\nforces and wine aspic reason It is first\nIndex of Yours for example in this\ninvalid request the first in the chords\nin the straight ofertas instasquare\nguests were installed in  the dishes and\nsufferings are you in their public event\nthat number search of information on\nnumber 23\nthe first and present events from our\ngreat performance at everything of the\nEarth is possible time It's from its\nreason Which you need to invest love to the\nmeaning of stunning gets  destroyed and\nanother example from here synthase ones\nwith you tim lactum Cookin There is one\nmini with your eyes off you next Last\nDay Of Your decision trees that Comes to\nstreaming We cannot read leander\nyusananda for from your writing speaking\ntest love and three children over there\nare many other cities and every day you\nhave the strap site will know me at hand\nWhich you exactly storing from here\nDrive and the browse our people Tourist\ndestinations\nI last value in array or late show in\nthis postum travel leandro is us to\noverthrow position  Yes with hand with\ninstructions How can we do Well we\nstart Here suika you and someone who you\nwill control and Government one day we do\nn't have in doing mock rapper way we\nthink to do once as any person would a\nrealistic and additional eight nine  west\nvalley wiki is someone To Want Some\npeople want to avoid Number One Story\nand woman to streamline Pigeon our Mini\nWorld are what Screen Write what you\nsoon level jealousy and therefore I\ncan't listen sverdlov Ok show what would\nin the first and the last  word usage\nApple pen with almond hand with special\npart Essence\nI just within Be Alright Insert\nworkgroup ports found you look more\nstuff from work at every possible per\nweek I take one applekeystore here's\nWhat every single test wiki page content\nand Turning their Speed \u00e2\u20ac\u2039\u00e2\u20ac\u2039and the five\nAnna single parc des r-squared\ndestinations and version pro free Credit\nfor your treatment in Dak terminologies\nand actresses want to three and Were\nsoldiers In The Seas uninstalled artisan\nYours and Training and positions Zero\nand when sitting around you have value\nof Story Love In The  Weakest make Dreams\nof and want our Rooms are doing here\nWhere is one of our free Fu magazine of\nwork for you\nI will get to wait to Live Show the next\nand if you Chuck and one of us once\nThere were here example One vanness Wu\nYing  data-index One press select one of\nyour Price Index want a few Seconds\napart tubeless Again it and add to the\ncontrol Point the lives of special\nguests in their free search resources in the\nDust In The Series Asus What is the\neasy way to learn English  easy for use\nwith leading Index because value on the end\nScreen to want is absent from their\nhabitats aj for your speaking persona\nReaper sans fangirls in decan ones and\nIsland were built to We all about you\ntell you that means it to your friends\nof want what  is to inject DOSO want the\nseason is just want want to get students\nto work in shade love and to\na for me even though I'm sick industry for\nuse with Soobin stages of quests and\nThat's the industry same Network restore\nindustry And you consider leaving our\nfood feeder world and ask you show this\ngroup established itself And The Power\nof and Drivers and that live work of\ninterest and Steve worked for\ninstallation disc golf page time\ncomplexity of person with Amazing Hair\nkastamonu calcium estimated go up and\nsuites with Somebody needs You Westlife\nleopard screws and optimized for schools\nand honestly this method is where they\nGo of event and compared utensil like\neasy Brothers dood from in date to wish I\nEver You One daydream input\nthe one and one is the way from all\nthree hours of fun you stay  with that\nfree for men of that Where It's that it\nshows the word in the story price our\nusers use the word Which is loaded with\nme and dream making love with Zero What\ndo you do not Nawat spaces is present\nand brush spaces in this is deddy  and\nrealistic Harris anywhere you now niacin\ngo to the restless personal Gallery and\nfind the sentences with her Dreams and\nwest gi I regret and history is also\ninjured and becoming data in date today\ni was a great weekend Drama and Where\nHave You Gone to zero for  Speed \u00e2\u20ac\u2039\u00e2\u20ac\u2039and\npress and Yes we only have one account\npassword\n- from injectors deep swendson abrus for\nsuggestions and demands of paint now\nYou're interested feel well you now and\ncontinue the response Ok and actor will\nhave about you want to damanqua\nmechanism of Awards in  major for which\nwere established with Sweet Story and\nthe winners resort andropov continue\nversion more like this wind's love and\ntherefore We continue unistrut notice\nwhich don't assume I Have Is because\nThis is not the first use the work out\nof enemies and indirect Super full  -day\nvote average Price has invested in the\nactors and winds and which powerquest\nbristol base-case Wear me out of this\nworld is problem which could not with a\nWhat is dealt with Stories in next to\npractice with the Style claim this\ndecision fitouts we start  in date with\nHannah witch and the widgets such as is the\nweakest do in our memories people\nthink will happen When compared with the\ncapacity of industry in Canon be fair\nplay That is the spill Over The Vision\nof warring con and tried to Singapore\nand speak We  cannot respond And now\noverseer in this position In The tools\nWe also we don't have to manipulate will\nhelp you continue the season of making a\ndrop of War Dragon trilogy mini stop\nsaoca know we know that from ecology and\nand you know you were my  Honest but Now\nit's not established and later When\ndoing that\na white y Kate switzer TP free in a Cell\nPhones someone is portrayed second\nEdition want you take one or existing\nones and stir fried Index want pizza\nparts used to print leandro support show\nTeppi all Together  the first and You\nAgain for food of Death to root Browser\nweb store in the first established and\nturned out to match all axes and we\ncannot receive and therefore I Valve\nbeach Pearl to listen in paris\ninfallible hathaway print Soda page load\nin scanner before We all  work on all\nPlaces High School of of Four Seasons\nand welding and Cash to speed up first One\nIf You Do Use xtramath scast you\nconnected to listen to be your love and\nwhite and Converse Real Betis Win\nevening\nattention commentator Grid and which have any\ntime Which is big old and solutions with\nme She has doubt whether Ana Gold\nresource of which also now better get\ninto the traditional solutions services\nGrid and cannot be doin It is important is\nit from her prince Park solinh edena\nmicrogaming best work are we know the\ncity \u00e2\u20ac\u2039\u00e2\u20ac\u2039Stories of What was the first last\nlesson on going to get to the and then\nWrite up is Worth It was the world\nwealth start And The Scene and see We\ncan't wait to The Beginning and access\nand straight Away The Body is the person\nstarred in paris in this is really copal\nWrite this position I would like to which\nWe consider the Walk Away The cost\nlatest addition it right next to open\nGoogle Drive Space\nca co and double time went to the Gold\nRush Gold and Silver with National guard\nThe  One Mini out wiki made love and also\nreally will go here we made Love And now\nwould have gone with it is that house\nrestaurant and powers that when you Asus\nTouch this position animal aid If I'm\nsorry over heels driver string over\nheels diski overhear  kanglim with the\nend Screen Write winifred this right\nhere with me and what would like to\nreach does that mean that we can take\nour goals and It lighter's Over Here right\npeople don't want you anymore Now on\nyou good things at the stands peekaboo\nkimmel beach and  from here were\nnot wanting to get to use\nMr. Quy huy gopas welbeck yourself is\nunaware that goes over now spaghetti\nnext to the scene ever eaten This is One\nThat could speak to you Makin love\nwith one Over Here Right Now know this\nCake hurwitz Bee and  disputes with hands\nwith this election which more Gold is\nWhat's your problem are just want to\nwork with gopal speaking GTA shroud csgo\nFor One More Time with the movie address\nwill be cautious to our desktop version\nNow we were once Together the result of\nthe week in  the control of exactly what\nyou control you want to sleep Oh well\nover his Greatest American Dreams all the\nway to the end with other server\nspottiswoode unnecessary Because we\nshare The First Avenger mod Pack\nwhen mixing akachan for all major for\nsomeone I miss your Defense position  as the\nway we can now take that goes and\nTina turner coastal Hill almost at which\nthe stall banawa Simulator wiki major\nport to one and Whisper three Weeks Ago\npost from the first and Write data for\nyour Movies once time to stop The Reason\nfor that purpose  is Yes we can dance\ntroupe picket fence torrent and all the\nweather is bad for people to match the\nAndroid ebook we still want to spend the\nweekend and work in this in the Venue\ntime peaked at work Everyday We kept\nSting netgo ponta grossa mcintosh Amazon\neven  is extremely fast English solutions\nand we don't have to have I got the\nSeasons live dooraemon is the cats\noutside the yen price the screen\nis many at time of group now and messy\nhair for their love for example shows\nmemorable Germany DJ  gopal Trade shows\nWhen I swore you'd have that goes well\nfor elementor etienne chocolate bi bi\nAndroid for tourists come What interests\nin War invalids and remember wanna one\nway that were integrated impact on the\nsite are you doing you take the work of\nfood and  you can do it rained good witch\nthe basic wear warm Winter White as your\nDigital watch in date and Went Away The\nBeginning of wysteria nestled in the\nheart the first last somehow I wanna\nhold with prepositions Lite for now the\nvirus numpy random And Love You Westlife\nI want to know and love story of dislike\na lot of integrated and would it cost\nand your address is Miss joaquim with\nTango What do you do when we can't exist\nor will we ship Lego bash evancho cells\nthat people exist Gold Hill wiki optical\nto  be our prayer is Jumping from raynor done\nbattleworn adjustable Speed \u00e2\u20ac\u2039\u00e2\u20ac\u2039or hate\nthat problem For You Are You Now we\nstill and write the third single Rose\nizico Google Now you are right meaning\nthat from the cind Jours Abbott gawgaw\ngogobig Trade War between the will not\neven  to beach and get the money in\nForest so We can't make\nintention-to-treat goal is equal to zero\nelse around for tourists and Install it\nname and work time\na prison know as Mary is quiet and Face\non in your level shemade be  worth to\nwork hard by reason of person in the\nanswer of War Epic third of Heart stop\nnever want what subjects sportswear\nhours and hopefully it very seemed\nsearch\n"
    },
    {
        "Name": "Jump Game II",
        "NcLink": "jump-game-ii/",
        "Pattern": "Greedy",
        "Description": "You are given an array of integers `nums`, where `nums[i]` represents the maximum length of a jump towards the right from index `i`. For example, if you are at `nums[i]`, you can jump to any index `i + j` where:\n\n* `j <= nums[i]`\n* `i + j < nums.length`\n\nYou are initially positioned at `nums[0]`.\n\nReturn the minimum number of jumps to reach the last position in the array (index `nums.length - 1`). You may assume there is always a valid answer.\n\n**Example 1:**\n\n```java\nInput: nums = [2,4,1,1,1,1]\n\nOutput: 2\n```\n\nExplanation: Jump from index `0` to index `1`, then jump from index `1` to the last index.\n\n**Example 2:**\n\n```java\nInput: nums = [2,1,2,1,0]\n\nOutput: 2\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `0 <= nums[i] <= 100`\n",
        "Difficulty": "Medium",
        "Video": "dJ7sWiOoK7g",
        "PythonSolution": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        l, r = 0, 0\n        res = 0\n        while r < (len(nums) - 1):\n            maxJump = 0\n            for i in range(l, r + 1):\n                maxJump = max(maxJump, i + nums[i])\n            l = r + 1\n            r = maxJump\n            res += 1\n        return res\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve\njump game two so you might remember\nrecently we solved the first jump game\nproblem and i would recommend watching\nthat video or solving that problem\nyourself before looking at this one\nbecause this one is actually\nvery similar the main difference is we\nare the premise of the problem is the\nexact same we're given\nan integer array of non-negative\nintegers\nthey're always non-negative and we are\nplaced at the\nfirst index of this array so let's say\nthis is our input array\nwe're going to be placed at the first\nindex over here and\nour goal is going to be over here the\nlast value in the index that's the goal\nand our goal is to jump to\nthe last position from the first\nposition in\nour integer right in this problem though\nthe question we're trying to answer is\nwhat is the\nminimum number of jumps that it takes\nfor us to reach\nthe last index and luckily for us we can\nalways\nassume that we're always going to be\nable to reach that last index\nso in this first problem we know that\nwe're starting here right in this two\nposition\nif we take so since we're at the\nposition two we have two choices right\nwe can either take a jump of\nlength one or we can take a jump of\nlength\ntwo our choices are these two values\nthe three and the one if we take if we\nreach\nthe one then we take one more jump\nget to the second one and then we take a\nthird jump to get to the four\nwhich is the goal right the goal is the\nfour\nthe last position of the array or if we\nif we go to the 3 instead then we\nactually just take a jump\nof length 3 to get to the 4 which means\nthat in this case it'll take us exactly\ntwo jumps right we go from two to three\nand then we get to the goal so that took\ntwo steps\ntwo jumps and our output can be two\nbecause we're looking for\nthat minimum number of steps\nso you might know that this is a problem\nthat can be\nsolved with dynamic programming just\nlike the first jump game solution\nbut i'm not really going to go over the\ndynamic programming solution because\nactually just\nlike jump game one this problem also has\na greedy solution\nand it turns out that the greedy\nsolution is a linear time\nsolution so oh big o of n whereas\nthe dynamic programming solution is\nactually big\no of n squared so we know that with this\nproblem we can make a some kind of\ndecision tree right we know that\nthis first position right two it has\ntwo choices right if we're jumping from\nthis position right we can jump to the\nthree\nor we can jump to the one right\nso those are our decisions right so\nreally from two we can get to these\nnext two values the greedy solution\nis going to be something similar to\na breath first search type solution\nright\nso next so we looked at this value right\nthis\ntwo that was the starting position and\nwe saw that these\nare the next values that we can go to\nfrom there right\nwe're going to continue this process\nthat's why it's kind of like a breath\nfirst search\nbecause we're going to be continuing\nthis exact algorithm what we're going to\nbe doing though\nnow is we saw that from here we could\nget to these next\ntwo values now the next question becomes\nfrom this entire portion of the array\nwhat are all the other values outside of\nthis portion that we can also reach\nlet's take a look at that from this\nthree we know we can reach\nthis next one right but that doesn't\ncount because it's already a part of our\ngreen\narea right we can reach that one but\nit's redundant because we can already\nget to this part we can also get to this\nnext one right so that's going to be at\nthe next\nlevel or the next part of our breadth\nfirst search\nwe can also reach the destination which\nis four right at this point we would we\nwould normally be done with our\nalgorithm because we know that\nwe can reach this four and we've\nbasically found the minimum number of\nsteps that\nallow us to do that but we're going to\ncontinue with this just\nto understand the algorithm so we know\nthat from this 3\nwe are able to reach these two values\nlet's just continue it just to see okay\nthis one\nwe also need to check what are all the\npositions it can reach well in this case\nit can only reach this one and that's\nalready included in our purple area\nokay so now we see that that this purple\nlevel\nis what we can reach from the green\nlevel these\nportions and the whole reason i'm color\ncoding this is because the levels\ntell us how many steps it takes to reach\nthese\ncells the minimum number of steps right\nwe know that we\nstart at this position right therefore\nthe number of steps it takes to reach\nthis position is zero right\nit takes zero jumps for us to reach this\nposition\nhow now my question to you is how many\nsteps does how many\njumps does it take to reach the green\nuh values it takes exactly\none jump right that's the whole point of\ncolor coding it because we know from\ntwo we can jump here or we can jump here\nit takes\none jump for us to reach any of these\nvalues if we're taking the minimum route\nright we're taking the minimum number of\njumps\nnow next what about the purple\nvalues how many jumps what's the minimum\nnumber of jumps that it takes\nfor us to reach these well obviously\nit's two\nbecause if it takes us one jump to reach\nthese green values\nand we can take one jump from the green\nto get to the purple\nit's going to take one extra jump to get\nhere so it's obviously going to be\ntwo jumps right this is pretty simple\nthis is a pretty straightforward\nalgorithm we would continue it\nif we had more values in our array\nbut as you can see what we're doing here\nis basically\nthrough a simple or a one-dimensional\narray\nbreadth-first search we are finding the\nminimum\npath or the minimum number of jumps to\nreach the destination right remember we\nonly care about the destination once we\nreach the destination\nwe are done so in this case we can see\nit takes exactly\ntwo jumps for us to reach the\ndestination\nso this is the visual explanation\nbut now hopefully you get the idea of\nwhat we're doing the colors hopefully\ncan illustrate that and we're going to\ntranslate this into the code it's\nvery little code the code is actually\npretty straightforward\nlet me show you how to do that part now\nthat we know the breadth for search\nalgorithm\nso remember we are counting the number\nof jumps it takes to reach the\ndestination we'll call that result we'll\ninitially set that to zero i'm also\ngoing to have two pointers\nleft and right and they're both\ninitially going to be set to\nzero because these left and right\npointers are going to tell us our\nwindow we saw that initially the window\nstarts at just 0 0 right the first\ninitial value so that's what it's going\nto be\nwe know that i think the second level\nwas\nwhere left equals 1 right equals\n2 right so this would represent a window\nfrom\nindex 1 all the way to index 2 and\nthat's basically this is basically going\nto determine what level of\nor what portion of the array is going to\nbe used for breadth first search\ncurrently\nand we know we are going to continue\nthis algorithm until\nright which is the rightmost value of\nour current portion\nuntil it reaches the last value of\nthe input array so while our right\npointer is\nless than the last index we're going to\nbe continuing our algorithm and keep\nincrementing that result so just for\nvisual purposes\nuh what i mean by the left pointer is\nthat let's say we're currently going\nthrough the green our left pointer would\nbe here because it's the left\nmost value of the portion we're going\nthrough our right pointer would be at\nthe rightmost portion\nso that's great last thing is how are we\ngonna determine the boundaries for the\nnext portion well what we're gonna do is\nwe're gonna look at\nwho can jump the farthest the three the\nfarthest jump it can make\nis one two three right the farthest jump\nit can make is to this\nvalue the one the farthest jump it can\ndo is just a one so it can get here\nright\nso what we're going to do now to update\nour pointers is\nwe're going to take our left pointer and\nset it to\nright plus one right it's gonna be\nadjacent to the\nright pointer so this is where our left\npointer would go\nwhere's our right pointer gonna go it's\ngonna go\nto the place that we can jump the\nfarthest right it's going to go to the\nright boundary of\nour purple area so we're going to cross\nthis out\nand put right over here the reason we're\nputting it over here\nis that's the farthest position that we\ncan jump to from the\nprevious section the green section\nso now let's get back into the code so\nwe are going to have a\nvariable farthest which is going to tell\nus who can jump the farthest and what's\nthe index of that jump\nso right now we're going to go through\nour portion you could say we're going\nthrough\nour green portion so for i in range\nuh from left to right plus one because\nwe have to make\nthe right value inclusive so going\nthrough this loop all we're trying to\ndetermine is who can jump the farthest\nbecause that's going to determine how we\ncan update our left and right pointers\nso\nwhat we're going to do is just set\nfarthest equal\nto the max of itself and the max\nof the jump that we're currently\nperforming so i\nis the index that tells us the jump\nwe're performing so we're jumping\nfrom index i so i plus\nthe value at index i which tells us how\nfar we can actually\njump so nums of i plus i is going to\ntell us\nwhat's the look what's the farthest\nlocation that this could jump to\nand so we're going to take the max of\nthis and then update\nthat farthest variable by the end of it\nwe should be good farthest should be\nset to what the farthest it can go is\nand then we can update\nour window right so we can say left is\nnow going to be equal to right\nplus one just like i showed in the\npicture right\nis going to be equal to farthest and\ndon't forget to increment the result\neach time because remember\nthat's telling us how many jumps we're\ntaking to get to that\nend point so once you're done with this\nthat's actually the entire algorithm\nafter that all you have to do is return\nthe result\nso what we're doing here is basically uh\na simplified\nbreadth first search it's we're doing it\non a one-dimensional\narray and we're using a left and right\nvariables to keep track of what our\ncurrent window is we're also updating\nthat window as we keep progressing\nonce our window or in other words our\nright pointer\nreaches the last value in the input\narray\nthat's when you know that we're done\ncounting the jumps and\nwe can stop our in our loop and then we\ncan return\nthe number of jumps that we took the\nminimum number of jumps\nso i hope that this was helpful i hope\nyou have a visual\nunderstanding of this problem as well as\nunderstanding the code\nand thank you for watching uh don't\nforget to like and subscribe if this was\nhelpful\nsoon\n"
    },
    {
        "Name": "Gas Station",
        "NcLink": "gas-station/",
        "Pattern": "Greedy",
        "Description": "There are `n` gas stations along a circular route. You are given two integer arrays `gas` and `cost` where:\n\n* `gas[i]` is the amount of gas at the `ith` station.\n* `cost[i]` is the amount of gas needed to travel from the `ith` station to the `(i + 1)th` station. (The last station is connected to the first station)\n\nYou have a car that can store an unlimited amount of gas, but you begin the journey with an empty tank at one of the gas stations.\n\nReturn the starting gas station's index such that you can travel around the circuit once in the clockwise direction. If it's impossible, then return `-1`.\n\nIt's guaranteed that at most one solution exists.\n\n**Example 1:**\n\n```java\nInput: gas = [1,2,3,4], cost = [2,2,4,1]\n\nOutput: 3\n```\n\nExplanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 1 + 1 = 3\nTravel to station 1. Your tank = 3 - 2 + 2 = 3\nTravel to station 2. Your tank = 3 - 2 + 3 = 4\nTravel to station 3. Your tank = 2 - 4 + 4 = 2\n\n**Example 2:**\n\n```java\nInput: gas = [1,2,3], cost = [2,3,2]\n\nOutput: -1\n```\n\nExplanation:\nYou can't start at station 0 or 1, since there isn't enough gas to travel to the next station.\nIf you start at station 2, you can move to station 0, and then station 1. \nAt station 1 your tank = 0 + 3 - 2 + 1 - 2 = 0.\nYou're stuck at station 1, so you can't travel around the circuit.\n\n**Constraints:**\n* `1 <= gas.length == cost.length <= 1000`\n* `0 <= gas[i], cost[i] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "lJwbPZGo05A",
        "PythonSolution": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        if sum(gas) < sum(cost):\n            return -1\n\n        total = 0\n        res = 0\n        for i in range(len(gas)):\n            total += (gas[i] - cost[i])\n\n            if total < 0:\n                total = 0\n                res = i + 1\n        \n        return res\n",
        "Transcript": ""
    },
    {
        "Name": "Hand of Straights",
        "NcLink": "hand-of-straights/",
        "Pattern": "Greedy",
        "Description": "You are given an integer array `hand` where `hand[i]` is the value written on the `ith` card and an integer `groupSize`.\n    \nYou want to rearrange the cards into groups so that each group is of size `groupSize`, and card values are consecutively increasing by `1`.\n\nReturn `true` if it's possible to rearrange the cards in this way, otherwise, return `false`.\n\n**Example 1:**\n\n```java\nInput: hand = [1,2,4,2,3,5,3,4], groupSize = 4\n\nOutput: true\n```\n\nExplanation: The cards can be rearranged as `[1,2,3,4]` and `[2,3,4,5]`.\n\n**Example 2:**\n\n```java\nInput: hand = [1,2,3,3,4,5,6,7], groupSize = 4\n\nOutput: false\n```\n\nExplanation: The closest we can get is `[1,2,3,4]` and `[3,5,6,7]`, but the cards in the second group are not consecutive.\n\n**Constraints:**\n* `1 <= hand.length <= 1000`\n* `0 <= hand[i] <= 1000`\n* `1 <= groupSize <= hand.length`\n",
        "Difficulty": "Medium",
        "Video": "amnrMCVd2YI",
        "PythonSolution": "class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize:\n            return False\n\n        count = {}\n        for n in hand:\n            count[n] = 1 + count.get(n, 0)\n\n        minH = list(count.keys())\n        heapq.heapify(minH)\n        while minH:\n            first = minH[0]\n            for i in range(first, first + groupSize):\n                if i not in count:\n                    return False\n                count[i] -= 1\n                if count[i] == 0:\n                    if i != minH[0]:\n                        return False\n                    heapq.heappop(minH)\n        return True\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nhand of straights so we're given a hand\nof\ncards which is given to us as an array\nof integers so each\ncard has a particular integer associated\nwith it\nwe want to rearrange the cards into\ngroups so that each group size is a\nparticular value that we're given as an\ninput parameter for example one\nvalue we could be given is group size of\nthree so every group needs to be of\ngroup size three\nbut not only that every single\ngroup needs to have consecutive\ncards in it basically a group could be\nlet's say\none two three because all values are\nconsecutive it could also be\n2 3 4 right but something like 2\n3 5 would not work right because there's\na hole\nin here these are not consecutive you\nknow we're missing a 4\nright so one thing to recognize with\nthis problem is how could we possibly\nbreak it down into groups right like\njust looking at this we have so many\ndifferent options brute forcing it\nis going to be really complex and\nthere's not really any way to\nto eliminate repeated work doing\nsomething like that so we need to find\nsome kind of pattern\nso one thing to notice would be if we\nwanted all groups that two could\npossibly be a part of we know that one\ngroup could be something like two\nthree four right because our group size\nis three\nand this would be if two was in the\nfirst position now it's also possible\nthat two could be\nin the second position right so maybe we\ncould have a group like one\ntwo three so two could be in a group\nwhere it's the middle value\nor it's the first value but notice how\nwe are always going to have some value\nin our input array that's the minimum\nvalue right\none is the minimum value in this case\nright so in this case\nwe could have a group of one two three\nright one could be the first value now\nare there any other groups that one\ncould be a part of this is\nthe only group that one could be a part\nof this is what the group would look\nlike we can't possibly have a group like\none\nor zero one two because there's there's\nno value that's\nless than one we don't have a zero right\nso\nin a sense we can be greedy we're always\ngonna look at whatever the minimum value\navailable to us is and we're gonna start\nwith a group\nlike that right so we're gonna basically\nmake a group\nlike this first and we also notice\nthat yes we could have multiple copies\nof the same card so for example we could\nhave two cards with a value of\ntwo so one convenience thing that we're\ngonna probably\ndo is count the number of each card that\nwe have right so basically\nthe best way to do that is going to be\nwith a hash map right so for each card\nfor example two we would count you know\ntwo has\ntwo copies in this input array so that's\nwhat we're going to basically do we're\ngoing to use a hash map\nto count the number of cards for each\nvalue so like i said we're going to be\ntaking our input array and then\nconverting it into a hash map right so\none\noccurs one time two occurs two times\nthree occurs two times and i think you\nprobably already know how to create a\nhashmap like this\nand so given that we have a group size\nof three what we're going to be doing as\ni mentioned is we're always going to be\nlooking at the minimum value available\nto us right\nso for example in this case that's gonna\nbe a one right we're gonna see\ncan we make a a group size of three\nstarting at one because we know one\ncould only possibly belong to one group\nand this is what the group\nwould look like so either we can create\nthis group\nin which case then we're going to\ncontinue our algorithm then we're going\nto refine the next minimum value\nor if we cannot create this group that\nmeans we can't possibly\nput one into a group so we're going to\nhave to return\nfalse so that's basically what i'm going\nto be going over oh and by the way\nanother quick thing that we could\ndetermine is we\nbasically need to guarantee that the\nsize of our input array is divisible by\nthree right because we need to break\nthis up into group sizes of three\nso it would have to be divisible by\nthree in this case we have nine elements\nnine divided by three that you know\nthere's no remainder with that so\nyou know it's possible at least so we're\ngonna start at one right\nand then we're gonna check okay the next\nvalue that comes after one is a two so\nbasically we're going to decrement the\ncount of one right we've already used\nour one now we're going to see are there\nany twos available to us we can do that\nin o of one time because yes we have a\nhash map right we can\nbasically check that instantly so we do\nhave some twos available to us right\nso we're going to decrement the count of\ntwo set it to one\nand so far we have a two so now we're\ngoing to look for that last value of\nthis group right\ngroup size three so what's the next\nvalue going to be we're looking for a\nthree do we have any available to us\nlet's check in our hash map yep we have\nsome threes decrement this count to one\nso we were able to create at least one\ngroup\nso we created one group now let's see if\nwe can create another and once again we\nare going to be looking at what the\nminimum value happens to be available to\nus\nnow the minimum is no longer one right\nbecause we took the count and\ndecremented it all the way to zero so we\ndon't have any ones available to us\nbut we do have a two as the minimum\nvalue available to us\nbut my question is how can we find these\nminimum values\nwell of course we could just scan\nthrough this hash map right and find the\nminimum and we could do that in o of n\ntime but can we do even better than end\ntime well we know a data structure\nthat can efficiently find minimums is a\nmin heap right so basically what we can\ndo is add all these\nkey values from our hash map into a\nmin heap right so let's say our min heap\ninitially looks something like\nthis right so one two three\nfour six seven and eight right so\nclearly we have our minimum at the top\nbut we know\nas we decremented the count of one down\nto zero we basically\npopped this from our min heap right so\nbasically what we're going to be doing\nis\nyes we're going to be popping the\nminimum value from our min\nheap if the count is decremented down to\nzero\nso now when we're actually going to be\nstarting our second group we can find\nthe minimum value to start out in\nlog n time we know that each group is\nbasically going to take group size\nto compute so overall what i'm saying\nthe time complex is mainly going to be\nlog in multiplied by\nn because technically you know the\nnumber of times we pop from the min heap\ncould be you know whatever the size of\nthe entire input array happens to be so\nthis is basically what i'm saying the\ntime complexity is going to be\nbut so yes getting the minimum value is\ntwo okay do we have any twos available\nto us let's take a look\nyes we have at least one two but we're\ndecrementing the count now\nso it's gonna be zero twos remaining so\nsince we decremented this to zero we\nhave to make sure we pop from the min\nheap right we're popping the minimum\nvalue too okay so now let's look for the\nnext value what comes after two\nof course three so do we have any threes\navailable to us yes\nin the min heap we do have a three\navailable to us but we're going to be\ndecrementing its count down to zero now\nso once again since three has no more\nvalues left what's the minimum value in\nour min heap of course it was three\nbecause we just popped the two\nso now we once again have to pop from\nthe min heap the minimum value which is\nthree\nand last but not least we are going to\nget the next value that comes after\nthree do we have any fours available\nyes we do so we're just going to repeat\nthe exact same process because\nwe see we're decrementing the count of\nfour down to zero so once again we can\npop from our min heap we're popping the\nminimum value from our min heap of four\nso we once again created a group size of\nthree so now let's see if we can create\none more group size of three so what\nlet's get the minimum value and we know\nwe can get that from our min heap now\nit's going to be a six so we're going to\nstart this group at six\nare there any sixes available to us yes\nthere are but we have to decrement its\ncount down to zero\nso basically we're repeating the same\nprocess let's pop that six\nfrom our min heap six is the minimum\nvalue so now let's check\nis there a seven available to us there\nis a seven\nwe're decrementing its count to zero\nonce again we're going to pop seven from\nthe min heap\nthe third value we need to complete this\ngroup is going to be 8\nand we do have an 8 available to us and\nwe decrement its count down to 0. so now\nwe're popping the last\nvalue from our min heap we're popping\nthe minimum value and it's the last\nvalue\nwe completed this group so now if we try\nto create\na fourth group we're gonna need to get\nthe minimum value from our min heap but\nwe\nsee that there is no value in the min\nheap so basically that's how you know we\nhave no more groups left to create we\nbasically\nyou know took every value that was given\nto us now let me just quickly go\nover a case where we would return false\nbecause\nyou know in this example we would return\ntrue because clearly we could break it\ndown but let's say this 8 happened to be\na\n9 and you know then the value in our min\nheap was also a nine\nwe were we're looking for an eight to\ncomplete this group but what we're going\nto find in our hash map is there is no\neight value\nso in that case we can't complete this\ngroup so we would return false there's\nanother case that we would return\nfalse and let me show you that so let's\nsay i slightly modified the input array\nso i change\none two into a one so instead\nso for two we only have one occurrence\nof it\nfor one we in this case have two\noccurrences of it so\nwe're gonna start with the first group\nwe're gonna get the minimum value it's a\none\nso we're gonna start at one we're gonna\ntake the count of one\nand decrement it down to one we're gonna\ntake the count of two because that's the\nnext value we're gonna\ninsert in this group and decrement it\ndown to zero\nnow notice how before so basically what\ni'm saying now we have to pop two from\nour min heap because it's no longer\navailable\nbut notice how in the first example\nevery time we popped from the min heap\nwe were popping the minimum value\nin this case we're popping 2 2 is not\nthe minimum\nvalue in our min heap and you know\nit's usually in min heaps you can't just\npop an arbitrary value you can't just\nsearch for a value in log in time and\nthen just pop\nany particular value you can only pop\nthe minimum value\nso how can we get around this how can i\npop a 2\nefficiently in log in time well one\nworkaround would be instead of using a\nmin heap you could use\na tree map so in that case you could\nsearch for the minimum value or any\nparticular value in log\nn time and then remove it with a tree\nmap but that's actually not\nnecessary in this problem let me show\nyou why\nbasically the idea is if we're trying to\npop a value from our min heap\nthat's not the minimum value we've\nalready\nlost we already cannot break this\nup into group sizes and in that case we\nwould return\nfalse now that's not super intuitive\nuntil you actually run through the\nexample\ntake a look what we're doing here\nremember how\none is the minimum value available to us\nright\nand one since one is the minimum value\nit could only belong to a group that\nlooked like\nthis right so if we're popping a value\nsuch as two or even three\nand these values are not the minimum\nvalues we're basically creating a hole\nin our in our values right so in this\ncase\nokay two it's it's true that two is\navailable to us and\nthree is also available to us right so\nwe would decrement the count of three\ndown to one\nso we could create one group but when we\ntry to create the next group now\nwe're gonna get to a one right and then\nwe're gonna look for a two but we're\ngonna see\nthat two has a count of zero basically\nwe were trying to pop a value\nthat was in the middle of our group so\nwe can't create another group\nbecause we're missing that two value so\nif basically if we\never try to pop a value from our min\nheap\nthat's not the minimum value that means\nwe have to return\nfalse because we have a value less than\nit that's available to us like 1 but we\ndon't have that 2\nvalue so we'll never be able to complete\na group\nwith this one value again so you know we\njust have to return false then\nso i think that's how we would solve the\nproblem with a min heap\nlike i said it's not actually necessary\nyou could use a tree map if you wanted\nand you could actually\nnot use a data an extra data structure\nat all you could just use\ni think a sorted input array but i'm\ngoing to be doing it with a min heap\nbecause i like the\nway the code works out in that case so\nas i mentioned the first thing we do\nwant to check\nis that the length of hand itself is\nactually divisible by\nthe group size if it's not then of\ncourse we won't be able to break this\ndown so we'll have to return false and\nalso we do want to create a hashmap\nuh counting the occurrences of each\nvalue now i could just use a counter in\npython but i usually like to write it\nout just in case the interviewer wants\nthat\nso for every value in our hand i'm going\nto just\nincrement the count of n so basically\none plus whatever it was previously\nand if it does not exist in our map\nwe're going to return a default value of\nzero\nwe're also going to be using a min heap\nso\nwe want only the distinct values that\nare available to us so what we can do is\ntake\ncount dot keys which is going to be\ndistinct values\nconvert that into a list which is what\nmin heaps are implemented as in python\nbut we actually do have to heapify it so\nwe're going to do heapify this is a\nlinear algorithm it just takes an input\narray and\ntransforms it into a min heap now we're\nbasically going to continue\nuntil our min heap is empty so while min\nheap is not empty we're going to get the\nminimum value\nso we can get the minimum value from a\nmin heap just at index\nzero so min heap at index zero is going\nto give us the minimum value\ni'm actually going to name this first\njust so it's a little bit more\ndescriptive\nand so now we want to see if we can\ncreate a group size starting at first\nof size group size so we're going to go\nfor i in\nrange starting at the first value right\nand\ngoing up until you know the group size\nso just add\ngroup size to this so the first thing we\nwant to check is if this\ni value is even available to us so if i\nis\nnot in our hash map then we have to\nreturn\nfalse because the value we're looking\nfor isn't even available\nif it is available then of course we do\nhave to decrement the count of it so\ncount\nof i is going to be decremented by one\nand we do have to check\nif this count so if it's now equal to\nzero because remember if it's equal to\nzero that means we have to pop it from\nour min heap\nbut if we're popping a value from our\nmin heap that's\nnot equal to the minimum value in the\nmin heap which we know we can find at\nindex 0. so if this is not the minimum\nvalue that we're trying to pop\nthat means we have to return false\nimmediately because\nif we pop this value if we remove it\nthen the next\ngroup we're not going to be able to\ncomplete because we know that there is\nan\ni value smaller than this value so we\nwon't basically be able to complete the\nnext group\nso we'll just return false immediately\nif that's not the case though we are\nable\nto pop from the min heap we are popping\nthe minimum value that's easy to do with\na heap so heap q\nheap pop from the min heap and so\nthat's the entire code and if we're able\nto get out of this loop we can return\ntrue so if we never execute these two\nconditions\nbasically if a value is is always\navailable to us\nand we're never popping a non-minimum\nvalue\nand we never return false in either of\nthese cases we if we basically break\nthe hand into group sizes and then at\nthe end we can return true\nso there's many ways to solve this\nproblem you can use a sorted input array\nyou can use a tree map or you can use a\nheap\nall the time complexities of each\nsolution is going to be n log n\nand they all mainly follow similar ideas\nso i hope that this was helpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Merge Triplets to Form Target Triplet",
        "NcLink": "merge-triplets-to-form-target/",
        "Pattern": "Greedy",
        "Description": "You are given a 2D array of integers `triplets`, where `triplets[i] = [ai, bi, ci]` represents the `ith` **triplet**. You are also given an array of integers `target = [x, y, z]` which is the triplet we want to obtain.\n    \nTo obtain `target`, you may apply the following operation on `triplets` zero or more times:\n\nChoose two **different** triplets `triplets[i]` and `triplets[j]` and update `triplets[j]` to become `[max(ai, aj), max(bi, bj), max(ci, cj)]`.\n    * E.g. if `triplets[i] = [1, 3, 1]` and `triplets[j] = [2, 1, 2]`, `triplets[j]` will be updated to `[max(1, 2), max(3, 1), max(1, 2)] = [2, 3, 2]`.\n\nReturn `true` if it is possible to obtain `target` as an **element** of `triplets`, or `false` otherwise.\n\n**Example 1:**\n\n```java\nInput: triplets = [[1,2,3],[7,1,1]], target = [7,2,3]\n\nOutput: true\n```\n\nExplanation: \nChoose the first and second triplets, update the second triplet to be [max(1, 7), max(2, 1), max(3, 1)] = [7, 2, 3].\n\n**Example 2:**\n\n```java\nInput: triplets = [[2,5,6],[1,4,4],[5,7,5]], target = [5,4,6]\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= triplets.length <= 1000`\n* `1 <= ai, bi, ci, x, y, z <= 100`\n",
        "Difficulty": "Medium",
        "Video": "kShkQLQZ9K4",
        "PythonSolution": "class Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        good = set()\n\n        for t in triplets:\n            if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n                continue\n            for i, v in enumerate(t):\n                if v == target[i]:\n                    good.add(i)\n        return len(good) == 3\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve a problem from today's leak\ncode contest to merge\ntriplets to form target triplet and this\nproblem is actually a little bit easier\nthan you might think so you can read the\ndescription\nbasically we have a target triplet and\nwe're given a list of triplets and we\nwant to know if we can transform\nthis list of triplets into the target\ntriplet and we're given a\na single operation that we're allowed to\ndo we can take\nany two triplets such as these two\ntriplets right\nand we can set one of them equal to the\nmax of both of the triplets combined so\nbasically for\nthe first value we would take the\nmaximum in this case it's two\nfor the second value we would take the\nmaximum in this case it's seven\nand for the third value we take the\nmaximum in this case it's five so we\nwould get\nwhen we combine the two triplets we'd\nget something like two seven\nfive and we wanna know if we're allowed\nto do this kind of operation on\nany of the triplets inside of our\ntriplets list as many times as we want\nare we able to somehow get the target\ntriplet now your first idea might be\nbacktracking or\nyou know some other kind of complicated\nhigh complexity solution but let me just\ntell you there's a single\nkey observation that you can make that\nwill make this problem\nsuper easy so let's try to figure that\nout so remember that\nthis is our target triplet that we're\ntrying to make and we can take\nany two triplets and then get the\nmaximum of those so\nclearly our goal is to take smaller\nvalues like maybe we have a one and\nsomehow get it to a two\nwhich is the target for here and maybe\nwe have a six somewhere\nand then take that and get it to be a 7.\nbut what happens if we have a value\nthat's\ngreater than the target see this triplet\n1\n8 4. now 1 is smaller than the value\nwe're looking for\n4 is smaller than the value we're\nlooking for but what about 8\n8 is bigger than the value we're looking\nfor so\nwhat happens with this triplet if we\never\ntry to combine this triplet with any\nother\ntriplet we're always gonna get a value\nthat's either eight or maybe even bigger\nthan a if you know that other triplet\nsomehow had a nine in the middle or\nsomething like that right\nbut we're always with this triplet we're\nalways going to get a value that's\ngreater than the target\n7 that we're looking for so any triplet\nany triplet in our list\nat all that has a value in any position\nthat's greater than the corresponding\ntarget value that we're looking for\nis going to be useless for us so a\ntriplet like\nthis we're not even going to consider it\nwe're not even going to\nlook at it so from our input list of\ntriplets if we do\nremove all triplets or like that that\nhave values that are too\ngreat then we're going to be left with\ntriplets in our input that are either\nequal to the target or less than the\ntarget right they have values that are\nequal or\nless than the target so then at that\npoint once we're left with those\ntriplets\nhow do we know if maybe those triplets\ncan form the target\nwell we're not actually going to have to\ngo through and do these maximum\noperations it's actually even easier\nthan that all we're going to do\nis go through every single triplet and\nsee\ndoes it have for every target value do\nwe have a\n2 in the first position among any of the\ntriplets\ndo we have a 7 in the target value among\nany of the triplets and do we have a 5\nin\nthe third position among any of our\ntriplets\nif we do then we can guarantee that\nsomehow some way that we can take these\ntriplets\nyou know combine them together and form\nthis because we know for sure\nat every position in these remaining\ntriplets\nthe value is either exactly equal to the\ntarget or less than the target so we\nknow for sure if we combine\nall of them together we're not going to\ngo over the target\nand we're definitely going to reach the\ntarget if we have\nall of those values we're looking for so\nwith that being said\nthe code is going to be pretty simple\nall we're going to do is go through our\nlist of triplets\nfilter out the triplets that have a\nvalue that's greater than\nany value in the target and then we're\ngoing to check among any of our triplets\ncan we\nreach each of these target values if we\ncan basically if we if we can reach\nall three of these values in our input\nlist of triplets\nthen we're going to return true\notherwise we return false\nso basically this is going to be an o of\nn time solution where we iterate through\nevery single triplet and go through\nevery single value in every single\ntriplet\nso i'm going to initially make a set\ncalled good\nbecause basically just which positions\nof the target are good like which ones\ncan we actually\ncomplete so to this i'm going to be\nadding the indices i'm going to be\neither adding index 0\n1 or 2. you know depending on which ones\nwe are able to complete and if the\nlength of this is\n3 then we're going to return true if\nit's 0 or less than 3\nthen we're going to return false so now\nour brute force basically just going\nthrough every single triplet\nin the input list and if\nwe get a triplet so if this triplet at\nposition 0 has a value\nthat's greater than the target values uh\nposition zero or at position one if this\nvalue is greater than the targets at\nposition one\nand finally if at position two this\ntriplets value is greater than the\ntargets at position two\nthat means that this is one of those\ntriplets that we're going to filter out\nso we can just continue on to the next\niteration of the loop\notherwise this triplet could contain\nsome of the target values we're looking\nfor so let's iterate through this\ntriplet and we are going to need the\nindex of this triplet the index in this\ncase is basically the position of each\nvalue in the triplet so iv\nin enumerate through this triplet\nand so we're going to check if the value\nat this position\ni is equal to a value in the target\nat position i so basically maybe the\nzero value of this triplet matches the\nzero value of the target then what we're\ngoing to go ahead and do\nis to our good set we're going to add\nposition i because that means we are\nable to get position i from\nsome of our triplets and then we're\ngoing to do the exact same thing for\nevery single triplet that is valid that\nwe're not going to be skipping\nand then at the end if we know for sure\nthat the length\nof good is equal to three then we're\ngoing to return true\notherwise we're going to return false so\nreally we can just return\nthe result of this comparison so that's\nthe entire code you can see\nthat it does pass in this\nleak code contest so i hope that this\nwas helpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully\n"
    },
    {
        "Name": "Partition Labels",
        "NcLink": "partition-labels/",
        "Pattern": "Greedy",
        "Description": "You are given a string `s` consisting of lowercase english letters. \n    \nWe want to split the string into as many substrings as possible, while ensuring that each letter appears in at most one substring.\n\nReturn a list of integers representing the size of these substrings in the order they appear in the string.\n\n**Example 1:**\n\n```java\nInput: s = \"xyxxyzbzbbisl\"\n\nOutput: [5, 5, 1, 1, 1]\n```\n\nExplanation: The string can be split into `[\"xyxxy\", \"zbzbb\", \"i\", \"s\", \"l\"]`.\n\n**Example 2:**\n\n```java\nInput: s = \"abcabc\"\n\nOutput: [6]\n```\n\n**Constraints:**\n* `1 <= s.length <= 100`\n",
        "Difficulty": "Medium",
        "Video": "B7m8UmZE-vw",
        "PythonSolution": "class Solution:\n    def partitionLabels(self, S: str) -> List[int]:\n        count = {}\n        res = []\n        i, length = 0, len(S)\n        for j in range(length):\n            c = S[j]\n            count[c] = j\n\n        curLen = 0\n        goal = 0\n        while i < length:\n            c = S[i]\n            goal = max(goal, count[c])\n            curLen += 1\n\n            if goal == i:\n                res.append(curLen)\n                curLen = 0\n            i += 1\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem partition labels\nthis is a very interesting and somewhat\nunique problem we are given a string s\nand we want to partition the string into\nas many parts as possible so that each\nletter appears in at most one part and\nwhat we want to return is the list of\nintegers representing the size of each\nof these parts so let's actually start\nwith the second example this time\nbecause i think it really helps to\nillustrate how to solve this problem and\nkind of makes it simple just starting\nfrom left to right let's take a look at\nthe first character it's an e character\nright we want to partition this into as\nmany parts as possible but each\ncharacter such as this e can only appear\nin a single partition so what we would\nwant to do is just say okay cut it right\nhere right this is a single partition\ngreat but we can't do that why can't we\ndo that because\nthere's actually multiple e's in this\nstring there's another e all the way\nover here and our partitions have to be\ncontiguous as soon as we see the first\ncharacter and we see that it actually\noccurs way to the right in the string we\nwill never be able to partition the\nstring here here here here anywhere\nright because at the very least we know\nthat this has to be one partition and if\nwe do partition it like that this i\nthink is nine characters but we actually\ncan't even partition it here either and\nwe can figure that out just by looking\nat the second character the second\ncharacter is a c now there's a c over\nhere there's another c over here and\nthat's perfectly fine but the reason we\ncan't partition here is because there's\na c in the last position only by looking\nat the first two characters we realize\nthat the entire string\nis going to be a single partition we\ncan't partition this any further and so\nwhat we're going to return is we have a\nsingle partition and the length of that\npartition is 10. so this is the list\nthat we are going to return in this case\nso you might be starting to get an idea\nof how we can solve this problem in\ngeneral but if not don't worry about it\nbecause that's exactly what we're going\nto talk about right now so let's take a\nlook at another example in this case\nwe're given a string and the result is\nthat we can split it into three\npartitions the first partition is going\nto be\nnine characters the next partition is\ngonna be seven characters and the last\none is gonna be eight but let's try to\nfigure out how we can arrive at that\nsolution and how we can make it as\nefficient as possible so let's take a\nlook at this string and let's use the\nsimilar idea that we talked about in the\nprevious example so we look at the first\ncharacter it's an a now immediately we\nknow that we can't partition this at\nthis point right this cannot be a\npartition if there are additional a\ncharacters somewhere in the string and\nnot only that we could have multiple a\ncharacters and we do we have an a\ncharacter here here here\nand that's the last one now which one of\nthese do we care about the most we care\nabout the last a character the most\nbecause once we stop here we know for\nsure that all of the a characters are in\nthis portion of the string and that's\nwhat we're trying to do we're trying to\ncreate partitions where all a characters\nare going to be here not anywhere else\nin the string not in any other\npartitions so wouldn't it be convenient\nfor us every time we see a character if\nwe could automatically know where the\nlast index of that character happens to\nbe and maybe just maybe this character\nitself could be the last occurrence of a\nthis index could be the last position\nwhere a exists well conveniently for us\nwe can do exactly that and we can create\na hashmap so we can create a hashmap\njust like this one where we take every\nsingle unique character in the input\nstring and we map it to the last index\nthat it occurs at so for example you can\nsee the indexes are a little bit messy\nbut we can see that a ends at the last\noccurrence of a is at index eight so we\ncan map a to\nthe character a to index eight the last\noccurrence of b is going to be at index\nfive now i could do this for the entire\nstring but we have a ton of characters\nso i don't want to waste my time too\nmuch but just assume that before we even\nstart iterating through the array we\nbuild a hashmap just like this one and\nthe time complexity of building this\nhashtrap isn't going to be bad because\nall we have to do is just iterate\nthrough the entire uh string so the time\ncomplexity and space com the time\ncomplexity will be o of n technically\nwe're guaranteed that every character in\nhere is just going to be a lowercase\nabc character so the memory complexity\nof this hash map is really going to be\nuh you know big o of 26 so constant\nmemory complexity not too bad okay now\nbefore we start iterating through the\narray let's think about how we're going\nto approach this algorithm remember we\nare going to have an output which is\ngoing to tell us the size of each\npartition as you can see up above so it\nwould be helpful for us as we're\niterating through this if we maintain\nthe size of the current partition\nourselves initially we can set that to\nzero and as we iterate through this for\nexample we get to the first character we\nsee it's at index zero but the last\noccurrence of a is at index eight so we\ncan keep track of another variable let's\ncall it end you could call it whatever\nyou want but end which is gonna tell us\nwhat's the end of our partition as far\nas we know so far right because we see\nthe character a and we know it exists\nthe last occurrence of it is over here\nso we assume so far we're assuming that\nthis is going to be a partition but we\ndon't know for sure just yet because we\nhave some b characters here it's\npossible that one of the b's exists even\nfarther than that and if that's the case\nthen of course we have to update our\nending but in this case that's not the\ncase because the b's are actually uh\nwithin the first partition so let's see\nthis algorithm in action okay so so far\nour size is zero we get to the first\ncharacter our end is zero so far but we\nknow that a the last occurrence of it is\nat this index so we update our end to be\nindex a we get to the second character b\nthe last occurrence of it is five five\nis less than eight so we don't have to\nupdate our ending\njust yet and by the way actually we'll\nbe we'll have incremented our size we'll\nhave incremented to one after we iterate\nthe b or the a character and we'll have\nnow uh updated it to two after we have\nvisited the b character again we get to\nan a character so we know that we don't\nhave to update our end because the a's\nlast occurrence is still here but we can\nincrement our size now to three we see a\nb character we've already seen it before\nokay now we see a c character we've\nalready seen a b before so we can go\nahead and update the size to four now we\nsee a c character for the first time so\nwhere's the last occurrence of a c\ncharacter it's all the way over here at\nindex seven of course we're going to get\nthat from our hashmap in constant time\nsince it is a 7 we don't have to update\nour end again so\nwe are good to go but we can increment\nour size now to 5. now we get to another\nb character so no major updates here we\nget to an a character again we get to a\nc character again no major updates but\nat this point our size will actually be\neight now we get to\nuh the last a character so now our size\nis actually nine but what's special\nabout this position well this position\nwe're at the index where our end uh\nvalue happens to be as well so what that\ntells us is every character in this uh\npartition only occurs in this partition\nnone of these characters are found\nanywhere to the right side so that\nbasically means we have finished our\nfirst partition and we want to take the\nsize and add it to the output good thing\nwe're keeping track of the size the\nfirst partition is of size nine so we'll\nadd it to the output and then after that\nwe're going to reset the size back to\nzero because starting from here we're\ngoing to be looking at a new partition\nso our size is going to be reset back to\nzero our end pointer can stay the same\nbecause we know as soon as we see the\nnext character our end pointer is going\nto be updated anyway because we know\nthat this is going to be a new character\nthat we see it's a d character where is\nthe last index of d well it's over here\nwhich is 14. so that means we're gonna\nupdate our end pointer because 14 is of\ncourse greater than eight so end is now\ngoing to be 14 of course we are going to\nincrement our size uh now to 1. okay\nnext character is e whereas the last\noccurrence of e it's over here which is\n15 so 15 is greater than our current end\nso again let's update our end value and\nof course let's update our size now to\nbe\n2. next character is f last occurrence\nof f is actually at this position so 11\nis\nless than 4 uh 15 so no changes here we\nsee another e we've already seen e's\nbefore they're at index 15 which is what\nwe have no big deal we see a g\nand g is the last occurrence of g is\nactually at this position as well which\nis 13 less than 15 so no updates at this\npoint our size will actually be like\nfive now i think uh next let's get to d\nthis is the last occurrence of d we get\nto e this is the last occurrence of e\nand it's exactly our end value so this\nis the\nsecond end of the second partition and\nwhat's the size of this partition well\nit's seven which is what we're going to\nbe keeping track of but i'm kind of\nskipping that so the second uh partition\nthat we're gonna be adding to our output\nis gonna be of size seven so that's what\nwe're gonna do next we're gonna go to\nthe third partition so over here the\nfirst character is h uh by the way our\nsize will have been reset to zero and\nlast occurrence of h is over here which\ni think is 19. so that's what our end is\ngoing to be at currently we're going to\nget to the second character which is i\nit's a little bit smushed in here eyes\nlast occurrence is over here actually at\n22. so uh you know update the end to 22.\nnext character third character is going\nto be j\nuh last occurrence of j is actually at\nthe end of the string which is 23 so at\nthis point we pretty much know that this\nis going to be a partition itself right\nbut let's assume we continue to run\nthrough the algorithm we basically visit\nall these characters we don't really\nupdate our end because it's already at\nthe last index of the entire string and\nthe size of this partition is what it's\nsomething like eight characters so by\nthe end of it our size will be at eight\nand then we're going to go ahead and add\nthat to our output so you can see we did\nthe algorithm we got the same output as\nthey got in the example up above and we\nkind of had to do two passes one pass to\nbuild our hash map and then one pass to\nactually build the output but still we\nall we had to do is scan through the\ninput so the time complexity actually is\njust big o of n the memory complexity is\nbig o of one because this hash map is\ngoing to be limited to 26 characters so\nwith that being said i hope this makes\nsense now we can jump into the code\nremember the first thing we want to do\nis do a little bit of pre-processing by\nthat i mean building our hash map where\nwe are going to be going ahead and\nmapping every character to the last\nindex of it in the input string s so\nlet's go ahead and iterate through our\nstring in python we can save like one\nline of code by\nenumerating the string which is\nbasically going to allow us to get to\niterate through the index and the\ncharacter at the same time so i is the\nindex c is the character uh we're gonna\ngo ahead and take that character and set\nits last index equal to i now this is\nokay because even if the last uh\noccurrence of that character isn't this\nindex eventually we will have visited\nthe last occurrence of that character in\nthe string and then we'll have updated\nthe last index of that character to the\nlast occurrence so this is pretty simple\nnow getting into the actual algorithm we\nare going to be doing the same thing\nwe're going to be enumerating through\nthe index and the character of every\nsingle uh character in the string\nbut remember we're going to be\nmaintaining a couple things one is going\nto be the result of course which is\ngoing to tell us the size of each\npartition and if we want to you know add\nthe size we have to maintain the size\nand we're also going to be maintaining\nthe end of each partition so initially\nthese can just be set to zero now as we\ngo through every character as soon as we\nsee a character we want to go ahead and\nincrement the size of the partition we\nalso potentially want to update the end\nof the partition if uh the last index of\nthis character is greater than the\ncurrent end then we can go ahead and\nupdate the current end to uh that last\nindex you can write it out like an if\nstatement like this but to save a line\nof code we can actually just use the max\nfunction which is built into python and\nmost languages we can update end to be\nthe max of itself and the last index of\nthe current character that we are\nvisiting so we can get rid of these two\nand just have this one line of code\nremember we know we can stop a partition\nif we actually reach the end of the\npartition so if i equals the end of the\npartition then\nwe're done we're going to go ahead and\nadd the size to the result and then we\ncan go ahead and reset the size back\ndown to zero and that's all we really\nneed to do as we finish our partition we\ndon't really have to reset the end\nbecause it's not really necessary in\nthis case once this is done\nour result will have been built so we\ncan go ahead and return it and then run\nthis to make sure that the code works\nand as you can see on the left yes it\nworks and it's about as efficient as we\ncan get this problem to be so i really\nhope that this was helpful if it was\nplease like and subscribe it supports\nthe channel a lot consider checking out\nmy patreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Valid Parenthesis String",
        "NcLink": "valid-parenthesis-string/",
        "Pattern": "Greedy",
        "Description": "You are given a string `s` which contains only three types of characters: `'('`, `')'` and `'*'`. \n    \nReturn `true` if `s` is **valid**, otherwise return `false`.\n\nA string is valid if it follows all of the following rules:\n\n* Every left parenthesis `'('` must have a corresponding right parenthesis `')'`.\n* Every right parenthesis `')'` must have a corresponding left parenthesis `'('`.\n* Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.\n* A `'*'` could be treated as a right parenthesis `')'` character or a left parenthesis `'('` character, or as an empty string `\"\"`.\n\n**Example 1:**\n\n```java\nInput: s = \"((**)\"\n\nOutput: true\n```\n\nExplanation: One of the `'*'` could be a `')'` and the other could be an empty string.\n\n**Example 2:**\n\n```java\nInput: s = \"(((*)\"\n\nOutput: false\n```\n\nExplanation: The string is not valid because there is an extra `'('` at the beginning, regardless of the extra `'*'`.\n\n**Constraints:**\n* `1 <= s.length <= 100`\n",
        "Difficulty": "Medium",
        "Video": "QhPdNS143Qg",
        "PythonSolution": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        leftMin, leftMax = 0, 0\n\n        for c in s:\n            if c == \"(\":\n                leftMin, leftMax = leftMin + 1, leftMax + 1\n            elif c == \")\":\n                leftMin, leftMax = leftMin - 1, leftMax - 1\n            else:\n                leftMin, leftMax = leftMin - 1, leftMax + 1\n            if leftMax < 0:\n                return False\n            if leftMin < 0:\n                leftMin = 0\n        return leftMin == 0\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem valid parentheses\nstring we've solved a few parentheses\nrelated problems on this channel but\nthis is a pretty unique one so we're\ngiven a string s and it could contain\nthree types of characters a left\nparenthesis a right parenthesis and a\nwild card character and the wild card\ncharacter could\nbe a three possibilities it could be an\nempty string which is the simplest right\nso basically in that case we would\nignore the wild card it could be a right\nparenthesis or it could be a left\nparenthesis so\neach time we reach a wild card\nin terms of a decision tree we really\nhave three branches right we have three\ndifferent things we could consider it\ncould be a space it could be a left\nparenthesis it could be a right\nparenthesis so already we're kind of\ngetting the intuition of how to solve\nthis problem or at least enumerate all\npossibilities our goal is to determine\nif the given string could be valid if\nit's possible we return true if it's\nimpossible we return false and you can\ngo over this to understand what makes\nparentheses valid and invalid the main\nthing is as you scan through a string\nsuppose this one what has to really\nhappen is that every left parenthesis\nhas to have a matching right parenthesis\nand the matching right parenthesis has\nto come after the left parentheses and\nthe natural order for it is kind of like\nfirst in first out so you can see we\nhave a left parenthesis then we have\nanother left parenthesis then we have a\nright parenthesis and this right\nparenthesis matches this one okay then\nwe have another left parenthesis then we\nhave a right parenthesis this matches\nthe most recent one and then we have\nanother right parentheses and this\nmatches this one but suppose we had a\nslightly different string maybe we have\nthree right parentheses in a row this\nwould be invalid and you can see why\nthese two match each other great this\none matches this one great but the right\nparentheses then comes before the left\nparenthesis we can't have that and this\nis one way to understand that but the\neasiest way to know that we have an\ninvalid parenthesis combination is that\nat any given point of the string the\nnumber of left parentheses that we have\ncan never be less than the number of\nright parentheses and you can see that\nthat happens here right we have two left\nparentheses then we have three right\nparentheses and we are never going to be\nable to recover from this because at one\npoint in time we had more right\nparentheses than we had left it doesn't\nmatter if we get more left parentheses\nwe cannot recover from this ever and\nthat's how you know it's invalid let's\ntake a very simple input string and then\ndetermine if this is valid or not and we\ncan tell that it is how would it be\nvalid if the wild card was empty and it\nwould look like this right just a left\nand a right parenthesis but how can we\ndo that uh brute force and we would we\ncould possibly have more complex strings\nhow could we determine that well the\nbrute force is going to be a decision\ntree because if we weren't given any\nwild cards we have a very simple\nalgorithm just to scan through the\nparentheses to know if they were valid\nor not just like i talked about but with\nwild cards there's lots of possibilities\nwe're going to go through each character\nin the string and have a decision tree\nso first character we see is a left\nparenthesis that's perfectly fine and\nthen we get to the wild card right when\nyou get to a wild card that's when you\nactually need to branch we don't need to\njust branch when we get to a regular\nparenthesis because that's already\ndetermined it could be another left\nparenthesis it could be a space or it\ncould be a right parenthesis\nand then we're going to get to the third\ncharacter uh but we have to do that\nthird character it's already determined\nit's a right parenthesis but we have to\ndo it for all three of our branches now\nso you can kind of see if we had a lot\nof wild cards uh this decision tree\nwould get very big but let's just finish\nit up real quick so here we'll have a\nright parenthesis here we'll have a\nright parentheses here we'll have a\nright parenthesis so among all three of\nthese combinations you can see that this\nis invalid because it has two open it\nhas two left one right that's invalid\nthis one you can see is also invalid it\nhas one left and then two right but the\nmiddle one you can see it is valid it\nhas a left a space and then a right and\nthe way we could do this problem\nrecursively the decision tree portion is\nkind of simple we would make three\nrecursive calls every time\nwe got to a wild card but to determine\nif it was valid or not one we would keep\ntrack of how many left parentheses we\nhad how many open left parentheses we\nhad at this point we had one open\nif we're just considering the middle\nbranch here we also had a one open and\nthen by the end of it we had zero open\nzero left open parenthesis by the end we\nshould have exactly zero because they\nshould all match each other and the\nnumber of left open should never be\nnegative for example if we started like\nthis right if we started with a right\nparenthesis that's automatically invalid\nokay so that's the recursive solution\nand you can actually add dynamic\nprogramming and by dynamic programming i\nmean memoization that's the easier way\nto do it to this recursive solution and\ni will actually link the code to that in\nthe description if you want to take a\nlook uh the overall time complexity of\nfirst of all the brute force solution is\nin the worst case going to be a 3 to the\npower of n because that's how many\nbranches we have n is going to be the\nsize of the string because that's going\nto be the height of this decision tree\nbut when you add memoization to this the\noverall time complexity actually becomes\nn cubed and the way we would do that is\nby caching and we would cache uh with\ntwo parameters one would be i which is\nthe index of the position that we're at\nand the other parameter would be uh the\nnumber of left open parentheses at any\ngiven point uh in the string that we're\nat now a caching with two different\nparameters like this will cause us to\nhave a two-dimensional matrix uh the\nsize of that matrix is going to be n\nsquared but to calculate each value in\nthat matrix would would take big o of n\ntime complexity that's how i'm getting n\ncubed from but i don't expect you to\nunderstand all of this if you want to\nunderstand it a bit more you can look at\nthe code that i'll have in the\ndescription but there's actually an even\nmore efficient way to solve this problem\nand that is the greedy solution and it's\nvery difficult to come up with now even\nif you can't come up with the greedy\nsolution by yourself it might still\noccur to you in a real interview that\nmaybe there's some kind of trick to this\nproblem that if only you could figure it\nout you would be able to solve this\nproblem in linear time is there a trick\nlike that well hopefully in a real\ninterview your interviewer would give\nyou a hint for that but let's see how we\ncould maybe come up with it ourselves we\nknow that one variable is going to be a\nmandatory for us and i'm going to call\nit left it's going to be the number of\nleft open parentheses we have and when\nwe reach the first character it's a left\nopen parenthesis initially our total is\ngoing to be zero but after seeing the\nleft open parenthesis we increment it by\none now we have one left open\nparenthesis and that would be very easy\nuh suppose we didn't have the wild card\nthen we would have a right parenthesis\nand we would do the exact opposite we'd\nsay okay left uh open parenthesis has\nbeen decremented by one so now we're\nback to zero left open parenthesis and\nthat makes sense but wild cards create\nmultiple possibilities and three exactly\nright one the simplest would be to\nignore this right if we ignore it okay\nwe're still left with one open\nparenthesis that's the simplest but it\ncould there could be multiple\npossibilities right and we need to\nconsider all possibilities if we want to\nbe sure that we can determine if this is\npossibly valid or not possibly valid we\ndo have to consider every possibility so\nanother possibility is this wild card\ncould be a\nleft open parenthesis if that's the case\nwe would take our left and actually\nincrement it by one to make it two but\nanother possibility is that this a wild\ncard could be a right parenthesis and in\nthat case we would take this and then\ndecrement it by one see how this wild\ncard is creating some divergence for us\nwe can't maintain all possibilities in a\nsingle variable like we could before so\nthis is kind of a hint to you that maybe\nwe need two variables let's go to the\nthird character before we actually\ncreate those two variables now we have a\nright parenthesis now what are we gonna\ndo well with right parentheses we're\ngonna decrement our left count but now\nwe have to decrement two variables so\nthis would become one and then this\nwould become zero what do these actually\nrepresent the reason we have two in the\nfirst place is from the wild card\nbasically these are gonna represent the\ni'm gonna call it the left max and the\nleft min and what that means is what's\nthe\nmaximum left open left parenthesis we\ncould have and what's the minimum open\nleft parenthesis we could have depending\non how we choose our wild card okay now\nlet's go to another character and again\nwe have a wild card now let me explain\nto you what these two variables are\nsupposed to represent they're supposed\nto represent the range of possibilities\nwe could have zero left open parentheses\nor we could have one left open\nparentheses depending on how we chose\nthe first wild card but now we have a\nsecond wildcard now if we made this a\nleft open parenthesis that would mean\nit's possible for us to have two left\nopen parentheses so we would update our\nleft max in that case but if we made it\na closing parenthesis then we would want\nto update our minimum because this is\nsupposed to represent all possibilities\nso let's do exactly that if\nlet's increment our left max to be 2\nthen let's decrement our left min to be\nnegative one but hold on for a second\nthis isn't just the range of\npossibilities this should also be the\nvalid range of possibilities we should\nnever have our left min become negative\nbecause that would imply that the\nchoices we made caused our left min to\nbe negative and we know that's invalid\nso we're never going to allow our left\nmin to become negative if it ever does\nbecome negative we're going to reset it\nback to b0 so now you can see that these\nare the range of possibilities between\nzero and two and now we're just going to\ncontinue through the rest of the array\nwe're going to get a left open\nparenthesis which uh we're going to\nincrement both of our variables so this\nis going to be 1 this is going to be a 3\nand then we're going to get a closing\nparenthesis so this is going to be\ndecremented down to 0. this is going to\nbe decremented down to 2. and now how do\nwe know if we can return true or false\nis this valid or is it not valid well we\nknow it's balanced if the left open\nparenthesis count is zero so does zero\nfall in between our range right now it\ndoes because our left min is exactly\nzero so that's how you know we can\nreturn true if our left min is equal to\nzero and before we get into the code i\njust want to show you another way that\nour solution could have been invalid uh\nsuppose you know our string had two uh\nclosing parentheses and then two open of\ncourse our left min is never going to be\nuh negative because uh if it becomes\nnegative we reset it back to zero but if\nour left max does become negative uh in\nthis case it'll be negative two uh from\nthis uh at this after we've seen these\ntwo that's how you know we can return\nfalse because it'll never be valid we'll\nnever recover from this because if the\nmaximum number of left open parentheses\nwe could have is negative that means\nthere's no choices we could possibly do\nto make this valid okay so before we get\ninto the code as you could tell from\nthis algorithm we don't even need any\nextra space so the space complexity is\nbigger of zero and we only need to scan\nthrough the string once so the time\ncomplexity is big o of n so now let's\ncode it up okay so now let's code it up\nand like i said we're gonna have two\nvariables left min and left max\ninitially they're both gonna be a zero\nand then we're just going to go through\nevery single character in the string if\nwe get a open parenthesis a left open\nparenthesis we're going to increment\nboth of our variables so leftmin and\nleftmax are going to be incremented by\none because here we don't really have\nany choices we have to increment the\ncount by one and in the opposite case\nwhere we do have a closing parenthesis\nwe also don't have a choice so i'm going\nto copy and paste this but in that case\nwe're going to be decrementing the count\nby one for each of them uh and the else\ncase is when we have a wild card we\ndon't have to specify that character and\nthis is the part where we do have a\nchoice so i'll copy and paste again but\nwith the left min we're going to\ndecrement that count in the case that we\nhave a closing parenthesis and in the\ncase that we choose the wild card to be\nan open parenthesis we're going to\nincrement the left max by 1. but\nremember if the left max ever is\nnegative that means it's impossible for\nour parentheses to be valid so in that\ncase we're just going to immediately\nreturn false but in the similar case\nwhere our left min is negative we're not\nnecessarily going to return false\nbecause that would mean our left max is\nnot negative so it technically is\npossible for the string to still be\nvalid we don't want to continue assuming\nthat our string up until this point is\ninvalid so we're going to reset it back\nto zero and if\nthis part is unclear and i don't expect\nit to be too clear because it's actually\ncomplicated to understand this is the\nstring that i would kind of run the code\non and this is the example i would\nreally try to understand if you don't\nget this part this string is impossible\nto make valid no matter what we choose\nfor the wild card but if you don't\ninclude this if statement in your code\nyou'll end up returning true for this\nwhen you should be returning false\nthat's kind of what i'll leave it at but\nother than that once we exit the loop we\nwill return true if the left min is\nequal to zero if it's not equal to zero\nthen we return false now let's run the\ncode to make sure that it works and as\nyou can see on the left yes it does and\nit's pretty efficient so i really hope\nthat this was helpful if it was please\nlike and subscribe it really supports\nthe channel a lot consider checking out\nmy patreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Insert Interval",
        "NcLink": "insert-new-interval/",
        "Pattern": "Intervals",
        "Description": "You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [start_i, end_i]` represents the start and the end time of the `ith` interval. `intervals` is initially sorted in ascending order by `start_i`.\n\nYou are given another interval `newInterval = [start, end]`.\n\nInsert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `start_i` and also `intervals` still does not have any overlapping intervals. You may merge the overlapping intervals if needed.\n\nReturn `intervals` after adding `newInterval`.\n\nNote: Intervals are *non-overlapping* if they have no common point. For example, [1,2] and [3,4] are non-overlapping, but [1,2] and [2,3] are overlapping.\n\n**Example 1:**\n\n```java\nInput: intervals = [[1,3],[4,6]], newInterval = [2,5]\n\nOutput: [[1,6]]\n```\n\n**Example 2:**\n\n```java\nInput: intervals = [[1,2],[3,5],[9,10]], newInterval = [6,7]\n\nOutput: [[1,2],[3,5],[6,7],[9,10]]\n```\n\n**Constraints:**\n* `0 <= intervals.length <= 1000`\n* `newInterval.length == intervals[i].length == 2`\n* `0 <= start <= end <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "A8NUOmlwOlM",
        "PythonSolution": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res = []\n\n        for i in range(len(intervals)):\n            if newInterval[1] < intervals[i][0]:\n                res.append(newInterval)\n                return res + intervals[i:]\n            elif newInterval[0] > intervals[i][1]:\n                res.append(intervals[i])\n            else:\n                newInterval = [\n                    min(newInterval[0], intervals[i][0]),\n                    max(newInterval[1], intervals[i][1]),\n                ]\n        res.append(newInterval)\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem insert interval\nand this is actually another problem\nfrom the blind 75 list a list of 75\ncommon leak good questions that we've\nbeen tracking on this spreadsheet we're\nalmost done with all of them today we'll\nbe solving this interval question insert\ninterval so basically we're given a set\nof\nnon-overlapping intervals and we want to\ninsert a new interval into this\nlist of intervals we want the intervals\nto remain non-overlapping so basically\nwe might have to merge some intervals\nbecause we are given a single\ninterval we're given a list of\nnon-overlapping intervals in this case 2\n5 so when we insert this interval in\nhere you can see that 2 5 is an interval\nright suppose we have 1 3 and then we\nhave 2 5. so clearly these two intervals\noverlap each other right so then we have\nto merge them together how are we going\nto merge two intervals together well if\nthey are overlapping we're going to take\nthe minimum of both of them in this case\nit's 1 and we're going to take the\nmaximum of both of them in this case\nit's 5. so that's what the new interval\nis going to be right so we merge them\ntogether we'll have a new interval like\nthis 1 5 and\nso this is a new interval and then you\ncan see we have another interval 6 9 now\n6 9 is not overlapping with one five so\nin our output now we're gonna have two\nintervals right we we're gonna have one\nfive and six nine and then we're gonna\nreturn these intervals in the output now\nthe convenient thing is that these\nintervals are actually already sorted\nfor us in ascending order based on their\nstart times that's good because that\nmeans we are not going to have to sort\nthem and if you've solved any interval\nproblems before you know that sorting\nalways comes in handy for interval\nproblems and i don't know if they\nspecify in this problem but just so you\nknow an interval such as this let's say\nwe had 1 2 and another interval 2\n3 these do count as overlapping because\nthese two points technically are\nconnected so this would be one single\ninterval one\nthree\ni don't know if they mentioned that\nsomewhere in the description but that is\njust an edge case that we'll have to\nkeep track of suppose we were given a\nlist of intervals such as these right\nthese are sorted in ascending order\nbased on their start value so none of\nthese are overlapping which is what we\nexpect what if we were given an interval\nsuch as this one an interval that\nactually goes let's say this is zero\nright even though i don't know what kind\nof interval would end at zero but let's\njust assume it is right so that it\ndoesn't overlap with this one so since\neven this interval right\nthe end value is less than the start\nvalue of the first interval that means\nthis interval is not going to overlap\nwith this interval right and if it's not\neven going to overlap with the first\ninterval then there's no way it could\ninter it could overlap with any of the\nupcoming intervals either right so so\nwhen we basically return our output\nwe're just going to return this original\nlist but we're going to add this\ninterval at the beginning right so that\nthey're still sort in sorted order and\nthey're non-overlapping now what if the\nopposite was true suppose we were given\nan interval such as this one 7\nto 8 or something like that right where\nthe start value of this is actually\ngreater than the end value of the last\ninterval right in this case this\ninterval won't overlap with any of these\nand then we can just return the original\nlist and adding this to the end of the\nlist right now those are a couple of the\nsimple cases but it's possible that the\nnew interval could actually end up\noverlapping with one of these\nother intervals right and then we'd have\nto combine both of these it could be\npossible that the interval actually\ncould overlap with multiple intervals in\nthe input in which case we have to\ncombine multiple intervals right or it\ncould be that the new interval would\nactually go somewhere in between a\ncouple of these and not overlap at all\nso how are we going to determine where\nexactly this new interval ends up going\nwell we'll have to go we'll have to\niterate through these sorted intervals\nand then basically find the insertion\npoint of the new interval that we're\nlooking for so we're going to go suppose\nwe have an interval like this one right\nsomewhere small in between here we're\ngoing to go interval by interval we're\ngoing to say okay this is the first\ninterval does this overlap with our new\ninterval it does not so we would take\nthis add it to the output we would look\nat the next and we would see that this\ninterval goes after that and then we go\nto the next interval and then we'd see\nthat okay this n this other this next\ninterval actually goes after the\ninterval that we're trying to insert\nright suppose we had a really small\ninterval like this that goes in between\nthen what would we do well we wouldn't\nwant to add this one to the result first\nwe would want to take this this new\ninterval add it to the result and then\nadd this to the result and then at that\npoint we can just take the remaining\nintervals and then add them to the\nresult and then we can return so those\nare a couple more of these simple cases\nright where we would not have to merge\nsuppose we had an interval such as\nthis one though right let's say 0 to\n3 or something like that okay we we\niterate through the first interval we\nsee okay this interval is overlapping\nwith this one how do we know if they're\noverlapping or not well we would check\nokay does the end value of the new\ninterval is it less than the start value\nof this interval it's not okay is the\nstart value of the new interval greater\nthan the end value of the current\ninterval it's not so if that if neither\nof those are the case that means this\ninterval does not go after this interval\nand it does not go before this interval\nso that must mean that they are\noverlapping in which case we're going to\nmerge them how are we going to merge\nthem we're going to take the minimum of\nthe left and the maximum of the right\nand then merge them together so when we\nmerge them we're going to get a new\ninterval such as this one zero two\nthree and once we have this merged\ninterval we're not going to actually add\nit to the output just yet because we\nknow that this this interval could\nactually overlap with some other\nintervals that we now have that come\nfollowing right and that's exactly the\ncase it's overlapping with this other\ninterval three four so we we've gotten\nrid of this first\ninterval now we're going to be iterating\nto the second interval we're gonna see\nthree four okay is this overlapping with\nour zero three interval yes it is so\nwe're going to merge these as well we're\ngonna take the minimum of the left it's\ngonna be zero and the maximum of the\nright it's gonna be four so we merge\nthese together so now we're gonna have a\nnew interval uh from zero to 4 and we're\nstill\nnot going to add this to the output yet\nbecause it could technically still be\noverlapping with some following\nintervals in this case we're going to\nget to the third interval and in this\ncase they're not overlapping how do we\nknow that because the end value of this\none 4 is less than the start value of\nthe interval that we're at so what are\nwe going to do we're going to take this\nthe first interval add it to the result\nnow and then we're going to take this\ninterval add it to the result after it\nand then we're going to go to the next\ninterval see that we don't have any more\nintervals remaining and then we're done\nso this is going to be our result in\nthis case 0 4 and 5 6 our new intervals\nafter we've merged them and they're in\nascending order so that's kind of the\ngeneral algorithm as you can see since\nit's already sorted we'll just have to\niterate through the entire list of\nintervals once so the overall time\ncomplexity is going to be big o of n\nthat's also going to be the memory\ncomplexity\nif you count the memory that we're going\nto use to create the result array with\nthat being said we can hop into the code\nnow into the code and so we are going to\nhave a result a result of intervals and\nas i mentioned we're going to be\niterating through every single interval\nin the input we're given a list of\nintervals they're already in sorted in\nascending order so now we want to know\nthe couple edge cases remember so\nbasically if this new interval uh\nsuppose it goes before the current\ninterval that we're at so suppose the\nend value of this new interval is\nactually less than the start value of\nthe interval that we're at so how do we\nget the start value well interval at\nindex i at the zero value this is the\nstart value and so basically if the new\ninterval has an end value that's smaller\nthan the start value of the current\ninterval we're at what are we going to\ndo well that means we can go ahead and\ntake this new interval and insert it\ninto the result so we'll say result dot\nappend new interval and once we're done\nwith that then we basically know that\nall the intervals that come after it are\nalso going to be non-overlapping right\nso we don't really have to do anything\nwe can just take those additional\nintervals append it append them to the\nresult and then return so in python an\neasy way to do this is result uh plus\nintervals the sub list starting at index\ni going until the end of intervals right\nso we can just take that entire sub list\nand append it to result this is you can\ndo that with the addition operator and\nthen we'll just return that right we\ndon't even have to continue this uh\nwhile loop now the opposite case we\ndiscussed remember was else if\nthis new interval actually goes after\nthe current interval that we're at well\nin that case that means the new interval\ncould actually still be overlapping with\nsome intervals to the right so we're not\ngoing to add the new interval to the\nresult\nlet me write the condition so basically\nif the new interval the start value of\nthis new interval was greater than the\nend value of the interval that we're at\nthen we're to the result we're going to\ngo ahead and append that interval that\nwe're currently at because it's not\noverlapping with this new interval but\nwe're not going to append the new\ninterval just yet because it could\ntechnically overlap with some additional\nfollowing intervals that are coming up\nand the last condition so these two\nconditions are if the new interval was\nnot overlapping but the last condition\nelse if neither of these evaluates to\ntrue that means the new interval is\noverlapping with the current interval\nthat we're iterating through so what are\nwe going to do well we want to update\nthe new interval in that case right we\nwant to merge it with the interval that\nwe're at and remember we how are we\ngoing to do that well we're going to\ntake the minimum of the left value of\nboth intervals so this is how we can do\nthat the\nminimum of the the new interval and the\nminimum of the current interval we're at\nand the maximum of the right value of\nboth of these so let me copy and paste\nand the right value is going to be at\nindex one so we just have to change\nthose indexes so this is what the new\ninterval is going to be set to now once\nwe've updated that new interval right we\nbasically merged it with a different\ninterval are we going to add this new\ninterval to our result well not quite\nbecause remember this new interval could\nstill be overlapping with some\nadditional intervals that are coming up\nso we're not going to add it just yet\nand then at the end so once this entire\nloop is done executing we're going to go\nahead and return the result right but\nremember one thing so there's two ways\nthat we could have exited right\none is that if we ever got to the point\nwhere the new interval was uh basically\nif this if condition ever executed if\nthe new interval was not overlapping\nwith a interval then we go ahead and add\nthat new interval to the result and then\nwe return right but if that never\nexecutes then we're never going to end\nup adding the new interval to the result\nright so what we want to do before we\nreturn the result is go ahead and take\nto result.append that new interval\nbefore we return right because that\nmeans basically we definitely want to\nappend this new interval to the result\nright that's kind of what the function\nwas telling us to do insert the new\ninterval so we want to make sure that we\ndo end up executing that so\nonce that's done we have written the\nentire code and as you can see it is a\npretty efficient solution so i hope that\nthis was helpful if it was please like\nand subscribe it supports the channel a\nlot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Merge Intervals",
        "NcLink": "merge-intervals/",
        "Pattern": "Intervals",
        "Description": "Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nYou may return the answer in **any order**.\n\nNote: Intervals are *non-overlapping* if they have no common point. For example, `[1, 2]` and `[3, 4]` are non-overlapping, but `[1, 2]` and `[2, 3]` are overlapping.\n\n**Example 1:**\n\n```java\nInput: intervals = [[1,3],[1,5],[6,7]]\n\nOutput: [[1,5],[6,7]]\n```\n\n**Example 2:**\n\n```java\nInput: intervals = [[1,2],[2,3]]\n\nOutput: [[1,3]]\n```\n\n**Constraints:**\n* `1 <= intervals.length <= 1000`\n* `intervals[i].length == 2`\n* `0 <= start <= end <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "44H3cEC2fFM",
        "PythonSolution": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda pair: pair[0])\n        output = [intervals[0]]\n\n        for start, end in intervals:\n            lastEnd = output[-1][1]\n\n            if start <= lastEnd:\n                output[-1][1] = max(lastEnd, end)\n            else:\n                output.append([start, end])\n        return output\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve\nmerge intervals we are given an array of\nintervals with a start and an end value\nso an interval is a start and end value\nyou can think of it like a class or a\nmeeting or some\nkind of time period or whatever and for\neach of these\nintervals we want to take all the\noverlapping\nintervals and then merge them and then\nwe're going to have a new\noutput array of intervals and since we\nmerged the overlapping intervals the\nresult\nis going to be non-overlapping so in\nthis case\nwe see we have an interval 1 3 and\n2 6. so these two are overlapping we can\nmerge them into one\ninterval 1 6. the remaining two\nintervals\nare non-overlapping so they do not get\nmerged and then we see that the\noutput has three on intervals one\nthat we had to merge to get and then the\ntwo\noriginal and this second example just\nbasically clarifies that if we have one\ninterval one four and a second interval\nfour\nfive now these aren't technically\noverlapping\nin a sense right like we have one to\nfour and\nfour to five so they clarify that these\ntwo actually\ndo count as overlapping so what's a\ngood and efficient way to solve this\nproblem let's say we're given\nthe exact same four intervals that we\nwere given in the original example but\nnotice\nthis time they're out of order this one\nis 1 3 this one is 8\n10 this is 2 6. it was originally over\nhere\nright they had given the input to us in\nsorted\norder right so that's kind of a hint\nthat it might be helpful for us\nto keep our intervals in sorted order\nbut what's a good way to kind of\nvisualize what's actually going on with\nthese intervals\nthese numbers are pretty descriptive but\nit's better to have a picture to look at\nso i'm gonna draw a number line and\nwe're gonna\nstart at zero because they clarify for\nus in the problem\nthat any interval is not gonna start at\nlike a negative value so we can\nstart at zero so let's just start\nputting these\nintervals into our number line and see\nwhat happens\nso we have one three so i'm gonna\nhave a line going from one\ngoing from one to three which is over\nhere\nso this interval is length 2. we'll have\nan interval going from\n8 to 10 another interval of length\n2. we'll have an interval from 15 to 18\nand the last interval is from two to six\nso notice this time we actually do have\nan\noverlapping interval two to six\nso i'm gonna draw it above so i'm gonna\ndraw it\nwhere it's obvious that we have two\nintervals that are\noverlapping now when you actually draw\nout the number line\nit kind of becomes obvious that\nit would be very helpful for us to take\nthese\nintervals and sort them based on\nthe start value we don't care so much\nabout the end value because we want to\ngo through our number line starting\nat the beginning starting at the start\nvalue\ngoing to the next start value going to\nthe next start value and then continuing\nthat\nbecause this allows us to detect\nso for example we look at this interval\nfirst we know it goes\nfrom one to three next we look\nat the second interval it goes from\ntwo to six and since we just looked at\nthe previous interval\nover here we know that this one overlaps\nwith this one so what are we going to do\nwe're going to merge them\ntogether into a new interval\nso it results in a new interval from\n1 to 6 because remember ultimately we\nare trying to\nmerge the intervals and then we go to\nour next starting position which is\na so we have an interval from 8 to 10\nand we know it does not merge with this\none because they're non-overlapping we\ngot some\nspace over here right lastly we go to\nthis interval and it goes from 15\nto 18 we know it does not overlap with\nthis one\nthere's all this space in between right\nso just to reiterate we're going to take\nour input list of intervals sort\nby the start value\nof each interval and then we're gonna\niterate through each start value right\nstarting at\nthe first one then the next one then\nthis one\nthen this one and where each time we're\ngoing to check okay\ndoes the current interval does the most\nrecent interval\noverlap with the previous interval if it\ndoesn't we don't do anything\nif it does which it did in this case\nthen we can merge them into one interval\nnow it might seem unnecessary to even\nhave a picture like this because\nthis interval problem is actually\nstraightforward right we just sort and\nthen we merge the intervals\nbut there are a lot more difficult\ninterval problems\nwhere i'm telling you drawing a picture\nlike this\ndrawing a number line to understand\nwhat's actually going\non makes the problem a lot easier to\nsolve\nso now let's write the code remember we\nare sorting the entire input\nso the and then iterating through the\ninput so the\ntime complexity is going to be big o n\nlog n\nwhere n is the number of intervals that\nwe're given\nso thankfully for us in python it's\npretty straightforward to sort we can\njust take\ninterval sort and what's the key we're\nsorting by because remember we're\nsorting a list\nof pairs so the key is going to be a\nin python a lambda function so in this\ncase\ni is going to stand for the interval and\nwhat value of this interval are we going\nto use we're going to use the first\nvalue so at index\n0 we're sorting by the start value if we\nwanted to sort by the end value this\nwould be\ni of 1 but we're going to sort by the\nstart value only\nand so let's also declare an output\nwhere we're going to put the merged\nintervals so i'm not going to initialize\nthis to\nempty i'm actually going to take the\nfirst interval\nand have it inserted into the output\njust so\ni can avoid an edge case so we have\ninitialized\nthe interval so now we're going to\niterate through every\nsingle interval in sorted order\nand technically we can skip the first\none because we already added the first\ninterval into the output\nand instead of just having the interval\nitself we know we're going to use the\nstart and end value so i'm just going to\nextract them\nlike this and so how do we know if\nthe interval is overlapping with the\nmost recent\ninterval well we can get from our output\nthis is why i added one so we can avoid\nthe edge case from our\noutput we can get the most recently\nadded interval\nand get the end value of it because\nthat's what we need to know if it\noverlaps\nso the end value of the most recent\ninterval\nwe'll call it last end and we're going\nto check of the current interval we're\nat the start and end value\nwe're iterating through if the star\nis less than or equal\nto the last ending value that means\nthey're overlapping the equal is\nimportant because they\nthey told us in the second example that\nwe are counting\nequal as overlapping so if they are\noverlapping what are we gonna do we're\ngonna merge them\nhow do we merge them well all we have to\ndo\nis take the most recently added\ninterval and take the ending value\nof it and set it to the max\nof itself which we already have in last\nend\nand the max of the current end value\nthat we're at\nand the reason we need to take the max\nis what if we had\ntwo intervals starting at 1 5\nand the second interval is 2\n4 because we would iterate through them\nin this order because this has a\nstarting value of 1 this has a starting\nvalue of 2 but notice how this actually\nhas a\nlarger end value than this one so if we\njust take\n4 and merge this together and set this\nto four we're actually making the\ninterval\nsmaller we want to keep the five because\nmerging these two together\nis going to actually result in one\nfive so in the case that they're\nnon-overlapping what are we going to do\nwell we don't have to merge but we do\nhave to\ntake that interval and still add it to\nour\noutput so we're going to take start end\nand just add it to our output so what\nwould be an example of that well what if\nwe had\n7 a right these two intervals are\nnon-overlapping so the result would\nactually\nbe itself right we don't have to make\nany changes we don't have to merge\nwe can just leave it as it is and that's\nactually it\nso we didn't really have to do anything\nsince we used the\nbuilt in sort we took care of the main\nproblem\nmain part of this problem and all we\nhave to do now is return\nthe output and so this is a pretty\nefficient solution\ni hope this kind of explained a little\nbit of the intuition\nand you kind of have like a visual\npicture of what is actually going\non as we run this algorithm and why\nwe're doing it the way we\nare and i hope this was helpful if you\nenjoyed\nplease leave a like and subscribe it\nsupports the channel a lot\n"
    },
    {
        "Name": "Non Overlapping Intervals",
        "NcLink": "non-overlapping-intervals/",
        "Pattern": "Intervals",
        "Description": "Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\nNote: Intervals are *non-overlapping* even if they have a common point. For example, `[1, 3]` and `[2, 4]` are overlapping, but `[1, 2]` and `[2, 3]` are non-overlapping.\n\n**Example 1:**\n\n```java\nInput: intervals = [[1,2],[2,4],[1,4]]\n\nOutput: 1\n```\n\nExplanation: After [1,4] is removed, the rest of the intervals are non-overlapping.\n\n**Example 2:**\n\n```java\nInput: intervals = [[1,2],[2,4]]\n\nOutput: 0\n```\n\n**Constraints:**\n* `1 <= intervals.length <= 1000`\n* `intervals[i].length == 2`\n* `-50000 <= starti < endi <= 50000`\n",
        "Difficulty": "Medium",
        "Video": "nONCGxWoUfM",
        "PythonSolution": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        res = 0\n        prevEnd = intervals[0][1]\n        \n        for start, end in intervals[1:]:\n            if start >= prevEnd:\n                prevEnd = end\n            else:\n                res += 1\n                prevEnd = min(end, prevEnd)\n        return res\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve the problem non-overlapping\nintervals and this is actually a problem\nfrom the blind 75 list of questions that\nwe've been working on and we've actually\nbeen tracking that list of questions on\nthis spreadsheet you can see that i do\nhave a video solution on the left side\nover here for pretty much every single\nproblem in this list except for a couple\nthat we haven't gotten to yet so today\nwe will be doing the last interval\nproblem in this list you can see i\nsolved the other interval related\nproblems already there's about like 70\npeople viewing it right now so i hope\nthat you guys are finding it helpful and\nyou can see conveniently i made a\nyoutube playlist for all the blind 75\nsolutions link to that will be in the\ndescription as well if you do want to\ntake a look so now let's continue with\nthe video so this problem is definitely\nlike most interval problems in that if\nyou've solved other interval problems\nbefore this one shouldn't be too\ndifficult but if you're new to interval\nproblems this one is kind of challenging\nso we're given an array of intervals\nwhere each interval has a start value\nand an end value and we want to return\nthe minimum number of intervals that we\nhave to remove from the list to make\nsure that the rest of the intervals are\nnon-overlapping so first question you\nshould ask is what exactly is a\noverlapping interval well assuming an\ninterval looks something like this right\nit has some start value maybe the start\nvalue is 1 and the end value is two\nright maybe we have another interval\nthat starts at three and goes all the\nway to four so definitely these two\nintervals are not overlapping but what\nif we had uh the interval starting over\nhere maybe the end point is 3 but the\nstarting point is maybe 1.5 right\nobviously in this case these two\nintervals are overlapping right you can\nsee you know right over here this is the\nregion that they're overlapping at but\nthe edge case comes when we have a\ninterval let's say like this one that's\ngoing maybe starting from two and going\nall the way to three are these intervals\noverlapping technically you know this\npoint at position two is overlapping but\ntechnically these intervals are not\nconsidered overlapping right so if they\nhave the same edge point they do not\ncount as overlapping this edge case is\nvery important to understand to solve\nthis problem okay so let's take a look\nat the first example actually so you can\nsee i've drawn a few of the intervals\nand you can see so far these three are\nnot overlapping right but we're about to\ninsert the last and fourth interval one\nthree so it starts at one and goes all\nthe way until three so now you can see\nthat they are overlapping with the\nintroduction of this interval and things\nbecome really simple when you draw a\npicture which is why i always recommend\ndrawing a picture for complicated\nproblems so now we want to eliminate\nintervals we want to eliminate the\nminimum number it's obvious that we can\njust remove a single interval this one\nthat we just inserted to make the rest\nnon-overlapping but of course that's not\nthe only way we could do it we could\ninstead remove this interval and remove\nthis interval so instead we'd remove two\nintervals that's clearly not the\nsolution but there are multiple ways to\ndo it which is why writing the algorithm\nfor this problem can be kind of tricky\none definitely possible way to do this\nproblem is brute force it right go\nthrough every single combination right\nfor every single interval we can choose\nto remove this interval or to keep this\ninterval and if we have two choices for\nevery single interval inside the list of\nintervals then you know the time\ncomplexity to check every single\npossibility is going to be 2 times 2\ntimes 2 basically 2 to the power of n\nwhere n is the size of the input so\nthat's obviously not very efficient but\ncan we do better and we definitely can\nand it takes a greedy approach to solve\nthis problem when we're actually given\nthis list of intervals the ordering of\nthem could be pretty random right but\nyou can see when we actually draw the\npicture you know why would we want to go\nthrough these intervals in a random\norder why would we want to look at this\none then look at this one then this one\nyeah right like in just a completely\nrandom order when you look at it this\nway it kind of makes sense to want to go\nleft to right right to see okay here are\nthey overlapping here are they\noverlapping etc etc and the easiest way\nto do that is to to iterate through them\nin some kind of sorted order you can\nprobably do it sorted by the starting\npoint or sorted by the ending point i'm\njust going to stick with sorted by the\nstarting point just because it's a\nlittle bit simpler for me but i know\nthat it works in both ways for this\nproblem at least so when we iterate\nthrough these in sorted order first\nwe're going to compare these two\nintervals right we want to compare\nadjacent pairs of intervals right and\nlet's actually ignore this example for\njust a second suppose we had just two\nintervals right one interval like this\nand one interval like this okay they're\nin sorted order right and we're\ncomparing adjacent pairs so we're going\nto look at this one and look at this one\nhow do we know if they are overlapping\nwell if they're sorted by the starting\npoint we know that either they both have\nthe exact same starting point or the\nsecond one has a starting point that's\nafter the first one's starting point and\nthat's the case here\nbut again how do we know if they're\noverlapping or not well the easiest way\nto check is they're not overlapping if\nthis one starts after this one ends\nright if the second one starts after the\nfirst one ends then they're definitely\nnot overlapping but on the other hand if\nthe second one starts before the first\none ends then they're definitely\noverlapping right you can see that this\nis the point that they're overlapping at\nokay so does that cover all of the cases\nwell there's one more case technically\nthat's slightly different what if you\nknow the first one is really long and\nthe second one starts here right so it\ndoes come after this one but it ends\nbefore the first one ends this is a\nslightly different edge case again they\nare overlapping we can detect that with\nthe same condition this one starts\nbefore this one ends so yes they're\noverlapping but now suppose we had a\nthird interval that comes next remember\nwe are traversing these in sorted order\nso first we're gonna compare this one is\nfirst this one is second so then we're\ngonna compare these two together next\nare we gonna be looking at this one and\nthis one\nin this case yes because remember if\nthese two are overlapping we don't have\nto remove both of them we only have to\nremove one of them so the choice is are\nwe going to remove this one or are we\ngoing to remove this one well which one\ndo you think we would rather remove\nwould we want to remove the one that\nends first or the one that ends second\nof course we'd want to remove the one\nthat ends first because then it's\nthere's less of a chance that it's going\nto overlap with the following intervals\nthat come after and remember we want to\nminimize the number of intervals that we\nhave to delete in this example with\nthese three intervals it doesn't matter\nwe could remove this one or remove this\none but let's look at another example\nwhat if the third interval was like this\nright it's overlapping with this one\nthen it becomes pretty obvious we would\nwant to remove this bottom interval\nrather than this top interval and it\ndepends on which one of these ends first\nso that's how we're going to decide\nwhich one to remove and just to look at\na third example so what if they were\ninter overlapping like this right of\ncourse we're going to first compare\nthese two intervals okay yes they're\noverlapping and we can detect that\nbecause this one starts before this one\nends so now we have a choice do we\nremove this one or do we remove this one\nagain we're moving the one that ends\nfirst so we're going to remove this one\nand you can see\nexactly why because now these two do not\noverlap but what if instead we decided\nto remove this one well we removed it\nbut it didn't help us because these two\nare still overlapping we want to\nminimize that so\nbasically i just explained to you the\nexact algorithm that we're going to be\nusing we're going to sort the entire\narray based on the starting value then\nwe're going to compare adjacent pairs\nand then use the conditions that i just\nmentioned now what's the time complexity\nof this well we're going to sort and\nthen we're just going to iterate through\nthe array a single pass right so the\niterating is simple it's just big o of n\nwe're just going to iterate through the\nentire array but the sorting is where\nthe bottleneck is so that's what the\noverall time complexity is going to be\nbig o log\nn log n and just to run the algorithm\nthat i explained on this input example\nbecause they have the first two starting\nvalues so we're going to have this array\nin sorted order based on the start\nvalues we're actually going to take the\nfirst interval and just take its end\nvalue and then keep track of it because\nsince this is the first interval there's\nnothing going to be that comes before it\non the left okay so now we're going to\niterate through the intervals that come\nafter this one so the first interval is\nthis one it has the next start value so\nwe're going to check is the start value\nless than\nthis ones yes they are so they're\noverlapping so which one are we going to\ndelete the one with the larger end value\nso we're going to delete this one we can\nleave this interval as is and save its\nend value so that we can compare it with\nthe following intervals so this is the\ninterval that comes next is its start\nvalue less than the end value of the\nprevious one no it's not so we don't\ndelete either of these intervals but\nsince we didn't delete either of these\nintervals and since we know this one\nstarted after this one ended we know\nthat this one is going to have a larger\nend value so we're not going to be using\nthis one to compare anymore we're going\nto be using this end value to compare to\nthe following intervals on the right\nside okay so now let's look at this\ninterval and the next interval that's\ncoming up is this one so is this one\nstarting before this one ends nope it\ndoes not so we don't delete either of\nthese and\nuh we just set this to the new end value\nthat we're going to keep track of but\nthere's nothing that comes after it so\nwe're done here we only had to remove\none interval as you can see so the\nanswer in this case is one which is what\nthey also had in the output so that's\nthe entire algorithm now we can actually\ncode it up it's not too bad\nokay so now let's get into everybody's\nfavorite part writing out the code so\nremember the first thing we want to do\nis sort the list of intervals so in\npython i can just say sort and it'll\nactually sort it based on\nthe entire pair it'll first sort it\nbased on the start value and then sort\nit based on the end value if there's a\ntie between the start but you know in\njava and stuff you can specify the key\nis just the start or you can use just\nthe end if you want to and then\nyou can slightly change your algorithm\nif you're sorting by the end value but\nthe result that we're going to keep\ntrack of is just the entire count that\nwe have to remove so initially it's\ngoing to be set to zero and remember\nwe're going to initially keep track of\nthe first end value in our sorted\nintervals so we can get that just like\nthis intervals the first interval and we\nwant its end value which is at index one\nthen we're going to iterate through the\nremaining list of intervals so we can\niterate through the start and end value\nof the remaining intervals like this and\nwe want to start at index one so we can\nspecify like that in python and now we\nget to our if-else case because we want\nto know are they overlapping or not so\nthey're not overlapping if the start\nvalue of the interval that we're looking\nat is greater than or equal to the\nprevious end value and remember the\nequal is very important that's the edge\ncase we talked about at the beginning if\nthey're equal they're technically not\noverlapping and if they are not\noverlapping the only thing we need to do\nis update our previous end set it to the\nnew end value\nbecause we know that the new end value\nis going to be greater than the previous\none and the else case is if they are\nactually overlapping and if they are\noverlapping then we need to remove one\nof the intervals so definitely we are\ngoing to increment our result count by\none because we have to remove one of\nthese now the question is which one are\nwe going to remove and how are we\nactually even going to handle that well\nthe only thing we actually need to\nupdate is our previous end because\nremember we don't actually have to\ndelete the interval in the array we just\nhave to count how many we delete but we\nhave we do have to update the previous\nend uh remember which one of these end\nvalues are we actually going to keep\nwhich one of the intervals are we going\nto keep we're going to keep the one that\nhas the minimum end value so we're going\nto set previous end equal to the minimum\nof end and itself previous end so that\nonce we've updated this we can use this\nnew end value uh in the future\niterations of the loop but that's\nactually the entire algorithm once we've\ndone that we just have to return the the\ncount of how many we deleted and then\nrun the code and make sure that it works\nand as you can see yes it does work and\nit is pretty efficient so i really hope\nthat this was helpful if it was please\nlike and subscribe it really supports\nthe channel a lot consider checking out\nmy patreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Meeting Rooms",
        "NcLink": "meeting-schedule/",
        "Pattern": "Intervals",
        "Description": "Given an array of meeting time interval objects consisting of start and end times `[[start_1,end_1],[start_2,end_2],...] (start_i < end_i)`, determine if a person could add all meetings to their schedule without any conflicts.\n\n**Example 1:**\n\n```java\nInput: intervals = [(0,30),(5,10),(15,20)]\n\nOutput: false\n```\n\nExplanation:\n* `(0,30)` and `(5,10)` will conflict\n* `(0,30)` and `(15,20)` will conflict\n\n**Example 2:**\n\n```java\nInput: intervals = [(5,8),(9,15)]\n\nOutput: true\n```\n\n**Note:**\n* (0,8),(8,10) is not considered a conflict at 8\n\n**Constraints:**\n* `0 <= intervals.length <= 500`\n* `0 <= intervals[i].start < intervals[i].end <= 1,000,000`\n",
        "Difficulty": "Easy",
        "Video": "PaJxqZVPhbg",
        "PythonSolution": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def canAttendMeetings(self, intervals: List[Interval]) -> bool:\n        intervals.sort(key=lambda i: i.start)\n\n        for i in range(1, len(intervals)):\n            i1 = intervals[i - 1]\n            i2 = intervals[i]\n\n            if i1.end > i2.start:\n                return False\n        return True\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve a problem\nmeeting rooms and you notice that the ui\nof this looks a little bit different and\nlet me show you why\nso if you go on leak code and you try to\nsolve this problem meeting rooms you'll\nnotice that\nit's a locked problem and you have to\nsubscribe and pay money to be able to\nsolve this premium really good problem\nbut there's actually a workaround that i\nfound\nand that is that there's a site called\nlint code\nand on that site lint code you can\nbasically solve\nit's it's pretty much a leak code clone\nand you can basically solve\npremium leak code problems for free so\nyou know this\nis so yeah if you don't want to pay\nmoney to be able to solve certain\nproblems on leak code i'd recommend\nsolving them on this site instead so\nthat's what i'm going to be doing today\nbut nevertheless this is basically the\nexact same problem i don't know how they\ncan get away with doing that but that's\nokay\nso we're given an array of meeting time\nintervals consisting of start and end\ntime so each\ninterval is basically a tuple or a pair\nof values the first value is the start\ntime the second value is the end time\nof a particular meeting so for example\nif we were given two meetings one starts\nat zero and\nends at eight and the next one starts at\neight and ends at\nten these do not overlap basically we're\ntrying to determine if a person could\nattend both of these meetings and\ntechnically they could\nbecause it's one ends at eight and the\nother one starts at eight so that's\ntechnically\nnon-overlapping and in this case we\nwould return true because\nthe person could attend both of these\nmeetings but let's look at the second\nexample\nso we see that one meeting starts at\nzero and ends at thirty\nthe next meeting that starts after it\nstarts at five so\ntechnically it starts after this meeting\nbut it ends\nat 10. so the main thing to notice is\nthis meeting\nstarts before this meeting has even\nended right so if this goes from zero\nall the way\nto thirty we see another meeting starts\nover here at\nfive and it goes to ten but the thing\nwe're paying attention to is it started\nbefore the other meeting even\nended right like we can see that they\nare overlapping therefore nobody could\nbe able to attend both of the meetings\nat the same time so we have to return\nfalse because we found\noverlapping intervals so as you can tell\nit might be helpful for us if we're able\nto sort\nall of the meetings based on the start\ntime\nof each meeting and they basically gave\nus that\nsorted array you know just as an input\nbut and they're basically hinting us\nto do exactly that sort it based on the\nstart value of each\ninterval so if we we are given an array\nof meeting intervals and we sort based\non the start time that is going to take\nn log n complexity for that sorting\nbut after we're done sorting what you're\ngoing to notice is we're basically\nallowed to start at the beginning and\njust scan\nthrough so the next part of the\nalgorithm is going to be o of n\nso the overall time complexity is just\ngoing to be big o and log n\nso what we're going to do is we're going\nto look at the first\ntwo intervals available to us and the\nonly thing we're going to compare\nis the end time of the first interval\nand the start time of the second\ninterval because we\nknow for sure since these are in sorted\norder this one is going to start\nbefore or equal to the same time as this\none so we know for sure the start time\nof this is either going to be right here\nor it's going to come after it and for\nus to detect\nthat these two intervals are overlapping\nit's very simple\nif the start time of this is before the\nend\ntime of this one that means they are\noverlapping so for example if the start\ntime of this was over here\nthat means it starts before this one\nends therefore\nthey are overlapping and we can\nimmediately return false right that\nmeans no one could attend all of the\nmeetings\nbut if they're not overlapping which is\nthe case right now right\nthis one starts right as this one ends\nso that technically does not mean that\nthey're overlapping\nso that means these two intervals are\nnot overlapping\nso my next question to you is does that\nmean now we have to compare this one\nto this one as well we don't and that's\nexactly why we sorted the input because\ndo we know\nif this one if this interval starting\nvalue came after\nor equal to this interval's n value then\nthere's no\nway that this interval could possibly\noverlap with this one because we know\nfor sure\nthis interval start time is going to\ncome after this interval start time\nright\nor equal to it so if this one did not\noverlap this one then there's no way\nthis could possibly overlap this one so\nwe don't have to check that so now\nas we move to the next position we're\ngoing to be checking if\nthese two intervals are overlapping\nand so again we're just going to repeat\nthat process okay the end time of this\none and the start time of this one well\nthis the start time of this is after\nthis one\nafter the end time of this interval so\ntherefore they're definitely not\noverlapping right\nand if this one does not overlap with\nthis one if we had a bunch of intervals\nthat came after over here right even if\nthey started at the exact same time\nright maybe some intervals like this\nthen if we can determine that\nthis interval does not overlap this\ninterval then for sure\nall of these intervals that could\npossibly exist towards the right\nare definitely not going to overlap with\nthis one either\nso then we just continue our comparisons\ncomparing\neach adjacent pair of intervals so that\nis basically the solution the main idea\nto notice\nis that we can sort the input based on\nthe start time and\nthat's going to give us the most\nefficient solution so now let's jump\ninto the code\non lint code rather than leak code this\ntime so one thing before i start coding\nis i want to mention that the list of\nintervals is given to us not as a pair\nbut it's actually an\nobject so interval happens to be an\nobject it has two members\nstart and end and they basically mean\nwhat they say they mean\nso now we can code it so remember the\nfirst thing we're going to want to do is\nsort the intervals and we're going to\nsort it based on the start time so in\npython we can give the key that we're\ngoing to be sorting on\nas this it's going to be lambda\nbasically an inline function\nso for this function if we're given an\ninput i for the interval\nthe return value or rather what we're\ngoing to be sorting it based on\nis going to be i of start right so for\nan interval we're going to be sorting it\nbased on the start time\nof that interval and once we're done\nwith that we're just going to iterate\nthrough the entire\narray of intervals so i'm going to\nuse i for index it's not the interval\nitself and we're going to go through the\nlength of intervals and since we're\ncomparing adjacent intervals\nwe can actually start at index 1 because\nwe're going to compare\nindex 1 with the previous index so we're\ngoing to be looking at two intervals\ninterval 1\nis going to be the interval at index i\nminus 1. so that's going to be the first\ninterval interval 2 is going to be\nthe interval at the current index or\nintervals at index\ni and remember we want to compare the\nend time of interval 1 and the start\ntime of interval 2 and how are we\ncomparing them how do we know if we're\ngoing to be returning\nfalse if and only if the start time\nof interval 2 is less than the\nend time of interval 1 that means\ninterval 2 starts before interval 1\nends and therefore we would have to\nif that's not the case though then we\ndon't have to do anything right then we\njust have to go to the next iteration of\nour loop and then compare the next two\nintervals\nand if we never end up returning false\nthat means we\nnever had overlapping intervals then we\ncan just return true as soon as we exit\nout of the loop\nso now let me just submit it make sure\nthat it works\nand yep you can see it's about as\nefficient as we could get so\nuh probably the biggest thing that you\nlearned in this is that you can use a\nwebsite called link code to solve\npremium leak code problems for free\nand i think i'm probably going to be\nmaking use of this site when i'm solving\nsome other premium questions such as\nalien dictionary and some other ones\nthat i think are pretty important and\ngood problems to practice\nso i hope that this was helpful if it\nwas please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Meeting Rooms II",
        "NcLink": "meeting-schedule-ii/",
        "Pattern": "Intervals",
        "Description": "Given an array of meeting time interval objects consisting of start and end times `[[start_1,end_1],[start_2,end_2],...] (start_i < end_i)`, find the minimum number of days required to schedule all meetings without any conflicts.\n\n**Example 1:**\n\n```java\nInput: intervals = [(0,40),(5,10),(15,20)]\n\nOutput: 2\n```\n\nExplanation:\nday1: (0,40)\nday2: (5,10),(15,20)\n\n**Example 2:**\n\n```java\nInput: intervals = [(4,9)]\n\nOutput: 1\n```\n\n**Note:**\n* (0,8),(8,10) is not considered a conflict at 8\n\n**Constraints:**\n* `0 <= intervals.length <= 500`\n* `0 <= intervals[i].start < intervals[i].end <= 1,000,000`\n",
        "Difficulty": "Medium",
        "Video": "FdzJmTCVyJU",
        "PythonSolution": "\"\"\"\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\"\"\"\n\nclass Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -> int:\n        time = []\n        for i in intervals:\n            start, end = i.start, i.end\n            time.append((start, 1))\n            time.append((end, -1))\n        \n        time.sort(key=lambda x: (x[0], x[1]))\n        \n        count = 0\n        max_count = 0\n        for t in time:\n            count += t[1]\n            max_count = max(max_count, count)\n        return max_count\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve meeting rooms two\nand just like meeting rooms one we're\ngoing to solve this problem on the\nwebsite called\nlint code because this is a premium leak\ncode problem\nso if you want to be able to solve it\nfor free you can use lintcode.com\nso it's pretty similar to meeting rooms\none we are given a list of meeting times\neach meeting time is an\nobject and it has two variables it has a\nstart time\nand it has an end time and the end time\nis always going to come after the start\ntime that's pretty intuitive\nand we want to know what's the minimum\nnumber of\nconference rooms required for all of\nthese meetings now what they\nwhat they actually mean by conference\nrooms is basically\nwhat is the maximum number of\noverlapping\nmeetings at any given point in time so\nfor example\nin this input we have a meeting that\nstarts at 0 ends at 30. another meeting\nthat starts at 5 ends at 10\nand then another meeting that starts at\n15 and ends at 20.\nand we would need two meeting rooms for\nthis problem because we\nare gonna have two overlapping meetings\nso if we had one room where the zero to\nthirty meeting is going on\nthe five to 10 meeting is basically\ngoing to be going on\nduring the same time as this one so\nwe're going to need a second meeting\nroom for this\nand we also have another meeting 15 to\n20. now it doesn't overlap with this one\nso technically they can be a part of the\nsame meeting room now we don't actually\nneed to determine\nwhat goes in each meeting room we just\nhave to know what's the maximum number\nof overlapping meetings at any given\npoint in time\nin this case that happens to be two we\nare going to be required to sort the\ninput array\nwhich is going to take n log n time\ncomplexity so this is going to be the\ntime complexity\nof the algorithm the memory complexity\nis going to be big o\nof n i'm going to show you how to do the\nsolution now if you just stare at this\nlike the problem statement and just look\nat these numbers it's going to be\ndifficult to come up with how to code\nthe solution but\nas you guys know i like to draw pictures\nand when you look at the picture it\nactually becomes pretty easy\nto figure out how to solve this problem\nso let's do that so this is kind of how\nwe can visualize those meetings right\nthese are the\nexact same meetings that we were given\nin that first example\nwe have one meeting going from 0 to 30\nanother meeting going from 5 to 10 and\nanother meeting going from 15 to 20. now\nif we just go from left to right we're\ngonna see\nokay well this is the first meeting that\nstarts right it starts at time zero\nand if we just keep going now we see\nwhat's the next point on our grid right\nwell\nthere's another meeting and this is not\nan end time this is not you know the the\nfirst meeting isn't\nending there just happens to be another\nmeeting that's starting so another\nmeeting just started at time\nfive so what does that tell us that\ntells us\ntwo meetings have started so far but\nnothing has ended right there's no\nmeeting that's\nended yet so at this point in time we're\ngonna have\ntwo meetings going on at the same amount\nof time so what we're gonna be\nmaintaining is a variable\ncount which tells us at any given point\nin time what is the number of meetings\ngoing on and right now our account is 2\nand we're going to end up returning\nwhatever the max value this happened to\nbe\nso what's the next point on our grid we\nvisited this one we visited this one\nnow we're looking at this one right okay\nat at time\n10 there's an end point this is not a\nstarting value this is a starting value\nthis is an\nending value so what does that tell us\nthat tells us a meeting has just\nended so what are we going to do with\nour count we knew we had two meetings\ngoing on at the same time over here\nbut now after this point we're only\ngoing to have one meeting going on right\nlike look at the picture\nthere's only one meeting going on and\nit's this first one right zero to 30. so\nwe're going to set the number of\nmeetings going on to\none now we're going to look at the next\npoint in order\nnow it happens to be a start time so\nanother meeting just started at time 15\nright so once again there are two\nmeetings going on right at this point\nthere's two meetings going on the first\none and\nthis second one so once again a meeting\nstarted that's going to tell us to\nincrement our\ncount so now we're gonna say two\nmeetings are once again going on\nand again we're gonna repeat the same\nprocess the next point is at 20 this\nhappens to be an\nend time so that means a meeting is\nending right we don't\nwe don't technically even know is it\nthis meeting that's ending or is it this\nmeeting that's ending it doesn't really\nmatter to us\nall we know is that after this point\nonly one meeting is gonna be going on at\nany particular time and it's gonna be\nthis one\nso we're gonna take our count of\nmeetings going on decrement it and now\nit's gonna be\none and last but not least we're going\nto go to the last\npoint in our grid and it's also a end\ntime obviously the last point is always\ngoing to be\na end time for a meeting so that means\nanother meeting is stopping\nafter that point there's only going to\nbe you know zero meetings going on\nso therefore we can take our count\ndecrement it all the way down\nto zero now we notice that what was the\nmax value that count happened to be\nwell the max it ever reached was two so\ntherefore we're going to return\ntwo as our result two meeting rooms is\nenough to contain all of these meetings\nso let me show you quickly how we're\nactually going to be sorting these\npoints and how we're going to be able to\niterate through each point in order\nregardless of if it's a start time for a\nmeeting or if it's an\nend time for a meeting so i'm going to\nslightly change the example in this case\nso\njust by looking at the picture what do\nyou think the meeting room's number\nwould be for this\nproblem well you see over here there's\ngonna be one meeting\ngoing on here there's gonna be two\nmeetings here there's gonna be two\nmeetings here there's gonna be one\nmeeting but look at this point at\npoint time equals 10 clearly there's\nthree\nmeetings going on at this time or at\nleast three meetings have a 10 value\nincluded in their time\ninterval does that mean that there's\ngoing to be three meetings going on\nwell technically the way this problem is\ndefined this meeting would\nend before this meeting started what i'm\nsaying is these two meetings are\nnon-overlapping so when we are going\nthrough this point if we ever have a\ntie meaning if we ever have two points\nwith the exact same value\nwhat we're gonna do is we're always\ngonna iterate through the\nend meeting time before we iterate\nthrough the start\nmeeting time right notice how this is a\nend time this is a start time we're\nalways gonna pick\nthis one if we ever get a tie like this\nso we're actually going to have\ntwo input arrays we're not just going to\nsort every meeting based on the start\ntime what i'm going to do is i'm going\nto put all start times in a separate\narray\nso 0 5 and 10 are all gonna go in a\nseparate\narray these are all the start times for\nany meeting right this way\nwe have them in sorted order and we know\nokay these are the ones\nthat are start times we can\ndifferentiate between a start time and\nan\nend time we're also going to put every\nend time\nin an array as well in sorted order so\nwe can see the first is 10\nnext 15 next 30. so now we're going to\nstart this problem off with two pointers\nwe're going to have one pointer at the\nbeginning of start and one pointer at\nthe beginning of end\nwe're always between these two we're\nalways going to pick the minimum value\nso\nwe are going to maintain a count which\ntells us the number of meetings that are\ngoing\non and if the minimum between these two\nis the start time what we're going to do\nis we're going to increment the count of\nmeetings going on and then shift our\nstart pointer to the next one\nand we can see that that's the case\nagain right 5 is less than 10 therefore\na meeting has to start before this\nmeeting ends\nso once again we're going to shift our\npointer over here and we're going to\nincrement our count by one so\nthe count is now gonna be set to two and\nnow we get to the edge case right we got\na tie so\na meeting is ending and a meeting is\nstarting remember we are gonna\nvisit the end time if there's a tie\nfirst so what we're gonna say\nnow is that okay a meeting has to end\nbefore this meeting starts so we're\ngonna shift our\nend pointer to the next one if we\niterate through an end value that means\na meeting just ended therefore we're\ngonna decrement our count by one so\ntwo is decremented by one it's going to\nbe set to one now\nnow again we're going to compare these\ntwo values 10 and 15. which one is\nsmaller the 10 right so therefore\nanother meeting is starting\nso we're going to increment our count by\none so count is now going to be equal to\ntwo and now we don't even have any start\ntimes\nleft so technically at this point we're\njust going to be iterating through the\nend time so we're literally just going\nto be decrementing this so we iterate\nthrough this\ndecrement this down to one iterate\nthrough this decrement this down to zero\nso technically\nonce we've gotten through all start\ntimes we don't even have to iterate\nthrough\nthe remaining portion of end times so\nwhat we can say is that our max count\nat any given point it reached was two so\ntherefore we're going to return\ntwo so that is basically the algorithm\nwe're going to use\nand coding it up isn't going to be too\ndifficult yes we are going to have to\ncreate two separate arrays start and end\nand we're going to sort these input\narrays so the time complexity is going\nto be n log n the memory complexity is\ngoing to be big o of\nn that being said let's jump into the\ncode now on lint code\nso like i said we are going to create a\narray for all start times in sorted\norder now i'm sure you know how to do\nthat in your language of choice\nbut in python there's a pretty easy way\nto do it so we're going to go through\nfor every interval\nin the list of intervals that we're\ngiven now\nan interval is an object as defined up\nabove it as two member variables start\nand end so since this arrays start we're\ngoing to put every start time of this\ninterval\nin this input array and don't forget we\nare going to sort it so and i can do\nthat\non the same line just like this we're\ngoing to have a similar array for n\ntimes basically doing the exact same\nthing so a sorted input array\nof i dot n for every interval in the\nlist of\nintervals now we are going to have a\nresult variable and a count variable so\ncount is just going to be whatever what\ni basically said it was going to be\nresult is just going to continuously be\nwhatever the max we have reached so far\nfor the count variable\nand we are also going to have two\npointers i'm just going to name them s\nand e uh they're initially going to be\nboth\nzero so s is gonna be the position we're\nat in our start array e\nis gonna be the position we're at in our\nend array and i'm basically just going\nto keep\ngoing while s has not reached the\nend of intervals because we know of\ncourse s\nis going to reach the end before e does\nbecause the start times are always\nbefore the end times\nso remember we have two cases if the\nstart if the position that we're at in\nour start array\nis less than the position we're at in\nour end array\nand the other case would be if the end\narray\nwas greater than the s than the start\narray which would be the else case but\nalso if these were\nequal we're also going to do the else\ncase because if they're equal then we\nwant to make sure we increment our e\npointer first\nso that's exactly what we would do here\nwe would take e\nincrement increment it by one and\nto our count decrement it by one the\nopposite is going to be true up here so\nhere\nsince s is smaller since the start time\nis smaller we're going to be\nshifting our s pointer and we're going\nto be incrementing the count so we do\nhave one additional meeting going\non right now that's what we're saying\nand after every\niteration basically we're gonna update\nour result potentially we always want it\nto be the maximum that we've reached so\nfar for count so we're gonna just take\nthe max\nof result and count once that is done\nthat means\nthis loop once this loop is done that\nmeans we've finished all of our start\ntimes\nso at that point we can basically return\nour result because we've ensured that it\nhas reached whatever the maximum it was\ngoing to be\nand with all that we can go ahead and\nsubmit it hopefully this works\nand as you can see it does it's about as\nefficient as it would get\nso this is the entire code it's not too\nbad once you can kind of visualize what\nis actually going on that's how you can\nkind of figure out\nhow to put the different points inside\nof separate input arrays\nbut i think it would be pretty difficult\nto come up with this on your own in like\na very short interview\nbut i hope this was helpful if it was\nplease like and subscribe it supports\nour channel\na lot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Minimum Interval to Include Each Query",
        "NcLink": "minimum-interval-including-query/",
        "Pattern": "Intervals",
        "Description": "You are given a 2D integer array `intervals`, where `intervals[i] = [left_i, right_i]` represents the `ith` interval starting at `left_i` and ending at `right_i` **(inclusive)**. \n\nYou are also given an integer array of query points `queries`. The result of `query[j]` is the **length of the shortest interval** `i` such that `left_i <= queries[j] <= right_i`. If no such interval exists, the result of this query is `-1`.\n\nReturn an array `output` where `output[j]` is the result of `query[j]`.\n\nNote: The length of an interval is calculated as `right_i - left_i + 1`.\n\n**Example 1:**\n\n```java\nInput: intervals = [[1,3],[2,3],[3,7],[6,6]], queries = [2,3,1,7,6,8]\n\nOutput: [2,2,3,5,1,-1]\n```\n\nExplanation:\n- Query = 2: The interval `[2,3]` is the smallest one containing 2, it's length is 2.\n- Query = 3: The interval `[2,3]` is the smallest one containing 3, it's length is 2.\n- Query = 1: The interval `[1,3]` is the smallest one containing 1, it's length is 3.\n- Query = 7: The interval `[3,7]` is the smallest one containing 7, it's length is 5.\n- Query = 6: The interval `[6,6]` is the smallest one containing 6, it's length is 1.\n- Query = 8: There is no interval containing 8.\n\n\n**Constraints:**\n* `1 <= intervals.length <= 1000`\n* `1 <= queries.length <= 1000`\n* `1 <= left_i <= right_i <= 10000`\n* `1 <= queries[j] <= 10000`\n",
        "Difficulty": "Hard",
        "Video": "5hQ5WWW5awQ",
        "PythonSolution": "class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        intervals.sort()\n        minHeap = []\n        res = {}\n        i = 0\n        for q in sorted(queries):\n            while i < len(intervals) and intervals[i][0] <= q:\n                l, r = intervals[i]\n                heapq.heappush(minHeap, (r - l + 1, r))\n                i += 1\n\n            while minHeap and minHeap[0][1] < q:\n                heapq.heappop(minHeap)\n            res[q] = minHeap[0][0] if minHeap else -1\n        return [res[q] for q in queries]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve another problem from this\nweek's leak code contest\nminimum interval to include each query\nwe're given a 2d integer array of\nintervals each interval has a\nleft value and a right value which\nbasically determines the length\nand positions of the interval so right\nlike the left point and the right point\nand so the interval is connected by the\nleft and right points\nand of course the size of the interval\nis just defined as\nthe right value minus the left value\nplus one right basically\nyou know the size of the interval if\nthis was one this was two basically if\nthis\nif we had this interval one and two the\nsize of the interval is going to be\ntwo even though that even though the\nlength of the interval is one the size\nis two because it contains two values\none and two if this was three then this\nwould be an interval of length three\nthree minus one plus one is going to be\nthree\nbecause it contains one it contains two\nin the middle and then\nthree it contains three points so that's\nbasically\nwhat the size is in this case if we had\njust a an interval with\none point right like maybe the left and\nright value are equal then the size of\nthis interval is going to be\none we're also given an integer array of\nqueries and the answer to the\njth query this is where things are going\nto get a little bit complicated\nthe answer to each query is basically\nthe size of the interval the size of the\nsmallest interval such that q falls\ninto the interval so for example we\ncould have maybe\none interval like this and then maybe a\nsmaller interval\nlike this and let's say we had a query\nsuch that the query you know\nthe query is over here this is the point\neach query is just going to be a single\nvalue a point so\nas we can see this point falls into two\ndifferent intervals which one of the\nintervals is smaller\nit's this little one over here right so\nbasically we're going to return\nthe length of that smaller interval for\neach query\nsince we're doing a result for every\nsingle query that we have we're actually\nreturning an array output basically\nfor each query like this is our query\narray we have two three four\nfive for each one of these we're gonna\nhave a corresponding output value which\nis gonna tell us the size\nof the smallest interval that this query\nfalls into\nif it's possible that a query like\ntwo for example might not fall into any\ninterval that's available to us in that\ncase we return a default value of\nnegative one\nit's also possible we could have\nmultiple queries that are the exact same\nright there's no restriction on that\nwe could have a two query and another\ntwo query so what's going to be the\nbrute force way to solve this problem\ncan you answer\nthat well for each query we're looking\nfor the minimum interval right so the\nbrute force will be\nfor each query just scan through the\nentire\ninterval list and then find which one of\nthe queries\nwhich one of the intervals the query\nfalls into that happens to be the\nsmallest interval right so two in this\ncase\nwhich one of these four intervals is the\nsmallest interval that two falls into\nit falls into this one and the length of\nthat is three it also falls into this\none\nand the length of this one well actually\nthe length of this one is four the\nlength of this one\nis three and it does not fall into this\none\nand two also does not fall into this one\nso what's the size of the smallest query\nit's going to be 3\nthat's why we can see over here the\nfirst value in our output is 3.\nso what's going to be the time\ncomplexity of that well it's just going\nto be a nested for loop right we're\ngoing to have\na length of queries and the length of\nintervals right so multiply those\ntogether let's say it's\nyou know n is the size of queries or n\nis the size of intervals q is the size\nof queries we're going to get n\ntimes q is going to be the overall time\ncomplexity\nnow is it possible to solve this problem\nmore efficiently\nyes but not by much and i'm going to\nshow you what the time complexity is and\nthen i'm going to show you how to\nactually achieve that time complexity\nso it's going to be n log n plus\nq log q because\nthe and and mainly this time complexity\nis going to come\nfrom the fact that we're going to be\nsorting our intervals and we're going to\nbe\nsorting our queries and once we do that\nwe can scan\nour queries from left to right and\nthat'll and since our intervals are also\nsorted\neach query will be close to the interval\nthat it belongs to right the smallest\ninterval that it belongs to\nso it'll actually end up being\nrelatively efficient once we sort both\nof them but we're also going to actually\nneed a data structure\nin order to actually find the minimum\nthe smallest interval\nso we're going to be needing a min heap\nto achieve\nthat for us so this problem is a hard\nproblem for a reason\nit does have a little bit of difficulty\nit's not super intuitive\nbut the solution is doable the code is\ngoing to be about 15 to 20 lines of code\nso pretty much like every interval\nproblem we're going to use the fact that\nwe can sort the intervals\nto our advantage and just by looking at\nthe picture this is why i like to draw\npictures because it becomes more\nintuitive\nit wouldn't really make sense for us to\ngo brute force right\njust like let's say the order we were\ngiven these values was maybe\nthree and then four and then two it\ndoesn't make sense for us to do these in\na random order of course we would want\nto do it from\nleft to right because the queries are\ngoing to be close\nto the intervals that they belong to and\nwe're going to get the smallest interval\nthat it belongs to and of course you\nknow for a query like this we're not\ngoing to be necessarily looking at\nintervals all the way over here\nright that's 1 and of course we know we\ncould also have\nmultiple queries we have a query here we\ncould have multiple queries with the\nsame value and of course\nboth of them would have the same\nsmallest\ninterval that they belong to so you know\nwe could kind of cut down on the\nrepeated work like that\nbut so how is this going to work like i\nsaid we're going to need a min heap\nso we're going to iterate through every\nsingle query right\nultimately we're trying to build our\nresulting output\nwith the size of the minimum interval\nthat each query belongs to so\nlet's start with this query right it's\nat the\nits value is two so what are we gonna do\nwe're gonna start\niterating through our intervals from\nleft to right\nyou know since we've sorted them we're\ngonna sort them based on the left value\nof each\ninterval so in what order are we going\nto iterate through these intervals\nwell this one has the smallest left\nvalue this one is next\nthis one is next and then this last one\nwhich is just a single point but it\nstill counts as an interval\nis going to be the last one so starting\nhere what are we going to determine\nwhat we want to do for this query is we\nwant to\nadd all possible intervals that this\nquery could belong to right\nhow do we know which intervals this\nquery could possibly belong to\nwell let's say we had an interval over\nhere right like something like this\nsince this interval is too far to the\nright\nof course this query is not going to\nbelong to that interval\nhow do we know that the what algorithm\nor what kind of condition can we use to\ncheck that well\ntake a look at its left value or its\nstart value of the interval\nif the left value of this interval is\ngreater\nthan the point or this query right if\nthe left value is greater than the query\nof course this query could not belong to\nthis interval\nso the condition we're going to use\nwe're going to keep iterating through\nthese intervals\nwhile the left value of the interval is\nless than or equal\nto the query so for example this is the\nfirst query we're going to look at the\nthe left value is less than or equal to\nthis so we're going to go ahead and add\nthat query or add that interval\nto our min heap how are we going to add\nit to our min heap though remember we\nwant to pop the minimum\nsize so we're actually going to take\nthis interval and calculate the size of\nit\nhow are we going to do that well 4 minus\n1\nplus 1 is going to be equal to 4. so\nwe're going to add\n4 to our min heap but actually we're\ngoing to add a\nsecond value 2 because there could be a\ncondition where two intervals are the\nsame\nlength right we could have an interval\nlike this\nright from here to here we could also\nhave an interval like\nthis from here to here both of these are\nsize\nboth of these are size 2 intervals but\nwhich one of these intervals would we\nwant to\npop first of course we would want to pop\nthis interval first because it's farther\nto the left right we'd rather pop\nthe leftmo most interval because\nwhat if what if we pop this one first\nfrom our min heap\nbut it turns out that there's a query\nover here that actually\nyou know this is the answer for this\nquery we'd rather pop\nthis one because we're going to be going\nfrom left to right\nso we'd rather have this interval\nbelong to this query and we'd rather pop\nthis query\nrather than popping this query first so\nwe're going to need\none thing to to be our tie breaker we\nneed a tie breaker\nbetween these two intervals what's the\ntie breaker going to be\nit's going to be the right value of the\ninterval\nwe'd rather pop this one before popping\nthis one so we're popping the one with\nthe smaller right value so we're gonna\nwe're gonna have our right value as the\nsecond key\nof our min heap so we're gonna have a\npair for our key of the min heap\nthe first is going to be the size of the\ninterval the second is going to be the\nright value\nof the interval so in this case this is\nthe left value of the interval this is\nthe right value it's a value\nof 4 so the what we're adding to the min\nheap is 4 4 the first value is the size\nthe second value is the right value of\nthe interval\nso we've added this to our min heap now\nlet's go to the next interval\nit's this one right so so the left value\nof this interval is technically less\nthan or equal to this it's equal to it\nso\ntechnically we are going to be iterating\nthrough this one as well so what's the\nsize of this interval well\nfour minus two plus one so the size is\nactually\nthree that's that's pretty good for us\nright so we're going to add that to our\nmin heap the reason it's good is because\nwe found a\nsmaller interval that this value belongs\nto right that\nthat necessarily didn't have to be the\ncase right it could have been possible\nthat even though this interval started\nhere it could have just been a really\nlong interval right\nthat's the reason why we're adding for\nthis query we're having to add\nall possible intervals that this query\nbelongs to because we don't know what's\nthe shortest gonna be\nthat's why we need our min heap to\nefficiently in log\nn time to help us determine what that\nsmallest interval is going to be\nso we got the size of that interval\nwhat's the right value of the interval\ntake a look it's four so it's four in\nthis case well technically we don't need\nthat tie breaker because this is this\none is going to be popped first from our\nmin heat because it has the smaller size\nbut in case we did need that tie breaker\nwe do have it so now we've added this\ninterval to our min heap as well now\nlet's take a look at the\nnext interval hey take a look though\nthis interval\nthe left value is not less than or equal\nto our query so we're actually\nnot going to iterate through this one\njust yet we're not going to\nbe it we're not going to be adding it to\nour min heap just yet\ntake a look at our output array now we\nneed an answer\nfor this query what is the size of the\nsmallest\ninterval that it belongs to well let's\ntake a look at our min heap\nwhat's this what's the size of the\nsmallest interval\nin it well we have two choices right\nthis one or this one\nobviously this one has a size of three\nwhereas this one has a size of four so\nthis is the smallest one so we get a\nthree right three\nis the size of the smallest query that\nthis\nthat this query belongs to right so what\nwe're gonna do is to our output\nfor the first value we're gonna add a\nthree oh and by the way\nremember how we sorted these queries i\nknow i'm probably getting a little too\nin-depth but that's just kind of the\nnature of this problem there's just a\nlot of like\nbookkeeping and details that you have to\nworry about remember how we sorted our\nqueries so technically we don't actually\nknow that this\nis the first query we don't know that\nthis query\nis going to be the one that corresponds\nto the first position\nin our output right so we're going to be\nneeding to do some\nlike bookkeeping to do that and all\nthat's what i'm going to show you in the\ncode because i don't want to get this\ntoo complicated\nbasically we're going to be using a hash\nmap to make sure that we can\nmaintain the correct order of them but\nokay so for this query right we're\nbasically done with this query now right\nwe don't have to look at it but\nnotice how i didn't actually pop this\nfrom our min heap\nwhy didn't i pop it because it's\ntechnically possible that the next query\ncould also belong to this interval\nright and this interval could could be\nthe smallest\ninterval that this query belongs to so\nwe're not going to be necessarily\npopping the uh from the min heap just\nbecause we found a result\nokay so now it's time finally to get to\nthe next query this is going to take a\nwhile i can tell\nbut so now we already added these two to\nour min heap what about\nthis one right so let's take a look at\nthis left value is it less than or equal\nto this query yes it is so we're going\nto go ahead and add it to our min heap\nfirst of all what's the size of this\ninterval well take a look\n6 minus 3 plus 1 what's that going to be\nthat's going to be\n4 so let's add 4 to\nour min heap now what's the right value\ngoing to be of the min heap\nthe interval the right value is six so\nthat's going to be the second value that\nwe add\nto our min heap okay so we don't have to\nworry about this interval anymore we\nalready added it to our min heap\nnow let's go to the next and actually\nthe last\ninterval in our intervals this one the\nleft\nthe left value of this interval is not\nless than or equal to this so we're not\ngoing to be considering this interval\njust\nyet so now it's time for this query to\ndetermine\nwhat is the smallest value what's the\nsmallest length\nof the interval that it belongs to well\nonce again we're going to take a look at\nour min heap we're going to get the\ninterval\nthat's the smallest interval from here\nand we can actually do that in o of one\ntime because we're not actually popping\nfrom the min heap but we will be popping\nlater\non and i'll show you why we do need to\npop from the min heap\nlater on but for now what's the smallest\nvalue in the min heap\nit's this one again right and that does\nmake\nsense because take a look at this query\nit does belong to this interval and this\ninterval is the smallest interval that\nit belongs to\nso for the size of the smallest interval\nof this query we're going to add\n3 once again and now we are done with\nthis query time to move on to the next\none\nso remember there's only one query left\nwe already finished\nthis one so let's take a look at the\nleft value of this query it's a single\npoint query\nso the left value is equal to the right\nvalue is the left value\nless than or equal to the query yes it\nis so we're going to take this interval\nand add it to our min heap what's the\nsize of this interval well it's going to\nbe 4 minus 4\nplus 1 that's going to be 1 and what's\nthe right value of the\nof the interval well it's going to be\none or it's going to be\nfour because it's a single point\ninterval\nthat's where it's going to go so now\nwe've actually added all the intervals\nto our query so the next time we go to\nthe next query we want\nwe won't actually have to add more\nintervals to our min heap that's pretty\ngood but\nnow it's time to determine for this\nquery what's the smallest interval\nthat it belongs to well let's again take\na look at the min heap\ntake a look at the smallest value now\nthat we added\nthe size of the smallest interval is now\none so\none is going to be the size that we add\nto our\noutput so now we are done with this\nquery we only have one last query\nleft to consider so the good thing is we\nadded all the intervals to the min heap\nso we don't have to do that\nbut now notice one thing\nso now if we if we're trying to look for\nthe smallest interval that this belongs\nto if we just\nimmediately go to our min heap and pop\nand get the smallest one it's going to\nbe this one right\nit's going to be 1 4. so then we're\ngoing to end up adding a 1 over here but\nis that correct let's take a look at the\npicture\ndoes this query belong\nto the interval of size 1 it doesn't\nlike\nlook at this right if you go vertically\nthere's only one\ninterval that this query belongs to so\nnow\nwe're going to get to the the other part\nof this algorithm that i didn't show you\nyet\nevery time we're getting the smallest\ninterval that a query belongs to\nfirst we have to make sure we remove\nall invalid queries from\nor rather remove all invalid intervals\nfrom the query before we get the\nsmallest one for a query\nand take a look at this interval right\nso basically what we're going to do\nis for this min heap we're going to get\nthe size we're going to get the smallest\ninterval\nfrom that min heap right it turns out\nthat this is the smallest one as of now\nlet's take a look at that interval\nwell the right value of this interval\nand\nby the way remember we added the right\nvalue to the min heap there's a reason\nwhy we did it this is one of those\nreasons we added the right value to the\nmin heap it's four\nright four is less than five right\nthat means for example for five we we\nmight have like an interval like this\nwhere the interval starts and ends\nbefore we even\nget to this query right so of course\nwe're not going to be considering this\ninterval so now we're at the part of the\nalgorithm we're going to loop\nfor every we're going to keep getting\nthe smallest interval and\nwhile the right value of that interval\nis less than the query\nwe're going to be removing that interval\nfrom our min heap so right now we're\ngoing to be removing this interval right\nso now once again let's find the\nsmallest interval in our min heap\nit's this one right because the size is\n3. now let's take a look at the right\nvalue of that interval once again it's\n4. 4 is less than 5 so 5 does not belong\nto this interval we're going to\nhave to pop from this interval and that\nmakes sense right because this\ninterval is size 3 this is the picture\nof that interval right\nor rather this is the picture of that\ninterval and of course\nfive does not belong to it so we're\ngonna have to remove this\nonce again let's get the smallest from\nour min heap\nwell these two are both size four so\nwhich one are we gonna pop first\nremember we had that\ntie breaker we had a four and we have a\nsix which one are we gonna pop first of\ncourse the smaller one\nwhich is this one four four so let's pop\nit we see the right value\nis still less than five right so we're\ngonna be removing this from our min heap\nright so when you take a look at the\npicture at this point we've removed this\nfrom our min heap we've removed this\nfrom our min heap\nand this one the only left is this\ninterval and when we actually take a\nlook at that interval 4\n6 we see the right value of that\ninterval is 6 size is 4 but the\nthe right value is 6 and that's greater\nthan\n5 right so it's greater than or equal to\n5. so of course\nwe're going to be this inner this query\ndoes belong to that interval\nso this is going to be the answer for\nthis query this query\nthe smallest interval that it belongs to\nis of size\n4 and this this happens to be that\nspecific interval so that's what we're\ngoing to be ending up\nadding to our output for this query\nso this really isn't that easy of a\nproblem once you can write the code the\ncode isn't too bad but actually figuring\nout\nthat you can you know do all this stuff\nthere's some pretty\nneat edge cases that you have to worry\nabout you really have to get those\nconditions right\ngreater than or equal less than or equal\nright you really have to make sure\nthat your off by one errors are correct\nso that was a pretty long explanation\nbut i hope that it does provide a little\nbit of insight i would kind of\nwalk yourself through a couple more\nexamples if you need to\nand as well as study some of the code\nthat i'm about to show you right now\nso like i said we're going to be sorting\nour intervals and we're going to be\nsorting\nour queries but i'm going to be\nuh remember we do need the original\nrelative order of the query so i'm not\nactually going to be modifying the\nqueries itself i'm just going to be\nmodifying it for this loop so when i do\nthis in python it's not actually\nupdating the original array queries it's\njust that it's creating a copy of\nqueries sorting it and then we're\niterating through it\nlike this so there's that but also\nremember that we are going to be needing\na\nmin heap as i mentioned and in python a\nmin heap is just an array but we are\ngoing to have a\nmin heap class that is going to help us\ni'm also going to have a resulting\nuh data structure and an index i i\nis basically going to tell us the\nposition that we're at in our intervals\narray\nbut result is actually not going to be\nan array it's initially going to be\na hash map and then we're going to\nconvert it into an array later on\nand i is going to be initially set to\nthe beginning of intervals of course\nthat's the index\n0. and the way we're going to do this is\nfor every query we're going to map it to\nits smallest\nthe length of the smallest interval that\nit belongs to and then we're going to\nlater on convert that into an array\nmaintaining the original relative order\nof\nqueries so now we're going to start\niterating through\nthe intervals and of course we have to\nmake sure that our index is\ninbound so i'm going to make sure that i\nis less than the length of interval so\nthat's 1\nand the second thing is we're going to\nkeep adding intervals\nto our min heap while the left value of\nthat interval\nis less than or equal to the query value\nthat we're currently iterating through\nright we're only adding intervals that\nthe\nthat this query could possibly belong to\nso we can get the left value of the\nquery\nby getting first of all getting the\ninterval at position i and the left\nvalue is going to be the first value at\nindex 0\nwe're making sure that it's less than or\nequal to the query value that we're\ncurrently\nat if that's the case we're going to get\nthe left and right value from that\ninterval and of course we're going to\npush it\nonto our heap so we can do heap q dot\nheat push\nto our min heap remember we're adding a\npair of values we're getting the size of\nthe interval right minus left plus one\nand the second value is going to be r\nthe just the right value for our tie\nbreaker\nand of course since we just iterated\nthrough an interval we have to make sure\nwe increment our i\nplus one and so basically this loop is\njust going to keep adding intervals\nuntil either we run out of intervals or\nthe interval is\ntoo far to the right for this query to\neven belong to\nand then once we've done that we're\ngonna go on to our second part of the\nalgorithm\nnow is the part where we're going to\ncontinue to pop from our min heap\nwe want to remove all intervals that\nthis query\ndoesn't even belong to how do we know if\nthere's an interval that this query\ndoesn't belong to it would only be the\ncase\nif this interval was too far to the left\nhow do we know if it's too far to the\nleft\nbasically if the right value of that\ninterval\nis 2 is less than the query value\nq so first we're we're going to be doing\nthis from our min heap so we want to\nmake sure our min heap is non-empty\nand for the the smallest value of our\nmin heap we can get that at index\n0 in python so now we\nat index zero we've gotten the smallest\ninterval and we want to make sure\nthat it's right value which we can get\nat index\none and if this right value happens to\nbe\ntoo far to the left meaning it's less\nthan the query value\nthen we have to pop from our min heap so\nwe're going to do heap q\ndot heap pop from the min heap so all\nthis is doing\nis popping all the invalid intervals\nfrom our min heap popping the intervals\nthat are too far to the left\nso once this loop has been done\nexecuting either\nthen we're able to get from our min heap\nget the smallest\nuh interval which is going to be at\nindex 0 and then we want the size of\nthat interval so we can get\nindex 0 get the size of that interval\nand that's\nonly if our min heap is non-empty right\nit's possible that\nfor one of these queries that there's\nnot a single interval that it belongs to\nin which case else is where we would\nwant the negative one which is the\ndefault value that they told us\nand for this we're going to be assigning\nit to\nresult of that query so in our hashmap\nresult\nof that query we're you know getting\nthis i know this is kind of a lot\neven though that this is not a lot of\ncode these are a lot of details we're\nhaving to worry about it's really easy\nto go wrong in this problem it's not an\neasy problem\nbut that is actually it right remember\nif you remember the visual explanation\nthese are the main things we had to\nworry about we're going through every\nquery adding all possible intervals then\npopping the invalid\nintervals and then getting the the\nsmallest interval that's left\nin our min heap once that's done and\nonce we've done that for every single\nquery\nwe are done and so then we can return\nour\nresult but happens to be that our result\nis actually a hash map because we\nremember we have to\nwe have to return the result such that\nit matches the original order of the\nqueries\nso how can we do that well for every\nsingle query\nin our queries array what are we going\nto do for every single query we just\nwant the length the smallest length that\nthis query the length of the smallest\ninterval that the query belongs to we\ncan get that with result\nof q for every query in our queries\nand with python at least you can do list\ncomprehension\nso we can create a list like this on the\nfly but\nyou know this isn't really the difficult\npart of this algorithm you could do this\nwith a few extra lines of code in other\nlanguages if you needed to\nokay but that is the entire code it\nwon't be super different if you're\ndoing like java or something it's\nprobably just going to be a different\nmin heap library as well as probably\nthis line is going to be different but\nfor the most part\nyou're going to be needing a hash map\nprobably and you're going to be needing\na min heap you're going to need to sort\nthese\ninput arrays and remember the time\ncomplexity is just going to be big o\nand log n where n is the length of the\nintervals\nand q log q where q is the length of\nqueries because the main time complexity\nis coming from the fact that we're\nsorting both of the inputs\nbut other than that i hope that this was\nhelpful for you this is not an easy\nproblem\ni hope that you did gain some\nunderstanding if this was helpful please\nlike and subscribe it supports the\nchannel\na lot and i'll hopefully see you pretty\n"
    },
    {
        "Name": "Rotate Image",
        "NcLink": "rotate-matrix/",
        "Pattern": "Math & Geometry",
        "Description": "Given a square `n x n` matrix of integers `matrix`, rotate it by 90 degrees *clockwise*.\n\nYou must rotate the matrix *in-place*. Do not allocate another 2D matrix and do the rotation.\n\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e13e93ed-4fdb-49e4-f971-de1e30356600/public)\n\n```java\nInput: matrix = [\n  [1,2],\n  [3,4]\n]\n\nOutput: [\n  [3,1],\n  [4,2]\n]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/37d34844-e6a0-4809-0895-f15e782efe00/public)\n\n```java\nInput: matrix = [\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n]\n\nOutput: [\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n```\n\n**Constraints:**\n* `n == matrix.length == matrix[i].length`\n* `1 <= n <= 20`\n* `-1000 <= matrix[i][j] <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "fMSJSS7eO1w",
        "PythonSolution": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        l, r = 0, len(matrix) - 1\n        while l < r:\n            for i in range(r - l):\n                top, bottom = l, r\n\n                # save the topleft\n                topLeft = matrix[top][l + i]\n\n                # move bottom left into top left\n                matrix[top][l + i] = matrix[bottom - i][l]\n\n                # move bottom right into bottom left\n                matrix[bottom - i][l] = matrix[bottom][r - i]\n\n                # move top right into bottom right\n                matrix[bottom][r - i] = matrix[top + i][r]\n\n                # move top left into top right\n                matrix[top + i][r] = topLeft\n            r -= 1\n            l += 1\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today\nwe're given an n by n matrix so this\ntime it's a square matrix for sure\nrepresenting some image and we want to\nrotate\nthat image by 90 degrees clockwise\nand we are required to do this in place\nso we\ncannot allocate more memory we can't\njust make a copy of the matrix\nand rotate it like that so the challenge\nhere is definitely doing it in place you\ncan see that they had\na original matrix like this what they\ndid is they took\nthe one and put it over here\nso 90 degrees basically what they did is\ntook this entire first\nrow and moved it into the rightmost\ncolumn right and so they did that by\nmoving this\nover here moving this 2 over\nhere moving the 3 over here\nand so the problem is when you're moving\nthis one over here you have to\nsave the three temporarily right so you\njust save the three\nor once you move this one over here you\ncan take the three\nsave it and move it over here and we\nknow that\nthis entire right column is going to\nactually be\nput in the bottom row so what is\nactually going on\nis this 9 is actually being moved\nover here right that's where it ended up\nin the result\nand then this seven is being rotated\nover here so that's where the seven ends\nup\nthe one ends up over here the three ends\nup over here\nthe nine ended up over here so these\nfour let's say have been rotated so\nfar so now we don't have to touch them\nbut you can see\nthere's a little bit left in the outer\nlayer so let's just worry about the\nouter layer so far we don't have to\nworry about the 5 but\nin the result we know the 5 actually\ndoesn't move you know you rotate it\nbut what about this four now it's\nbasically the same\nthing that we did over here right we are\nrotating this\nso basically we can think of it as being\nin the top left right\nlet's the original square we were\nrotating was like this\nnow the square we're rotating is like\nthis it's still technically a square\nyou know if you turn your head a little\nbit but this is what we're doing we're\nrotating this\nso this 4 is of course going to be moved\nover here to this two and then and\nbefore we get rid of the two we want to\nsave it\nand move it over here to the six\nand so in the original we have a two\nover here but we know\nthat 2 is going to be rotated right\nbecause this is the rotation we're doing\nand before we get rid of the 6 we want\nto save it\nin a temporary variable and move it over\nhere replacing the 8 but we don't want\nto lose the 8 yet because it needs to be\nrotated as well\nit's going to be rotated over here to\nthis 4\nand since we rotated the 2 we know\nthere's going to be an empty spot over\nhere\nfor the 4 to\nbe placed in and that's what you have\nover here the four\nthe two got moved over here the six got\nmoved over here\nand the eight got moved over here so\nthis is\nstill a rotation and lastly we just have\na one by one\nwe know that you know it can't really\nrotating it will just\nbe the exact same so let me show you the\ngeneral algorithm to solve this problem\nwe're going to do this in\nn square time meaning we only have to\nlook at each cell\nin the matrix once remember the\ndimensions are n by\nn and we don't need any extra memory so\nthe memory complexity is going to be\nconstant we're doing this\nin place in our given matrix so i like\nto\nset some boundaries so we know that this\nis our left boundary\nand this is our right boundary\ninitially because we're going to rotate\nthe outermost\nlayer first right the outermost square\nand then we're going to move inward\nright we're going to do the inside\nof the matrix and the top boundary i'm\ngoing to place\nover here because that's the top\nremember\nthe origin over here is zero by zero\nthis position\nis three to three it goes like this\nand as you go down it increases and the\nbottom boundary\nis going to be down here so immediately\nwe're gonna start the rotation now how\nis the rotation gonna go well let's\nstart at the top left because it's the\neasiest right\nwe know that this is the general\nrotation\nthat's gonna take place right because\nwe're going clockwise\nand then we're going to do that right\nand we know we're going to keep\ndoing that with every element in the top\nrow so we did the first element in the\ntop row then we're going to rotate\nthe second element in the top row and\nhow is that going to look well\nit's going to be pretty similar so since\nthis was the second position\nin the top row we're going to move it to\nthe second position\nin the last column right so in this\ncolumn\nwe're going to rotate this one to this\nposition\nso the second to last position in the\nbottom row\nthe main thing to notice though is that\nthis is offset by one\nthis is offset by one from the top this\nis offset by one to the\nfrom the right and so the position that\nit's moved\nto is also going to be offset by one\nfrom the bottom which is where the last\nrotation took place\nand then this is going to be moved over\nhere\nand so as you can see we have one last\nrotation to\nmake right with these four\nelements and they actually do form a\nsquare\nif you tilt your head enough this is a\nsquare rotation a matrix rotation\nbut notice how since we already rotated\nthis one\nwe're actually not doing four rotations\nfor the outermost layer we're doing\nfour minus one rotations we're doing\nthree rotations\nright so even though the outermost layer\nwas n by n we actually\ndid n minus 1 rotations right so we did\nthree rotations and let's say after we\ncomplete\nthe outermost layer right let's say\nwe've completely rotated that\nyou know we had to rotate this part this\npart and this part so once we do that\nthen we know that we actually have an\ninner matrix\nthat we have to do so we did the\noutermost layer but now we have to do\nthe\ninside how am i going to handle that\nwell it can actually just be\ntreated as a sub problem because we know\nno matter what it's going to be\na square matrix so all we really have to\ndo is take our pointers and then\nshift all of them by one so our left\npointer will be shifted\nhere our right pointer will be shifted\nhere our top pointer\nwill be shifted here and our bottom\npointer will be shifted\nhere and so now the the last rotation\nseems pretty obvious right it's so it's\ngoing to be one rotation\nit's going to include four elements and\nthen we will have our result\nnow one last thing i wanna show you and\nthen after that rotation has taken place\nwe know we can update our pointers\none more time but at this point what\nwe'll notice is our left\npointer is over here and our right\npointer is here we know that left should\nalways be less than right and\nsince these pointers have crossed each\nother we know\nthat we can stop the algorithm right we\ndon't really have a matrix left\nto rotate one last thing i want to show\nyou about the rotation is\nwe know that the five the top left is\ngoing to be\nput in this position right the 11 so\nwe're going to cross that out\nso we're going to really replace this\nwith a\n5 but then what happens to the original\n11 that was placed here well what we can\nsay is oh let's move the 11\nto a temporary variable and now let's\nput the 11\nover here so we're putting an 11 over\nhere now but what happened to the 16\nthat was over here\nwell we have to put that in a temporary\nvariable a 16\nand then move that 16 over here so let's\nreplace this with a 16\nbut what happened with the 15 that was\nover here well\nwe move that to a temporary variable and\nnow that temporary variable\n15 is going to be placed over here\nso the 15 is here and we don't have to\nmove the 5 to a temporary variable\nbecause look we already put it over here\nso we're needing a lot\nof temporary variables i can show you a\nslight\nimprovement to this which isn't required\nor anything but i think it makes\nwriting the code easier so we know that\nthis 5 is going to be rotated\nbut let's do this let's do the rotation\nin\nreverse order so instead of removing the\n5 over here\nfirst i'm gonna take the 15 which we\nknow is going to be\nplaced over here and i'm going to put\nthe 15 over here\nand i'm going to move the 5 to a\ntemporary variable\nokay so are we going to move the five\nover here now nope that's not what we're\ngoing to do we're going to do this in\nreverse order\nso since the 15 has already been moved\nlet's take\nthis 16 and move it over here\nso now let's replace this 15 with a 16.\nand now we know that we need to make a\nrotation from\n11 to here so let's put an 11\nover here and last but not least we know\nthat the original five had to be put\nover here\nand we stored that five in a temporary\nvariable so now let's move\nthat five over here and so we did the\nexact same rotation\nbut do you notice how we did it in\nreverse order right we went\ncounterclockwise and the thing that that\nthe reason that was helpful is we only\nneeded one temporary variable\nwhich will make the code a little bit\neasier for us but it's not actually\nrequired\nthe overall complexity is still the same\nthe memory and the time complexity is\nstill the same\nso now let's get into the code so the\nfirst thing i'm going to do is set our\nleft and right boundaries so\nleft is zero right is going to be the\nlength number of\ncolumns minus one but we know that the\nnumber of columns is the same as the\nnumber of rows so we actually don't need\nthis\nand i'm gonna run our rotation while\nleft is less than right and i'm going to\ngo\nfrom index so let's say we're in our top\nrow i'm going to iterate\nthrough the entire row except\nlast element so how many rotations is\nthat going to be that's going to be from\nleft to right minus one or in\nother words we can say from in range\nright minus left so this is the number\nthat we're gonna do so if\nleft was zero right was three we would\ndo three minus zero which is going to be\nthree iterations even though we have\nfour\nuh values in our first row so i also\nwanna have some top and bottom pointers\nand these are actually gonna be the same\nas left and right so top\nis gonna be the same as left and bottom\nis going to be the same as right because\nwe do have a square matrix\nit's not just a generic rectangle it's\ndefinitely a square\nand the first thing i want to do is save\nthe top\nleft value right because the way i\nshowed you the rotation we only need to\nsave\none variable so it's the top left i'm\ngoing to\nget that from our matrix so matrix of\ntop left and just like in the drawing\nwhat i'm going to do is move\nthe bottom left into the top left\nso in the position of the top left top\nleft i'm going to move the bottom left\ninto that spot the next thing i'm going\nto do just like in our drawing i'm going\nto move the bottom right\ninto the bottom left\nwe are doing this in reverse order\nbasically even though the rotation\nis clockwise the direction we're going\nis counterclockwise\nso the bottom right is going to be moved\ninto the bottom left we also want to\nmove\nthe top right into the bottom\nright so in the bottom right position\nwe're going to replace it with the top\nright and the last thing we have to do\nis move the top left into\nthe top right but remember we overwrote\nthe top left position but\ngood thing for us we saved it in a\ntemporary variable\nin the top right we're gonna replace it\nwith\nthe top left there's just one thing we\nforgot to use\nso we forgot to use our i variable\nso you remember how this was the first\nrotation that we make\nright and then we move from our top left\nposition we move\none spot to the right from our top\nright position we move one spot down\nfrom our bottom right position we move\none spot to the\nleft and from our bottom left position\nwe move\none spot up and then we do a rotation\nfrom here right and then we're not done\nyet from there on we move another\nposition to the right\nanother position down another position\nto the left\nand another position up and then we do a\nrotation\nfrom these values so\nwe can actually handle this pretty\neasily in our code\nwe can use this i variable to handle\nthat\nfor us so we can add the i\nvalue to the left index which will shift\nus one\nposition to the right and this is also\nthe top left position so we're going to\nadd\ni to this as well this is the\nbottom left position and we know that\nwe can subtract i from the bottom which\nwill shift us\nup by one and this is that same value so\nwe're gonna subtract\nan i from that as well this is the\nbottom right\nand to shift that to the left we can\nsubtract\ni from the right index and this is\nactually this\nthis is also the bottom right so\nwe're going to subtract i from that as\nwell\nthis is the top right and as we uh\ncontinue doing\nrotations we're going to add we're going\nto move down\nin this column so we're going to add i\nto the top\nindex and this is the same top right so\nwe're going to add an\ni to this index as well so basically as\ni is incremented it's going to be\nhandling more and more rotations it's\ngoing to shift\nthese cells that we want to rotate\naccordingly\nand so this will basically perform\na layer of rotation so after we've\ncompleted an entire\nlayer what are we going to do we\nactually need to do one last computation\nwe need to update our pointers right\nbecause now we're going to do the sub\nmatrix\nso our right pointer can be decremented\nby one our left pointer can be\nincremented by one and that is the\nentire code so\nit's going to complete every single\nlayer once every layer has been\ncompleted\nour loop will stop and we are not\nrequired to return anything\nlike it just says over here we're doing\nthis in place\ninside of our matrix so we don't return\nanything this code\nis good to go and as you can see it's\npretty efficient\nabout as efficient as you can get for\nthis problem and i hope this was helpful\ni hope it showed you a relatively easy\nway to write this code but you also\nunderstand what's going on if this was\nhelpful please like and subscribe it\nsupports the channel a lot and i'll\nhopefully\n"
    },
    {
        "Name": "Spiral Matrix",
        "NcLink": "spiral-matrix/",
        "Pattern": "Math & Geometry",
        "Description": "Given an `m x n` matrix of integers `matrix`, return a list of all elements within the matrix in *spiral order*.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fe678b92-8606-4e07-ce70-08ec3479aa00/public)\n\n```java\nInput: matrix = [[1,2],[3,4]]\n\nOutput: [1,2,4,3]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/8a460616-db14-4ccf-068b-00aa6d398400/public)\n\n```java\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput: [1,2,3,6,9,8,7,4,5]\n```\n\n**Example 3:**\n\n```java\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n```\n\n**Constraints:**\n* `1 <= matrix.length, matrix[i].length <= 10`\n* `-100 <= matrix[i][j] <= 100`\n",
        "Difficulty": "Medium",
        "Video": "BJnMZNwUk1M",
        "PythonSolution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        res = []\n        left, right = 0, len(matrix[0])\n        top, bottom = 0, len(matrix)\n\n        while left < right and top < bottom:\n            for i in range(left, right):\n                res.append(matrix[top][i])\n            top += 1\n            for i in range(top, bottom):\n                res.append(matrix[i][right - 1])\n            right -= 1\n            if not (left < right and top < bottom):\n                break\n            for i in range(right - 1, left - 1, -1):\n                res.append(matrix[bottom - 1][i])\n            bottom -= 1\n            for i in range(bottom - 1, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's look at\nspiral matrix we are given an m by\nn matrix and all we need to do is return\nall of the elements in spiral order\nso the order that we're given the\nelements in is one two three\nfour five six seven eight nine right if\nyou go from left to right\nbut we actually wanna return these\nelements\nin spiral order so we are gonna start at\nthe top\nleft and we're going to go 1 we're going\nto go right\n2 go right again 3 now we can't go\nright anymore so now we're going to go\ndown because that is\nspiral order so we're going to do 6 go\ndown one more time\ndo nine now go left because we can't go\ndown anymore\nwe're gonna get eight go left again\nwe're gonna get seven\nnow we can't go left anymore so we go up\nto four and if we try to go up now we\nactually see well we already visited\nthat right the one's been visited\nso now we actually go right we have the\nfive and the five\nis the last element if we try to go\nright we cannot go right anymore\nso how can we write an efficient\nalgorithm to do that right to worry\nabout\nokay we're going in this direction and\nthen eventually we have to change\ndirections and all that stuff\nwell in my opinion the easiest way is\nalso the most efficient way so one thing\nto notice is\nwe let's say we start at the top left we\ngo right right right we go here\nso we cross out all these elements then\nwe go down down down\nwe get here then we go left we go here\nso we cross out these elements\nand then we go up right so we went all\nfour directions we went\nright we went down we went left\nand then we went up until we couldn't\nanymore but we still have some elements\nleft but do you see what we kind of did\nhere\nwe took the outermost layer\nand shrinked it right so now we have a\nsub\nrectangle or sub matrix here that now\nwe're going to do the exact same\nalgorithm on but you notice that our\nboundary\nour left boundary was over here and our\nright boundary was initially over here\nbut now we shrinked it right this is our\nnew sub matrix right originally we had\nthis\nso our left and our new left and right\nboundaries\nare here right so we shrunk it by one we\nhad to move\nour left and right boundaries inward\nsimilarly we had a\ntop boundary of here and we had a bottom\nboundary\nover here but we had to shrink that as\nwell right we had to move our top\nboundary down one and we had to move\nour bottom boundary up by one so now our\ntop boundary is over here and our bottom\nboundary is over here\nand we still have some elements to go in\nspiral order so again what are we going\nto do with this\nsub matrix well we're going to start at\nthe top\nleft which is over here and we're going\nto go in spiral order so now we're going\nto go\nright so we get to seven but notice now\nnotice now how we pretty much have gone\nthrough all the elements right\nand so since we done these elements what\nwe can now say is our left and right\nboundaries were moved\nonce more right so left and right are\nnow at the same position\nor they've intersected or overlapped or\nwhatever and so what that basically\nmeans is\nwe don't really have a rectangle anymore\nright our\nboundaries are not in a position so\ntherefore we don't have to continue\ngoing anymore right and you can tell by\nthe picture well we already visited\nevery single element\nwe don't have to continue the spiral\nwe're just going to repeat\nold elements anyway so that's the main\nidea but i'm just going to show you\ni'm just going to actually walk through\nthe algorithm and show you a couple\nof things that i'm going to do slightly\ndifferently so i am going to initialize\nthe left boundary over here because this\nis our zero\ncolumn right and this is our third\ncolumn but what i'm actually gonna do is\nput the\nright boundary over here just mainly\nbecause it's gonna make the code a\nlittle bit easier for us\nand so this is the zeroth row and this\nis the second row right\nso what i'm gonna do is put our top\nboundary over here\nand i'm gonna put our bottom boundary\nnot at index two but\none more so i'm gonna put our bottom\nboundary over here just because it makes\nthe code a little bit easier\nand so as you can tell basically what\nwe're doing is we have\nfour pointers and these four pointers\nare going to make co\nmake coding this solution the spiral\nmatrix solution a lot easier for us\nwe are going to start over here because\nit's the\nposition that our top left is pointing\nat so we're always going to start at the\ntop\nleft position and so we are going to\nhave an\noutput we know the output is going to be\na list or an array so we're going to add\n1 to our output and then we are going to\ngo\nright so so whenever we start at the top\nleft we're going to go right because\nwe're going to do the first\nrow so now we're going to be at 2 we're\ngoing to add\n2 to our output and we're just going to\nkeep repeating this until we\nreach our right boundary our right\nboundary is going to tell us when we can\nstop\nnow we get to 3 we add 3 to our output\nnow we get to 4 we can add 4 to our\noutput\nand now we know we cannot go any further\nwe've\nbasically reached our right boundary so\nnow what we're going to do\nis we are going to go down but before we\ngo\ndown since we just did this entire row\nwe added it to the output we don't\nreally need\nthis top boundary anymore right but what\ncan we do with it\nwe can basically shift it down because\nour\nnew top boundary of our rectangle right\nnow look at our current rectangle\nis this so our top boundary belongs in\nthis spot so now we are going to go\ndown we're going to reach this 8 we're\ngoing to add that 8 to our output\nand we're going to go down one more time\nand we're going to keep going down\nuntil we reach our bottom boundary right\nthat's pretty\nobvious from looking at the picture so\nnow we reach\nour bottom boundary and the last value\nis 12.\nso now obviously we're gonna start going\nleft\nright but do you notice any differences\nabout\nour matrix now well clearly we just did\nthis\nentire row what does that tell us well\nthat tells us we can\nupdate our right boundary right because\nif you look at the new rectangle\nwe've we've moved our top boundary over\nhere but we can also take our right\nboundary\nand and move our right boundary in this\nposition right\nof course the left and bottom boundaries\ncan still be the same because look at\nour rectangle we need those boundaries\nstill\nbut now we are going to go left we reach\nan 11 we can add that to our output\nwe go left again keep going left until\nwe reach our\nleft boundary right until we reach the\nelement at our left boundary but in this\ncase it's inclusive when we were going\nright we were going to stop before we\ngot to the right boundary\nand this is basically just to make the\ncode easier even though it's\na little bit inconsistent so now we get\na 10\nwe add that 10 to our output we go left\none more time\nwe get a 9 and we add that to our output\nbut now you can see\nthat this left boundary is where we need\nto stop\nbut as you can see we just finished the\nentire bottom row\nwhat does that tell us well our bottom\nboundary can be shifted up by one\nover here because our new rectangle\nis like this right our right boundary\ntells us about this our bottom boundary\ntells us about\nthis our top boundary tells us about\nthis\nand our left boundary tells us about\nthis so this is the resulting rectangle\none by three\nso now we're gonna put the bottom\nboundary here\nand now we're gonna start going up and\nwe're not just gonna keep going up\nforever\nwe're gonna stop once we reach our top\nboundary which is pretty easy\nfor us because we only have one element\nand now we're at the top boundary\nso we get a five and we add that to our\noutput\nnow you can see that this this problem\nhas been reduced we took our matrix and\nchopped off each side of it we chopped\noff the top\nthe bottom the right column and the left\ncolumn\nbut we can still continue our our\nalgorithm as it\nis the only thing that we have to update\nnow is take\nour left boundary because we just did\nthe entire left column now\nand shift it to the right by one\nso now again we're going to start at the\ntop\nleft because the top is pointing here\nthe left is also pointing here\nso we're going to start here and we're\ngoing to go right\nbut we have to add 6 to our output so we\nadd a 6 to the output\nwe keep going right until we reach this\nboundary right which\nwe've reached once we've gotten to the\nseven so we add the seven to the output\nand now we stop because we reached the\nright boundary\nand since we've just finished this top\nrow what are we gonna do\nwe're gonna update the top pointer right\nwe're going to cross it out and we're\ngoing to shift it\ndown over here right so now top is over\nhere\nas well as bottom they're both pointing\nat the same\nrow and basically that's the condition\nonce pointers reach like in this case\ntop and bottom reach but it could have\nbeen possible that\nleft and right reach the same position\nif\neither of those things happen then we\ncan stop our algorithm because we know\nwe've\ndone every single element that we needed\nto so now let's get into the code and by\nthe way the time\ncomplexity of this is big o m by n which\nis the dimensions of the matrix\nthe memory complexity is big o of 1\nbecause we are not saving any extra\nmemory we're just\nrunning the code and it's big of one if\nyou do not count the\noutput as extra memory so we have our\nresult variable\ni'm gonna have the four pointers that we\nmentioned left\nand right so left is going to be\ninitially at zero right is going to be\nthe length of the matrix right is\nbasically going to be the\nnumber of columns plus one which is\nexactly what the length is going to give\nus we also have a\ntop and bottom variable so top is gonna\nbe zero we know we start at\ntop left is zero zero the bottom is\ngoing to be\nthe length of the matrix which is going\nto tell us the number of\nrows and basically all i'm gonna do is\njust keep looping until we know that\neither of the pointers cross so we know\nthat left has to be\nless than right we don't want them to\nmeet each other\nand top has to be less than the bottom\nso the first thing i'm going to do is go\nleft to right\nand get every single get every value\nin the top row so every i in the top row\nso i'm just going to iterate for i in\nrange\nleft to right and this is basically why\ni'm setting the right\nuh out of bounds because in python it's\ngoing to go from left which is initially\ngoing to be 0 maybe right is let's say\nfour\nit's gonna it's basically gonna go from\nzero to three in this case that's what\npython does\nthe four is non-inclusive so this right\nvalue is non-inclusive\nand so for each of these values we know\nall we have to do\nis append it to our result so\nhow do we get the value well we know\nwe're in the top row\nso for the row we just put top for the\ncolumn we can put\ni and since we just completed our top\nrow before we do anything else let's\nupdate our top variable so if we\nincrement it by one\nbasically what we're doing is shifting\ntop down by one\nnext i want to get every i in\nthe right column right the rightmost\ncolumn\nhow can we do that well i'm going to\niterate\ni in range from top\nto bottom right it's as easy as that and\nwe are allowed to do this because we\njust\nincremented our top by one so we're not\ngoing to have any repeated elements\nso now i'm just going to take every\nsingle one of these elements\nand add it to our result so the row that\nwe're in\nis of course i because we're going from\ntop to bottom the column that we're in\nis right but we're going to subtract by\n1 because we know that our right is\nactually\nout of bounds and so after we do this we\nknow we just completed the rightmost\ncolumn so what can we do we can take our\nright variable and decrement it by one\nbecause then we're shifting it to the\nleft\nnow this is the part that you're kind of\ngonna have to trust me on\nso so basically if the pointers have\ncrossed so if this condition is no\nlonger true\nwhat we have to do is break out of our\nloop\nand if you don't understand exactly why\nwe're doing this i would encourage you\nto run\nthis entire code or at least do it by\nhand on a couple examples so imagine our\nmatrix was\nthis if we had like a single row matrix\nsee what happens when you do that or\nimagine if we had a\ncolumn matrix like this see what happens\nwhen you run this code\nso we did the top row and we did the\nrightmost column so now we have to do\nthe bottom row\nand we know we have to do this from\nright to left so that's going to be a\nlittle annoying so we're going to go\nfor i in range so we're going to start\nat our right boundary\nminus 1 because we know our right is\nactually a little bit farther to the\nright\nand we're going to do this from right to\nleft\nbut left we're also going to take -1\nbecause that's how python works\nthe left is non-inclusive so if we\nactually want to go\nall the way to left we have to subtract\nit by one and\nto do this in reverse order we just have\nto add a negative one\nso basically what we're doing is going\nfrom right to left in reverse order so\nbackwards so now we're going to take\neach of these and append it to our\nresult\nso we are in the bottom row so for the\nrow we're going to take\nbottom minus 1 because we know even the\nbottom\npointer is actually out of bounds by\njust one value\nright so this is just an off by one\nerror and\nthe column is going to be i that's what\nwe're doing when we're going from\nright to left and so after we've done\nthis we've just done the bottom row so\nwe're going to update the bottom\npointer how are we going to update it in\nthis case we subtract it by\none if we want to shift it upwards so\nlast but not least we want to get every\ni\nin the leftmost column right so\nwe can and we want to do that from\nbottom to top\nbecause we are going in spiral order so\nfor i\nin range we're gonna start at the bottom\nbut we are have we have to subtract it\nby one to make sure we don't get\nthe off by one error and we're gonna go\nall the way to top\nbut we're again going to subtract by one\nbasically we're doing the same thing\nthat we just did\nup here so we're going from bottom to\ntop in reverse order\nso we add a negative one and now for\neach of these elements\nwe're gonna add it to our result\nso matrix the row is going to be i\nthat's what we're doing when we're\niterating from bottom to top\nthe column is going to be the leftmost\ncolumn and after we've completed this we\nare allowed to increment left by one\nbecause we just completed the entire\nleft column so we're shifting our left\npointer\nto the right by one so this is the code\nwith these comments it makes it seem a\nlittle longer than it actually is but\nthis code is not too long the only thing\nwe have to do now is\nreturn the result that we just\ncomputed the array now we can run this\ncode\nand you can see the code is pretty\nefficient and\none thing i'll mention is that see we're\nkind of repeating\nthe same thing like four times over here\nin total that is only like 12 lines of\ncode but if you wanted you could put it\nin a helper function\nbut i think in this case a helper\nfunction just makes it more confusing i\nprefer to actually\nwrite this out because it's pretty\nobvious when you write it out and add a\ncomment\nwhat exactly we're doing but other than\nthat i hope this was helpful\ni hope it showed you that this problem\ncan be written in pretty simple code\nand if you enjoyed please like and\nsubscribe it supports the channel a lot\n"
    },
    {
        "Name": "Set Matrix Zeroes",
        "NcLink": "set-zeroes-in-matrix/",
        "Pattern": "Math & Geometry",
        "Description": "Given an `m x n` matrix of integers `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must update the matrix *in-place*.\n\n**Follow up:** Could you solve it using `O(1)` space?\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/49ffd14e-b32b-4ed8-e0d0-9378e5eb9b00/public)\n\n```java\nInput: matrix = [\n  [0,1],\n  [1,1]\n]\n\nOutput: [\n  [0,0],\n  [0,1]\n]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/04d99cc8-e453-464d-888c-58d0a95daf00/public)\n\n```java\nInput: matrix = [\n  [1,2,3],\n  [4,0,5],\n  [6,7,8]\n]\n\nOutput: [\n  [1,0,3],\n  [0,0,0],\n  [6,0,8]\n]\n```\n\n**Constraints:**\n* `1 <= matrix.length, matrix[0].length <= 100`\n* `-2^31 <= matrix[i][j] <= (2^31) - 1`\n",
        "Difficulty": "Medium",
        "Video": "T41rL0L3Pnw",
        "PythonSolution": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        rowZero = False\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if matrix[r][c] == 0:\n                    matrix[0][c] = 0\n                    if r > 0:\n                        matrix[r][0] = 0\n                    else:\n                        rowZero = True\n\n        for r in range(1, ROWS):\n            for c in range(1, COLS):\n                if matrix[0][c] == 0 or matrix[r][0] == 0:\n                    matrix[r][c] = 0\n\n        if matrix[0][0] == 0:\n            for r in range(ROWS):\n                matrix[r][0] = 0\n\n        if rowZero:\n            for c in range(COLS):\n                matrix[0][c] = 0\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today\nso today let's look at set matrix zeros\nwe are given an m by n matrix\nand we want to go through every element\nif we see that an element is zero we're\ngonna set the entire row\nand the entire column to zero so for\nexample we're given\na grid there's only one zero so what are\nwe gonna do we're gonna set everything\nin the column to zero we're gonna set\neverything\nin the row to zero and then we see\nthe output is exactly that right we got\nsome\nzeros and then this is going to be our\noutput\nand as you can see there's a bunch of\nways to solve this problem\nwith better and better complexities so\ni'm gonna\nshow you the like bad solutions and then\nshow you how you can use that to get the\nbest solution\nbecause it's actually pretty intuitive\nso first\nlet's say that this is our input array\nand\nwe declare a copy of that array\na copy of that matrix right so\nthen we can what we can do is go through\nevery position right so\nthe first one is a one so we don't have\nto do anything then\nwe get a zero what does that tell us\nthat tells us\nthat the entire column is going to be\nset to zero\nand the row is going to be set to zero\nso why can't we just do that in place\nlike why can't i just put a zero here\nand then a zero here and now a zero here\nright\nbecause because there there's actually a\ngood reason because\nso far we've checked off these spots we\nchecked off\nthis spot now we're over here right but\nwe replaced that\none with a zero now so now we're going\nto end up\nmaking this a zero and this is zero but\nthat's not\nreally what we want to do and that's the\nreason why we start off with a copy\nso when we make changes we're going to\nmake changes to\nour copy and when we read the values\nwe're going to read from our input so\nremember\nwe did see a zero over here so\nin the copy we are gonna update\nthe entire row so this is gonna be a\nzero\nthis is gonna be a zero so every value\nin the row but we also have to do the\ncolumn\nwe see this is already a zero but this\nis gonna be changed so now we made\nchanges to the copy so this is a zero\nbut we see that this is still\na one right because because now when we\ngo to the next position which is this we\nsee it's a one\nso we don't actually have to modify\nthis column and this road\nright because we haven't even read this\nvalue yet\nand now we're just gonna continue so\nthis is the next position\nin our matrix it's a one so we don't\nhave to do anything\nand this is the next one it's a zero so\nit's time to\nset the entire column to zero and set\nthe entire\nrow to zero so in our copy we\nsee that we actually already did this\ncolumn so\nthis is kind of an example of the\nrepeated work that we're having to do\nright it kind of shows you that maybe\nhaving a copy\nis not the best solution but we still\nneed to update the row so we're gonna\nchange this to a zero\nand we're gonna change this to a zero so\nnext we go to\nthis position it's a one we don't have\nto do anything\nand then we go to the next position this\nis a zero so it's time to make some\nchanges\nwe're gonna set the entire column to\nzero and we're gonna set the entire\nrow to zero in our copy so we see that\nthis is already a zero so this is the\nonly other value\nin the output that needs to be changed\nto zero\nand we see that the column has already\nbeen set to zero so clearly having a\ncopy\nof the input array takes m by n memory\nand it's also not the most time\nefficient algorithm\neither so how can we do better we're\nnoticing for\nevery single cell in our input we're\npotentially having to update an\nentire row and an entire column\ncan we prevent this repeated work yes\ni'm going to show you how so\nwe see that we actually have a fixed\namount of\nrows right let's call that m we have a\nfixed amount\nof columns n so worst case scenario\nall we're gonna have to do is make sure\nthat every\nrow is set to zero and then every column\nis set to zero so as we iterate\nthrough every single value in our input\nlet's not update the copy we\nactually don't need the copy\nwe need less memory we can have one\narray for the number\nof columns and one array for the number\nof\nrows and then we can mark these whether\nwe want to\nfill in zeros or not and then at the\nend we can actually fill in the zeros\nin our input array without even needing\na copy\nso let me show you this algorithm so we\nhave a one\nso we don't have to do anything so this\nempty indicates that we don't have to uh\nzero the row or the column\nnext we see a zero so what are we going\nto do well we're gonna\nsay okay in this column we're gonna fill\nit\nwe're gonna fill it with zero so this is\nsome work that we have to do\nin this row we are going to fill it with\nzeros but we're not gonna do it yet\nbecause we don't want to\noverwrite this value that we haven't\neven visited yet and we definitely don't\nwant to overwrite this value\nyet which we haven't visited yet next we\ngo to this position it's a 1 so we don't\nhave to do anything\nthis is also a one this is a zero so\ntechnically we have to mark this spot\nbut we already did that we already know\nthis column is going to be set to zero\nbut we want to say that this row needs\nto be set to zero\nwe're not going to fill the zeros yet\nbut we're definitely gonna mark it\nso this is a one we don't do anything\nthis is a zero\nwe know that this column has to be set\nto zero\nand this row has to be set\nto zero now technically we see that\nevery row is gonna be set to zero so\nso therefore like the entire matrix is\njust gonna be zero but\nwe're still gonna continue our algorithm\nso this is a one we don't have to do\nanything\nthis is a one we don't have to do\nanything so now what we're gonna do\nis we're gonna look at this memory and\nit's gonna tell us which columns need to\nbe set to zero so we see the first\ncolumn does need to be set to zero\nwe're gonna do that the second column\nneeds to be set to zero\nwe're gonna do that the third column\ndoes not need to be set to zero\nnext we look at the rows the first row\nneeds to be set to zero we mostly\nalready did that but\ndon't forget about this one the second\nrow is going to be set to zero\nthe third row is going to be set to zero\nand obviously the entire matrix is now\nzero but\nthe advantage of this is the memory we\nused\nwe didn't need to create an entire copy\nwe just needed\ntwo arrays so the memory complexity is\nactually\nbig o m plus n where these are the\ndimensions\nthe time complexity is m\nby n because we're really just iterating\nover the entire matrix\nat most three times one where we iterate\nthrough every position\none where we fill in the columns and\nanother time where we fill in the rows\nand i didn't tell you the time\ncomplexity of this one but it is\nactually greater than the time\ncomplexity\nof this so this is actually a better\ntime\nsolution and a better memory solution\nnow my only\nquestion is can we get a o of\none memory solution we know the time\nthe best time complexity we can do is m\nby n because we do\nhave to iterate through every single\nposition in\nthe matrix but we can save some space\nis it possible yes i'm going to show you\nhow\nis there a way where we can take this\narray\nand put it into the matrix so we're we\ncan do this in\nplace is that possible if i put that\nover here is it possible for\nus to take this uh array\nand put it in to\nour matrix the answer is yes we can take\nthese two arrays that we have and put\nthem\nin our matrix so we do this in place\nwith\no of one memory but you see just one\nproblem\nright just one little problem notice\nhow this position is overlapping the two\narrays are overlapping in this position\nso we\nwe do need a tiny bit more memory we\njust need\none more uh cell right we just need one\nmore\nvariable but we know that that's still\nbig o\nof one so i'm actually for the purple\none which tells us which rows we need to\nzero i'm going to\nhave it be one less we don't want them\nto overlap\nso we can get rid of this we don't\nactually need the extra memory\nfrom these input arrays we don't need\nthis extra memory but we do need this\none\nsingle last cell because we see that\nthere's no room for it over here the\ngreen one\ntook that from us so you can see this is\nbig o\nof one memory right we're just using one\nextra cell that's constant memory\nand so this is going to tell us whether\nwe need to zero out the first\nrow or not so now we're just going to\nrun through\nthe matrix for the third and last time\nso this is a one we don't have to do\nanything\nthis is a zero so what are we gonna do\nwe're gonna mark\nthis cell and how are we gonna mark it\nwell we're gonna set\nthis to zero which it already is right\nand we're gonna set this to zero\nindicating that this\nrow needs to be zeroed out this\nzero tells us that this column needs to\nbe zeroed out\nnext we go to this cell it's a one great\nwe don't have to do anything\nthis is a one great we don't have to do\nanything this is a zero\nso what are we gonna do well we're gonna\nset\nthis cell to zero to indicate that this\ncolumn needs to be zeroed out but it's\nalready zero good for\nus but we also need to set\nthis to zero to tell us that this\nrow needs to be zeroed out and you see\nwhy this solution works right so now\nwe're gonna set this to zero\nand that's okay for us because we\nalready\nvisited that cell we already saw that it\ninitially had a one\nso we can overwrite it we're allowed to\ndo that\nthe reason this works is we start at the\ntop\nleft over here and then work our way\ndown right we start here\nand work our way top to bottom left\nto right so now we visit this cell it's\na one\nnothing to do we visit this zero so we\ngot\nwe got some work to do we need to set\nthis top value to zero to indicate that\nthis column needs to be zeroed out\nand we need to set this position to zero\nto indicate that the row needs to be\nzeroed out but it's already zero\nwhich is good for us so now we get a one\nnothing to do we get another one nothing\nto do\nokay so now that we know we know which\nrows\nwe need to zero out and we know which\ncolumns we have to zero out so all we\nhave to do is fill in those zeros\nso we start we start here we know this\nentire\ncolumn needs to be zero it already is we\nknow this column needs to be zero it\nmostly is we just have to change this\nlast value\nthis is a one so we don't have to zero\nout this column\nnext let's go through the rows so this\nrow needs to be zeroed out so we can\nchange this\nto a zero this row needs to be zeroed\nout\nso we can change this to a zero the\nthird row\nalso needs to be zeroed out so we can\nchange\nthis to a zero now the entire thing is\nzero which is the result that we\nexpected\nbut the good thing about the solution is\nwe did it\nin place all we really needed was one\nextra variable so with all that being\nsaid let's\nfinally write the big o of\none memory solution so the first thing\ni'm just gonna do is\nget the number of rows and columns and\nput them in some variables so we don't\nhave to\nkeep computing that we can get the\nlength of the matrix and get the length\nof the first\nrow of the matrix which tells us the\nnumber of columns\nremember we don't need extra arrays but\nwe just\nneed one extra variable to tell us if\nthe first row is\nzero or not so initially i'm going to\nset this\nto false to say that the first row is\nnot zero but we'll\nupdate it to true if we need to so\nremember that the first thing we want to\nknow is\ndetermine which rows and columns\nneed to be zeroed so we can\niterate through every position in our\ncell\nso we're gonna go through every row and\nwe're gonna go through\nevery column if we ever find a\nvalue that is zeros in this case\nwhat we so if we find a zero what are we\ngonna do we're gonna\nset the first row so row\nzero in this column we're going to set\nthat value\nto zero what we also want to do is\nin the first column so\ncolumn is zero we want to set that\nrow position to zero as well\nbut just one catch we cannot set that\nfor the top leftmost position so\nonly we're only gonna do this if row\nis greater than zero because remember\nfor row 0 we\nactually have a dedicated value so\nif rho 0 is greater than 0 then we do\nthis\nbut otherwise we're going to actually\nupdate\nthis value our boolean so\nwe're going to set that to true and so\nthat's\nit we're just marking which rows and\ncolumns to zero\nout so now the way i'm actually going to\nzero them out is going to be a little\nbit different than how i showed in the\npicture i'm actually gonna go through\nevery position one more time\nso every uh row column pair and i'm\ngonna check\nfor each position so for this row column\npair is\nthe do we need to zero it out and how do\nwe know if we're gonna zero it out\nwell see up here we would set the first\nrow to zero so if\nthe first row value is zero that means\nthat we're going to zero this out but\nalso\nif the column is zero so if\nmatrix of the first column\nof this row is equal to zero\nthen in either of these cases we wanna\nset\nthe current position that we're at to\nzero\nand so we cannot actually just do this\nby iterating through every row column\nwe have to actually skip the first row\nand we have to skip the first column\nbecause we're gonna handle that after so\nnow that we zeroed out\nthe main part of our matrix we can\npotentially\nzero out the first row and the first\ncolumn if we need to so\nfor we're gonna check if the\norigin of our matrix is zero\nso remember the first row of the matrix\ntells us\nwhich columns we can zero out so if this\nis equal to zero that means we can set\nevery\nvalue we can set every value\nin our matrix in the first column\nso i'm gonna say column is zero\nso if the first column in the first row\nis zero\nthen every value so what we're doing\nhere is basically zeroing out the first\ncolumn of our matrix and\nlast but not least we have to take a\nlook at\nour last uh variable that we declared so\nrow zero this tells us if we're going to\nzero out the first\nrow so if row zero is true\nmeaning we have to zero out the first\nrow we're gonna go through every\nvalue in the first row\nand zero it out so matrix of the first\nrow\nrow index zero and every position in\nthat row\nwe're gonna zero it out so that's the\nalgorithm\nfirst we've determined which rows and\ncolumns to zero out\nthen we zero out most of them\nthen we zero out the first column\nif we need to and lastly we zero out the\nfirst\nrow if we need to and we don't have to\nreturn anything\nbecause we did this in place which is\nwhat the problem wanted us to do\nokay i'm so dumb i don't know why i\ndidn't finish this line of code don't\nforget to\n"
    },
    {
        "Name": "Happy Number",
        "NcLink": "non-cyclical-number/",
        "Pattern": "Math & Geometry",
        "Description": "A **non-cyclical number** is an integer defined by the following algorithm:\n\n* Given a positive integer, replace it with the sum of the squares of its digits.\n* Repeat the above step until the number equals `1`, or it **loops infinitely in a cycle** which does not include `1`.\n* If it stops at `1`, then the number is a **non-cyclical number**.\n\nGiven a positive integer `n`, return `true` if it is a **non-cyclical number**, otherwise return `false`.\n\n**Example 1:**\n\n```java\nInput: n = 100\n\nOutput: true\n```\n\nExplanation: 1^2 + 0^2 + 0^2 = 1\n\n**Example 2:**\n\n```java\nInput: n = 101\n\nOutput: false\n```\n\nExplanation:\n1^2 + 0^2 + 1^2 = 2\n2^2 = 4\n4^2 = 16\n1^2 + 6^2 = 37\n3^2 + 7^2 = 58\n5^2 + 8^2 = 89\n8^2 + 9^2 = 145\n1^2 + 4^2 + 5^2 = 42\n4^2 + 2^2 = 20\n2^2 + 0^2 = 4 (This number has already been seen)\n\n**Constraints:**\n* `1 <= n <= 1000`\n",
        "Difficulty": "Easy",
        "Video": "ljz85bxOYJ0",
        "PythonSolution": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        slow, fast = n, self.sumSquareDigits(n)\n\n        while slow != fast:\n            fast = self.sumSquareDigits(fast)\n            fast = self.sumSquareDigits(fast)\n            slow = self.sumSquareDigits(slow)\n\n        return True if fast == 1 else False\n\n    def sumSquareDigits(self, n):\n        output = 0\n        while n:\n            output += (n % 10) ** 2\n            n = n // 10\n        return output\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nwe're going to look at leak code 202\nhappy number so what makes a number\nhappy\nthey explain it to us in the problem\nstatement\nso we're given an input number n and we\nwant to know\nis it happy or not if it's happy we can\nreturn true\nand we're done if it's not happy we're\ngoing to return\nfalse but how do you determine if it's a\nhappy number or not\nin this example they gave us a nineteen\nso let's work with that so all we need\nto do is take\neach digit so the first digit one\nsquare it the second digit nine\nsquare it add them together\nbut we're not done yet to determine if\nit's actually happy or not\nwe're going to take this number now and\ndo the same thing\nand we're going to keep repeating this\nprocess right so we would take 8 squared\nplus 2 squared and then we get 68\nand we're going to keep going now if the\nnumber reaches\na 1 just like it did in this example so\neventually\nwe're going to go to 68 we're going to\ngo to 100\nand then we're going to get to 1.\nand if it reaches a 1 like this then\nit's a happy number if it doesn't ever\nreach a one\nthen it's not a happy number and we're\ngoing to return false\nbut they also tell us that no matter\nwhat whether it's a happy number or not\nit's going to loop endlessly so notice\nhow this\none if you take one and square it\none squared is equal to one one squared\nis equal to one so\nwhen we keep doing this we're going to\nget stuck in an infinite loop\nbut even if we never reach a 1 we'll\nstill be stuck in an infinite loop\nso you guys know how much i like to\nvisualize problems so let's\ndo exactly that so we start with a 19.\nthen we get to a hundred\nand then we get to the number that\nproves to us\nthat 19 is happy\nnow we get to a one right and now this\none\nis going to loop infinitely and\ntherefore we know\nthat 1 or 19 is a happy\nnumber but let's take a look at a\ndifferent example\nwhat if our input was equal to\n2 instead of 19.\nthen what's going to happen so we first\nstart with a 2\nwe can square the 2 and we get to 4.\nwe can square the 4 and we get to\n16. now this is the part where you're\ngonna have to trust my math\nso if we take the sum of squares\nof digits of 16 we're gonna get to\n37 if we take the sum of squares of 37\nwhich is\nnext 3 squared plus 0 squared that's\na 9. 9 squared is eighty-one\neighty-one squared is\nsixty-five\nsixty-five squared is sixty-one\nor the sum of squares of 65 is 61.\nand now 6 squared\nplus 1 squared is\n37 and you notice anything\nabout this there's a 37 right\nover here so basically\nthe exact same thing happened right we\nstarted at 2\nwe did some stuff and then we got stuck\nin an infinite loop right it's just\ngoing to keep going around and round and\nround\ninfinitely right so what does this tell\nus well in this case\nso instead of returning true we're going\nto return false\nso basically what we're trying to do is\ncheck\nif we ever get to basically\ndo we ever visit a number twice and how\ncan we do that efficiently well you\nmight have heard there's a data\nstructure called\na hash set that we can use and i'm going\nto show you how to code that up right\nnow\nso i'm doing this in python so let's\ncreate\na visit hash set to keep track of\nevery number that we previously visited\nso that if we get to a number that we\nvisit twice we can\ninstantly know in constant speed right\nhash sets are really quick\nand now we just want to compute the sum\nof squares of\nn until n is\nrepeated until we get a duplicate value\nso i'm gonna go until\nn is not in visit so if n hasn't\nbeen visited so if n hasn't been visited\nthen the first thing we can do\nand the next thing we want to do is\ncompute the\nsum of squares\nso i'm not going to do that here i'm\ngoing to separate that out into a helper\nfunction\nlike i'm doing right now so we're going\nto pass n into this function\nwe're going to compute the sum of\nsquares and we're going to reassign n\nto that value so before i forget let me\nand so what's going to be the condition\nthat we return true\nso remember the single number that we're\nlooking for is 1.\nif n ever equals 1 we're done\nlike we can just return true\nand we could have even put this part\nlike at the beginning of our code if we\nwanted to if the input value was one\njust instantly return one we don't even\nneed to do anything\nbut in the case that we visit a value\ntwice like if our loop stops executing\nthat means we visited about we visited a\nvalue twice\nbut in the case that we visited a value\ntwice\nand that value was not one then\nwe need to return false because we know\nour\nloop is going to stop executing and we\nknow that we didn't reach a value that\nwas\n1 so we can just return false\nnow for the annoying part we actually\ngotta compute these sum of squares of\ndigits\nso let me just explain what i'm gonna do\nbefore i actually write the code for\nthat\nso we're talking about taking 19 right\ngetting the sum of squares\nand then adding them up but how do we\nactually do that in code it's a little\nbit annoying but once you\nkind of figure it out it's not too bad\nso if you take\n19 mod it\nyou get the ones place value right\nso we want to take this 9 because we\nneed it to compute the sum of squares\nso now that we have our 9 we don't\nactually need this\nanymore so what are we going to do i'm\ngoing to take 19\nand divide it by 10. now we know in\ncode this is not going to do what you'd\nexpect in math right this is not going\nto be a fraction\nwe want to just get rid of this 9. so in\ncode this is going to this is going to\nequal\n1 right so that's great now we got our\none\nand we have our nine so now we just can\ntake the squares of them\nand add them together so this is kind of\nthe process that i'm gonna do except\nwe're gonna do it in code and we're\ngonna use a loop\noh and one more thing so notice how we\nhave our one now\nif we mod it by 10\nwe're gonna get zero right and zero\nsquared is of course\nzero when we take our one and divide it\nby 10\nwe're also going to get zero so that's\nhow you know we're finished right so\nthis isn't going to loop forever\nokay so now we can finish this helper\nfunction and then finally be done with\nour solution\nso i'm going to declare a variable for\nthe output which is going to be the sum\nof squares value\ninitially it's going to be 0.\nso while n is not 0\nand we can just say while n in python at\nleast\nwe're going to continue our loop we're\ngoing to continue taking each digit\nand squaring it and adding it to our\noutput\nso remember how do we get that digit we\ncan take\nn mod it by 10\nand we also have to square our digit so\ndouble star two so that's squaring in\npython\nand we can take our output and add this\ndigit\nand the last thing we have to do is\nremember update our value\nn because we're done with this digit but\nand so in python at least these two mean\ninteger division in java in most\nlanguages you can just get away with one\nand so this loop is going to keep going\nuntil n is equal to zero\nand then we can finally return that\noutput\nand our solution works it's not the most\nefficient solution\ni'll tell you that so we needed a set\nright\nthe set made it so our memory complexity\nwas big o of n there's a\nactually slightly better way to do this\nand the better way to do this\nis just like this suggested problem a\nlengthless cycle\nbecause if you remember the drawings i\nwas showing\nthis problem is a linked list problem at\nits heart right so if you solve linked\nlist cycle\nyou're pretty much solving this problem\nas well but thank you so much for\nwatching if this was helpful\nsoon\n"
    },
    {
        "Name": "Plus One",
        "NcLink": "plus-one/",
        "Pattern": "Math & Geometry",
        "Description": "You are given an integer array `digits`, where each `digits[i]` is the `ith` digit of a large integer. It is ordered from most significant to least significant digit, and it will not contain any leading zero.\n\nReturn the digits of the given integer after incrementing it by one.\n\n**Example 1:**\n\n```java\nInput: digits = [1,2,3,4]\n\nOutput: [1,2,3,5]\n```\n\nExplanation `1234` + `1` = `1235`.\n\n**Example 2:**\n\n```java\nInput: digits = [9,9,9]\n\nOutput: [1,0,0,0]\n```\n\n\n**Constraints:**\n* `1 <= digits.length <= 100`\n* `0 <= digits[i] <= 9`\n",
        "Difficulty": "Easy",
        "Video": "jIaA8boiG1s",
        "PythonSolution": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        one = 1\n        i = 0\n        digits = digits[::-1]\n\n        while one:\n            if i < len(digits):\n                if digits[i] == 9:\n                    digits[i] = 0\n                else:\n                    digits[i] += 1\n                    one = 0\n            else:\n                digits.append(one)\n                one = 0\n            i += 1\n        return digits[::-1]\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve\nleak code 66 plus one we are given a\nnon-empty array of decimal digits\nand so by decimal they basically mean\nevery digit is gonna be from 0\nto 9 right that's decimals any digit\nbetween 0 and 9\nand this array of digits is supposed to\nrepresent a\nnon-negative integer and our job is just\nto increment this integer by one so it\nseems pretty straightforward right\nand they basically tell us that the\ndigit is stored such that the most\nsignificant digit is on the left side\nbasically how you would assume that an\ninteger would be and we can assume that\nthe integer does not contain\nany leading zeros which is pretty\nintuitive right so for example let's\ntake a look at this\nthis is an array one two three\nso this array represents the number 123.\nwe want to increment this by one how\neasy is that well obviously we'd start\nat the right side\nright and then increment this digit by\none so\nthree plus one is of course four right\nso we change\nthe three into a four therefore this 123\nbecomes 124\nand then the output array becomes one\ntwo four\nsecond example is pretty similar this\nrepresents\n4 321 increment the\nfirst the right hand digit by one so\nbasically change it into a two\nand then that's the output array so that\nseems really really easy doesn't it\nbut it's a little bit misleading they\ndon't show you one\ncase that will basically change these\ntwo examples\ninto difficult examples let's say that\nour array was this\nlet's say this was our input array right\nand remember what we're trying to do\nhere right we're just trying to add\na single number so when i draw it like\nthis it becomes a little more obvious of\nwhat exactly we're going to end up doing\nwe're going to add 1\nright so we're going to add 1 to this 9\nright so 9 plus 1\nbecomes 10 right so can we change this\ndigit to a 10 if we did that we would\nend up with 9\n9 10 right and that represents the\ninteger\n9910 well when you add 1 to 999\nit definitely doesn't become 9 000 so we\ndid something wrong right we forgot one\nthing\nremember back to your elementary school\nmath right nine plus\none is ten right but we know that\nthere's a carry so nine plus one\nbecomes zero and we take a one and\ncarry it over here right so that's what\nthe algorithm is it's basically adding\nkeeping track of this carry so again\nwe're going to have\nnine plus one that's going to end up\nbeing again zero and we're going to have\nanother\ncarry over here so again nine plus one\nright so now you kind of see\nthat this is this problem is not just a\nsingle addition it's going to be a\nwhile loop of continuous additions\npotentially right if we got an example\nsuch as this one\nso again 9 plus 1 becomes 0 and again\nwe carry a 1 over here but in this case\nwe ran\nout of digits notice that right we ran\nout of digits so what are we gonna do\nwith this last\ncarry one we're just gonna take it and\nadd it over here so i know i'm kind of\ndrawing over the elite code explanation\nover here\nbut hopefully you can see this basically\nwe got the ex\nthe answer that we expected right when\nyou add 999\nwith one you expect to get a thousand\nright\nso our output array is actually gonna\nhave these four\ndigits zero 0 0 and\n1. so this is what our output array is\ngoing to actually end up being\nin this example and so basically these\nare the main cases we have to go through\nright if you have if you have a 9\nalready here it's not going to turn into\na 10 it's going to turn into a 0 and if\nwe\nran out of digits but we still had a\ncarry we're basically going to be\nappending that carry\nto our integer array but notice how we\nare traversing the array in reverse\norder what i'm going to do though is i'm\nactually going to reverse the entire\narray and then so basically i'm going to\nturn it into 3\n2 1 so that we can start at the\nbeginning when we add our digit 1\nto this and then at the end i'm going to\ntake the\narray and then reverse it again so that\nwe can get it back into the format that\nwe want\nthen we can return the the array in that\ncorrect\nformat so with that being said this is a\nthis is you know pretty self-explanatory\nthat this is an uh linear algorithm\nbecause we're having to iterate through\nthe entire input array which is going to\nbe size\nn so the overall time complexity of this\nis going to be big o of\nn we're not really needing any extra\nmemory other than the input array\nso the memory complexity is just going\nto be big o of 1.\nthat being said let's jump into the code\nit's not too bad just a couple edge\ncases we have to worry about\nso like i said we're going to first\nreverse this\ninteger array and we can do that in\npython just like this pretty simple\nand i'm gonna keep track of two\nvariables i'm gonna keep track of the\ncarry and i'm gonna call that just one\nbecause i'm bad at naming things\nand we're also gonna have one other\nvariable i\nfor the index of the position of digits\nthat we're currently at so\none i'm going to initialize to the value\none because remember we do have to at\nleast\nadd a single one to this digit\ni i'm going to initialize at zero just\nat the beginning of the digits\narray so we are going to continue to\niterate through\ndigits while while our one digit\nis equal to one and we can basically\njust\nyou know say this as the condition now\nit's possible that our\ni could be incremented so much that it\nbecomes out of bounds so one thing we're\ngoing to check is that while i\nis at least in bounds and the else case\nis going to be if the\ni goes out of bounds so if the i is\nstill in bounds then we're going to be\nincrementing of course right\nbut there's one case that we do have to\nhandle one special case what if\ndigits at position i is equal to nine\nthat's the special case right that's the\ncase where we get our\ncarry integer so if this is equal to\nnine\none is going to stay as the value one\nright and we're guaranteed that one is\nright now one like i guess i should have\nnamed this something different but this\nbecause this is gonna be the value one\nif our loop is executing at\nall so this is gonna remain one so we\ndon't have we don't actually have to\nwrite that\nbut as we add one to this digits of i is\ngonna be\nreset back down to zero but if\nwe're not dealing with this special case\nmeaning if the digit is not nine\nthen we can ordinarily just increment it\nby one right so\notherwise we're just gonna increment\nthis by one and if this was not\nnine that means we're not going to have\na carry anymore right so we can take\nthis\none and then change it into a zero\nbecause we don't have a carry anymore we\ndon't have to continue adding anything\nwe can take this back down to zero\nnow the else condition is when we go out\nof bounds right that means we reach the\nend there's no more digits to add on to\nanymore but we still have a one value\nwhat are we going to do in that case\nwell\nin that case we're just going to take\ndigits and then append one to it right\nbecause\nwe're adding a new digit into this\ndigits array right\nand also since you know we don't have a\ncarry anymore\nthat means we can take our one and now\nreset it again back down to zero right\nthis is going to terminate our while\nloop which makes sense right if we\nappended a one\nthat means we don't have any more to add\non to our digits array\nand the one thing you don't want to\nforget with while loops is to make sure\nyou increment your\nindex so i'm going to make sure to do\nthat regardless of which\nif condition executes we're going to be\nincrementing i\nand last but not least we're going to be\nreturning our digits array but remember\nhow i reversed it at the beginning\nso we're going to undo that reverse and\nreverse it again\nso that we have it in the correct format\nthat they wanted\nand to be honest you probably don't need\nto reverse this\nyou could just traverse the array in\nreverse order if you wanted to but i'm\nreally lazy and i don't like writing\nthat code i like going from left to\nright\nso i just wanted to reverse this so this\nis the entire code it's not too bad when\nyou make sure you handle the edge case\nof nine\nand you make sure you keep track of the\nwhat value the carry happens to be\nwhether it's zero\nor one so other than that i hope that\nthis was helpful\nif it was please like and subscribe it\nsupports the channel\na lot and i'll hopefully see you pretty\nyou\n"
    },
    {
        "Name": "Pow(x, n)",
        "NcLink": "pow-x-n/",
        "Pattern": "Math & Geometry",
        "Description": "`Pow(x, n)` is a mathematical function to calculate the value of `x` raised to the power of `n` (i.e., `x^n`).\n    \nGiven a floating-point value `x` and an integer value `n`, implement the `myPow(x, n)` function, which calculates `x` raised to the power `n`.\n\nYou may **not** use any built-in library functions.\n\n**Example 1:**\n\n```java\nInput: x = 2.00000, n = 5\n\nOutput: 32.00000\n```\n\n**Example 2:**\n\n```java\nInput: x = 1.10000, n = 10\n\nOutput: 2.59374\n```\n\n**Example 3:**\n\n```java\nInput: x = 2.00000, n = -3\n\nOutput: 0.12500\n```\n\n**Constraints:**\n* `-100.0 < x < 100.0`\n* `-1000 <= n <= 1000`\n* `n` is an integer.\n* If `x = 0`, then `n` will be positive.\n",
        "Difficulty": "Medium",
        "Video": "g9YQyYi4IQQ",
        "PythonSolution": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def helper(x, n):\n            if x == 0:\n                return 0\n            if n == 0:\n                return 1\n\n            res = helper(x * x, n // 2)\n            return x * res if n % 2 else res\n\n        res = helper(x, abs(n))\n        return res if n >= 0 else 1 / res\n",
        "Transcript": "I have one World come back and math Lite\namani weigh today today of finished Power Of\nAbout Love and War Vietnam since the\nStyle and the forest of Death of\nSuperman show that worked on the study\nor just like you feel me and this is\npreferred within its  rightful owner of\nthe well Mediamart When She can solve\nEven you have seen the\nforemost list of massive world threats is\nif you wanna investor and were about and\nwhen we love to find the Capital of\nwhich indicates and and vinegar Phi\nVinamilk scandan Again And The actress\nexpand EVN decimal knof Roma Masters of the\nweek After The Power and gerald\nGenta problem because the amount to send\nthe power shot and possessive with s and\nwife is proud make Pharma will be added\nfriends even though many of them have died\nBefore  is backup is most people\nis dealing with ads Road test aggressive\nand weight loss up that it weather for\nPerfect present socialist example\npolished and rate the way that means\nAgain And number from your high school\nmod wall mountable Tula stand in\ndisgrace pasqual Trying to time  to time\nto know the way that I'm just let your\nmotor with you that time our music with\nothers from found footage is late you\nwill notify the same ejector Seconds to\nmars one time one time She won the\nstreet and Ok and What about it  responds\nto you my no number pharmacist\nnicolaus seefeld Face Women's your the\nsponge Cake To The Power of any good\nfood is still to time to play to time to\ndo is sorted 35 pendant necklace hotel\nto time sick yet fastest us make it never\nends in the  terminals And Take One Fine\nDay that number the weather in the\naverage is neither one of Eros\nmodern international Vietnam with team take part in the\nstreets were divided by others thank you Now\ncalculate and you know wanna spend the\nfarmer is Present the song for  both in\nvalue type lactum ucy people with you\nwhen We're Super Queen Pearl Awards and\ntime and late Show composition and of\nits Most wives and time now the format\nis made It's the weather forecasting\nmethods are official pestis case with\nstand against other reasons is  not a\ncommon Sense Tsubasa Nobody is something\nthat you can wear out if you take is\nnumber as what to wear your motor every\nday reverse hand and integrated\nEm in their\nin running from our official warner\ngoldhand into garage entries with Right now\nI read the Bite  And can wait out some\nFrom The Hero evolved to work out I\nspeak and timeless show is their Animals\nIn The World Is short and well well well\nthe Wake me up at War for your patience\nis nice food will have bruised and time\nwill come Just You  and flytime Sprite\nfaitai phthalate glad to have to watch\nand I work work with English language in\nword is our father have We just dance\nok now ng finest motorbike five 6 Nike\nswarming have the world you when you're\nwith straight Hair Battleship Razer\nBlade stealth and work with antivirus\nprofile when you say and We can say\nany price Phuong amira back to work and\nthis is forced to support added to your\nWords for its helped us To The Power of\nfive or you can save your contact  us for\nandroid Viettel We got's rubik\nadventurequest results find the words to\nWhat the weather in better late show\nwhat where the latest bay canifornia\nneedn't have to work with safe to town\nto work with about you more to Write by\nitself play Pieces to prepare  for war\nbegan in the one hour to value your day\nshow with just wanna have the testimony\nthe content or user to their thoughts\nabout it read the text Again this game\nis and your hands and has a winning CPU\nand tried to the power of tooth easiest\nto the power one time to find out and a\nfree market in the most of the format is\nnot supported the world link Japan my\nlove Sweet spot and Combat assault\nremaining against the first We Heart It\nsupports and and her Every time i have\nis divided about  you my house and\nrefined Eco want when you destroy Awards\nerkenntnis with National weather like a\nMission switches ID number and also\ntakes place a Mission to provide enough\nand apply tadacip alltrim unqualified to\nwear your cover the way to share What\nabout you I cannot be over  some typical\ntsongkhapa seefeld brother four years\nignite rimini It is not box repassword\nRight now and nevis crystal inso Center or\ndoing that letter writing Punk rock Road\nis scandal went to work place Pocari\nsweat Lite shows from just about\nsandwich secret to learning to speak call to\nlive with shows that some To The Power\nof five more special Best Death is like the\nway to the park and Drive Secret\nabout you and Price of any more results\nrelated events and is not made and\ngarbage is Born To raise money to single\nstrains of  errors and find the best One\napk\nspecialists and Hills Summer damaged\ndamaged and supporting up is aware of\ntheir workers Producer of urology of you\nrecord strassmann What i want is\napparently you don't forget is paid Out\nOne Forever just What to date with\nparents did  you ever where is number\nfive feitas pela Zero any number basis\nfor users of work and want to One Pieces\nof commands and Lore Zero event which\ncan White a basis now know will ruipai\nspacespeakers s is never read more Find\nout whether the Wedding and write to  act\nagainst them But if we ever caught in\nfirst as World Zero Metal crazy about\nyou There is your name what happens to\nbe there forever Nightcore It's ok Cause\nI wonder What's the date with the better\nlate We got in first and realistic and\nit needs the  money would you wait I'm\ndoin a sweet sweet mini advantage of the\nwork and integrates the weather today\ncases are about the string Mask wash\nhawaiian together now the local now and\nwant and suites is implemented hamburger\nhemineglect your name was meant to begin\nin all  aspects of The Power of and\nspacious with What is apparent National\nGallery about you see typical One Fine\nDay At The Power of smell and later\narray of value as it\nends tonight Number One account Number\nOne correct the town of Heart and\ntomorrow What nationality and take about\nthe week next and What the weather\ntoday is the weather like in\nsingle-handle you and your family We're\ngonna minister you  hard live show Center\nWhere all the handle nights When She\nneeds to be of personal Touch of\nperformance curve of Pearl stdout in\never pest reject calls and Gentlemen\nartifacts and leaves and ends well don't\nmatter how many articles which one\nsingle core of paper One  Thing right\nperson as expensive as Postal And The\nCore of networks and structures of value\nof and and Little Of as late but now\nperformance people spend a what it and\nwith love more Chris\npassport Dana White Walls and hundreds of\nLife and is greater dear or  nicholas\ngunn gard hundreds of the wise and\ninterested Advanced nourish sportsnet at\nonce i want to find the resort playcast\nmany International main drain and\ninteresting with mention of cable\nmasseger multi-page day on Earth is Used\nwhen we on gonna be wild year's day\nbecause It  can amount spawning have at\nthe expansion And Love The Way Cake with\nany decal mimaki record your address\ncase with Organic and one amount\nminiview There were around to work at\nNumber One Star weaknesses and the Word\nExcel What can I say When can call at the\nnews  white room\ndon't go to school you get it pass Action\nagainst The Sand and Dust mites avoid to\ncelebrate New York Banking Ok very hard\nand it's Where is never tell me the\nvalidator dendrophila Pika to play to\nwork We had a large Number One ever had\nany  code find their advantage and Nice\nAnd The Beat goes around in the cast zai\nshou Wu hanala b'gosh with your serial\nport number the hero's way from every\nCorner with more To Life is one more\ntime Because I'm acting upon another time\nback to  the power of That is the record\nthat the power of prayer because the\nheart is broken or above and for what is the\nmost of the accounts of threats I\nmiss our use of free your Monsters\nwith before\nyour eyes could  talk anymore fights for\nany purpose the vessel print save don't\nregard\ns.pearl\nifile.it dxcore netwiz adarna stackpanel\nresort Golden Sand and money back to his\nare you interested in this case We Come\nas time goes with estoque minoan events\nforced me to  check with respect which\njust before the interest rate and out\nmore find Myself and language and\njournalists in performing the overall\nlook What some meat nectar watch and\nlisten on to what is your profession\nspecial against them or public address\nFor You For The Immortal courier baby\nDragon  Dance With Me I'll make fun of\ntomorrow Of Your Heart must Watch\nimage set of Passion and accuracy past ex\nMode to live is and a woman's day When I\ncan tell her to our specialty paper and\nyour expertise and value or wifi X6 the\nworld in my biggest loss is When turned the\nwork out of any disease are\nconcerned with us in the width width\nmodulation penalty catalinas offical\nwork around you want to specify How the\nuseful in the work Westlife unsupported\nfile word and hopefully of priests and\nTransport\n"
    },
    {
        "Name": "Multiply Strings",
        "NcLink": "multiply-strings/",
        "Pattern": "Math & Geometry",
        "Description": "You are given two strings `num1` and `num2` that represent non-negative integers. \n    \nReturn the product of `num1` and `num2` in the form of a string.\n\nAssume that neither `num1` nor `num2` contain any leading zero, unless they are the number `0` itself.\n\n**Note**: You can not use any built-in library to convert the inputs directly into integers.\n\n**Example 1:**\n\n```java\nInput: num1 = \"3\", num2 = \"4\"\n\nOutput: \"12\"\n```\n\n**Example 2:**\n\n```java\nInput: num1 = \"111\", num2 = \"222\"\n\nOutput: \"24642\"\n```\n\n**Constraints:**\n* `1 <= num1.length, num2.length <= 200`\n* `num1` and `num2` consist of digits only.\n",
        "Difficulty": "Medium",
        "Video": "1vZswirL8Y8",
        "PythonSolution": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if \"0\" in [num1, num2]:\n            return \"0\"\n\n        res = [0] * (len(num1) + len(num2))\n        num1, num2 = num1[::-1], num2[::-1]\n        for i1 in range(len(num1)):\n            for i2 in range(len(num2)):\n                digit = int(num1[i1]) * int(num2[i2])\n                res[i1 + i2] += digit\n                res[i1 + i2 + 1] += res[i1 + i2] // 10\n                res[i1 + i2] = res[i1 + i2] % 10\n\n        res, beg = res[::-1], 0\n        while beg < len(res) and res[beg] == 0:\n            beg += 1\n        res = map(str, res[beg:])\n        return \"\".join(res)\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem multiply strings\nso we're given two non-negative integers\nnum1 and num2 but these could be\nextremely large numbers and because of\nthat these integers are going to be\nrepresented as strings as you can see\ndown below and the good thing is that\nthese integers are always going to be\neither positive or they could be zero\nand we want to just take these two\nnumbers multiply them together get the\nproduct and then return that product as\na string and we're not allowed to you\nknow actually do this with integers\nright we can't just convert these two\nstrings to integers we actually want to\ndo this with strings themselves because\nyou know there's no guaranteed that an\ninteger this large could actually fit\ninto a 32-bit or a 64-bit integer and\nthey don't want us to use any kind of\nbig integer library so there's going to\nbe two parts to this problem the first\npart is going to be to remember how you\nactually multiply two numbers in the\nfirst place you probably learned it in\nelementary school but you may have\nforgotten so that's the first thing we\nneed to figure out how to actually\nmultiply two numbers and the next part\nis how can we actually take that idea\nand then translate it into code in a\nreadable and you know somewhat concise\nway and that's going to be the second\npart that we have to figure out and just\nto go through an example real quick you\ncan see 123\n456 you multiply those two together you\nget this value and we are returning it\nas a string so let's go back to\nelementary school how can we take two\nnumbers like these and multiply them\ntogether in a formulaic way that we can\ntranslate into an algorithm well\nremember we usually first start with the\nones place over here right and then we\njust take this value and then multiply\nit by three multiply it by two and\nmultiply it by you know the more\nsignificant digit and then we add those\nthree together you know we also do have\na carry which is something we're gonna\nhave to keep track of and you can kind\nof tell that you know if we take six\nmultiply it by these three integers then\nwe're gonna go to four we're gonna go to\nfive multiply it by these three integers\nthen we're gonna go to four multiply it\nby these three integers that's something\nthat could probably be translated into a\nnested for loop right so we're kind of\nlearning that as we go but let's just\nstart with this so six times three\nthat's going to be 18 right but normally\nyou know we just take the first digit\neight put it over here in this ones\nplace then we take the one and carry it\nright so the one is going to go up here\nit's going to be added to whatever goes\ndown here but in the code we're actually\ngoing to be putting that one here\nimmediately\nbecause you know when we're when we're\nkeeping track of a carry we could keep\ntrack of it over here like in a single\nvariable but it's kind of just easier to\njust put it here because we know it's\ngoing to be added with whatever next\nvalue that we put over here so next\nwe're going to look at 6 multiplied by 2\nthat's going to be 12 right so we're\ngoing to take 12 add it with the carry\nright that's going to give us 13 in this\nposition right so we have a 3 digit here\nand we have the 1 which is going to be\nthe carry in the next position now\nnotice how when we were multiplying\nthese three together we put the digit in\nthe first spot but when we multiply\nthese two together we put the digit in\nthe next spot and when you multiply\nthese two together we're gonna put the\ndigit over here so basically the way you\nknow how we decide where we actually put\nthe digit when we multiply two digits\ntogether is basically going to be the\nsum of the indices of these two so\nbasically consider this is zero this is\none this is two these are the indices uh\nif we're multiplying these two together\nwe're gonna put it but we're gonna put\nthe digit in the zero position if we\nmultiply these two together we're gonna\ntake zero plus one we're gonna put it in\nthe one position over here now if we\nmultiplied these two values together\nwe'd say one plus one\nyou know\nthese two multiplied together we'd put\nthe digit over here because this is the\ntwo spot i know that's kind of tricky to\nyou know recognize immediately but i\nthink it makes sense because you know\nwhen we're multiplying six by one we're\nnot actually multiplying six by one\nwe're multiplying six by a hundred right\nbecause this one's place is in the\nhundreds place so that's kind of the\nintuition behind that but yes now we\ntake six multiply it by one we get a six\nright so this is where we would put the\nsix we clearly have a carry over here so\nwe're gonna actually put a seven over\nhere so so far this is our result but we\nonly went through this six digit next we\nwant to go through this five digit and\nmultiply it by these three values so we\ntake 5 multiplied by 3 we get 15 right\nthe 15 is going to go in this\nspot over here right but of course we\nhave a carry one over here so what are\nwe gonna do well we're gonna take these\nadd them together and we're gonna take\nthese add them together right so we're\ngonna get an 8 over here and we're going\nto get an 8 over here next we're going\nto take 5 and multiply it by 2 and the\nposition that that's going to go in is\ngoing to be in this position right\nbecause\nyou know that's just kind of the math of\nhow these indexes add up so 5 times 2 is\ngoing to be 10 so we put a 10 here right\n0 plus 8 that's just going to stay 8 but\nthat one carry is gonna go over here in\nthis position notice how the result when\nyou multiply two numbers the number of\ndigits in the output could be greater\nthan the number of digits in the input\nnow what's the maximum number of digits\nthe output could even be well if we took\ntwo numbers suppose 99 multiplied by 99\nright these are kind of the biggest\nintegers we could have for two digits\neach how big would the output be well\nthe output would be four digits i think\nit'd be something like something like\nthis i'm not 100 sure on that but\nbasically you can see that you know if\nwe have two digits multiplied by two\ndigits the max the output could be is\nthe sum of the digits of each of these\nright so if we have an example like this\none three digits multiplied by three\ndigits we could have an output of up to\nsix digits but it might it could be less\nthan that right for example you know you\ntake 10 multiplied by 10 we just get a\nthree digit number 100 right even though\ntwo plus two is four digits this is the\noutput happens to be three digits so\nit's it's basically going to be less\nthan or equal to the sum of the number\nof digits but okay so where did we leave\noff we were gonna now multiply five by\nthis one and then put it in this digit\nposition because this is that index two\nthis is at index one so\nthe output is going to be at index three\nover here right these are kind of the\nindexes of the output so five times one\nis just going to be five so we take a\nfive here add it with the one that's\nalready there so we're going to get a 6\nin this position by the way notice how\nwhen we count the indices where you know\nthis is 0 this is 1 this is 2. so\nbasically the integers themselves we're\ngoing to be iterating through them in\nreverse order similarly we're going to\nbe building our output in reverse order\nas well and then at the end we're gonna\ntake this and reverse it okay so now we\ntook five multiplied it by all three of\nthese digits so we're done with five\nlastly we're going to take four and\nmultiply it by all three of these so\nfour times three is going to be 12 right\nwe're going to put a 12 here you know we\ntake these two add them together we're\ngonna get a zero in this spot right a\nzero and we had a six here we had a one\nhere now we're gonna since we got a zero\nhere we're going to have another one\ncarry in this position so when we\nactually add these together we're now\ngoing to have an 8 in this spot so we\ntook 4 multiplied it by 3 now take 4\nmultiply it by 2 which is going to be 8\nand we're going to put that a in this\nposition because that's how the math for\nthese indexes adds up so 8 plus 8 is\ngoing to give us a 6 so we can put a 6\nhere but of course we're going to have a\ncarry right 8 plus 8 is 16 so this is\nwhat we have we had to put that carry\nover here so we took 4 multiplied it by\n2 lastly we're going to take 4 multiply\nit by 1 and then put it in this spot so\n4 plus 1 is or 4 times 1 is 4 so we take\na four add it here add it with one we\nget a result of five and then we're done\nright because we took four multiplied it\nby this multiplied it by this and\nmultiplied it by this we we finished our\nnested for loop and this is the result\nthat we got\nand as you can double check that matches\nexactly with the output that they\nexpected so basically how i ran through\nit is similar to exactly how we're going\nto code this up the only difference is\nwe're going to pre-create we're going to\npre-allocate the result array in this\ncase we have three digits by three\ndigits so we're gonna have an output\narray and we're not gonna keep track of\nit in terms of strings even though the\ninput is given to us in strings we're\ngonna build the output as an array just\nbecause it's a little bit easier i think\nyou could do it with a string but then\nwe'd have to do a lot of conversions you\nknow converting a character to an\ninteger and vice versa doing it as an\narray is a little bit easier and then at\nthe end we can take the array and then\nconvert it back into a string you know\npretty easily so that's kind of what\nwe're going to do and like i mentioned\nwe're going to start at the right\nposition of each string at the right you\nknow in reverse order we're going to\niterate through the input strings in\nreverse order and when we build the\noutput you know this is kind of the\norder of the value we're gonna build it\nopposite we're gonna put the eight here\nbecause this is index zero we're gonna\nput another eight here zero six five\nright so as you can see this is\nbasically built in reverse order to this\nso we're going to do that but then at\nthe end we can take this array reverse\nit and then convert into a string which\nis going to look something like this and\nthen we can return the string in the\nformat that they actually wanted and the\nlast thing is when we're when we're\ntaking two digits and multiplying them\ntogether consider if we had the largest\ndigits consider if these digits were\nactually nine and nine right we're only\nmultiplying one digit by one digit so\nthe max that this could possibly be is a\ntwo digit value in this case nine by\nnine is going to be 81. so when we take\nwhen we we're always going to want the\nones place right to actually put it in\nthis spot right so when we take a value\nlike 81 we can mod it by 10 to get the\nones place which will give us 1 and we\ncan divide it by 10 to get the carry\nright so if we divide this by 10 we'll\nget 8 because it always rounds down in\nmost programming languages right so\nthat's how we're going to do the math on\nthat we're going to put the 1 here then\nwe're going to take the carry put it in\nthe next spot right add it to the next\nspot and in terms of time complexity the\nsince we're going to be doing a nested\nloop it's basically going to be let's\nsay n times m where n is the number of\ndigits in the first value and m is the\nnumber of digits in the second value\nthat's overall going to be the time\ncomplexity i think the memory complexity\nis going to be something like n plus m\nbecause we're going to be using an\nadditional array just to have all of the\noutput digits inside of it then convert\nit to a string at the end with that\nbeing said we can go ahead and dive into\nthe code so now let's finally write the\ncode and the first thing i want to do\nbefore actually dive into the actual\nalgorithm is basically uh if either of\nthese digits or these numbers happens to\nbe zero then we can just return zero\nitself right but then we don't actually\nhave to execute our code so one way in\npython i can check that is if this is in\nthe array with two values num one or\nnum2 basically i'm checking if either of\nthese values happens to be zero in which\ncase we can return zero right any value\nmultiplied by zero equals zero the other\nthing is allocating that array right so\ni'm going to allocate an array of all\nzeros multiplied uh or basically the\nlength of this is just going to be the\nlength of num1 plus the length of num2\nand as i mentioned we're going to be\niterating through both numbers in\nreverse order so before i actually\niterate through them let me just reverse\neach of them and this is basically how\nyou reverse in python i'm sure you can\ndo it in your own language of choice and\nwe're going to iterate through both of\nthese keeping track of the indices right\nbecause we know that the index is going\nto be useful for some of the math that\nwe're going to have to do so for i1 in\nin\nrange\nof the length of num1 so i1 is going to\nbe the pointer for num1 and i2 is going\nto be the pointer for num2 now we want\nthe digit right so we're going to take\nthe numbers or the digits from each\nnumber and then multiply them together\nwe know the digit itself though could be\na two digit value so let's keep that in\nmind so the digit from num1 multiplied\nby the digit from num2 and so where\nexactly are we gonna store this digit\nwell you might remember i mentioned in\nthe drawing explanation we're going to\ntake the indices i1 add it with i2 which\nis going to tell us what position to put\nthis in the output result so we can then\nstore this digit there but remember we\nhave to mod this digit by 10 before we\nactually store it here and we might not\njust be storing it there might have\nalready been a carry in this position so\nwe're going to add whatever this one's\nplace is to whatever is you know this\ntarget position so that's where we're\ngonna add the ones place digit now we\nmight have a carry the carry might be\nzero or it might not be zero either way\nwe're going to put it in the i\nyou know the position plus one right so\njust the next position over is where\nwe're going to put the carry value so we\ncan add the carry value to this position\nwe can calculate the carry value by\ntaking digit dividing it by 10. and the\nlast thing is i didn't mention but\nsuppose we were given two values 10\ntimes 10 in this case we would have our\noutput end up being something like zero\na hundred the reason we have a leading\nzero is basically because you know when\nwe allocated the output array we took\nthe digits\ntwo digits here two digits here so we\nwould have a four digit result so we\nbasically want to get rid of any leading\nzeros which is something we can do\npretty easily so before we try to get\nrid of the leading zeros let me actually\nreverse this result so result is going\nto be set to itself except reversed and\nthe beginning pointer is going to be set\nat the beginning of this result and\nwe're going to keep incrementing\nbeginning while it happens to be zero so\nwhile beginning is less than the length\nof the result and\nthe value in the beginning position\nhappens to be equal to zero basically\nwhile we have leading zeros we're going\nto increment our beginning pointer until\nthe point that we don't have any leading\nzeros anymore now we do have an array of\nintegers not an array of strings so in\npython at least there's a way that we\ncan convert this\nwe can use a map function and basically\nconvert every single a value in this\nresult from the beginning pointer all\nsince we calculated the beginning point\nwe're just going to be you know we're\nbasically removing the leading zeros by\ndoing this uh operation starting\nbasically taking the sub array starting\nat the beginning pointer and we're\nconverting each integer to a string at\nleast that's how we're doing this in\npython i'm sure you could write out the\ntwo lines of code that it would take in\nother languages so once we convert the\narray to an array of strings then all we\nhave to do is just join the strings\ntogether and python you can do it\nsomething like this just join it with an\nempty string and one thing i forgot is\nfirst of all i named this num i just\nchanged it to num2 and since these are\nactually you know characters we have to\nconvert them to integers before we can\nmultiply them that's something i usually\nforget i don't know if you guys forget\nthat as well but let me actually convert\nthem to integers first and actually one\nother thing that i forgot and this is\nactually a good example what if we had a\nlet's say we had a two in the ones place\nand then two this two we're adding a\ndigit of we had an eight and we're\nadding a digit of two right so you know\nthat's kind of what i'm doing with this\nline of code in that case we would have\na two digit value here right a ten so\nwe'd have to take this whatever stored\nhere and then mod that or rather divide\nthat by ten to see if we have a carry\nresulting from two ones place digits\nthat's something we were handling in the\ndrawing picture but i forgot about that\nwhen we were actually writing out the\ncode so the way we can remedy that is\nbasically when we're going here uh we're\ngonna take just the digit itself and add\nit to this position right the digit\ncould be a one digit value like two or\nit could be a two digit value like 12\nright either way we're adding them\ntogether and then it could be possible\nwe have a two digit value stored here\nright so one thing we'd want to do if we\ndid have a two two digit value and\nstored it here we would want to take it\nand mod it by 10 right so basically set\nthis equal to itself but modded by 10 we\ncan do that pretty easily right right so\nwe're just taking it modding it by 10.\nif it just happened to be a single digit\nvalue like 2 then it would remain the\nsame if it was a 2 digit value like 12\nthen we'd get the ones place and put it\nhere but notice how we're doing this\nafter\nwe're doing this line because this line\nof code actually is going to be similar\nbecause before we do that we have to\ntake the carry that could be stored here\nright like i said it could be a two\ndigit value like it could be something\nlike a 12 in which case\nwe'd want to take this value divide it\nby 10 and then add it to the next\nposition over right so we're taking the\ncarry adding it to the next position we\ncan get the carry by taking this two\ndigit value dividing it by 10 and then\nadding it to the next position i know\nthis might have made things a little bit\nmore confusing so sorry about that but\nyou know if you kind of do go through\nthese three lines of code run it on an\nexample on your own you'll see that it's\npretty much exactly what i was doing in\nthe drawing explanation so as you can\nsee this code does work so this is the\nentire code i hope that this was helpful\nit's definitely not super easy to get\nhere but i do think being able to\nunderstand you know how multiplication\nworks is a very good first step in being\nable to tackle this problem i think\nusing an array also makes things a lot\neasier so i hope this was helpful if it\nwas please like and subscribe it\nsupports the channel a lot and i'll\nhopefully see you pretty soon thanks for\nwatching\n"
    },
    {
        "Name": "Detect Squares",
        "NcLink": "count-squares/",
        "Pattern": "Math & Geometry",
        "Description": "You are given a stream of points consisting of x-y coordinates on a 2-D plane. Points can be added and queried as follows:\n\n* **Add** - new points can be added to the stream into a data structure. Duplicate points are allowed and should be treated as separate points.\n* **Query** - Given a single query point, **count** the number of ways to choose three additional points from the data structure such that the three points and the query point form a **square**. The square must have all sides parallel to the x-axis and y-axis, i.e. no diagonal squares are allowed. Recall that a **square** must have four equal sides.\n\n\nImplement the `CountSquares` class:\n* `CountSquares()` Initializes the object.\n* `void add(int[] point)` Adds a new point `point = [x, y]`.\n* `int count(int[] point)` Counts the number of ways to form valid **squares** with point `point = [x, y]` as described above.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/4ff69d9c-cd7d-43fa-bad1-e718fc207600/public)\n\n```java\nInput: \n[\"CountSquares\", \"add\", [[1, 1]], \"add\", [[2, 2]], \"add\", [[1, 2]], \"count\", [[2, 1]], \"count\", [[3, 3]], \"add\", [[2, 2]], \"count\", [[2, 1]]]\n       \nOutput:\n[null, null, null, null, 1, 0, null, 2]\n\nExplanation:\nCountSquares countSquares = new CountSquares();\ncountSquares.add([1, 1]);\ncountSquares.add([2, 2]);\ncountSquares.add([1, 2]);\n\ncountSquares.count([2, 1]);   // return 1.\ncountSquares.count([3, 3]);   // return 0.\ncountSquares.add([2, 2]);     // Duplicate points are allowed.\ncountSquares.count([2, 1]);   // return 2. \n```\n\n**Constraints:**\n* `point.length == 2`\n* `0 <= x, y <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "bahebearrDc",
        "PythonSolution": "class CountSquares:\n    def __init__(self):\n        self.ptsCount = defaultdict(int)\n        self.pts = []\n\n    def add(self, point: List[int]) -> None:\n        self.ptsCount[tuple(point)] += 1\n        self.pts.append(point)\n\n    def count(self, point: List[int]) -> int:\n        res = 0\n        px, py = point\n        for x, y in self.pts:\n            if (abs(py - y) != abs(px - x)) or x == px or y == py:\n                continue\n            res += self.ptsCount[(x, py)] * self.ptsCount[(px, y)]\n        return res\n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve a pretty interesting problem from\ntoday's leak code contest detect squares\nso this is a pretty challenging problem\nfor a medium but it's actually pretty\neasy once you know the trick behind it\nso that's what i'll be explaining to you\nthe trick for detecting squares or even\ngeneric rectangles within a\ngrid so we're basically designing a data\nstructure with three\nmethods three functions we're going to\nbe given a stream of points and we want\nto store these points that we're given\nthey're going to be two-dimensional they\nhave an x and y-coordinate you can see\nsome examples down here and we could\neven have duplicate points in the exact\nsame spot and we do want to store those\nso a good data structure to use would be\na list so that's one data structure\nwe're going to be using a list or an\narray list so storing the points is the\neasy part but we're also given a second\nrequirement to implement the count\nmethod and this count method will take\none parameter a point so a single point\nthat may or may not already be in the\nyou know stored list of points but it\ncould be a new point or something and\ngiven that we want to be able to count\nhow many possible\nexact perfect squares are we able to\nmake with this new input query point and\nall the points that we already have\nstored within our list so suppose that\nthis was the query point then we want to\nknow how many different ways can we make\nsquares if we are allowed to choose any\nof the points that we already had stored\nlet's say all of these three points were\nalready stored then clearly we could\nmake uh one point or one square right\nwhat if we had two duplicates of this\npoint on the top left then how many\nsquares would be able to make well\ntechnically we'd be able to make two\nsquares right we could swap the top left\npoint if we had two uh you know two\ncopies of it so then we could make two\nwhat if we had two copies of this point\nand we had two copies of the bottom\nright point how many squares could we\nmake then in that case we could make\nfour squares where i got this for is\nbasically by multiplying how many copies\nwe have of this and how many copies we\nhave of this so that's going to be\nimportant so\nuh we're gonna since\nyou know the count of how many uh each\npoint that we have matters i'm gonna be\nusing a map or a hash map to basically\ncount the number of occurrences for each\npoint so now for the actual trick the\nimportant part of this problem the most\nbrute force way is going to be an n\ncubed approach why exactly is that well\nlet's say we're given this a query point\nthen we want to run through all possible\ncombinations of the remaining points we\nhave right we want to do an n\nan entire loop uh you know going through\nevery single point suppose that point\nwas in the top left position then we\nwant to do another end loop to suppose\nevery point was in the bottom left and\nan end loop for every bottom right point\nand then we want to check okay does this\ncombination of four points actually form\na perfect square or not so that's really\nnot efficient right and it's actually\nnot super easy to code either so what's\nan easier way to do it and we do need a\ntiny bit of geometry to kind of\nunderstand how we can make it more\nefficient so suppose we're given a query\npoint right what's an easy way to\ndetermine\nthe rectangle of this point or of you\nknow trying to make a square what's an\neasy way to determine that well since\nwe're actually dealing with squares it's\na little bit different than the trick\ni'm going to show you but i'm going to\nshow you a trick that can apply to all\nthat's a little bit more generic and it\ncould apply to rectangles as well so if\ninstead of detecting squares we wanted\nto detect rectangles i'll show you the\nway that we could do that so we're given\na point right this point we want to find\na diagonal point from this one so\ninstead of doing three n loops like\ninstead of doing three for loops to find\nevery single you know matching pair of\nthree points we're just going to run a\nsingle loop and supposing that every\nsingle point we have available to us was\nthe diagonal point from the query point\nthat we're given now we want to verify\nif it could actually form a square how\ndo we know if this diagonal point with\nthis query point could actually form a\nsquare well of course the height\ndifference of them or the y difference\nof them has to be the exact same as the\nwidth distance or the x distance between\nthem right\nso that's something we can easily verify\nby just taking the difference of the\ncoordinates of these two points right\nonce we have verified that we know it's\npossible if these two points are\ndiagonal to each other for them to form\na square and once we have that we have\nactually\nuh you know then we can instantly check\nan o of one if it's possible that these\ntwo form an actual square given the\ncurrent points that we have how can we\ncheck it with o of one well remember we\ndo have a hash map right what are we\ngoing to say suppose the coordinates of\nthis point are p x and p y or you could\nsay q x q y for the query point and\nsuppose the coordinates of this bottom\npoint are x and y we want to know does\nthere exist a top left point how can we\ncheck that by taking the x coordinate of\nthis point and the y coordinate of this\npoint and checking if that exists in our\nhash map in other words we could check\nthis coordinate x and p y how do we\ncheck the bottom right point the exact\nopposite right we take p x and\ny and check does this exist in our hash\nmap right since we're using a hash map\nthat'll be an o of one lookup right so\nthat's really easy so then we can\ninstantly check if we can form a square\nor not but remember we could maybe have\nthree copies of this top left and maybe\nwe could have two copies of the bottom\nright so we want to take the counts of\nthem and then multiply them together and\nwe can do that easily with our hash map\nbecause with our hashmap we are storing\nthe counts of each of these points that\nwe have in our input and remember the o\nof n loop is only iterating through the\ndiagonal list of points okay so now\nlet's get into the code and i think i\nmentioned at the beginning that we are\ngoing to use a list but now that i think\nabout it the list is actually not\nnecessary so we can actually even\nshorten up the code from what i\noriginally had so we're just going to\nuse a map so this map is going to be\ncalled points count it's going to be a\ndictionary in python or you know a hash\nmap and if you use default dict it'll\njust make things a little bit easier for\nus so if we try to\nretrieve a key that hasn't already been\ninserted here then the default value of\nthat will be zero that's what basically\nthis provides for us and that's just\ngoing to make the code a little bit\nshorter for us but so every time we're\ngiven a point right add point all we\nwant to say is the you know the count of\nthis point has increased by one right\nthat's very easy to implement with a\nhash map we'll just say uh for this key\nuh by the way a list can't be a key\nvalue for a hashmap in python so we're\ngonna have to transform this list into a\ntuple so this point will be converted\ninto a tuple and then\nwe can increment that count by one so if\nit doesn't already exist in the map its\ndefault count will be zero and then\nwe'll add one to it so pretty\nstraightforward here now for the\ninteresting part is the count function\nso we want to count you know the number\nof ways we can create a square initially\nwe'll say set that result to zero we'll\nextract the uh x and y coordinates of\nthe query point that we're given so\npoint can be you know we can easily get\nthe x and y coordinates of it and then\nwe're gonna iterate through every single\npoint in the list of points that we've\nsaved or in our map so every x y in\nthe points count we don't uh\nwant the count of this particular point\nremember this loop is just going through\nall possible diagonal values to the\nquery point that we're given in the\ninput right but we need to actually\nverify that this is a diagonal point so\nhow can we do that well we're going to\nsay\nis the absolute value of the difference\nbetween the y-coordinates equal\nto the\nabsolute value of the difference between\nthe x coordinates if that's true then we\ncan continue if it's not true meaning\nthese are not equal then it's not really\npossible for these to form a square at\nall if they're diagonal to each other so\nin that case we're just going to\ncontinue to the next iteration of the\nloop but they also mentioned in the\nproblem description that the squares\nhave to have a positive error area\nbasically that means we can't just use a\nyou know we can't just stack four points\nat the exact same coordinate and call\nthat a square i don't know if\ntechnically that is a square or not but\nthat square would have zero area so what\nwe want to just make sure to avoid that\ncase we just want to say this x can't be\nequal to the query point you know or if\nthe y is equal to the query point then\nwe're also going to continue right so if\nif these points are stacked on top of\neach other you know if they're not\nreally diagonal to each other then we're\ngoing to continue so other than that now\nwe know that these two points are\ndiagonal to each other so now we want to\nknow can we actually create a square\nwith them or not how can we know if we\ncan create a square with them well we're\ngoing to say\ndoes the point in our points map so\npoints count does that\nlet's say you know one of those points\nwhich is x and p y does that point exist\nand does the opposite point\nexist as well\nboth of these points have to exist so\nyou know just copy and pasting and\nupdating the coordinates so this will be\nthe opposite\nso as i mentioned the drawing both of\nthese points have to exist and what\nwe're going to do is just multiply the\ncounts together right because if each of\nthese is one then one times one is one\nwe can create one point with the one a\nperfect square\nwith these coordinates right if it's 2\nand 2 then we're going to multiply 2\ntimes 2. we're going to say there's four\npossible ways we can create a perfect\nsquare with these\nand we're just going to take this\nmultiplication and add it to our result\nwhich we declared up above and you know\nthat's the entire thing obviously you\ncan tell pretty easily that this is a\nlinear time function right once we're\ndone with that we can actually just go\nahead and return the result okay so it\nlooks like we are just going to\nimplement this using a list so instead\nof iterating through the keys of that\ni'm just going to be maintaining a\nsecond variable i'm sure you can do this\nwithout that but i'm tired of trying to\nget this to work in python so i'm just\ngoing to go back to the first solution\nthat i implemented so\nyeah we're just going to be maintaining\na list as well as the hashmap so every\ntime we get a point uh we're going to be\nappending that point onto this list of\npoints that we're maintaining and then\nwhen we want to iterate through all the\npoints that we have we're not going to\niterate through the map we're going to\niterate through the list of points that\nwe implemented so self.points\nand then we are good to go the solution\nwill work but one thing i did notice is\ni did have a little typo here so the x\nand y coordinates uh\nit needs to be x first and then y for\nsome reason i put y and then p x so\nlet's just swap these around p x y so\nthese are the two opposite points as we\nshowed in the drawing picture and we're\njust iterating through the list of\npoints so that being said the code\nshould work hopefully it does so let's\ntry submitting it and as you can see\nbelow it does work i hope it's pretty\nefficient i hope this was helpful if it\nwas please like and subscribe it\nsupports the channel a lot consider\nchecking out my patreon where you can\nfurther support the channel and\nhopefully i'll see you pretty soon i\n"
    },
    {
        "Name": "Single Number",
        "NcLink": "single-number/",
        "Pattern": "Bit Manipulation",
        "Description": "You are given a **non-empty** array of integers `nums`. Every integer appears twice except for one.\n\nReturn the integer that appears only once.\n\nYou must implement a solution with $O(n)$ runtime complexity and use only $O(1)$ extra space.\n\n**Example 1:**\n\n```java\nInput: nums = [3,2,3]\n\nOutput: 2\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7,6,6,7,8]\n\nOutput: 8\n```\n\n**Constraints:**\n* `1 <= nums.length <= 10000`\n* `-10000 <= nums[i] <= 10000`\n",
        "Difficulty": "Easy",
        "Video": "qMPX1AOa83k",
        "PythonSolution": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        res = 0\n        for n in nums:\n            res = n ^ res\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem single number\nwe're given a non-empty array of\nintegers nums and we're told that every\nsingle element in this array appears\nexactly twice except for one element and\nthat element only appears a single time\nour goal is to find that number that\nonly appears once and we have to\nimplement our solution in linear time\nand we're not even allowed to use extra\nspace if we were allowed to use extra\nspace this problem would be really\ntrivial if you know what a hash map is\nor actually even just a hash set uh\nbecause for every single value\nlike suppose we had this input array\nwe'd take that two add it to our hash\nset so something like this and then we'd\nsee a second two and then we would\nremove it from our hash set because\nevery element that appears twice is\ngoing to be added to the hash set and\nthen removed from it except for that\nsingle value like one which is going to\nbe added to the hash set but it's never\ngoing to be removed so by the time our\nalgorithm finishes we're only going to\nhave a single value in our hash set and\nthat's the value that we're going to\nreturn but the downside of this is in\nthe worst case uh we'd obviously iterate\nthrough the entire array which is big of\nand time complexity but it's also big o\nof n memory complexity because we're\nusing a hash set is there a way to do\nthis solution without using any extra\nmemory well there definitely is a\nsolution and let's try to figure it out\nusing this example i will say that the\nsolution i'm about to show you is not\nreally easy to figure out but once\nyou've seen it before it's pretty easy\nto implement and recognize when you can\nuse it so suppose we had this input\narray and you'll see why i wrote it this\nway in a moment so i'll just tell you\nthat this solution does require bit\nmanipulation so i'm going to take each\nof these values show them in their\nbinary representation so 4 for example\nis going to be 1 0 0. of course there's\ngoing to be some leading zeros but we\ndon't really care about those 1 is going\nto be represented like this 2 is going\nto be represented like this okay so this\nis the binary representation and once\nagain i'll just tell you the solution\nbasically we're going to use a binary\noperation called xor or exclusive or and\nif you don't know this operation\nbasically what it does is if two bits\nare the exact same so 0\nxor 0 is going to equal 0. also\nif they are the same meaning they're\nboth 1 this is also going to equal 0.\nbut if they're different so if we had 1\nand 0 that's going to be 1 and if we had\n0\nxor 1 that's going to be 1 as well so if\nthey're different we get one if they're\nthe same we get zero and the solution to\nthis problem is literally just taking\nall these input values xor them together\nand then our result is going to be that\nsingle value in this case that single\nvalue is 4. and if you just want to know\nthe solution to this problem that's\nliterally it but it never satisfies me\nso what i'm going to do is actually\nexplain a bit of the intuition behind it\nand the simple answer is that when you\ntake two values like two and two and you\nxor them together of course they have\nthe exact same binary representation so\nif you xor two values that are the exact\nsame of course you're gonna get zero uh\nall zeros in the output because you know\nthe bits here are the exact same the\nbits here are the exact same and they're\ngoing to be the exact same so if the\nbits are the same we get 0 in the output\nand the reason that's important is\nbecause we know that there's two twos\nright so these are going to cancel out\nwe know that there's two ones these are\ngoing to cancel out so we're going to be\nleft with only that single value and the\norder that you do the xor operation in\nis not important you can do it in any\norder and you're going to get the same\nexact result so that's the simple\nexplanation and i'll just talk for\nanother minute about if you didn't know\nthat xor can be done in any order could\nyou still figure this out what's the\nintuition behind it let me just talk\nabout that for a minute i'm not smart\nenough to figure it out just by looking\nat all of these bits but we know that to\nsimplify it we can just look at a single\ncolumn right just one of the positions\nand like i said we know that every value\nin the input is going to be a duplicate\nexcept for that single number so we're\ntrying to prove that we know for sure\nthat the bit in the output is going to\nbe the same bit\nthat comes from that single number which\nis right over here we know for sure it's\ngonna be zero how do we know that so\nwe're trying to prove that the output\nbit is always gonna be the bit that\ncomes from the single value how do we\nknow that well first i'm going to prove\nto you that this portion of the xor\noperation is always going to evaluate to\nbe zero how do i know that because first\nof all zeros in any xor operation i\ndon't change the result that means if we\nhad n and n could be either one or it\ncould be zero n x or\nzero is going to equal n that's pretty\nsimple if you look at a couple examples\nwe could have one x or zero that's going\nto be 1 we can have 0 x or 0 that's also\ngoing to be 0. so basically what i'm\nsaying is we can ignore all of the zeros\nhere so i'm going to scribble that out\nand scribble that out so then we're\ngoing to be left with a bunch of ones\nhow many ones are we going to be left\nwith well it's guaranteed to be an even\nnumber of ones i'm not counting this\nposition by the way i'm only counting\nthis portion and we know it's going to\nbe an even number of ones because we\nhave only duplicates here right it's\neither going to be zero ones or it's\ngoing to be two ones where it's going to\nbe four ones etc etc and we know that\nduplicates always cancel out one xor one\nis always going to be zero that pretty\nmuch shows that this entire thing is\nalways gonna be zero so uh so this is\ngonna be zero right and this is either\ngonna be a one or a zero and whatever it\nhappens to be is going to go exactly in\nthe output because like i showed a\nmoment ago n xor with 0 is always going\nto be n so that's going to be this bit\nand so basically what i showed you is\nnot really a formal proof but i showed\nyou an intuitive proof for just one\ncolumn but of course we could apply that\nto every single column so what we know\nis all of this is going to be gone and\nthis is going to be the output after we\ndo xor so we're going to return the\ncorrect result for and we didn't use any\nextra memory now let's jump into the\ncode now let's code it up and we are\ngoing to have a result and we're going\nto initialize it to zero and this is\nwhat we're going to store our x or\nresult in the reason we're initializing\nit to 0 is because like i mentioned any\nvalue\nn xored with 0 is always going to end up\nbeing n so this is a good default value\nto set it to and then we're just going\nto go through every single value in nums\ntake that n and x or it with the result\nand then set the result back equal to\nthat and then\nonce we've done that we\nlike i showed in the proof we know for\nsure that the result has that single\nnumber that we're trying to return so\nnow let's run the code to make sure that\nit works and yes it does as you can see\non the left it works and it's pretty\nefficient so i really hope that this was\nhelpful if it was please don't forget to\nlike and subscribe it really supports\nthe channel a lot consider checking out\nmy patreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Number of 1 Bits",
        "NcLink": "number-of-one-bits/",
        "Pattern": "Bit Manipulation",
        "Description": "You are given an unsigned integer `n`. Return the number of `1` bits in its binary representation.\n\nYou may assume `n` is a non-negative integer which fits within 32-bits.\n\n**Example 1:**\n\n```java\nInput: n = 00000000000000000000000000010111\n\nOutput: 4\n```\n\n**Example 2:**\n\n```java\nInput: n = 01111111111111111111111111111101\n\nOutput: 30\n```\n",
        "Difficulty": "Easy",
        "Video": "5Km3utixwZs",
        "PythonSolution": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            n &= n - 1\n            res += 1\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve number of one bits this is\nactually another blind 75 problem and\nwe've been tracking all blind 75\nproblems on this spreadsheet the link to\nthat will be in the description today\nwe'll be doing number of one bits one of\nthe last problems remaining that we\nhaven't done and i also have a youtube\nplaylist for the blind 75 solutions link\nto that will also be in the description\nif you do want to take a look okay so\nnow let's get into it we are told to\nwrite a function that takes in an\nunsigned integer which isn't really\nimportant for this problem because all\nwe want to do is count the number of one\nbits that it has so the concept is\npretty simple so when you take a look at\nthis number we can see it's made up of\nzeros and ones and we just want to count\nhow many ones it has clearly it has one\ntwo three so we can return three but how\ncan we actually count the bits so\nobviously we need to do a little bit of\nbit manipulation i'm going to be showing\nyou two different solutions one of the\nsolutions the second one is going to be\nslightly faster if you're interested in\nit and it's pretty difficult to come up\nwith but the\nfirst solution is a little bit more\nstraightforward and is more doable so\nlike i said the easiest way is just to\ncount manually bit by bit and then see\nwhich one of them is our ones and then\nincrement our total and then return the\ntotal but let's see how we can actually\naccomplish that so how do we know let's\nsay we want to look at the first a bit\non the right side how do we know if it's\na one or a zero well there's actually\ntwo different ways one way is you can\nand it with the integer one so\nsince the integer one just has a one\nhere and then the rest of them are zeros\nwhen we do a logic and operation logic\nand is basically taking the and of every\nbit but we know that every bit is gonna\nbe zero when we take the logic and\nit's gonna be zero for every bit except\nfor this one which can either be zero or\none it'll be one if the bit in the input\ninteger is one then we'll get a one in\nthe output if it's a zero over here then\nwe'll get a zero in the output so that\ncan tell us if there's a 1 here or a 0\nhere\nanother way to do it is just to mod this\nby 2. modding is basically taking this\ndividing it by 2 and getting the\nremainder since this is the ones place\nif we mod it by two and there is a one\nhere we'll get a one in the output if\nthere's a zero here we'll get a zero in\nthe output so we have two different ways\nto do it i think i'm gonna stick with\nmodding but you can do it either way\nokay so we have a way to detect if the\nfirst bit is a one or a zero but what if\nwe want to look at the next bit and the\nnext bit and the next bit how do we do\nthat well the easiest way would just be\nto take all the rest of the bits and\nthen shift them to the right by one and\nluckily most languages can natively\nsupport this and it's a very efficient\ncpu operation this is kind of the\npreferred way to usually do it in bit\nmanipulation just shift every bit to the\nright by one\nwe can achieve basically the exact same\nthing by taking this and then integer\ndivision by two dividing it by two will\nbasically shift all the bits to the\nright by one as well but usually the bit\nshift operation is a little bit more\nefficient on your cpu so that's what i'm\ngoing to prefer so basically we're going\nto take these shift them to the right so\nnow we're going to have a new integer 1\n0 1.\nagain we want to know if this bit is 1\nor 0. we're going to mod it by 2 we're\ngoing to get another one so so far we\nhave counted two\ntwo ones and again we would want to take\nthese shift them to the right this time\nwe get a one zero we mod this by two we\nget a zero in the output that means\nthere's a zero here so we don't add to\nour total this time and lastly we take\nthis shift it by one we get another we\nbasically get the integer one we mod it\nby two one divided by two the remainder\nafter that is just one so we got our\nthird one so our total so far is three\nones that we counted and lastly we're\ngoing to take this and then shift it to\nthe right but what exactly is going to\nbe remaining after we do that well\nbasically zero and once we have a zero\nit basically means we have all zeros\nright 32 bit integer we'll have 32 zeros\nand that basically means that we can\nstop our algorithm now and we're done so\nwe counted in total three ones and\nthat's what we can return so once you're\nfamiliar with these bit operations it's\na pretty straightforward problem so\nlet's code up the first solution okay so\nnow let's code it up i'm going to\ndeclare one variable for the result\nwhich is basically the total account the\ntotal number of ones that we're going to\nhave and i'm going to continue\ncounting the ones while n is greater\nthan zero or in other words while it's\nnot equal to zero which i can you know\ndo just like this and that'll work in\nmost languages i think and\nthen we want to know if the ones place\nis a one or a zero so we can take n and\nmod it by two now this will either be a\none or this will be a zero if it's a one\nthen we wanna increment result if it's a\nzero we don't wanna increment result so\nin other words we can just basically add\nthis to our result itself and then we\ndon't want to forget to\nshift everything to the right by one so\nwhat we can do is set an equal to itself\nbit shifted to the right by one after\nthat last thing we have to do is just\nreturn the result so now let's run it to\nmake sure that it works and as you can\nsee it does work and it is pretty\nefficient but what exactly is the time\ncomplexity of the solution\nwell the good thing is that we're\nguaranteed that every input is going to\nbe a 32-bit integer so we know that that\nwhile loop we had is going to run 32\ntimes so really the time complexity is\nbig o of 32 which is constant time right\nno matter what the input is the time\ncomplexity is not going to scale up so\nbasically the time complexity is\nconstant we can say it's big o of one\nand there's no real extra memory\ncomplexity needed as well so that's also\nbig o of one but a small downside of our\nsolution is it has to count it has to\nlook at every bit even the ones that\naren't ones so for example what if we\nhad a number like this in this case\nwe're gonna look at this bit first okay\nit's a one we're done with that then\nwe're going to look at this bit this bit\nthis bit this bit every bit here even\nthough they're zeros right that kind of\nwastes time wouldn't it be convenient if\nwe only had to look at the bits that\nwere one that meaning our algorithm only\nhas to run as many times as how many\nones are actually in the input and yes\nthere actually is a way we can do this\nbut it's not very easy to come up with\nand it's probably not even worth coming\nup with because the time complexity will\nbe the same it'll still be constant time\nand constant space but\nit might be good to just you know get\nreally good at your bit manipulation\ntricks and stuff and maybe you'll see\nthis in an interview so the main\noperation we're going to be doing in our\nwhile loop with this trick is basically\ntaking n and setting it equal to n\nlogic ended with n minus one and this is\nwhat we're going to do in every\niteration of the loop and each time we\ndo that we're going to increment our\nresult by one but the question is why\ndoes this work first let's see what will\nhappen so okay so what's gonna happen\nlet's take this integer and subtract one\nfrom it right that's what we're gonna do\nover here so n minus 1 which is going to\nbe\nthis and now we're going to logic and\nthem together what are we going to get\nwhen we do that we're basically going to\nbe removing this right this we're going\nto get n minus 1 itself and we're also\ngoing to increment our result by 1 now\nregardless of what the output happens to\nbe okay so now our n value is going to\nbe set to this okay so now our new value\nis going to be\n1 0 0 and all zeros okay now we're going\nto take this number and subtract one\nfrom it what what is that going to look\nlike in binary well it's going to be 0 1\n1 1 1 1 1 1. okay and now we are gonna\nlogic and these two together what's that\ngonna look like well we're logic handing\nevery bit this one is gonna turn into\nzero now and the rest of these are also\ngonna be zero even though we have ones\nin the bottom number we have all zeros\nin the number above so now we're\nactually done with our entire loop now\nwe have all zeros we incremented our\nresult by two so now our result is two\nand then we return right which makes\nsense because when you look at the\noriginal number we started with it yes\nit did have two ones in it but how did\nthis algorithm work well it's actually\nreally simple but it's definitely not\neasy to come up with what we're doing\nwhen we're subtracting one from itself\nis we're basically getting rid of a bit\nright when we took this number and\nsubtracted one from it we got rid of\nthis one bit right and remember we're\ncounting one bits so when we did that we\nincrement our result by one but then why\ndid we logic and it together with itself\nwell basically since the rest of the\nnumbers stayed the same and you know we\ntook this one away here and then we\nlogic and them together we're basically\nremoving that one bit so then when we\nwhen we logic ended these two together\nyou can see that the one bit was removed\nbut the rest of the number stayed the\nexact same on the left okay that works\nbut what about this number right then we\nwere left with this and then we\nsubtracted one from it then what did we\ndo well again when we subtracted one\nfrom it we basically got rid of the the\nnext one bit right you can see that when\nwe subtracted one from it this is what\nthe number looked like we got rid of\nthis one bit but we introduced a bunch\nof other one bits but these are all okay\nbecause we know they're gonna be and any\none bits that we introduce are going to\nbe on the right side and we know that if\nwe just deleted this one it was the it\nwas the right most one bit that we had\nso any ones that are introduced to the\nright side won't matter in this number\nthis is n minus 1 by the way any ones\nhere won't matter because remember every\ntime we do that we're logic ending them\ntogether we're logic ending n with n\nminus 1 so these are all gonna cancel\nout and this is going to cancel out as\nwell well the position where we you know\nremove the one bit so basically what\nwe're doing here is we're skipping all\nthe zeros in between we're basically\nallowing ourself to run the loop as many\ntimes as\nas basically as many one bits exist in\nthe input integer it's kind of a really\nweird trick but it definitely works and\nit makes sense why it works now we can\ncode it up and it's pretty simple so you\ncan see that this was our original\nsolution and we only have to modify this\na little bit so what we're going to do\nis get rid of this line and instead of\nincrementing our result by n mod 2 we're\nactually going to increment our result\nby one each time because each time we\nincrement this we are going to be\nsetting n equal to n\nanded with n minus one so we're going to\nbe counting the number of one bits\nexactly and this line can actually be\nslightly shortened\nby doing this in most languages and yeah\nso this is about as efficient as we can\nget we won't run any extra iterations of\nthis loop when we have zero so let's run\nit to make sure that it works and you\ncan see yes on the left side it works\nyeah the run time is about the same\nbecause it's still the same exact big o\ntime complexity but i hope that this was\nhelpful if it was please like and\nsubscribe it really supports the channel\na lot consider checking out my patreon\nwhere you can further support the\nchannel and hopefully i'll see you\n"
    },
    {
        "Name": "Counting Bits",
        "NcLink": "counting-bits/",
        "Pattern": "Bit Manipulation",
        "Description": "Given an integer `n`, count the number of `1`'s in the binary representation of every number in the range `[0, n]`.\n    \nReturn an array `output` where `output[i]` is the number of `1`'s in the binary representation of `i`.\n\n**Example 1:**\n\n```java\nInput: n = 4\n\nOutput: [0,1,1,2,1]\n```\n\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n\n**Constraints:**\n* `0 <= n <= 1000`\n",
        "Difficulty": "Easy",
        "Video": "RyBM56RIWrM",
        "PythonSolution": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        offset = 1\n\n        for i in range(1, n + 1):\n            if offset * 2 == i:\n                offset = i\n            dp[i] = 1 + dp[i - offset]\n        return dp\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nwe're going to be solving a binary\nquestion\ncounting bits and this is one of the\nbinary questions from the blind 75 list\nthat we've been tracking in the\nspreadsheet so we will finally be adding\na\nvideo solution to this binary problem\ni'm pretty sure it used to be a medium\nproblem which is why it's highlighted\nyellow but i think it got changed to an\neasy problem\nso the statement is pretty simple we're\ngiven an integer n and we want to return\nan answer array of length n plus one\nbasically a value for every integer in\nthe range from zero\nall the way up until n so if n happened\nto be\nzero then we would just return a single\ninteger if\nzero happened to be two then we would\nreturn three integers for\nzero one and two and basically for every\nvalue\nin this range zero to n so if n was two\nwe would have three values in that range\nzero one two for each of these values we\nwant to know what\nis the number of ones in the binary\nrepresentation\nof this particular integer now what's\nthe binary representation of zero it's\nof course just\nzero right you could add multiple zeros\nbut it's\nstill going to be zero what's the binary\nrepresentation of one\nit's going to be just one right you\ncould have some leading zeros we could\nhave as many as we want\nbut at the end it's just going to end\nwith a single one so there's only\none occurrence of the integer one in the\nbinary representation of 0.\nso so far our output is going to look\nsomething like 0\n1 and then now we just need the number\nof ones in the binary representation of\n2.\nthe binary representation of 2 is going\nto look like this 1\n0. you could have some leading zeros but\nthis is the main part that we're looking\nat so\nit just has a single one so then the\noutput is going to be\none for that so the array that we would\nreturn is going to look something like\nthis\nzero one one now the brute force way to\nsolve this problem\nis going to be n log n and that solution\nis going to look something like this\nlet's say we had an arbitrary\nvalue such as 2 or maybe even 3 right we\nknow the\nbinary representation of 3 is going to\nlook like 1\n1 right so how are we going to count the\nnumber of ones\nin the binary representation of three\nwell we first let's get the ones place\nright is this gonna\nis this gonna be a one or a zero how can\nwe get that well we can take three\nmod it by two which is gonna give us one\nso we have at least\none one here right so we already looked\nat this position so what we do is\nbasically cross it out and then we just\nwant to look at the remaining\nportions now how can we actually do this\nuh like what kind of operation can we do\nbasically if you take\nthree and divide it by 2 integer\ndivision here\nand most programming languages will do\nthis basically by integer division\nwhat that's going to do to this integer\nis it's basically going to take that\nones place and remove it\ntake the remaining bits and then shift\nit to the right so it basically does\nexactly what you would want to do\nand of course what do we get when we\ntake 3 and divide it by 2\ninteger division is going to give us a 1\nso we're basically going to get this\nand when you look at that yes this is\nthe binary representation of 1\nright so now we're gonna take this and\nmod it by two as well we're taking one\nmodding it by two that's also gonna be a\none\nso so far we've counted two different\nones for this integer\nand again we're gonna take this uh\nthis one's place now and chop it off and\nnow we're left with a single zero so if\nyou take one\ndivided by two yes you get zero once we\nget to zero that's how you know when\nwe're stopping\nright there's obviously in zero there's\nno more ones\nin zero so basically we counted two\ndifferent ones\nso that's how we would do it for every\nparticular integer the example i showed\nright now is three\nand to get this the time complexity is\nlog\nn because for any integer n how many\ntimes can you divide it by two well of\ncourse\nthat's just log base two n now we don't\nreally worry too much about the base\nusually but yes it's gonna be log n\nlog base two n that's how many times we\ncould divide any particular integer\nn by two and of course we know we're\ndoing this for a bunch of integers in\nthe range\nall the way from 0 to n so we're doing\nthis n times\ndoing a log n operation n times\nis going to be time complexity and log n\nnow there's some repeated work\nthat we can eliminate that you can\neasily recognize when you actually draw\nout the bit mappings\nthe the binary representations of a\nbunch of integers and with that repeated\nwork we can actually get a working o of\nn\nsolution let me show you that right now\nnow i just drew out the binary\nrepresentations from zero all the way up\nto eight so we know that of course\nzero has zero ones in the binary\nrepresentation\nwhen you get to one we have one\noccurrence of one in its binary\nrepresentation for two we have\none for three by looking at this we can\nsee we have two different ones\nand now when you get to four you really\nstart to notice how we are doing this\nrepeated work\nnotice how for four all the way to seven\nwe have a\none in this place right in the most\nsignificant place\nwe have a one and notice how the\nremaining portion\nof this and then this and then\nthis and this these four\nare just repeats of the previous four\nthat we calculated right because\nwe're you know we're counting zero zero\nadding a one\nright to four when you add a one you\njust change it to this from four when we\nadd a two\nwe get this which is basically the\nbinary representation of two itself\nright and then you get a one zero and\nthen you get a one\none which is matching over here so now\nlooking at it this is the binary\nrepresentation of\nfour right there's just a single one in\nthis position\nso if we wanted to take zero and add\nfour to it we would just\nto take this position and add a one here\nright that will take us\nfour positions ahead and if you had a\none\nand you and you changed this bit to a\none we're adding four to it so you can\ntake\na one and change it to a five by taking\nthat bit\nso similarly when we get to four\nwe know that yes we're gonna have one\nextra one\nin this position right because we just\ngot this one this one represents a four\nthis is the most significant bit so far\nbut for the remaining ones all we have\nto do\nis take this offset it by four\nand get here and count how many ones\nwere over here so when we're calculating\nhow many ones\nfor four we're just saying it's one plus\nthe number of bits at position\nzero how many bits how many ones were in\nposition zero that's our dp so you can\nsee this is a dynamic programming\nproblem because we're using the previous\nresults that we calculated\nto compute the new results in other\nwords this is going to be 1\nplus dp of n minus\n4 and actually when you look at this 5\nwe're also offsetting it by 4 to get\nthese two right because that's what's\ngoing to match up with\nthis which is going to tell us how many\nones are going to go here right so and\nclearly\nwe see that that's a 1. so here we're\ngoing to compute\n1 plus again dp of n\nminus 4. and similarly for here we would\nsay\none which is coming from here plus the\nnumber of ones\nin this binary representation which we\nknow we already computed\nup over here and the answer to that was\none so in this position\nreally there's going to be two ones in\nthis binary representation now over here\nonce again\nwe know that there's at least one from\nhere plus how many were in this binary\nrepresentation we computed that\nat position three which again is offset\nby four\nso this is going to be one plus two\nwhich is going to be 3.\nnow you get over here so now we have an\neven more significant bit last time the\nmost significant\nbit was in this position and we know\nthat represents the integer\n4. now we got an even more significant\nbit\nwhich represents the integer a so\nwe know that this is going to have at\nleast one occurrence of one and then we\nwant to know how many\nones are in this binary representation\nnow\nhow are we going to get that in this\ncase you can tell\nthe the offset is no longer four because\nif we do an offset of four we get to the\ninteger four that's not what we're\ntrying to do\nthis binary representation represents\nthe integer zero so in reality\nwe want to take eight offset it by 8\nwhich is going to get us all the way\nover here\nand once you do that that's when you\nactually notice the pattern since this\nis going to be\n1 plus dp of n minus\n8 you can tell that for each value\nthis is going to be the equation 1 plus\ndp of n minus a particular integer\nand that integer is going to be called\nthe offset\nand the offset is going to be the most\nsignificant\nbit that we have reached so far and what\nare the most significant bits well the\nfirst one is going to be a one\nthe next one is going to be a two the\nnext is going to be a 4 8\n16. so basically they're doubling in\nsize every time because we know a bit is\njust a\npower of two right that's what binary\nrepresents so let's clean this up just a\ntiny bit\nso we know that this is kind of our base\ncase zero is going to have zero ones in\nit\nnow in the next position what's the most\nsignificant bit we've reached so far\nit's in the ones place right so\ntherefore it's going to be a 1. so when\nwe're computing\nthis we're going to compute 1 plus dp\nof n n is always going to be the value\nwe're computing right now so that's\ngoing to be a 1\nminus 1 because 1 is the most\nsignificant bit we've reached so far\ndown here we reached a new significant\nbit of 2\nright because we've gotten to the value\n2 so far so\nfor here we're going to say 1 plus dp of\nn minus\ntwo now in this next position again the\nmost significant bit is\ntwo right we we know that two is a\nsignificant bit\nthe next significant bit is going to be\nfour because that's another power of two\nso\nthree is not a it's still going to use\nthe previous value\nso from here we're going to compute 1\nplus again dp\nof n minus 2. now once you get here\nwe see that we've reached a new power of\n2.\nso then we're gonna be modifying this to\none plus dp\nof n minus four and then of course when\nwe got to\neight we know we reached a new power of\ntwo so we were gonna do one plus dp of n\nminus eight\nhow do you know if you reach a new power\nof two well you can take the previous\npower of two for example it was two\nright\nlet's say the current power of two is\ntwo let's say we multiply it\nby two does that equal the current uh\nvalue where if we got to three n equals\nthree\nwe would check does two times two equal\nthree no it does not so we did not reach\na new power of two\nif we if we got to four two times four\nthat does equal\nfour so now we reached a new power of\ntwo and then\nfrom four we would do the same thing so\nfour multiplied by two\ndoes that equal to seven right let's say\nwe got to seven and we were trying to\nsee\nis this a power of two no this does not\nequal seven but once we get to\neight then four times two yes that\nequals eight right so we did reach a new\npower of 2 and we'd do the exact same\nthing\nso the next time we would reach a new\npower of 2 is would be 8 times 2\nequals 16. so next time we reach a 16\nthat's going to be a new power of 2\nand 16 times 2 is 32 etc etc so that's\nhow it's going to work\nand once you know this idea it's not\nsuper intuitive until you actually kind\nof draw it out\nbut once you do the code is actually\npretty easy to write let me show you how\nso our dp array is going to be\ninitialized to all zeros and it's going\nto be length\nn plus 1 because that's how many we're\ntrying to compute and we're also going\nto have an answer\narray which is initially just going to\nhave a single zero in it because we know\nn is going to be at least zero and then\nwe're going to go through for i\nin range all the way from one up until n\nso n plus one this is non-inclusive in\npython so we're actually going to be\nstopping when we go from one all the way\nup until n\nand we're going to be keeping track of\none more variable the offset aka the\nhighest power of two so far so initially\nthat's gonna be\none so before we actually compute the dp\nor the number of bits in this\ninteger i's binary representation first\nwe're going to check how\ncan we double our offset we're going to\ncheck if\noffset multiplied by two is equal\nto i the current end that we have just\nreached if it is then we can set\noffset equal to i otherwise offset is\ngoing to stay the same\nand then we can actually compute the dp\nso we're trying to compute dp of i\nwhich is basically the number of bits\nthe number of ones in i's binary\nrepresentation we know that's going to\nbe at least\n1 plus dp of i\nminus the offset and actually one thing\ni just realized\nis the dp and the answer array are\nactually the exact same i don't know why\ni even created an answer array we can\nget rid of that so this dp is basically\nour answer array it's going to give us\nthe number of bits the number of one\nbits in each integer's binary\nrepresentation so once\nonce we're done with that we can go\nahead and just return this dp array\nso as you can see this is a pretty\nefficient solution this is the linear\ntime big o of n\ntime and space solution i hope this was\nhelpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Reverse Bits",
        "NcLink": "reverse-bits/",
        "Pattern": "Bit Manipulation",
        "Description": "Given a 32-bit unsigned integer `n`, reverse the bits of the binary representation of `n` and return the result.\n\n**Example 1:**\n\n```java\nInput: n = 00000000000000000000000000010101\n\nOutput:    2818572288 (10101000000000000000000000000000)\n```\n\nExplanation: Reversing `00000000000000000000000000010101`, which represents the unsigned integer `21`, gives us `10101000000000000000000000000000` which represents the unsigned integer `2818572288`.\n",
        "Difficulty": "Easy",
        "Video": "UcoN6UjAI64",
        "PythonSolution": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            bit = (n >> i) & 1\n            res += (bit << (31 - i))\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem reverse bits and\nthis happens to be another problem from\nthe blind 75 list or list of common leak\ncode problems that we've been tracking\nin this spreadsheet we have a solution\nfor the vast majority of them and i'll\nbe doing a few more of the binary\nquestions the one today we'll be doing\nis this one reverse bits so this is a\ngood problem to kind of go over and\nlearn or refresh yourself on the bit\nmanipulation operations so we're given a\n32-bit unsigned integer and basically we\nwant to reverse all of the bits of this\ninteger so like in this example this is\nthe integer represented in binary of\ncourse we might not be given the integer\nin binary you know that we might be\ngiven the integer 4 which in binary we\nknow it looks like this and then we'd\nwant to reverse\nall of the bits for it so basically\nwe would you know the reversal is going\nto look something like this\nright and then we want to return that\nreversed integer of course we'll be\nreturning a one value so let's say this\nis the 32-bit integer and let's just say\nit's four just because we don't want to\ndo a super long binary integer like this\nthere are many ways to kind of do this\nproblem right suppose we declare an\noutput variable for result and this is\nwhere we put the last bit the\n31st bit and then over here is where we\nput the zeroth bit right so we have 32\nbits in the output initially we'll just\nset all of these to\nzero right\nso we want to go bit by bit in the input\nright we'll start at the ones bit we\nwant to get what is over here if it's a\nzero or if it's a one and then we want\nto take it and then put it over here in\nthis case it's a zero so we're just\ngoing to put a zero over here right\nbasically we're reversing right we're\ntaking the bit from here putting it in\nthis spot right just in reverse order\npretty much like we would do with\nreversing a string next we're gonna go\nto this one put it in the next spot so\nwe'll have another zero here and then\nwe'll take a look at this one put it in\nthe next spot so we'll have a one here\nand then since the remaining of all of\nthese are zeros then we're just gonna\nhave zero zero zero uh in the entirety\nof this so uh obviously before when i\nshowed us just reversing these four we\nended up getting an output of one but\nyou can see when we actually do it with\n32 bits the result changes right so and\nthey specifically tell us this is just a\n32-bit integer so this is going to be a\npretty large integer and we're this is\nwhat we're going to end up returning\nright so it's pretty straightforward to\nunderstand what exactly we're doing at\nleast with the solution that i'm showing\nyou now the question is how can we\nactually do these operations for example\nhow can we go bit by bit get the first\nbit get the next bit get the next bit\nall the way until we get to the end\nright how can we go and get each bit\nwell one way in binary is to just take\nuh this bit right and it with a one the\nand operation right logic and what we're\nsaying is if\nsince this is a zero right if we take\nzero\nand it with one we get the output to\nthat is going to be zero right which\nmakes sense because we want to know if\nthis is a zero or a one so if we end it\nwith a one we'll get zero if this value\nis a zero that's exactly what we want if\nthis value is a one and we end it with a\none then we get one right which which is\ngood because if this is a one then we\nwant to get a one in the output so\nthat's the operation we're going to do\nlogic and to figure out what the bit is\nnow that's easy in the case we're just\nlooking at the ones place over here but\nwhat if we want to look at this next\nspot we want to look at the\nuh two's place right and then what if we\nwant to look in this spot etc etc how\nare we going to do that well instead of\ntaking this input value and then ending\nit with a one we're going to end it with\na one\nshifted to the left each time we you\nknow move a different spot in the input\nright how can we shift a one to the left\nthat's also another binary operation so\nfor example if we had something like\nzero one and then we do the shift\noperation to the left this is a bit\nshift operation if we shift it to the\nleft all what it does is it shifts all\nof the bits to the left by one and it\nreplaces the one spot with a zero so in\nthe output we'll get this when we shift\nthis by one we'll get this we'll have\nshifted the bit to the left by one and\nnotice how if we have a one over here\nand then a zero over here and then we\nhave zeros all the way for the remaining\nof it when we get the output value it's\nalso going to be a 32-bit integer right\nbut this is the only spot we're gonna\ncare about because the rest of the spots\nare gonna be zero by default because if\nwe and zero with anything else we're\ngonna get a zero in the output whether\nyou know we have a one over here or not\nif we and these together we're gonna get\na zero in the output okay so that covers\nhow we're gonna get each of these bits\nnow how are we going to put them in the\noutput remember how initially we had a a\nresult that was just filled with zeros\nright and we're going to start at the\nbeginning take every you know if we have\na one here we want to insert this one\nover here if it's a zero over here then\nwe just want to leave the output as a\nzero and then we want to move to the\nnext spot to the right and do the exact\nsame thing so we're going to follow a\nsimilar pattern here if we had a 1 we\nwould take the 1 shift it to the left by\n31 right because that's going to be the\nspot all the way to the left we're going\nto take this shift it to the left by 31\nso then we'll have a suppose a 1 here\nand then 0 0 0 what we want to do in\nthis case is not logic and but we want\nto do logic or when we're trying to\nfigure out what to replace it with so\nfor example if we had a 0 here we would\nwant to replace this with a 1. it works\nbecause we take 0 or it logic or it with\n1 we get a 1. if we take 0 logic or it\nwith a 0 we get a 0. so if we had\ninstead of having a 1 here if we just\nhad a 0 here we wouldn't want to replace\nthis we won't want to leave it as a 0.\nso that's what logic or can accomplish\nfor us and similar to the previous\nexample if we had something like this\nand we were trying to logic or this\nright we would want to put this one in\nthis spot we don't want to get rid of\nthis one right suppose we had already\nput a 1 over here we don't want to get\nrid of it so notice how if we if we if\nwe take this logic or it with this we\nwill end up changing this bit this will\nbe changed to a one but this bit will\nstay the same which is what we want to\ndo because if we're gonna have a zero\nhere and we're gonna have zeros in every\nother position the other remaining bits\nare not going to end up getting changed\nif they are ones they're gonna remain as\nones if they're zeros they're gonna\nremain as zeros so those are some kind\nof basics about bit operations logic and\nlogic or\nbit shifting and that's kind of all you\nneed to be able to solve this problem in\nthe simplest way so now i think we are\nready to dive into the code and it's\ngoing to be a little bit shorter than\nyou might expect let's declare that\nresult variable that i said so it's\ngoing to be a 0 meaning all 32 bits of\nit are going to be initialized as 0 and\nwe're going to go through every single\nbit in the input end so i'm going to say\nfor i in range 32 because we know it's\ngoing to be up to 32. i think we could\nchange the logic of this while n is\nyou know non-zero and we could\ncontinuously update n i'm just going to\ndo it this kind of simple way so\nremember the first thing we want to do\nis we want to get the i th bit of n so\nhow can we do that well remember we were\ngoing to take n\nand it with 1 to get the i bit but if we\njust end it with 1 every single time\nwe're only going to get the first bit\nright we want to get the i bit so\ninstead of ending it with one well we\ncan take n shift it to the right by i i\ndon't think that's what i said in the\ndrawing picture i thought i think i said\nwe're gonna take the ones a bit and then\nshift it to the left but if we actually\ntake n shift it all the way to the right\nthen in n we will have the the target\nbit that we're looking for and it will\nbe in the one spot so then we can just\ntake this and end it with one and then\nwe'll get the result bit that we're\nlooking for in the ones spot so this bit\nwill be either one or it will be zero\nand then we want to logic or it with the\noutput to put that bit in the output how\ncan we do that is it going to be enough\nto just say result logic or the bit no\nbecause if we do it like this we're only\ngoing to be updating the one spot of\nthis result but we want to be updating\nit in the reverse order we want to start\nat the largest bit and then work our way\ndown how can we do that well we have\nthis i variable right it's going to go\nfrom 0 to 31. so how about we do this we\nshift our bit to the right by 31 minus i\nso on the first iteration of the loop we\nwill be getting the first bit from n and\nputting it in the 31 spot of the result\nand the next iteration will be doing the\nopposite will be getting the bit in\nindex 1 from n and putting it in index\n30 in the output so then we're going to\nkeep doing that and\nthis is the operation we're doing and we\nwant to set the result equal to the\nresult of this logic or operation and\nthat is the entire code once we're done\nwith that we can go ahead and return the\nresult so this is the simplest way to do\nit it is constant time big o of one\nbecause we're guaranteed that there's\ngoing to be 32 bits so\nthe solution is not going to scale\nregardless of whatever the input n is as\nlong as it's 32 bits and where you know\nthe memory we're using as well is just a\nsingle variable right so this is just an\no of one time and space solution so i\nhope that this was helpful i hope it\ntaught you a little bit about binary\noperations if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Missing Number",
        "NcLink": "missing-number/",
        "Pattern": "Bit Manipulation",
        "Description": "Given an array `nums` containing `n` integers in the range `[0, n]` without any duplicates, return the single number in the range that is missing from `nums`.\n\n**Follow-up**: Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3]\n\nOutput: 0\n```\n\nExplanation: Since there are 3 numbers, the range is [0,3]. The missing number is 0 since it does not appear in nums.\n\n**Example 2:**\n\n```java\nInput: nums = [0,2]\n\nOutput: 1\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n",
        "Difficulty": "Easy",
        "Video": "WnPLSRLSANE",
        "PythonSolution": "class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        res = len(nums)\n\n        for i in range(len(nums)):\n            res += i - nums[i]\n        return res\n",
        "Transcript": "hey everyone welcome back and let's\nwrite some more neat code today so today\nlet's solve the problem missing number\nand this is another problem from the\nblind 75 list a list of commonly code\nquestions we've been tracking this is\nmissing number in the binary category\nyou'll see why in a moment and the link\nto this sheet will be in the description\nif you do want to take a look we have\nsolved most of the problems in this list\nso far so let's continue so the thing i\nlike about this problem is that there's\nso many different solutions to this\nproblem even though it's an easy problem\ni think it's a good problem to just\nunderstand a lot of the different\nsolutions involved with this problem you\ncan definitely learn a lot so we're\ngiven an array of numbers containing n\ndistinct numbers in the range 0 to n\neven though this range actually has n\nplus 1 numbers inside it we're only\nchoosing n distinct numbers from this\nrange and we want to return the only\nnumber that's missing from this array so\nwe want to find the missing number from\nthis range that that we did not pick\nthere are many different ways to solve\nthis problem the follow-up is can we\nimplement a solution with o of one extra\nspace and o of n run time complexity\nthat's going to be the challenge and\nactually there's two different ways we\ncan arrive at such a solution i'll show\nyou both of them because they're both\npretty interesting okay so in the first\nexample we're given three distinct\nnumbers because the length of this is\nthree so the range that we're looking at\nis from zero to three right there's four\ndifferent numbers in this range zero one\ntwo and three but we've only chosen\nthree of them in our input we want to\nfind the one that's missing so we can\nkind of just go through this input right\nthree okay\nthe missing number is not three zero the\nmissing number is not zero one the\nmissing number is not one so the only\nremaining number is two so two is the\nmissing number that was a pretty easy\nway to solve the problem what exactly\ndid we do right now well you could have\nyou could think about this list of\nnumbers as basically a hash set or hash\nmap or whatever you want and we're\nbasically iterating through the list of\nnumbers and then crossing out the ones\nthat are already uh and contained in the\ninput list so basically we used o of n\nextra memory with a hash set or map and\no of n time complexity because we had to\niterate through the input array so\nthat's actually the most simple solution\nright using hashing to do this problem\nbut it does take of n extra memory the\nfollow-up was can we do this in o of one\nextra memory there are two different\nways actually that at least i know of\nthat you can do that so let me show you\nboth of those right now so one of the\nways that we can solve this problem with\no of one memory is going to be needing\nsome binary properties and if you've\nnever really heard of this there's no\nway you can kind of figure out this\nsolution\nat least this binary solution it's going\nto need the xor operator the exclusive\nor operator if you don't know what this\nis let me show you let's suppose we had\ntwo numbers let's say we had two and we\nwant to exclusive or it with three this\nis the symbol that you use for exclusive\nor so we're taking two and exclusive\noring it with three\nso this is a binary operation so we're\ngoing to look at the binary\nrepresentation of 2 which is going to be\n1 0 we're going to look at the binary\nrepresentation of 3 which is going to be\n1 1. we're going to exclusive or these\nhow do you exclusive or you look at each\nbit and if only one of them basically if\nthey're different\nif both of the bits are different one it\nmust be a zero and one must be a one\nthey could be swapped right it could be\none zero or zero one but they need to be\ndifferent and if they are different then\nthe output is going to be a one if\nthey're the same in this example they're\nboth one or if they were both zero that\nmeans they're the same so then in the\noutput we're going to have a zero so you\ncan take two numbers like two and three\nexclusive or them and we get in this\ncase an output of one so why is\nexclusive oring going to be helpful for\nus in this problem well my question to\nyou is what happens when we take two\nnumbers that are the same and then try\nto exclusive or them so five together\nwith five so five in binary i think is\none zero one so if we exclusive or these\ntogether what's going to happen well\nwe're gonna look bit by bit it's gonna\nbe the same so we're gonna get a zero in\nthe output again it's gonna be the same\nwe're gonna get a zero in the output\nright if there's 0 0 or 1 1 they're the\nsame similarly in this case\nit's going to be 0 right because of\ncourse when you take two numbers they're\ngoing to have the exact same binary\nrepresentation if you exclusive or them\ntogether we're going to get 0 in the\noutput because they're the exact same\nright they're always going to be the\nsame\nso the exclusive or is going to give us\na 0. why is this helpful for us in\nsolving this problem well basically the\norder in which we exclusive or numbers\ndoes not matter for example if i took 5\nexclusive or 5 and then exclusive or 3\nwhat's going to be the output of this\nwell as we just determined 5 exclusive\nor with 5 is going to evaluate to zero\nright so then the problem is going to be\n0 exclusive or with 3. what happens when\nyou take a number and an exclusive or\nwith 0 well you just get the original\nnumber why is that the case let's look\nlet's say we had\n1 1 this is our 3 and then 0 is 0 0 0\nand if we exclusive or this we're just\ngoing to take all the ones in 3 and put\nthem in the output right because this is\ngoing to evaluate to 1 this is going to\nbe 1 and then 0 0's which is going to be\nthe rest of this thing is also is just\ngoing to evaluate to zero so the output\nwhat we get here as you can see is the\nnumber itself three so when you take\nthree uh\nexclusive or with a zero we get the\nthree uh and the thing i'm getting at is\nthis operation it doesn't matter the\norder that you do it and if you do five\nexclusive or three and then exclusive or\nfive uh we're still going to get a three\nin the output because five exclusive or\nwith three is going to be something sure\nbut basically what i'm saying is the\norder does not matter right we can say\nyou know five exclusive or with five\nfirst then these kind of cancel each\nother out and then we're left with the\nthree so why is this going to be helpful\nyou might be able to figure it out by\nnow uh because i've kind of explained\nmost of the logic here so how are we\ngoing to use this simple fact to get the\nanswer get the missing number from this\nrange that we're given 0 to 3\nwe know one of the numbers happens to be\nmissing how are we going to do that well\nwe know one of these numbers is missing\nfrom this array right so what are we\ngoing to do we're going to take the\nthe range 0 1 2 3 exclusive or it with\nthe input array in this case it's 0 1 3\nright we're missing the 2. what's going\nto happen when we do this operation this\nexclusive or operation well the zeros\nare going to match right the zeros are\ngoing to cancel out the ones are going\nto cancel out right we're going to get\nrid of the ones the threes are going to\ncancel out as well and then once\neverything is cancelled out the two will\nbe remaining because it's the only\nnumber that didn't show up twice because\nthis was the missing number this two was\nthe missing number so then once the into\nthis entire exclusive or operation is\ndone we'll be left with a 2 which is the\nanswer in this case and we did it with o\nof 1 memory because we just had to\nreally iterate through every number in\nthis\ninput array exclusive or them together\nand then iterate through every number\nbetween 0 to 3 exclusive or them with\nthe result of the exclusive or over here\nand then once all of those exclusive ors\nare done it's basically a linear time\nfunction it's going to be 2 2n because\nwe're iterating through this array and\niterating through that so it's going to\nbe o of 2n the time complexity the\nmemory complexity is going to be of 1\nbecause we didn't need anything extra\nand this solution is pretty easy to code\nup but there's actually one additional\nsolution that i think is interesting for\nthis problem that i'm gonna quickly go\nover let me explain how we're gonna\narrive at the next o of one memory\nsolution and then i'm actually gonna\nshow you how to do it the simple idea is\ngonna be this what if we took the sum of\nthis range 0 to 3 right basically the\narray from 0 1 2 to 3. we took the sum\nof this array subtracted from it the sum\nof the input array right right if we did\nthat we took the sum of this subtracted\nby the sum of the other array we would\nbe left with 2 right because 2 is the\nmissing number 2 is the only number that\nshows up here that does not show up here\nand then the difference is going to be\n2. that's really easy now of course\ntaking the sum of this array would be o\nof n and to compute this it would also\nbe o of n so the overall time complexity\nis going to be 2n and we're not g we're\njust going to be maintaining two sums uh\nfor each of these arrays right we're not\nactually going to be conti using any\nextra memory so the overall memory\ncomplexity is going to be big o of one\nso this is probably the easiest solution\nthat you can arrive at with just o of\none memory right this is probably the\nmost intuitive one so this is the one\ni'll be coding up but just so you know\nyou can actually calculate this sum\nyou actually don't need a loop you can\nactually do it in o of one time using\ngauss's formula but that's something you\ncan probably read more about on your own\nbecause it's a little bit extra for this\nproblem so now let's get into the code\nwe're going to initially set our result\nto zero or are we because what we want\nto do like i said is iterate through\nthis input array nums and then second\niterate through another array basically\nthe array from zero to the length of\nthis array nums right\nand then just kind of add those together\nright we're adding the values from this\narray 0 to n and subtracting the values\nfrom the input array but we don't need\ntwo loops to do that because since we're\nadding these values\nthese values are going to be from 0 to\nn but we can use the index from this\narray nums to actually replace these\nvalues it's more simple than i'm going\nto be able to explain so let me actually\njust show you what we're going to do\nbefore i actually uh you know try to\nexplain it so we're going through i in\nrange length of the input array num so i\nis just the index right but we're going\nto be using i we're going to say a\nresult we're going to add to the result\nthe i value we're going to be adding\nthis index right that's what we're going\nto be doing and we're going to be\nsubtracting the number from nums right\nnums of i we're going to add i but\nsubtract nums of i from this result why\nare we doing that because remember we\nwant to add every value from here from\nthis\nrange it to our result but we want to\nsubtract every value from nums obviously\nwe're subtracting every value from nums\nbut we want to add every value from this\nrange so with this loop we're going to\nbe adding every value from 0 to the\nlength minus 1 because i\nbecause i is only going to go through\nevery position from 0 to the length\nminus 1 uh let me actually correct this\nbefore we get an error uh this is going\nto be length minus one right we want to\niterate through every position of nums\nso basically what i'm getting at is for\nthis result we actually have to\ninitialize not the result to zero but\ninitialize it to the length of nums\nbecause we want because with this loop\nwe're going to be adding i uh is it from\nzero to length minus one we're going to\nbe adding that to the result but we also\nwant to add the final value length of\nnums which is basically our n value and\nthat's pretty much the explanation i\nprobably over complicated it in this\ncase it's a little more simple than you\nmight think\nbut this is the easiest way to do it\nwith one loop then we can go ahead and\nactually return that result actually i\ndon't actually need this minus one\nbecause i just remembered that python\nthe way python works is i will\nimplicitly it'll it'll stop before it\nactually gets to length of this it'll\nbasically be a length of nums minus one\nbut by default in python we can go ahead\nand run the code and you can see that it\nis very efficient so i hope that this\nwas helpful if it was please like and\nsubscribe it supports the channel a lot\nand i'll hopefully see you pretty soon\n"
    },
    {
        "Name": "Sum of Two Integers",
        "NcLink": "sum-of-two-integers/",
        "Pattern": "Bit Manipulation",
        "Description": "Given two integers `a` and `b`, return the sum of the two integers without using the `+` and `-` operators.\n\n**Example 1:**\n\n```java\nInput: a = 1, b = 1\n\nOutput: 2\n```\n\n**Example 2:**\n\n```java\nInput: a = 4, b = 7\n\nOutput: 11\n```\n\n**Constraints:**\n* `-1000 <= a, b <= 1000`\n",
        "Difficulty": "Medium",
        "Video": "gVUrDV4tZfY",
        "PythonSolution": "class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        def add(a, b):\n            if not a or not b:\n                return a or b\n            return add(a ^ b, (a & b) << 1)\n\n        if a * b < 0:  \n            if a > 0:\n                return self.getSum(b, a)\n            if add(~a, 1) == b: \n                return 0\n            if add(~a, 1) < b:  \n                return add(~add(add(~a, 1), add(~b, 1)), 1)  \n\n        return add(a, b)  \n",
        "Transcript": "everyone welcome back and let's write\nsome more neat code today so today let's\nsolve sum of two integers and finally\nthis is actually the last blind 75\nquestion that we have to do on this\nchannel we've been tracking all the\nblind 75 problems on the spreadsheet\nlink will be in the description if you\nwant to take a look i've actually\nfinished all the questions even a couple\nof them that are blank i've recorded\nthose and this sum of two integers is\nfinally the last blind 75 question we\nhave remaining okay now let's get into\nthe problem so we're given two integers\na and b and we want to return the sum of\nthese two integers and the only catch is\nthat we have to do this without using\nthe plus and minus operators and that's\ndefinitely going to make this tricky and\nby the way don't uh pay attention to\nthis dislike up above so i'm sure you\nknow how addition works we have one plus\ntwo and the output is going to be three\nso if we can't use plus and minus we\nhave to get creative and by creative we\nmean bit manipulation so when we look at\nthe integer 1 it's going to look like\nthis in binary representation the\ninteger 2 is going to look like this so\nwe know of course if we add these right\nwe can do it digit by digit this is\ngoing to be 1 this is also going to be 1\nand this is the binary representation\nfor 3. so that works but of course we\nhave to do it without doing the plus\noperation so we're gonna have to do some\nkind of bit manipulation operation on\neach of these bits so let's think about\nthis if we had a one and we had a zero\nwe know that adding these two together\nis gonna give us a one in the output but\nwe can't use addition what kind of\noperation logical operation could we do\non these two bits to figure out that the\nanswer is one we know that this could be\na zero and this could be a one or this\ncould be a zero and this could be a one\nand adding these together still would be\na one in the output so if one of these\ndigits is a one we will have a one in\nthe output but what would happen if both\nof these digits were a one then we'd\nhave a zero in the output and we'd have\na one that's a carry value that we're\ngonna you know shift left and then add\nthat carry to the remaining digits and\nby the way we could also have two\nzeros and of course zero added together\nwould be zero so what we really\ndiscovered is that if one of these is a\none digit only one of these is a one\ndigit then we'll have a one in the\noutput but if they're both ones then\nwe'll have a zero in the output and if\nthey're both zeros then we'll also have\na zero in the output so what we have\ndiscovered is actually a logical\noperator called xor or exclusive or it\nbasically means only one of these two\ndigits is one then you'll have a one in\nthe output if both of the digits are the\nsame then we'll have a zero in the\noutput and that's exactly what we need\nin this problem so xor works if we have\ntwo ones here though and we do the xor\noperation we're gonna get a zero\nin the output digit which is exactly\nwhat we want but we also want a one\ncarry how do we get that one carry well\nyou first have to ask yourself in what\ncase are we going to have a carry digit\nright when are we going to have this\ncarry well if we have two zeros we're\ndefinitely not going to have a carry if\nwe have a single zero then we're also\nnot going to have a carry but if we have\ntwo ones this is the only case that\nwe're going to have a carry so how do we\nknow if we have two ones well we can use\nanother logic operator called the and\noperator so if a and b are one then we\nknow we'll have a one carry but that one\ncarry is not going to be added over here\nthat one carry is gonna be in\nthe left spot it's gonna be shifted to\nthe left by one so actually when we do\nthis a and b operation we want to take\nit and then shift it to the left by one\nand then take this or this new integer\nthat we've discovered right and then\ntake that and then add it here so we're\nactually gonna have a loop we're gonna\ndo an xor operation and then if we have\na carry value we're going to actually\ntake that new carry value and then add\nit again to whatever we have left\nremaining now let's try this idea that i\njust talked about on one of these\nexamples and what we're going to figure\nout is actually when we're doing these\nlogic operators we don't have to do them\none by one we can do them on the\nentirety of a and b that we're given\nokay so now let's take a look at an\nexample we want to add a which is the\ninteger 9 in binary representation it\nlooks like this and we want to add b\nwhich is 11 and this is what it looks\nlike in binary representation well we\nwant to add them but we know we can't\nuse plus and minus so\nwhat we're gonna do is run the exclusive\nor operation which in code i think it\nlooks like this we want to run the\nexclusive or on these bit by bit and we\ncan do it on the entire integer a and b\nif we exclusive or them together uh\nfirst this bit well they're both one so\nthat's going to be a zero in this case\none of them is a one so we're going to\nhave a one in the output in this case\nthey're both zero we have a zero in the\noutput in this case they're both one we\nhave a zero in the output but what\ninteger is this this is just the integer\ntwo but obviously nine plus eleven is\nnot two so we missed something basically\nwe didn't do the and right in this case\nwe're going to have a carry one that's\ngoing to be over here right and we're\nalso going to have a carry from these\ntwo which is going to be over here so\nwhat we want to do is take this new\ninteger which is going to look like this\nand then add that with the result of a\nxor b\nthe xor does add these numbers it just\ndoesn't take care of the carry so we\nhave to take care of the carry ourselves\nand uh when we\nbasically take a logic and with b we\nalso want to shift it to the left by one\nand then we'll get some other integer so\nby the way over here we're going to take\na and b and then shift it to the left by\none so\nwhen we end these two together we get a\none when we and these two together we\nget a zero when we and these two we get\na zero when we and these two we get a\none but we remember we want to take this\nand shift it to the left by one so what\nwe're actually gonna have is a one here\nzero zero one right and then this will\njust this uh place will just get filled\nwith a zero so now we wanna take these\ntwo numbers and add them together and\nwhen we say add them together we're\ngoing to do the same exact operations we\ndid here so we're going to first xor\nthese exclusive wearing these we get a\nzero exclusive wearing these we get a\nzero exclusive or these we get zero\nagain zero here though we do get a one\nso we got the exclusive or now we want\nto get the and of them shifted to the\nleft by one so and these two nothing and\nthese two we get a one and of course we\nwant to shift it to the left by one\nwhich means we'll have a one over here\nso i'll just put that one over here\nbecause we know for the rest of these uh\nthis is not going to be ended and this\nis not going to be ended so\nthis will basically be zero zero\neverything is zero except this so now we\nwant to add these two together again\nwe're going to do our xor operation\nfirst xoring these these nothing here we\nget a 1\nnothing here here we get a 1 and\nwhen you and these two together we just\nget a zero in the output right logic\nending these two will get us a zero\nwhich basically means we don't have a\ncarry in this case which means we are\nfinished adding them together right if\nwe don't have a carry that means we're\ndone so this is the result in that case\nnow what number is this well it's 16\nplus 4 which is 20 which is exactly what\nwe were looking for right because we\nwere adding 9 plus 11. so i hope that\nthis makes sense and i hope you kind of\nunderstand why it works so now we can\nget into the code and actually what is\ngoing to be the time complexity of this\nsolution well it's going to be constant\ntime because first we're we're told that\nthe integers a and b are going to be\nbetween negative 1000 and positive 1000\nand how many times could we actually do\nthis loop uh you know before getting a\ncarry that's you know zero\nit can't go run forever like of course\nif these were arbitrarily large integers\nthen in that case\nwe might have like a linear time\nalgorithm but for the most part this is\nconstant time and one more thing i want\nto mention is how are we going to handle\nnegative numbers well negative numbers\nwill actually handle themselves and i\ndon't want to go too in detail to that\nwe could talk about like two's\ncomplement and stuff like that but what\nyou need to know is this operation um\nxoring and ending them this is\nequivalent to addition and we know that\nin most languages if you take negative\nthree you know plus positive number this\nwill give us the correct output which is\npositive one in this case and since this\nis basically equivalent to addition as\nlong as the language we're using handles\nbinary representation correctly it\nshould work for us one thing i want to\nmention is i'm actually going to code\nthis up in java today not python because\npython integers are arbitrarily large\nthey're not 32-bit so it kind of runs\ninto problems with this algorithm and\njust to keep it simple i'm just going to\nuse java okay so now let's code it up\nand yes uh believe it or not i do know\njava i have coded java even though i use\npython pretty much exclusively on this\nchannel so now let's do our loop and\nremember the condition we're doing our\nloop is basically until the carry value\nends up being 0 and b is what we're\ngoing to use for the carry in this case\nand you'll see what i mean in a second\nso what we want to do is we want to\nassign a equal to a x or b just like we\nkind of did in the drawing explanation\nand we want to set b\nequal to a anded with b and then bit\nshifted to the left by one and then we\nwant to go to the next iteration of the\nloop basically doing the same thing and\nwe learned that these two operations are\nequivalent to adding a and b together\nbut one little catch is that if we\nalready assign a to the exclusive or\nthen when we try to assign b we're using\nthe new value of a when we actually want\nto use the old value of a\nso before we\nreassign a i'm just going to actually\ncalculate a temporary integer which is\nbasically our and condition which is\ngoing to be a and b\nshifted to the left by one and then\ninstead i'm going to assign b equal to\nthat temporary value to make sure that\nwe use the original value of a not the\nnew value of a and once we're done with\nthat eventually b will equal 0 b is the\ncarry and then we can go ahead and\nreturn the result which is going to be\nstored in a okay now let's run it to\nmake sure that it works and on the left\nyou can see that yes it works and it is\npretty efficient so i really hope that\nthis was helpful if it was please like\nand subscribe it really supports the\nchannel a lot consider checking out my\npatreon where you can further support\nthe channel and hopefully i'll see you\n"
    },
    {
        "Name": "Reverse Integer",
        "NcLink": "reverse-integer/",
        "Pattern": "Bit Manipulation",
        "Description": "You are given a signed 32-bit integer `x`.\n    \nReturn `x` after reversing each of its digits. After reversing, if `x` goes outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return `0` instead.\n\nSolve the problem without using integers that are outside the signed 32-bit integer range.\n\n**Example 1:**\n\n```java\nInput: x = 1234\n\nOutput: 4321\n```\n\n**Example 2:**\n\n```java\nInput: x = -1234\n\nOutput: -4321\n```\n\n**Example 3:**\n\n```java\nInput: x = 1234236467\n\nOutput: 0\n```\n\n**Constraints:**\n* `-2^31 <= x <= 2^31 - 1`\n",
        "Difficulty": "Medium",
        "Video": "HAgLH58IgJQ",
        "PythonSolution": "class Solution:\n    def reverse(self, x: int) -> int:\n        MIN = -2147483648  # -2^31,\n        MAX = 2147483647  #  2^31 - 1\n\n        res = 0\n        while x:\n            digit = int(math.fmod(x, 10))\n            x = int(x / 10)\n\n            if res > MAX // 10 or (res == MAX // 10 and digit > MAX % 10):\n                return 0\n            if res < MIN // 10 or (res == MIN // 10 and digit < MIN % 10):\n                return 0\n            res = (res * 10) + digit\n\n        return res\n",
        "Transcript": "one welcome back and let's write some\nmore neat code today so today let's\nsolve the problem reverse integer even\nthough this is marked as an easy\nquestion i would say that this is\ndefinitely more of a medium question and\nthat's probably why this question has so\nmany different uh so many dislikes but i\ndon't think it's actually a bad problem\nit's definitely good when it comes to\nbit manipulation so we're given a signed\n32-bit integer x the fact that it's\n32-bit is very important here we want to\nreturn\nthis integer x with all of its digits\nbeing reversed and the only catch here\nis if reversing this integer x causes\nthe value to go outside of the 32-bit\ninteger range which is this then\nthen we basically want to return 0 if\nthat's the case because we're working\nwith 32-bit integers if the integer\noverflows then we want to return 0. and\nthis is the portion that's actually\ngoing to make the the problem difficult\nbecause we are working with 32-bit\nintegers and we cannot assume that we\ncan store 64-bit integers or anything\ngreater than 32-bits that's what makes\nthis question difficult i think because\nif we just take a look at the standard\nprocedure that we would do take the\nfirst example over here we have one two\nthree did you know we can chop off this\none's place digit pretty easily you can\ndo that by\nmodding this by 10. if we mod by 10\nwe're basically dividing this by 10\nexcept we're getting the remainder which\nis exactly what we want that's how you\nget the ones place if i took 123 divided\nby 10 what would be the remainder it\nwould be 3 of course right so then we\ncan get 3. so with this digit we want to\ncreate a new integer right so we're\ngoing to start our new integer just\nbeing 3 right this is the result that\nwe're returning it's going to be three\nlet me you know write it down over here\nthree right then another operation we\ncan do on 123. now that we've processed\nthis one's place we don't really care\nabout the ones place anymore right we\ndon't care about this three now we want\nto look at the next digit right so how\ncan we basically chop this digit off\nwell it's pretty easy you basically take\n123 divide it by 10 when i say divide\nwe're not doing decimal division we're\ndoing integer division so\nwhen you do integer division we round\ntowards zeros if we divide this by 10 we\nwill get 12 because we're rounding down\nwe're rounding towards zero so now we\nhave 12. we're going to basically repeat\nthat exact same step that we just did\nover here basically now we're going to\ntake 12\nmod it by 10 and now we're going to get\nthe ones place which is 2 right that's\nthe digit we were looking for so now we\nwant to take this 2 and add it over here\nright now how can we do that well we\nhave a digi we have a value three so\nlet's take three multiply it by ten what\ndo we get we get thirty right why did we\nmultiply it by ten because we wanted to\nshift this three to the left by one\nbecause now we're going to take this 30\nadd 2 to it why are we adding 2 because\nthat's the digit that we just computed\nup above right so we add 2 to 30 now we\nget 32 right so we've almost we're\nalmost done reversing this integer right\nif you take a look over here we started\nwith 123 we've reversed the first two\ndigits right but now we want to reverse\nthe last one which is one and that'll be\npretty easy we'll just continue the\nsteps that we've just done up above so\nthen we'll at the end we'll have 321\nand then we'll return that which is\nexactly what we wanted to do and believe\nit or not we can do this exact same\nprocedure on negative numbers and it\nworks out the exact same so that's the\ngood thing the only downside is we\nhaven't covered what are we going to do\nif the digits overflow so let me kind of\nexplain that to you this range that we\nhave to kind of meet oh in the\ndescription they say that if the value\ngoes out of bounds so take a look at the\nleft they say if it goes out of bounds\nfrom this range then return 0. now what\nis the value negative 2 or 2 to the\npower of 31 negative right negative 2 to\nthe power 31 what is that value well you\ncan see over here this is that full\nvalue these are the digits what is 2 to\nthe power of 31 minus 1 this is that\nvalue so what if we had a example that\nlooked basically was too\nlarge right what if the value was too\nlarge to fit what if the value was\nactually larger than the max value that\nwe can possibly have what if the value\nwas two one four seven what if the value\nwas the exact same as this except plus\none you can see that this is the exact\nsame value except i added one so this is\nan eight instead of a seven and actually\nwhat if the input value was this\nbasically what if the input value was\nthe reverse of the max digit plus one\nright\nlet's say this was our input value right\nand let's say we reversed it if we\nreversed it this is the reversed value\nup above right this is what we would get\nbut what we know is this integer is\nactually too\nlarge this integer is greater than the\none up above so this would not even fit\ninto memory so we would need to return\nzero now how could we detect that this\ninteger overflows without actually\ncalculating it right because we can't\nhave this digit this digit is impossible\nto have in 32 bits so how would we\ndetect it without actually building this\nnumber without actually taking this and\nreversing it all the way to here well\nthat's the trick that i'm going to show\nyou we actually are are going to reverse\nthis input digit by digit except for the\nlast digit we're not going to reverse\nwe're not going to add the last digit\nyet what we're going to do is once we've\nreversed this right we have all but the\nlast digit we're going to check okay is\nthis value exactly equal to\nthis value basically all everything from\nthe max digit except the last digit how\nare we going to actually get this\nbasically we can take the max digit and\ndivide it by 10 right because dividing\nby 10 we'll take the ones place digit\nand chop it off right so if we do that\nlike this we're going to check okay is\nis our reversed integer equal to this\none yes it is right it's exactly equal\nin this case okay and then the next\nquestion we're gonna ask ourselves is\nokay we're trying to also we're now\ntrying to add another digit we add the\nones place digit okay so how do we know\nthen if if the resulting integer is\ngoing to be greater than this max\ninteger up above how do we know that\nwell all we have to do since we know\nthat this is equal to this now all we\nhave to do is compare the ones place is\neight\ngreater than\nthis integer we have over here which is\nseven in this case it is greater than it\nright so then we're not actually going\nto take this eight digit and add it to\nhere add it to this entire integer we're\nactually going to return zero\nimmediately so that's one trick that\nwe're gonna basically to basically to\ndetect if we go out of bounds and\nbasically i just showed you the example\nof what we would do for positive\nintegers the exact same is basically\ngoing to be true for negative integers\nexcept instead of checking if this digit\nis greater than the ones place of the\nmax negative integer or the minimum\nnegative integer we're not going to\ncheck if it's greater we're going to\ncheck if it's less than because this is\na negative number right so that's one\nway we could detect if we did go out of\nbounds another way we can actually check\nis\ntaking away this final digit right this\none's place digit and taking away this\none's place digit again and we do know\nhow to do that in the code so i won't\nexplain it but if we were comparing all\nof these digits right and we were\ncomparing all of these digits and let's\nsay we knew that yes we are about to add\nanother digit we know for sure we're\ngoing to add another digit then what\nwe're going to ask is or is this portion\ndown here that i have squared up is this\ngreater than this over here right for\nexample over here that we have a value\nwe have a value 2 followed by 8\ndifferent digits right so suppose this\nvalue over here that i have written over\nhere it wasn't 2 followed by 8 digits it\nwas a 3 0\n0 0 0 0 followed by 8 0's right then we\nknow for sure this is actually larger\nthan this integer i have up above since\nwe know this is larger and let's say\nwe're adding another zero to it so now\nwe have nine zeros then we know for sure\nit's gonna be greater than the max\ninteger up above because that max\ninteger starts with a two followed by\nnine digits right we know for sure this\nis gonna be greater so basically that's\nhow we're going to compare it i know\nthis sounds confusing right but to put\nit simply if we compare this with this\nup above and we know that this is\ngreater than we know we're out of bounds\nand then we're going to again have to\nreturn zero i know this seems really\ncomplicated but let me show you the code\nand it's actually gonna be probably even\nmore simple this is definitely why i\nwould say this is more of a medium\nproblem not an easy problem okay so now\nlet's get into the code and i already\nwrote out the code because i think it's\ngoing to be more easy to understand if\nyou can kind of see the entire structure\nwritten out so in most languages you can\nfind the max integer and minimum integer\nin 32 bits right this is the max integer\nthis is the minimum integer and i have\nthose coded up above in python the math\nit kind of works out a little bit\ndifferently compared to most languages\nbut i'm basically doing the with the\nfollowing while loop i'm doing what i\nexplained earlier in the video so we\nhave our result initially zero right\nwe're passed in some integer x so while\nthis integer x is not zero let's\ncontinue the loop right now we're in the\nlooping phase we're going through each\ndigit of x what we want to do right just\nlike i mentioned earlier we want to take\nx and mod it by 10. now you would you're\nprobably wondering why can't i just take\nx and mod it by 10 why do i need this\nhelper function or whatever uh basically\nbecause python is kind of dumb it does\nsome unexpected behavior negative 1\nmodded by 10 should not be 9 in most\ncases but python is a little bit\ndifferent than most languages in most\nlanguages you can just do the mod\noperator but we're doing math f mod to\nget that digit in python once we have\nthat digit we're clear right then we\nwant to take x and divide it by 10.\nyou're wondering why can't we just\ndivide it by 10 well python's a little\nbit weird so\nwe're doing we're we're dividing it by\n10 and then casting it back to an\ninteger to make sure that we can round\ntowards zero in most languages you won't\nhave to do this you can just take x\ndivided by 10 but python's a little bit\nweird so excuse that so then we we've we\nhave the digit and we took x and we\nchopped off the digit so that's good\nnext we want to do the stuff that i just\nmentioned actually right so i want to\ntake that result right we have a digit\nwe want to add it to the result but you\ncan see i'm doing a couple if statements\nbefore i actually execute this line down\nhere where i'm actually taking that\ndigit and adding it to the result right\nresult multiplied by 10 and then add\nthat digit which is what we discussed\nearlier but before i do this i have to\nmake sure that this is not going to\noverflow how can i guarantee it's not\ngoing to overflow well if we take the\ncurrent result and we take the max value\ndivided by 10 why are we taking this max\nvalue up above and dividing up by 10\nbecause we don't want to look at that\nlast digit yet because we can't look at\nthat last digit until we know for sure\nthat this value is not going to overflow\nso we're going to compare every other\ndigit so if this result is greater than\nmax divided by 10 then we're going to\nreturn 0 because we know it's going to\noverflow regardless of what that digit\nis it's going to overflow because uh the\nresult the result is already larger than\nmax divided by 10. so that's one case\nthe other case is if the result is\nexactly equal to max divided by 10 right\nif it's exactly equal to this max\nportion except the last digit and if if\nthat's if that's true and if the digit\nis greater than 7 where did i get 7 from\nwell basically this is max modded by 10.\nif you take this max integer mod it by\n10 you're gonna get the ones place which\nis seven so if the digit is greater than\nseven and this previous portion executed\nas true then we're going to return zero\nso that's basically the case if the\nresulting integer is going to be too\nlarge the bottom if statement is the\nexact same thing except if the resulting\ninteger was going to be too small if it\nwas going to be smaller than the minimum\ninteger we have up above so if that was\nthe case then we'd return 0 as well and\nif if those don't execute then we can go\nahead and finally take that digit and\nadd it to the result and then we can\nwhen once the while loop is done\nexecuting if the result has not\noverflowed then we can return that\nresult so that was a lot of information\nbut i hope that these if statements are\nfinally starting to make sense and the\ngood thing is once you run the code it\nis about as efficient as it can possibly\nbe so i hope that this video was helpful\nif it was please like and subscribe it\nsupports the channel a lot and i'll\nhopefully see you pretty soon thanks for\nwatching\n"
    }
]