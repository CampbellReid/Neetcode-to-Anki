[
  {
    "Name": "Contains Duplicate",
    "NcLink": "duplicate-integer/",
    "Pattern": "Arrays \u0026 Hashing",
    "Description": "Given an integer array \u0060nums\u0060, return \u0060true\u0060 if any value appears **more than once** in the array, otherwise return \u0060false\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1, 2, 3, 3]\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [1, 2, 3, 4]\n\nOutput: false\n\u0060\u0060\u0060\n",
    "Difficulty": "Easy",
    "Video": "3OamzN90kPg",
    "PythonSolution": "class Solution:\n    def hasDuplicate(self, nums: List[int]) -\u003E bool:\n        hashset = set()\n\n        for n in nums:\n            if n in hashset:\n                return True\n            hashset.add(n)\n        return False\n    "
  },
  {
    "Name": "Valid Anagram",
    "NcLink": "is-anagram/",
    "Pattern": "Arrays \u0026 Hashing",
    "Description": "Given two strings \u0060s\u0060 and \u0060t\u0060, return \u0060true\u0060 if the two strings are anagrams of each other, otherwise return \u0060false\u0060.\n\nAn **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022racecar\u0022, t = \u0022carrace\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022jar\u0022, t = \u0022jam\u0022\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060s\u0060 and \u0060t\u0060 consist of lowercase English letters.\n",
    "Difficulty": "Easy",
    "Video": "9UtInBqnCgA",
    "PythonSolution": "class Solution:\n    def isAnagram(self, s: str, t: str) -\u003E bool:\n        if len(s) != len(t):\n            return False\n\n        countS, countT = {}, {}\n\n        for i in range(len(s)):\n            countS[s[i]] = 1 \u002B countS.get(s[i], 0)\n            countT[t[i]] = 1 \u002B countT.get(t[i], 0)\n        return countS == countT\n"
  },
  {
    "Name": "Two Sum",
    "NcLink": "two-integer-sum/",
    "Pattern": "Arrays \u0026 Hashing",
    "Description": "Given an array of integers \u0060nums\u0060 and an integer \u0060target\u0060, return the indices \u0060i\u0060 and \u0060j\u0060 such that \u0060nums[i] \u002B nums[j] == target\u0060 and \u0060i != j\u0060.\n    \nYou may assume that *every* input has exactly one pair of indices \u0060i\u0060 and \u0060j\u0060 that satisfy the condition.\n\nReturn the answer with the smaller index first. \n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: \nnums = [3,4,5,6], target = 7\n\nOutput: [0,1]\n\u0060\u0060\u0060\n\nExplanation: \u0060nums[0] \u002B nums[1] == 7\u0060, so we return \u0060[0, 1]\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [4,5,6], target = 10\n\nOutput: [0,2]\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: nums = [5,5], target = 10\n\nOutput: [0,1]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00602 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-10,000,000 \u003C= nums[i] \u003C= 10,000,000\u0060\n* \u0060-10,000,000 \u003C= target \u003C= 10,000,000\u0060\n",
    "Difficulty": "Easy",
    "Video": "KLlXCFG5TnA",
    "PythonSolution": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -\u003E List[int]:\n        prevMap = {}  # val -\u003E index\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i\n"
  },
  {
    "Name": "Group Anagrams",
    "NcLink": "anagram-groups/",
    "Pattern": "Arrays \u0026 Hashing",
    "Description": "Given an array of strings \u0060strs\u0060, group all *anagrams* together into sublists. You may return the output in **any order**.\n\nAn **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: strs = [\u0022act\u0022,\u0022pots\u0022,\u0022tops\u0022,\u0022cat\u0022,\u0022stop\u0022,\u0022hat\u0022]\n\nOutput: [[\u0022hat\u0022],[\u0022act\u0022, \u0022cat\u0022],[\u0022stop\u0022, \u0022pots\u0022, \u0022tops\u0022]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: strs = [\u0022x\u0022]\n\nOutput: [[\u0022x\u0022]]\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: strs = [\u0022\u0022]\n\nOutput: [[\u0022\u0022]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= strs.length \u003C= 1000\u0060.\n* \u00600 \u003C= strs[i].length \u003C= 100\u0060\n* \u0060strs[i]\u0060 is made up of lowercase English letters.\n",
    "Difficulty": "Medium",
    "Video": "vzdNOK2oB2E",
    "PythonSolution": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -\u003E List[List[str]]:\n        ans = defaultdict(list)\n\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord(\u0022a\u0022)] \u002B= 1\n            ans[tuple(count)].append(s)\n        return ans.values()\n"
  },
  {
    "Name": "Top K Frequent Elements",
    "NcLink": "top-k-elements-in-list/",
    "Pattern": "Arrays \u0026 Hashing",
    "Description": "Given an integer array \u0060nums\u0060 and an integer \u0060k\u0060, return the \u0060k\u0060 most frequent elements within the array.\n\nThe test cases are generated such that the answer is always **unique**.\n\nYou may return the output in **any order**.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,2,3,3,3], k = 2\n\nOutput: [2,3]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [7,7], k = 1\n\nOutput: [7]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 10^4\u0060.\n* \u0060-1000 \u003C= nums[i] \u003C= 1000\u0060\n* \u00601 \u003C= k \u003C= number of distinct elements in nums\u0060.\n",
    "Difficulty": "Medium",
    "Video": "YPTqKIgVk-k",
    "PythonSolution": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -\u003E List[int]:\n        count = {}\n        freq = [[] for i in range(len(nums) \u002B 1)]\n\n        for n in nums:\n            count[n] = 1 \u002B count.get(n, 0)\n        for n, c in count.items():\n            freq[c].append(n)\n\n        res = []\n        for i in range(len(freq) - 1, 0, -1):\n            for n in freq[i]:\n                res.append(n)\n                if len(res) == k:\n                    return res\n"
  },
  {
    "Name": "Encode and Decode Strings",
    "NcLink": "string-encode-and-decode/",
    "Pattern": "Arrays \u0026 Hashing",
    "Description": "Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.\n\nPlease implement \u0060encode\u0060 and \u0060decode\u0060\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: [\u0022neet\u0022,\u0022code\u0022,\u0022love\u0022,\u0022you\u0022]\n\nOutput:[\u0022neet\u0022,\u0022code\u0022,\u0022love\u0022,\u0022you\u0022]\n\u0060\u0060\u0060\n\n**Example 2:**\n\u0060\u0060\u0060java\nInput: [\u0022we\u0022,\u0022say\u0022,\u0022:\u0022,\u0022yes\u0022]\n\nOutput: [\u0022we\u0022,\u0022say\u0022,\u0022:\u0022,\u0022yes\u0022]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= strs.length \u003C 100\u0060\n* \u00600 \u003C= strs[i].length \u003C 200\u0060\n* \u0060strs[i]\u0060 contains only UTF-8 characters.\n",
    "Difficulty": "Medium",
    "Video": "B1k_sxOSgv8",
    "PythonSolution": "class Solution:\n    \n    def encode(self, strs: List[str]) -\u003E str:\n        res = \u0022\u0022\n        for s in strs:\n            res \u002B= str(len(s)) \u002B \u0022#\u0022 \u002B s\n        return res\n\n    def decode(self, s: str) -\u003E List[str]:\n        res = []\n        i = 0\n        \n        while i \u003C len(s):\n            j = i\n            while s[j] != \u0027#\u0027:\n                j \u002B= 1\n            length = int(s[i:j])\n            i = j \u002B 1\n            j = i \u002B length\n            res.append(s[i:j])\n            i = j\n            \n        return res\n"
  },
  {
    "Name": "Product of Array Except Self",
    "NcLink": "products-of-array-discluding-self/",
    "Pattern": "Arrays \u0026 Hashing",
    "Description": "Given an integer array \u0060nums\u0060, return an array \u0060output\u0060 where \u0060output[i]\u0060 is the product of all the elements of \u0060nums\u0060 except \u0060nums[i]\u0060.\n\nEach product is **guaranteed** to fit in a **32-bit** integer.   \n\nFollow-up: Could you solve it in $O(n)$ time without using the division operation?\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,4,6]\n\nOutput: [48,24,12,8]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [-1,0,1,2,3]\n\nOutput: [0,-6,0,0,0]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00602 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-20 \u003C= nums[i] \u003C= 20\u0060\n",
    "Difficulty": "Medium",
    "Video": "bNvIQI2wAjk",
    "PythonSolution": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -\u003E List[int]:\n        res = [1] * (len(nums))\n\n        for i in range(1, len(nums)):\n            res[i] = res[i-1] * nums[i-1]\n        postfix = 1\n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res\n"
  },
  {
    "Name": "Valid Sudoku",
    "NcLink": "valid-sudoku/",
    "Pattern": "Arrays \u0026 Hashing",
    "Description": "You are given a a \u00609 x 9\u0060 Sudoku board \u0060board\u0060. A Sudoku board is valid if the following rules are followed:\n\n1. Each row must contain the digits \u00601-9\u0060 without duplicates.\n2. Each column must contain the digits \u00601-9\u0060 without duplicates.\n3. Each of the nine \u00603 x 3\u0060 sub-boxes of the grid must contain the digits \u00601-9\u0060 without duplicates.\n\nReturn \u0060true\u0060 if the Sudoku board is valid, otherwise return \u0060false\u0060\n\nNote: A board does not need to be full or be solvable to be valid.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)\n\n\u0060\u0060\u0060java\nInput: board = \n[[\u00221\u0022,\u00222\u0022,\u0022.\u0022,\u0022.\u0022,\u00223\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022],\n [\u00224\u0022,\u0022.\u0022,\u0022.\u0022,\u00225\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022],\n [\u0022.\u0022,\u00229\u0022,\u00228\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00223\u0022],\n [\u00225\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00226\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00224\u0022],\n [\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00228\u0022,\u0022.\u0022,\u00223\u0022,\u0022.\u0022,\u0022.\u0022,\u00225\u0022],\n [\u00227\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00222\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00226\u0022],\n [\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00222\u0022,\u0022.\u0022,\u0022.\u0022],\n [\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00224\u0022,\u00221\u0022,\u00229\u0022,\u0022.\u0022,\u0022.\u0022,\u00228\u0022],\n [\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00228\u0022,\u0022.\u0022,\u0022.\u0022,\u00227\u0022,\u00229\u0022]]\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: board = \n[[\u00221\u0022,\u00222\u0022,\u0022.\u0022,\u0022.\u0022,\u00223\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022],\n [\u00224\u0022,\u0022.\u0022,\u0022.\u0022,\u00225\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022],\n [\u0022.\u0022,\u00229\u0022,\u00221\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00223\u0022],\n [\u00225\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00226\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00224\u0022],\n [\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00228\u0022,\u0022.\u0022,\u00223\u0022,\u0022.\u0022,\u0022.\u0022,\u00225\u0022],\n [\u00227\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00222\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00226\u0022],\n [\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00222\u0022,\u0022.\u0022,\u0022.\u0022],\n [\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00224\u0022,\u00221\u0022,\u00229\u0022,\u0022.\u0022,\u0022.\u0022,\u00228\u0022],\n [\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u0022.\u0022,\u00228\u0022,\u0022.\u0022,\u0022.\u0022,\u00227\u0022,\u00229\u0022]]\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation: There are two 1\u0027s in the top-left 3x3 sub-box.\n\n**Constraints:**\n* \u0060board.length == 9\u0060\n* \u0060board[i].length == 9\u0060\n* \u0060board[i][j]\u0060 is a digit \u00601-9\u0060 or \u0060\u0027.\u0027\u0060.\n",
    "Difficulty": "Medium",
    "Video": "TjFXEUCMqI8",
    "PythonSolution": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -\u003E bool:\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        squares = defaultdict(set)  # key = (r /3, c /3)\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \u0022.\u0022:\n                    continue\n                if (\n                    board[r][c] in rows[r]\n                    or board[r][c] in cols[c]\n                    or board[r][c] in squares[(r // 3, c // 3)]\n                ):\n                    return False\n                cols[c].add(board[r][c])\n                rows[r].add(board[r][c])\n                squares[(r // 3, c // 3)].add(board[r][c])\n\n        return True\n"
  },
  {
    "Name": "Longest Consecutive Sequence",
    "NcLink": "longest-consecutive-sequence/",
    "Pattern": "Arrays \u0026 Hashing",
    "Description": "Given an array of integers \u0060nums\u0060, return *the length* of the longest consecutive sequence of elements.\n\nA *consecutive sequence* is a sequence of elements in which each element is exactly \u00601\u0060 greater than the previous element.\n\nYou must write an algorithm that runs in \u0060O(n)\u0060 time.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [2,20,4,10,3,4,5]\n\nOutput: 4\n\u0060\u0060\u0060\n\nExplanation: The longest consecutive sequence is \u0060[2, 3, 4, 5]\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [0,3,2,5,4,6,1,1]\n\nOutput: 7\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-10^9 \u003C= nums[i] \u003C= 10^9\u0060\n",
    "Difficulty": "Medium",
    "Video": "P6RZZMu_maU",
    "PythonSolution": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -\u003E int:\n        numSet = set(nums)\n        longest = 0\n\n        for n in numSet:\n            if (n - 1) not in numSet:\n                length = 1\n                while (n \u002B length) in numSet:\n                    length \u002B= 1\n                longest = max(length, longest)\n        return longest\n"
  },
  {
    "Name": "Valid Palindrome",
    "NcLink": "is-palindrome/",
    "Pattern": "Two Pointers",
    "Description": "Given a string \u0060s\u0060, return \u0060true\u0060 if it is a **palindrome**, otherwise return \u0060false\u0060.\n    \nA **palindrome** is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022Was it a car or a cat I saw?\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: After considering only alphanumerical characters we have \u0022wasitacaroracatisaw\u0022, which is a palindrome.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022tab a cat\u0022\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation: \u0022tabacat\u0022 is not a palindrome.\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 1000\u0060\n* \u0060s\u0060 is made up of only printable ASCII characters.\n",
    "Difficulty": "Easy",
    "Video": "jJXJ16kPFWg",
    "PythonSolution": "class Solution:\n    def isPalindrome(self, s: str) -\u003E bool:\n        l, r = 0, len(s) - 1\n\n        while l \u003C r:\n            while l \u003C r and not self.alphaNum(s[l]):\n                l \u002B= 1\n            while r \u003E l and not self.alphaNum(s[r]):\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l, r = l \u002B 1, r - 1\n        return True\n    \n    def alphaNum(self, c):\n        return (ord(\u0027A\u0027) \u003C= ord(c) \u003C= ord(\u0027Z\u0027) or \n                ord(\u0027a\u0027) \u003C= ord(c) \u003C= ord(\u0027z\u0027) or \n                ord(\u00270\u0027) \u003C= ord(c) \u003C= ord(\u00279\u0027))\n"
  },
  {
    "Name": "Two Sum II Input Array Is Sorted",
    "NcLink": "two-integer-sum-ii/",
    "Pattern": "Two Pointers",
    "Description": "Given an array of integers \u0060numbers\u0060 that is sorted in **non-decreasing order**.\n\nReturn the indices (**1-indexed**) of two numbers, \u0060[index1, index2]\u0060, such that they add up to a given target number \u0060target\u0060 and \u0060index1 \u003C index2\u0060. Note that \u0060index1\u0060 and \u0060index2\u0060 cannot be equal, therefore you may not use the same element twice.\n\nThere will always be **exactly one valid solution**.\n\nYour solution must use $O(1)$ additional space.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: numbers = [1,2,3,4], target = 3\n\nOutput: [1,2]\n\u0060\u0060\u0060\n\nExplanation:\nThe sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, \u0060index1\u0060 = 1, \u0060index2\u0060 = 2. We return \u0060[1, 2]\u0060.\n\n**Constraints:**\n* \u00602 \u003C= numbers.length \u003C= 1000\u0060\n* \u0060-1000 \u003C= numbers[i] \u003C= 1000\u0060\n* \u0060-1000 \u003C= target \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "cQ1Oz4ckceM",
    "PythonSolution": "class Solution:\n    def twoSum(self, numbers: List[int], target: int) -\u003E List[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l \u003C r:\n            curSum = numbers[l] \u002B numbers[r]\n\n            if curSum \u003E target:\n                r -= 1\n            elif curSum \u003C target:\n                l \u002B= 1\n            else:\n                return [l \u002B 1, r \u002B 1]\n"
  },
  {
    "Name": "3Sum",
    "NcLink": "three-integer-sum/",
    "Pattern": "Two Pointers",
    "Description": "Given an integer array \u0060nums\u0060, return all the triplets \u0060[nums[i], nums[j], nums[k]]\u0060 where \u0060nums[i] \u002B nums[j] \u002B nums[k] == 0\u0060, and the indices \u0060i\u0060, \u0060j\u0060 and \u0060k\u0060 are all distinct.\n\nThe output should *not* contain any duplicate triplets. You may return the output and the triplets in **any order**.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [-1,0,1,2,-1,-4]\n\nOutput: [[-1,-1,2],[-1,0,1]]\n\u0060\u0060\u0060\n\nExplanation: \n\u0060nums[0] \u002B nums[1] \u002B nums[2] = (-1) \u002B 0 \u002B 1 = 0.\u0060\n\u0060nums[1] \u002B nums[2] \u002B nums[4] = 0 \u002B 1 \u002B (-1) = 0.\u0060\n\u0060nums[0] \u002B nums[3] \u002B nums[4] = (-1) \u002B 2 \u002B (-1) = 0.\u0060\nThe distinct triplets are \u0060[-1,0,1]\u0060 and \u0060[-1,-1,2]\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [0,1,1]\n\nOutput: []\n\u0060\u0060\u0060\n\nExplanation: The only possible triplet does not sum up to 0.\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: nums = [0,0,0]\n\nOutput: [[0,0,0]]\n\u0060\u0060\u0060\n\nExplanation: The only possible triplet sums up to 0.\n\n\n**Constraints:**\n* \u00603 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-10^5 \u003C= nums[i] \u003C= 10^5\u0060\n",
    "Difficulty": "Medium",
    "Video": "jzZsG8n2R9A",
    "PythonSolution": "class Solution:\n    def threeSum(self, nums: List[int]) -\u003E List[List[int]]:\n        res = []\n        nums.sort()\n\n        for i, a in enumerate(nums):\n            if a \u003E 0:\n                break\n\n            if i \u003E 0 and a == nums[i - 1]:\n                continue\n\n            l, r = i \u002B 1, len(nums) - 1\n            while l \u003C r:\n                threeSum = a \u002B nums[l] \u002B nums[r]\n                if threeSum \u003E 0:\n                    r -= 1\n                elif threeSum \u003C 0:\n                    l \u002B= 1\n                else:\n                    res.append([a, nums[l], nums[r]])\n                    l \u002B= 1\n                    r -= 1\n                    while nums[l] == nums[l - 1] and l \u003C r:\n                        l \u002B= 1\n                        \n        return res\n"
  },
  {
    "Name": "Container With Most Water",
    "NcLink": "max-water-container/",
    "Pattern": "Two Pointers",
    "Description": "You are given an integer array \u0060heights\u0060 where \u0060heights[i]\u0060 represents the height of the $i^{th}$ bar.\n\nYou may choose any two bars to form a container. Return the *maximum* amount of water a container can store.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public)\n\n\u0060\u0060\u0060java\nInput: height = [1,7,2,5,4,7,3,6]\n\nOutput: 36\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: height = [2,2,2]\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00602 \u003C= height.length \u003C= 1000\u0060\n* \u00600 \u003C= height[i] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "UuiTKBwPgAo",
    "PythonSolution": "class Solution:\n    def maxArea(self, heights: List[int]) -\u003E int:\n        l, r = 0, len(heights) - 1\n        res = 0\n\n        while l \u003C r:\n            res = max(res, min(heights[l], heights[r]) * (r - l))\n            if heights[l] \u003C heights[r]:\n                l \u002B= 1\n            elif heights[r] \u003C= heights[l]:\n                r -= 1\n            \n        return res\n"
  },
  {
    "Name": "Trapping Rain Water",
    "NcLink": "trapping-rain-water/",
    "Pattern": "Two Pointers",
    "Description": "You are given an array non-negative integers \u0060heights\u0060 which represent an elevation map. Each value \u0060heights[i]\u0060 represents the height of a bar, which has a width of \u00601\u0060.\n\nReturn the maximum area of water that can be trapped between the bars.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0c25cb81-1095-4382-fff2-6ef77c1fd100/public)\n\n\u0060\u0060\u0060java\nInput: height = [0,2,0,3,1,0,1,3,2,1]\n\nOutput: 9\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= height.length \u003C= 1000\u0060\n* \u00600 \u003C= height[i] \u003C= 1000\u0060\n",
    "Difficulty": "Hard",
    "Video": "ZI2z5pq0TqA",
    "PythonSolution": "class Solution:\n    def trap(self, height: List[int]) -\u003E int:\n        if not height:\n            return 0\n\n        l, r = 0, len(height) - 1\n        leftMax, rightMax = height[l], height[r]\n        res = 0\n        while l \u003C r:\n            if leftMax \u003C rightMax:\n                l \u002B= 1\n                leftMax = max(leftMax, height[l])\n                res \u002B= leftMax - height[l]\n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])\n                res \u002B= rightMax - height[r]\n        return res\n"
  },
  {
    "Name": "Best Time to Buy And Sell Stock",
    "NcLink": "buy-and-sell-crypto/",
    "Pattern": "Sliding Window",
    "Description": "You are given an integer array \u0060prices\u0060 where \u0060prices[i]\u0060 is the price of NeetCoin on the \u0060ith\u0060 day.\n\nYou may choose a **single day** to buy one NeetCoin and choose a **different day in the future** to sell it.\n\nReturn the maximum profit you can achieve. You may choose to **not make any transactions**, in which case the profit would be \u00600\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: prices = [10,1,5,6,7,1]\n\nOutput: 6\n\u0060\u0060\u0060\nExplanation: Buy \u0060prices[1]\u0060 and sell \u0060prices[4]\u0060, \u0060profit = 7 - 1 = 6\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: prices = [10,8,7,5,2]\n\nOutput: 0\n\u0060\u0060\u0060\n\nExplanation: No profitable transactions can be made, thus the max profit is 0.\n\n**Constraints:**\n* \u00601 \u003C= prices.length \u003C= 100\u0060\n* \u00600 \u003C= prices[i] \u003C= 100\u0060\n",
    "Difficulty": "Easy",
    "Video": "1pkOgXD63yU",
    "PythonSolution": "class Solution:\n    def maxProfit(self, prices: List[int]) -\u003E int:\n        res = 0\n        \n        lowest = prices[0]\n        for price in prices:\n            if price \u003C lowest:\n                lowest = price\n            res = max(res, price - lowest)\n        return res\n"
  },
  {
    "Name": "Longest Substring Without Repeating Characters",
    "NcLink": "longest-substring-without-duplicates/",
    "Pattern": "Sliding Window",
    "Description": "Given a string \u0060s\u0060, find the *length of the longest substring* without duplicate characters.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022zxyzxyz\u0022\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: The string \u0022xyz\u0022 is the longest without duplicate characters.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022xxxx\u0022\n\nOutput: 1\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= s.length \u003C= 1000\u0060\n* \u0060s\u0060 may consist of printable ASCII characters.\n",
    "Difficulty": "Medium",
    "Video": "wiGpQwVHdE0",
    "PythonSolution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -\u003E int:\n        charSet = set()\n        l = 0\n        res = 0\n\n        for r in range(len(s)):\n            while s[r] in charSet:\n                charSet.remove(s[l])\n                l \u002B= 1\n            charSet.add(s[r])\n            res = max(res, r - l \u002B 1)\n        return res\n"
  },
  {
    "Name": "Longest Repeating Character Replacement",
    "NcLink": "longest-repeating-substring-with-replacement/",
    "Pattern": "Sliding Window",
    "Description": "You are given a string \u0060s\u0060 consisting of only uppercase english characters and an integer \u0060k\u0060. You can choose up to \u0060k\u0060 characters of the string and replace them with any other uppercase English character.\n\nAfter performing at most \u0060k\u0060 replacements, return the length of the longest substring which contains only one distinct character.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022XYYX\u0022, k = 2\n\nOutput: 4\n\u0060\u0060\u0060\n\nExplanation: Either replace the \u0027X\u0027s with \u0027Y\u0027s, or replace the \u0027Y\u0027s with \u0027X\u0027s.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022AAABABB\u0022, k = 1\n\nOutput: 5\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 1000\u0060\n* \u00600 \u003C= k \u003C= s.length\u0060\n",
    "Difficulty": "Medium",
    "Video": "gqXU1UyA8pk",
    "PythonSolution": "class Solution:\n    def characterReplacement(self, s: str, k: int) -\u003E int:\n        count = {}\n        \n        l = 0\n        maxf = 0\n        for r in range(len(s)):\n            count[s[r]] = 1 \u002B count.get(s[r], 0)\n            maxf = max(maxf, count[s[r]])\n\n            if (r - l \u002B 1) - maxf \u003E k:\n                count[s[l]] -= 1\n                l \u002B= 1\n\n        return (r - l \u002B 1)\n"
  },
  {
    "Name": "Permutation In String",
    "NcLink": "permutation-string/",
    "Pattern": "Sliding Window",
    "Description": "You are given two strings \u0060s1\u0060 and \u0060s2\u0060.\n    \nReturn \u0060true\u0060 if \u0060s2\u0060 contains a permutation of \u0060s1\u0060, or \u0060false\u0060 otherwise. That means if a permutation of \u0060s1\u0060 exists as a substring of \u0060s2\u0060, then return \u0060true\u0060.\n\nBoth strings only contain lowercase letters.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s1 = \u0022abc\u0022, s2 = \u0022lecabee\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: The substring \u0060\u0022cab\u0022\u0060 is a permutation of \u0060\u0022abc\u0022\u0060 and is present in \u0060\u0022lecabee\u0022\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s1 = \u0022abc\u0022, s2 = \u0022lecaabee\u0022\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= s1.length, s2.length \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "UbyhOgBN834",
    "PythonSolution": "class Solution:\n    def checkInclusion(self, s1: str, s2: str) -\u003E bool:\n        if len(s1) \u003E len(s2):\n            return False\n\n        s1Count, s2Count = [0] * 26, [0] * 26\n        for i in range(len(s1)):\n            s1Count[ord(s1[i]) - ord(\u0022a\u0022)] \u002B= 1\n            s2Count[ord(s2[i]) - ord(\u0022a\u0022)] \u002B= 1\n\n        matches = 0\n        for i in range(26):\n            matches \u002B= 1 if s1Count[i] == s2Count[i] else 0\n\n        l = 0\n        for r in range(len(s1), len(s2)):\n            if matches == 26:\n                return True\n\n            index = ord(s2[r]) - ord(\u0022a\u0022)\n            s2Count[index] \u002B= 1\n            if s1Count[index] == s2Count[index]:\n                matches \u002B= 1\n            elif s1Count[index] \u002B 1 == s2Count[index]:\n                matches -= 1\n\n            index = ord(s2[l]) - ord(\u0022a\u0022)\n            s2Count[index] -= 1\n            if s1Count[index] == s2Count[index]:\n                matches \u002B= 1\n            elif s1Count[index] - 1 == s2Count[index]:\n                matches -= 1\n            l \u002B= 1\n        return matches == 26\n"
  },
  {
    "Name": "Minimum Window Substring",
    "NcLink": "minimum-window-with-characters/",
    "Pattern": "Sliding Window",
    "Description": "Given two strings \u0060s\u0060 and \u0060t\u0060, return the shortest **substring** of \u0060s\u0060 such that every character in \u0060t\u0060, including duplicates, is present in the substring. If such a substring does not exist, return an empty string \u0060\u0022\u0022\u0060.\n\nYou may assume that the correct output is always unique.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022OUZODYXAZV\u0022, t = \u0022XYZ\u0022\n\nOutput: \u0022YXAZ\u0022\n\u0060\u0060\u0060\n\nExplanation: \u0060\u0022YXAZ\u0022\u0060 is the shortest substring that includes \u0060\u0022X\u0022\u0060, \u0060\u0022Y\u0022\u0060, and \u0060\u0022Z\u0022\u0060 from string \u0060t\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022xyz\u0022, t = \u0022xyz\u0022\n\nOutput: \u0022xyz\u0022\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022x\u0022, t = \u0022xy\u0022\n\nOutput: \u0022\u0022\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 1000\u0060\n* \u00601 \u003C= t.length \u003C= 1000\u0060\n* \u0060s\u0060 and \u0060t\u0060 consist of uppercase and lowercase English letters.\n",
    "Difficulty": "Hard",
    "Video": "jSto0O4AJbM",
    "PythonSolution": "class Solution:\n    def minWindow(self, s: str, t: str) -\u003E str:\n        if t == \u0022\u0022:\n            return \u0022\u0022\n\n        countT, window = {}, {}\n        for c in t:\n            countT[c] = 1 \u002B countT.get(c, 0)\n\n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\u0022infinity\u0022)\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 \u002B window.get(c, 0)\n\n            if c in countT and window[c] == countT[c]:\n                have \u002B= 1\n\n            while have == need:\n                if (r - l \u002B 1) \u003C resLen:\n                    res = [l, r]\n                    resLen = r - l \u002B 1\n                    \n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] \u003C countT[s[l]]:\n                    have -= 1\n                l \u002B= 1\n        l, r = res\n        return s[l : r \u002B 1] if resLen != float(\u0022infinity\u0022) else \u0022\u0022\n"
  },
  {
    "Name": "Sliding Window Maximum",
    "NcLink": "sliding-window-maximum/",
    "Pattern": "Sliding Window",
    "Description": "You are given an array of integers \u0060nums\u0060 and an integer \u0060k\u0060. There is a sliding window of size \u0060k\u0060 that starts at the left edge of the array. The window slides one position to the right until it reaches the right edge of the array.\n\nReturn a list that contains the maximum element in the window at each step.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,1,0,4,2,6], k = 3\n\nOutput: [2,2,4,4,6]\n\nExplanation: \nWindow position            Max\n---------------           -----\n[1  2  1] 0  4  2  6        2\n 1 [2  1  0] 4  2  6        2\n 1  2 [1  0  4] 2  6        4\n 1  2  1 [0  4  2] 6        4\n 1  2  1  0 [4  2  6]       6\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-1000 \u003C= nums[i] \u003C= 1000\u0060\n* \u00601 \u003C= k \u003C= nums.length\u0060\n",
    "Difficulty": "Hard",
    "Video": "DfljaUwZsOk",
    "PythonSolution": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -\u003E List[int]:\n        output = []\n        q = deque()  # index\n        l = r = 0\n\n        while r \u003C len(nums):\n            while q and nums[q[-1]] \u003C nums[r]:\n                q.pop()\n            q.append(r)\n\n            if l \u003E q[0]:\n                q.popleft()\n\n            if (r \u002B 1) \u003E= k:\n                output.append(nums[q[0]])\n                l \u002B= 1\n            r \u002B= 1\n\n        return output\n"
  },
  {
    "Name": "Valid Parentheses",
    "NcLink": "validate-parentheses/",
    "Pattern": "Stack",
    "Description": "You are given a string \u0060s\u0060 consisting of the following characters: \u0060\u0027(\u0027\u0060, \u0060\u0027)\u0027\u0060, \u0060\u0027{\u0027\u0060, \u0060\u0027}\u0027\u0060, \u0060\u0027[\u0027\u0060 and \u0060\u0027]\u0027\u0060.\n\nThe input string \u0060s\u0060 is valid if and only if:\n\n1. Every open bracket is closed by the same type of close bracket.\n2. Open brackets are closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nReturn \u0060true\u0060 if \u0060s\u0060 is a valid string, and \u0060false\u0060 otherwise.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022[]\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022([{}])\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022[(])\u0022\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation: The brackets are not closed in the correct order.\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 1000\u0060\n",
    "Difficulty": "Easy",
    "Video": "WTzjTskDFMg",
    "PythonSolution": "class Solution:\n    def isValid(self, s: str) -\u003E bool:\n        Map = {\u0022)\u0022: \u0022(\u0022, \u0022]\u0022: \u0022[\u0022, \u0022}\u0022: \u0022{\u0022}\n        stack = []\n\n        for c in s:\n            if c not in Map:\n                stack.append(c)\n                continue\n            if not stack or stack[-1] != Map[c]:\n                return False\n            stack.pop()\n\n        return not stack\n    "
  },
  {
    "Name": "Min Stack",
    "NcLink": "minimum-stack/",
    "Pattern": "Stack",
    "Description": "Design a stack class that supports the \u0060push\u0060, \u0060pop\u0060, \u0060top\u0060, and \u0060getMin\u0060 operations.\n\n* \u0060MinStack()\u0060 initializes the stack object.\n* \u0060void push(int val)\u0060 pushes the element \u0060val\u0060 onto the stack.\n* \u0060void pop()\u0060 removes the element on the top of the stack.\n* \u0060int top()\u0060 gets the top element of the stack.\n* \u0060int getMin()\u0060 retrieves the minimum element in the stack.\n\nEach function should run in $O(1)$ time.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: [\u0022MinStack\u0022, \u0022push\u0022, 1, \u0022push\u0022, 2, \u0022push\u0022, 0, \u0022getMin\u0022, \u0022pop\u0022, \u0022top\u0022, \u0022getMin\u0022]\n\nOutput: [null,null,null,null,0,null,2,1]\n\nExplanation:\nMinStack minStack = new MinStack();\nminStack.push(1);\nminStack.push(2);\nminStack.push(0);\nminStack.getMin(); // return 0\nminStack.pop();\nminStack.top();    // return 2\nminStack.getMin(); // return 1\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060-2^31 \u003C= val \u003C= 2^31 - 1\u0060.\n* \u0060pop\u0060, \u0060top\u0060 and \u0060getMin\u0060 will always be called on **non-empty** stacks.\n",
    "Difficulty": "Medium",
    "Video": "qkLl7nAwDPo",
    "PythonSolution": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -\u003E None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -\u003E None:\n        self.stack.pop()\n        self.minStack.pop()\n\n    def top(self) -\u003E int:\n        return self.stack[-1]\n\n    def getMin(self) -\u003E int:\n        return self.minStack[-1]\n"
  },
  {
    "Name": "Evaluate Reverse Polish Notation",
    "NcLink": "evaluate-reverse-polish-notation/",
    "Pattern": "Stack",
    "Description": "You are given an array of strings \u0060tokens\u0060 that represents a **valid** arithmetic expression in [Reverse Polish Notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nReturn the integer that represents the evaluation of the expression.\n\n* The operands may be integers or the results of other operations.\n* The operators include \u0060\u0027\u002B\u0027\u0060, \u0060\u0027-\u0027\u0060, \u0060\u0027*\u0027\u0060, and \u0060\u0027/\u0027\u0060.\n* Assume that division between integers always truncates toward zero.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: tokens = [\u00221\u0022,\u00222\u0022,\u0022\u002B\u0022,\u00223\u0022,\u0022*\u0022,\u00224\u0022,\u0022-\u0022]\n\nOutput: 5\n\nExplanation: ((1 \u002B 2) * 3) - 4 = 5\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= tokens.length \u003C= 1000\u0060.\n* tokens[i] is \u0060\u0022\u002B\u0022\u0060, \u0060\u0022-\u0022\u0060, \u0060\u0022*\u0022\u0060, or \u0060\u0022/\u0022\u0060, or a string representing an integer in the range \u0060[-100, 100]\u0060.\n",
    "Difficulty": "Medium",
    "Video": "iu0082c4HDE",
    "PythonSolution": "class Solution:\n    def evalRPN(self, tokens: List[str]) -\u003E int:\n        stack = []\n        for c in tokens:\n            if c == \u0022\u002B\u0022:\n                stack.append(stack.pop() \u002B stack.pop())\n            elif c == \u0022-\u0022:\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif c == \u0022*\u0022:\n                stack.append(stack.pop() * stack.pop())\n            elif c == \u0022/\u0022:\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(float(b) / a))\n            else:\n                stack.append(int(c))\n        return stack[0]\n"
  },
  {
    "Name": "Generate Parentheses",
    "NcLink": "generate-parentheses/",
    "Pattern": "Stack",
    "Description": "You are given an integer \u0060n\u0060. Return all well-formed parentheses strings that you can generate with \u0060n\u0060 pairs of parentheses.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: n = 1\n\nOutput: [\u0022()\u0022]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: n = 3\n\nOutput: [\u0022((()))\u0022,\u0022(()())\u0022,\u0022(())()\u0022,\u0022()(())\u0022,\u0022()()()\u0022]\n\u0060\u0060\u0060\n\nYou may return the answer in **any order**.\n\n**Constraints:**\n* \u00601 \u003C= n \u003C= 7\u0060\n",
    "Difficulty": "Medium",
    "Video": "s9fokUqJ76A",
    "PythonSolution": "class Solution:\n    def generateParenthesis(self, n: int) -\u003E List[str]:\n        stack = []\n        res = []\n\n        def backtrack(openN, closedN):\n            if openN == closedN == n:\n                res.append(\u0022\u0022.join(stack))\n                return\n\n            if openN \u003C n:\n                stack.append(\u0022(\u0022)\n                backtrack(openN \u002B 1, closedN)\n                stack.pop()\n            if closedN \u003C openN:\n                stack.append(\u0022)\u0022)\n                backtrack(openN, closedN \u002B 1)\n                stack.pop()\n\n        backtrack(0, 0)\n        return res\n"
  },
  {
    "Name": "Daily Temperatures",
    "NcLink": "daily-temperatures/",
    "Pattern": "Stack",
    "Description": "You are given an array of integers \u0060temperatures\u0060 where \u0060temperatures[i]\u0060 represents the daily temperatures on the \u0060ith\u0060 day.\n    \nReturn an array \u0060result\u0060 where \u0060result[i]\u0060 is the number of days after the \u0060ith\u0060 day before a warmer temperature appears on a future day. If there is no day in the future where a warmer temperature will appear for the \u0060ith\u0060 day, set \u0060result[i]\u0060 to \u00600\u0060 instead.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: temperatures = [30,38,30,36,35,40,28]\n\nOutput: [1,4,1,2,1,0,0]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: temperatures = [22,21,20]\n\nOutput: [0,0,0]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= temperatures.length \u003C= 1000\u0060.\n* \u00601 \u003C= temperatures[i] \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "cTBiBSnjO3c",
    "PythonSolution": "class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -\u003E List[int]:\n        res = [0] * len(temperatures)\n        stack = []  # pair: [temp, index]\n\n        for i, t in enumerate(temperatures):\n            while stack and t \u003E stack[-1][0]:\n                stackT, stackInd = stack.pop()\n                res[stackInd] = i - stackInd\n            stack.append((t, i))\n        return res\n"
  },
  {
    "Name": "Car Fleet",
    "NcLink": "car-fleet/",
    "Pattern": "Stack",
    "Description": "There are \u0060n\u0060 cars traveling to the same destination on a one-lane highway.\n\nYou are given two arrays of integers \u0060position\u0060 and \u0060speed\u0060, both of length \u0060n\u0060. \n* \u0060position[i]\u0060 is the position of the \u0060ith car\u0060 (in miles)\n* \u0060speed[i]\u0060 is the speed of the \u0060ith\u0060 car (in miles per hour)\n\nThe **destination** is at position \u0060target\u0060 miles.\n\nA car can **not** pass another car ahead of it. It can only catch up to another car and then drive at the same speed as the car ahead of it.\n\nA **car fleet** is a non-empty set of cars driving at the same position and same speed. A single car is also considered a car fleet.\n\nIf a car catches up to a car fleet the moment the fleet reaches the destination, then the car is considered to be part of the fleet.\n\nReturn the number of **different car fleets** that will arrive at the destination.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: target = 10, position = [1,4], speed = [3,2]\n\nOutput: 1\n\u0060\u0060\u0060\n\nExplanation: The cars starting at 1 (speed 3) and 4 (speed 2) become a fleet, meeting each other at 10, the destination.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: target = 10, position = [4,1,0,7], speed = [2,2,1,1]\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: The cars starting at 4 and 7 become a fleet at position 10. The cars starting at 1 and 0 never catch up to the car ahead of them. Thus, there are 3 car fleets that will arrive at the destination.\n\n**Constraints:**\n* \u0060n == position.length == speed.length\u0060.\n* \u00601 \u003C= n \u003C= 1000\u0060\n* \u00600 \u003C target \u003C= 1000\u0060\n* \u00600 \u003C speed[i] \u003C= 100\u0060\n* \u00600 \u003C= position[i] \u003C target\u0060\n* All the values of \u0060position\u0060 are **unique**.\n",
    "Difficulty": "Medium",
    "Video": "Pr6T-3yB9RM",
    "PythonSolution": "class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -\u003E int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n        stack = []\n        for p, s in pair:  # Reverse Sorted Order\n            stack.append((target - p) / s)\n            if len(stack) \u003E= 2 and stack[-1] \u003C= stack[-2]:\n                stack.pop()\n        return len(stack)\n"
  },
  {
    "Name": "Largest Rectangle In Histogram",
    "NcLink": "largest-rectangle-in-histogram/",
    "Pattern": "Stack",
    "Description": "You are given an array of integers \u0060heights\u0060 where \u0060heights[i]\u0060 represents the height of a bar. The width of each bar is \u00601\u0060.\n    \nReturn the area of the largest rectangle that can be formed among the bars.\n\nNote: This chart is known as a [histogram](https://en.wikipedia.org/wiki/Histogram).\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: heights = [7,1,7,2,2,4]\n\nOutput: 8\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: heights = [1,3,7]\n\nOutput: 7\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= heights.length \u003C= 1000\u0060.\n* \u00600 \u003C= heights[i] \u003C= 1000\u0060\n",
    "Difficulty": "Hard",
    "Video": "zx5Sw9130L0",
    "PythonSolution": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -\u003E int:\n        maxArea = 0\n        stack = []  # pair: (index, height)\n\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] \u003E h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i - index))\n                start = index\n            stack.append((start, h))\n\n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights) - i))\n        return maxArea\n"
  },
  {
    "Name": "Binary Search",
    "NcLink": "binary-search/",
    "Pattern": "Binary Search",
    "Description": "You are given an array of **distinct** integers \u0060nums\u0060, sorted in ascending order, and an integer \u0060target\u0060.\n    \nImplement a function to search for \u0060target\u0060 within \u0060nums\u0060. If it exists, then return its index, otherwise, return \u0060-1\u0060.\n\nYour solution must run in $O(log n)$ time.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [-1,0,2,4,6,8], target = 4\n\nOutput: 3\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [-1,0,2,4,6,8], target = 3\n\nOutput: -1\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 10000\u0060.\n* \u0060-10000 \u003C nums[i], target \u003C 10000\u0060\n",
    "Difficulty": "Easy",
    "Video": "s4DPM8ct1pI",
    "PythonSolution": "class Solution:\n    def search(self, nums: List[int], target: int) -\u003E int:\n        l, r = 0, len(nums) - 1\n\n        while l \u003C= r:\n            m = l \u002B ((r - l) // 2)  # (l \u002B r) // 2 can lead to overflow\n            if nums[m] \u003E target:\n                r = m - 1\n            elif nums[m] \u003C target:\n                l = m \u002B 1\n            else:\n                return m\n        return -1\n"
  },
  {
    "Name": "Search a 2D Matrix",
    "NcLink": "search-2d-matrix/",
    "Pattern": "Binary Search",
    "Description": "You are given an \u0060m x n\u0060 2-D integer array \u0060matrix\u0060 and an integer \u0060target\u0060.\n\n* Each row in \u0060matrix\u0060 is sorted in *non-decreasing* order.\n* The first integer of every row is greater than the last integer of the previous row.\n\nReturn \u0060true\u0060 if \u0060target\u0060 exists within \u0060matrix\u0060 or \u0060false\u0060 otherwise.\n\nCan you write a solution that runs in \u0060O(log(m * n))\u0060 time?\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7ca61f56-00d4-4fa0-26cf-56809028ac00/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 10\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/f25f2085-ce04-4447-9cee-f0a66c32a300/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 15\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060m == matrix.length\u0060\n* \u0060n == matrix[i].length\u0060\n* \u00601 \u003C= m, n \u003C= 100\u0060\n* \u0060-10000 \u003C= matrix[i][j], target \u003C= 10000\u0060\n",
    "Difficulty": "Medium",
    "Video": "Ber2pi2C0j0",
    "PythonSolution": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -\u003E bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n\n        top, bot = 0, ROWS - 1\n        while top \u003C= bot:\n            row = (top \u002B bot) // 2\n            if target \u003E matrix[row][-1]:\n                top = row \u002B 1\n            elif target \u003C matrix[row][0]:\n                bot = row - 1\n            else:\n                break\n\n        if not (top \u003C= bot):\n            return False\n        row = (top \u002B bot) // 2\n        l, r = 0, COLS - 1\n        while l \u003C= r:\n            m = (l \u002B r) // 2\n            if target \u003E matrix[row][m]:\n                l = m \u002B 1\n            elif target \u003C matrix[row][m]:\n                r = m - 1\n            else:\n                return True\n        return False\n"
  },
  {
    "Name": "Koko Eating Bananas",
    "NcLink": "eating-bananas/",
    "Pattern": "Binary Search",
    "Description": "You are given an integer array \u0060piles\u0060 where \u0060piles[i]\u0060 is the number of bananas in the \u0060ith\u0060 pile. You are also given an integer \u0060h\u0060, which represents the number of hours you have to eat all the bananas.\n\nYou may decide your bananas-per-hour eating rate of \u0060k\u0060. Each hour, you may choose a pile of bananas and eats \u0060k\u0060 bananas from that pile. If the pile has less than \u0060k\u0060 bananas, you may finish eating the pile but you can not eat from another pile in the same hour.\n\nReturn the minimum integer \u0060k\u0060 such that you can eat all the bananas within \u0060h\u0060 hours.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: piles = [1,4,3,2], h = 9\n\nOutput: 2\n\u0060\u0060\u0060\n\nExplanation: With an eating rate of 2, you can eat the bananas in 6 hours. With an eating rate of 1, you would need 10 hours to eat all the bananas (which exceeds h=9), thus the minimum eating rate is 2.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: piles = [25,10,23,4], h = 4\n\nOutput: 25\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= piles.length \u003C= 1,000\u0060\n* \u0060piles.length \u003C= h \u003C= 1,000,000\u0060\n* \u00601 \u003C= piles[i] \u003C= 1,000,000,000\u0060\n",
    "Difficulty": "Medium",
    "Video": "U2SozAs9RzA",
    "PythonSolution": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -\u003E int:\n        l, r = 1, max(piles)\n        res = r\n\n        while l \u003C= r:\n            k = (l \u002B r) // 2\n\n            totalTime = 0\n            for p in piles:\n                totalTime \u002B= math.ceil(float(p) / k)\n            if totalTime \u003C= h:\n                res = k\n                r = k - 1\n            else:\n                l = k \u002B 1\n        return res\n"
  },
  {
    "Name": "Find Minimum In Rotated Sorted Array",
    "NcLink": "find-minimum-in-rotated-sorted-array/",
    "Pattern": "Binary Search",
    "Description": "You are given an array of length \u0060n\u0060 which was originally sorted in ascending order. It has now been **rotated** between \u00601\u0060 and \u0060n\u0060 times. For example, the array \u0060nums = [1,2,3,4,5,6]\u0060 might become:\n\n* \u0060[3,4,5,6,1,2]\u0060 if it was rotated \u00604\u0060 times.\n* \u0060[1,2,3,4,5,6]\u0060 if it was rotated \u00606\u0060 times.\n\nNotice that rotating the array \u00604\u0060 times moves the last four elements of the array to the beginning. Rotating the array \u00606\u0060 times produces the original array.\n\nAssuming all elements in the rotated sorted array \u0060nums\u0060 are **unique**, return the minimum element of this array.\n\nA solution that runs in \u0060O(n)\u0060 time is trivial, can you write an algorithm that runs in \u0060O(log n) time\u0060?\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [3,4,5,6,1,2]\n\nOutput: 1\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [4,5,0,1,2,3]\n\nOutput: 0\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: nums = [4,5,6,7]\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-1000 \u003C= nums[i] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "nIVW4P8b1VA",
    "PythonSolution": "class Solution:\n    def findMin(self, nums: List[int]) -\u003E int:\n        start , end = 0, len(nums) - 1 \n        curr_min = float(\u0022inf\u0022)\n        \n        while start  \u003C  end :\n            mid = start \u002B (end - start ) // 2\n            curr_min = min(curr_min,nums[mid])\n            \n            # right has the min \n            if nums[mid] \u003E nums[end]:\n                start = mid \u002B 1\n                \n            # left has the  min \n            else:\n                end = mid - 1 \n                \n        return min(curr_min,nums[start])\n    "
  },
  {
    "Name": "Search In Rotated Sorted Array",
    "NcLink": "find-target-in-rotated-sorted-array/",
    "Pattern": "Binary Search",
    "Description": "You are given an array of length \u0060n\u0060 which was originally sorted in ascending order. It has now been **rotated** between \u00601\u0060 and \u0060n\u0060 times. For example, the array \u0060nums = [1,2,3,4,5,6]\u0060 might become:\n\n* \u0060[3,4,5,6,1,2]\u0060 if it was rotated \u00604\u0060 times.\n* \u0060[1,2,3,4,5,6]\u0060 if it was rotated \u00606\u0060 times.\n\nGiven the rotated sorted array \u0060nums\u0060 and an integer \u0060target\u0060, return the index of \u0060target\u0060 within \u0060nums\u0060, or \u0060-1\u0060 if it is not present.\n\nYou may assume all elements in the sorted rotated array \u0060nums\u0060 are **unique**,\n\nA solution that runs in \u0060O(n)\u0060 time is trivial, can you write an algorithm that runs in \u0060O(log n) time\u0060?\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [3,4,5,6,1,2], target = 1\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [3,5,6,0,1,2], target = 4\n\nOutput: -1\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-1000 \u003C= nums[i] \u003C= 1000\u0060\n* \u0060-1000 \u003C= target \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "U8XENwh8Oy8",
    "PythonSolution": "class Solution:\n    def search(self, nums: List[int], target: int) -\u003E int:\n        l, r = 0, len(nums) - 1\n\n        while l \u003C= r:\n            mid = (l \u002B r) // 2\n            if target == nums[mid]:\n                return mid\n\n            if nums[l] \u003C= nums[mid]:\n                if target \u003E nums[mid] or target \u003C nums[l]:\n                    l = mid \u002B 1\n                else:\n                    r = mid - 1\n                    \n            else:\n                if target \u003C nums[mid] or target \u003E nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid \u002B 1\n        return -1\n"
  },
  {
    "Name": "Time Based Key Value Store",
    "NcLink": "time-based-key-value-store/",
    "Pattern": "Binary Search",
    "Description": "Implement a time-based key-value data structure that supports:\n \n* Storing multiple values for the same key at specified time stamps\n* Retrieving the key\u0027s value at a specified timestamp\n\nImplement the \u0060TimeMap\u0060 class:\n* \u0060TimeMap()\u0060 Initializes the object.\n* \u0060void set(String key, String value, int timestamp)\u0060 Stores the key \u0060key\u0060 with the value \u0060value\u0060 at the given time \u0060timestamp\u0060.\n* \u0060String get(String key, int timestamp)\u0060 Returns the most recent value of \u0060key\u0060 if \u0060set\u0060 was previously called on it *and* the most recent timestamp for that key \u0060prev_timestamp\u0060 is less than or equal to the given timestamp (\u0060prev_timestamp \u003C= timestamp\u0060). If there are no values, it returns \u0060\u0022\u0022\u0060.\n\nNote: For all calls to \u0060set\u0060, the timestamps are in strictly increasing order.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput:\n[\u0022TimeMap\u0022, \u0022set\u0022, [\u0022alice\u0022, \u0022happy\u0022, 1], \u0022get\u0022, [\u0022alice\u0022, 1], \u0022get\u0022, [\u0022alice\u0022, 2], \u0022set\u0022, [\u0022alice\u0022, \u0022sad\u0022, 3], \u0022get\u0022, [\u0022alice\u0022, 3]]\n\nOutput:\n[null, null, \u0022happy\u0022, \u0022happy\u0022, null, \u0022sad\u0022]\n\nExplanation:\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\u0022alice\u0022, \u0022happy\u0022, 1);  // store the key \u0022alice\u0022 and value \u0022happy\u0022 along with timestamp = 1.\ntimeMap.get(\u0022alice\u0022, 1);           // return \u0022happy\u0022\ntimeMap.get(\u0022alice\u0022, 2);           // return \u0022happy\u0022, there is no value stored for timestamp 2, thus we return the value at timestamp 1.\ntimeMap.set(\u0022alice\u0022, \u0022sad\u0022, 3);    // store the key \u0022alice\u0022 and value \u0022sad\u0022 along with timestamp = 3.\ntimeMap.get(\u0022alice\u0022, 3);           // return \u0022sad\u0022\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= key.length, value.length \u003C= 100\u0060\n* \u0060key\u0060 and \u0060value\u0060 only include lowercase English letters and digits.\n* \u00601 \u003C= timestamp \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "fu2cD_6E8Hw",
    "PythonSolution": "class TimeMap:\n\n    def __init__(self):\n        self.keyStore = {}  # key : list of [val, timestamp]\n\n    def set(self, key: str, value: str, timestamp: int) -\u003E None:\n        if key not in self.keyStore:\n            self.keyStore[key] = []\n        self.keyStore[key].append([value, timestamp])\n\n    def get(self, key: str, timestamp: int) -\u003E str:\n        res, values = \u0022\u0022, self.keyStore.get(key, [])\n        l, r = 0, len(values) - 1\n        while l \u003C= r:\n            m = (l \u002B r) // 2\n            if values[m][1] \u003C= timestamp:\n                res = values[m][0]\n                l = m \u002B 1\n            else:\n                r = m - 1\n        return res\n"
  },
  {
    "Name": "Median of Two Sorted Arrays",
    "NcLink": "median-of-two-sorted-arrays/",
    "Pattern": "Binary Search",
    "Description": "You are given two integer arrays \u0060nums1\u0060 and \u0060nums2\u0060 of size \u0060m\u0060 and \u0060n\u0060 respectively, where each is sorted in ascending order. Return the [median](https://en.wikipedia.org/wiki/Median) value among all elements of the two arrays.\n\nYour solution must run in $O(log (m\u002Bn))$ time.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums1 = [1,2], nums2 = [3]\n\nOutput: 2.0\n\u0060\u0060\u0060\n\nExplanation: Among \u0060[1, 2, 3]\u0060 the median is 2.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums1 = [1,3], nums2 = [2,4]\n\nOutput: 2.5\n\u0060\u0060\u0060\n\nExplanation: Among \u0060[1, 2, 3, 4]\u0060 the median is (2 \u002B 3) / 2 = 2.5.\n\n**Constraints:**\n* \u0060nums1.length == m\u0060\n* \u0060nums2.length == n\u0060\n* \u00600 \u003C= m \u003C= 1000\u0060\n* \u00600 \u003C= n \u003C= 1000\u0060\n* \u0060-10^6 \u003C= nums1[i], nums2[i] \u003C= 10^6\u0060\n",
    "Difficulty": "Hard",
    "Video": "q6IEA26hvXc",
    "PythonSolution": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003E float:\n        A, B = nums1, nums2\n        total = len(nums1) \u002B len(nums2)\n        half = total // 2\n\n        if len(B) \u003C len(A):\n            A, B = B, A\n\n        l, r = 0, len(A) - 1\n        while True:\n            i = (l \u002B r) // 2\n            j = half - i - 2\n\n            Aleft = A[i] if i \u003E= 0 else float(\u0022-infinity\u0022)\n            Aright = A[i \u002B 1] if (i \u002B 1) \u003C len(A) else float(\u0022infinity\u0022)\n            Bleft = B[j] if j \u003E= 0 else float(\u0022-infinity\u0022)\n            Bright = B[j \u002B 1] if (j \u002B 1) \u003C len(B) else float(\u0022infinity\u0022)\n\n            if Aleft \u003C= Bright and Bleft \u003C= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) \u002B min(Aright, Bright)) / 2\n            elif Aleft \u003E Bright:\n                r = i - 1\n            else:\n                l = i \u002B 1\n"
  },
  {
    "Name": "Reverse Linked List",
    "NcLink": "reverse-a-linked-list/",
    "Pattern": "Linked List",
    "Description": "Given the beginning of a singly linked list \u0060head\u0060, reverse the list, and return the new beginning of the list.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: head = [0,1,2,3]\n\nOutput: [3,2,1,0]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: head = []\n\nOutput: []\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= The length of the list \u003C= 1000\u0060.\n* \u0060-1000 \u003C= Node.val \u003C= 1000\u0060\n",
    "Difficulty": "Easy",
    "Video": "G0_I-ZF0S38",
    "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseList(self, head: ListNode) -\u003E ListNode:\n        prev, curr = None, head\n\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev\n"
  },
  {
    "Name": "Merge Two Sorted Lists",
    "NcLink": "merge-two-sorted-linked-lists/",
    "Pattern": "Linked List",
    "Description": "You are given the heads of two sorted linked lists \u0060list1\u0060 and \u0060list2\u0060.\n\nMerge the two lists into one **sorted** linked list and return the head of the new sorted linked list.\n\nThe new list should be made up of nodes from \u0060list1\u0060 and \u0060list2\u0060.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/51adfea9-493a-4abb-ece7-fbb359d1c800/public)\n\n\u0060\u0060\u0060java\nInput: list1 = [1,2,4], list2 = [1,3,5]\n\nOutput: [1,1,2,3,4,5]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: list1 = [], list2 = [1,2]\n\nOutput: [1,2]\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: list1 = [], list2 = []\n\nOutput: []\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= The length of the each list \u003C= 100\u0060.\n* \u0060-100 \u003C= Node.val \u003C= 100\u0060\n",
    "Difficulty": "Easy",
    "Video": "XIdigk956u0",
    "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\n# Iterative Solution\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -\u003E ListNode:\n        dummy = node = ListNode()\n\n        while list1 and list2:\n            if list1.val \u003C list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n\n        node.next = list1 or list2\n\n        return dummy.next\n    \n# Recursive Solution\n# class Solution:\n#     def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -\u003E Optional[ListNode]:\n#         if not list1:\n#             return list2\n#         if not list2:\n#             return list1\n#         lil, big = (list1, list2) if list1.val \u003C list2.val else (list2, list1)\n#         lil.next = self.mergeTwoLists(lil.next, big)\n#         return lil\n"
  },
  {
    "Name": "Reorder List",
    "NcLink": "reorder-linked-list/",
    "Pattern": "Linked List",
    "Description": "You are given the head of a singly linked-list.\n    \nThe positions of a linked list of \u0060length = 7\u0060 for example, can intially be represented as:\n\n\u0060[0, 1, 2, 3, 4, 5, 6]\u0060\n\nReorder the nodes of the linked list to be in the following order:\n\n\u0060[0, 6, 1, 5, 2, 4, 3]\u0060\n\nNotice that in the general case for a list of \u0060length = n\u0060 the nodes are reordered to be in the following order:\n\n\u0060[0, n-1, 1, n-2, 2, n-3, ...]\u0060\n\nYou may not modify the values in the list\u0027s nodes, but instead you must reorder the nodes themselves.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: head = [2,4,6,8]\n\nOutput: [2,8,4,6]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: head = [2,4,6,8,10]\n\nOutput: [2,10,4,8,6]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= Length of the list \u003C= 1000\u0060.\n* \u00601 \u003C= Node.val \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "S5bfdUTrKLM",
    "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -\u003E None:\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        second = slow.next\n        prev = slow.next = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n\n        first, second = head, prev\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2\n"
  },
  {
    "Name": "Remove Nth Node From End of List",
    "NcLink": "remove-node-from-end-of-linked-list/",
    "Pattern": "Linked List",
    "Description": "You are given the beginning of a linked list \u0060head\u0060, and an integer \u0060n\u0060.\n    \nRemove the \u0060nth\u0060 node from the end of the list and return the beginning of the list.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: head = [1,2,3,4], n = 2\n\nOutput: [1,2,4]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: head = [5], n = 1\n\nOutput: []\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: head = [1,2], n = 2\n\nOutput: [2]\n\u0060\u0060\u0060\n\n**Constraints:**\n* The number of nodes in the list is \u0060sz\u0060.\n* \u00601 \u003C= sz \u003C= 30\u0060\n* \u00600 \u003C= Node.val \u003C= 100\u0060\n* \u00601 \u003C= n \u003C= sz\u0060\n",
    "Difficulty": "Medium",
    "Video": "XVuQxVej6y8",
    "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -\u003E Optional[ListNode]:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        while n \u003E 0:\n            right = right.next\n            n -= 1\n\n        while right:\n            left = left.next\n            right = right.next\n\n        left.next = left.next.next\n        return dummy.next\n"
  },
  {
    "Name": "Copy List With Random Pointer",
    "NcLink": "copy-linked-list-with-random-pointer/",
    "Pattern": "Linked List",
    "Description": "You are given the head of a linked list of length \u0060n\u0060. Unlike a singly linked list, each node contains an additional pointer \u0060random\u0060, which may point to any node in the list, or \u0060null\u0060.\n\nCreate a **deep copy** of the list. \n\nThe deep copy should consist of exactly \u0060n\u0060 **new** nodes, each including:\n* The original value \u0060val\u0060 of the copied node\n* A \u0060next\u0060 pointer to the new node corresponding to the \u0060next\u0060 pointer of the original node\n* A \u0060random\u0060 pointer to the new node corresponding to the \u0060random\u0060 pointer of the original node\n\nNote: None of the pointers in the new list should point to nodes in the original list.\n\n*Return the head of the copied linked list.*\n\nIn the examples, the linked list is represented as a list of \u0060n\u0060 nodes. Each node is represented as a pair of \u0060[val, random_index]\u0060 where \u0060random_index\u0060 is the index of the node (0-indexed) that the \u0060random\u0060 pointer points to, or \u0060null\u0060 if it does not point to any node.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5a5c2bdd-51e2-4795-4544-096af4b6cc00/public)\n\n\u0060\u0060\u0060java\nInput: head = [[3,null],[7,3],[4,0],[5,1]]\n\nOutput: [[3,null],[7,3],[4,0],[5,1]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6e56fa98-cf1e-4ca6-18d4-716dac4ba900/public)\n\n\u0060\u0060\u0060java\nInput: head = [[1,null],[2,2],[3,2]]\n\nOutput: [[1,null],[2,2],[3,2]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= n \u003C= 100\u0060\n* \u0060-100 \u003C= Node.val \u003C= 100\u0060\n* \u0060random\u0060 is \u0060null\u0060 or is pointing to some node in the linked list.\n",
    "Difficulty": "Medium",
    "Video": "5Y2EiZST97Y",
    "PythonSolution": "\u0022\u0022\u0022\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: \u0027Node\u0027 = None, random: \u0027Node\u0027 = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\u0022\u0022\u0022\n\nclass Solution:\n    def copyRandomList(self, head: \u0027Optional[Node]\u0027) -\u003E \u0027Optional[Node]\u0027:\n        oldToCopy = {None: None}\n\n        cur = head\n        while cur:\n            copy = Node(cur.val)\n            oldToCopy[cur] = copy\n            cur = cur.next\n        cur = head\n        while cur:\n            copy = oldToCopy[cur]\n            copy.next = oldToCopy[cur.next]\n            copy.random = oldToCopy[cur.random]\n            cur = cur.next\n        return oldToCopy[head]\n"
  },
  {
    "Name": "Add Two Numbers",
    "NcLink": "add-two-numbers/",
    "Pattern": "Linked List",
    "Description": "You are given two **non-empty** linked lists, \u0060l1\u0060 and \u0060l2\u0060, where each represents a non-negative integer.\n    \nThe digits are stored in **reverse order**, e.g. the number 123 is represented as \u00603 -\u003E 2 -\u003E 1 -\u003E\u0060 in the linked list.\n\nEach of the nodes contains a single digit. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nReturn the sum of the two numbers as a linked list.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fee72e19-6a21-45a5-365e-3cb45aba9700/public)\n\n\u0060\u0060\u0060java\nInput: l1 = [1,2,3], l2 = [4,5,6]\n\nOutput: [5,7,9]\n\nExplanation: 321 \u002B 654 = 975.\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: l1 = [9], l2 = [9]\n\nOutput: [8,1]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= l1.length, l2.length \u003C= 100\u0060.\n* \u00600 \u003C= Node.val \u003C= 9\u0060\n",
    "Difficulty": "Medium",
    "Video": "wgFPrzTjm7s",
    "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -\u003E Optional[ListNode]:\n        dummy = ListNode()\n        cur = dummy\n\n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            # new digit\n            val = v1 \u002B v2 \u002B carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)\n\n            # update ptrs\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next\n "
  },
  {
    "Name": "Linked List Cycle",
    "NcLink": "linked-list-cycle-detection/",
    "Pattern": "Linked List",
    "Description": "Given the beginning of a linked list \u0060head\u0060, return \u0060true\u0060 if there is a cycle in the linked list. Otherwise, return \u0060false\u0060.\n\nThere is a cycle in a linked list if at least one node in the list that can be visited again by following the \u0060next\u0060 pointer.\n\nInternally, \u0060index\u0060 determines the index of the beginning of the cycle, if it exists. The tail node of the list will set it\u0027s \u0060next\u0060 pointer to the \u0060index-th\u0060 node. If \u0060index = -1\u0060, then the tail node points to \u0060null\u0060 and no cycle exists.\n\n**Note:** \u0060index\u0060 is **not** given to you as a parameter.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/3ecdbcfc-70fc-429a-4654-cf4f6a7dbe00/public)\n\n\u0060\u0060\u0060java\nInput: head = [1,2,3,4], index = 1\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/89e6716c-9f65-46da-d7b2-f04a93269700/public)\n\n\u0060\u0060\u0060java\nInput: head = [1,2], index = -1\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= Length of the list \u003C= 1000\u0060.\n* \u0060-1000 \u003C= Node.val \u003C= 1000\u0060\n* \u0060index\u0060 is \u0060-1\u0060 or a valid index in the linked list.\n",
    "Difficulty": "Easy",
    "Video": "gBTe7lFR3vc",
    "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -\u003E bool:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n"
  },
  {
    "Name": "Find The Duplicate Number",
    "NcLink": "find-duplicate-integer/",
    "Pattern": "Linked List",
    "Description": "You are given an array of integers \u0060nums\u0060 containing \u0060n \u002B 1\u0060 integers. Each integer in \u0060nums\u0060 is in the range \u0060[1, n]\u0060 inclusive.\n\nEvery integer appears **exactly once**, except for one integer which appears **two or more times**. Return the integer that appears more than once.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,3,2,2]\n\nOutput: 2\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,3,4,4]\n\nOutput: 4\n\u0060\u0060\u0060\n\nFollow-up: Can you solve the problem **without** modifying the array \u0060nums\u0060 and using $O(1)$ extra space?\n\n**Constraints:**\n* \u00601 \u003C= n \u003C= 10000\u0060\n* \u0060nums.length == n \u002B 1\u0060\n* \u00601 \u003C= nums[i] \u003C= n\u0060\n",
    "Difficulty": "Medium",
    "Video": "wjYnzkAhcNk",
    "PythonSolution": "class Solution:\n    def findDuplicate(self, nums: List[int]) -\u003E int:\n        slow, fast = 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while True:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n            if slow == slow2:\n                return slow\n"
  },
  {
    "Name": "LRU Cache",
    "NcLink": "lru-cache/",
    "Pattern": "Linked List",
    "Description": "Implement the [Least Recently Used (LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU) cache class \u0060LRUCache\u0060. The class should support the following operations\n\n* \u0060LRUCache(int capacity)\u0060 Initialize the LRU cache of size \u0060capacity\u0060.\n* \u0060int get(int key)\u0060 Return the value cooresponding to the \u0060key\u0060 if the \u0060key\u0060 exists, otherwise return \u0060-1\u0060.\n* \u0060void put(int key, int value)\u0060 Update the \u0060value\u0060 of the \u0060key\u0060 if the \u0060key\u0060 exists. Otherwise, add the \u0060key\u0060-\u0060value\u0060 pair to the cache. If the introduction of the new pair causes the cache to exceed its capacity, remove the least recently used key.\n\nA key is considered used if a \u0060get\u0060 or a \u0060put\u0060 operation is called on it.\n\nEnsure that \u0060get\u0060 and \u0060put\u0060 each run in $O(1)$ average time complexity.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput:\n[\u0022LRUCache\u0022, [2], \u0022put\u0022, [1, 10],  \u0022get\u0022, [1], \u0022put\u0022, [2, 20], \u0022put\u0022, [3, 30], \u0022get\u0022, [2], \u0022get\u0022, [1]]\n\nOutput:\n[null, null, 10, null, null, 20, -1]\n\nExplanation:\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 10);  // cache: {1=10}\nlRUCache.get(1);      // return 10\nlRUCache.put(2, 20);  // cache: {1=10, 2=20}\nlRUCache.put(3, 30);  // cache: {2=20, 3=30}, key=1 was evicted\nlRUCache.get(2);      // returns 20 \nlRUCache.get(1);      // return -1 (not found)\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= capacity \u003C= 100\u0060\n* \u00600 \u003C= key \u003C= 1000\u0060\n* \u00600 \u003C= value \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "7ABFKPK2hD4",
    "PythonSolution": "class Node:\n    def __init__(self, key, val):\n        self.key, self.val = key, val\n        self.prev = self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}  # map key to node\n\n        self.left, self.right = Node(0, 0), Node(0, 0)\n        self.left.next, self.right.prev = self.right, self.left\n\n    def remove(self, node):\n        prev, nxt = node.prev, node.next\n        prev.next, nxt.prev = nxt, prev\n\n    def insert(self, node):\n        prev, nxt = self.right.prev, self.right\n        prev.next = nxt.prev = node\n        node.next, node.prev = nxt, prev\n\n    def get(self, key: int) -\u003E int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        return -1\n\n    def put(self, key: int, value: int) -\u003E None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) \u003E self.cap:\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]\n"
  },
  {
    "Name": "Merge K Sorted Lists",
    "NcLink": "merge-k-sorted-linked-lists/",
    "Pattern": "Linked List",
    "Description": "You are given an array of \u0060k\u0060 linked lists \u0060lists\u0060, where each list is sorted in ascending order.\n\nReturn the **sorted** linked list that is the result of merging all of the individual linked lists.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: lists = [[1,2,4],[1,3,5],[3,6]]\n\nOutput: [1,1,2,3,3,4,5,6]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: lists = []\n\nOutput: []\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: lists = [[]]\n\nOutput: []\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= lists.length \u003C= 1000\u0060\n* \u00600 \u003C= lists[i].length \u003C= 100\u0060\n* \u0060-1000 \u003C= lists[i][j] \u003C= 1000\u0060\n",
    "Difficulty": "Hard",
    "Video": "q5a5OiGbT6Q",
    "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -\u003E Optional[ListNode]:\n        if not lists or len(lists) == 0:\n            return None\n\n        while len(lists) \u003E 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i \u002B 1] if (i \u002B 1) \u003C len(lists) else None\n                mergedLists.append(self.mergeList(l1, l2))\n            lists = mergedLists\n        return lists[0]\n\n    def mergeList(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n\n        while l1 and l2:\n            if l1.val \u003C l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next\n"
  },
  {
    "Name": "Reverse Nodes In K Group",
    "NcLink": "reverse-nodes-in-k-group/",
    "Pattern": "Linked List",
    "Description": "You are given the head of a singly linked list \u0060head\u0060 and a positive integer \u0060k\u0060.\n\nYou must reverse the first \u0060k\u0060 nodes in the linked list, and then reverse the next \u0060k\u0060 nodes, and so on. If there are fewer than \u0060k\u0060 nodes left, leave the nodes as they are.\n\nReturn the modified list after reversing the nodes in each group of \u0060k\u0060.\n\nYou are only allowed to modify the nodes\u0027 \u0060next\u0060 pointers, not the values of the nodes.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/67cf2fff-f20a-4558-6091-c3e857f56e00/public)\n\n\u0060\u0060\u0060java\nInput: head = [1,2,3,4,5,6], k = 3\n\nOutput: [3,2,1,6,5,4]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/af843e59-df12-4c55-652b-6ddab0a92900/public)\n\n\u0060\u0060\u0060java\nInput: head = [1,2,3,4,5], k = 3\n\nOutput: [3,2,1,4,5]\n\u0060\u0060\u0060\n\n**Constraints:**\n* The length of the linked list is \u0060n\u0060.\n* \u00601 \u003C= k \u003C= n \u003C= 100\u0060\n* \u00600 \u003C= Node.val \u003C= 100\u0060\n",
    "Difficulty": "Hard",
    "Video": "1UOPsfP85V4",
    "PythonSolution": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -\u003E Optional[ListNode]:\n        dummy = ListNode(0, head)\n        groupPrev = dummy\n\n        while True:\n            kth = self.getKth(groupPrev, k)\n            if not kth:\n                break\n            groupNext = kth.next\n\n            prev, curr = kth.next, groupPrev.next\n            while curr != groupNext:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            tmp = groupPrev.next\n            groupPrev.next = kth\n            groupPrev = tmp\n        return dummy.next\n\n    def getKth(self, curr, k):\n        while curr and k \u003E 0:\n            curr = curr.next\n            k -= 1\n        return curr\n"
  },
  {
    "Name": "Invert Binary Tree",
    "NcLink": "invert-a-binary-tree/",
    "Pattern": "Trees",
    "Description": "You are given the root of a binary tree \u0060root\u0060. Invert the binary tree and return its root.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ac124ee6-207f-41f6-3aaa-dfb35815f200/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3,4,5,6,7]\n\nOutput: [1,3,2,7,6,5,4]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e39e8d4f-9946-4f99-ee3d-0d4df08d4d00/public)\n\n\u0060\u0060\u0060java\nInput: root = [3,2,1]\n\nOutput: [3,1,2]\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: root = []\n\nOutput: []\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= The number of nodes in the tree \u003C= 100\u0060.\n* \u0060-100 \u003C= Node.val \u003C= 100\u0060\n",
    "Difficulty": "Easy",
    "Video": "OnSn2XEQ4MY",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -\u003E Optional[TreeNode]:\n        if not root: return None\n\n        root.left, root.right = root.right, root.left\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root\n"
  },
  {
    "Name": "Maximum Depth of Binary Tree",
    "NcLink": "depth-of-binary-tree/",
    "Pattern": "Trees",
    "Description": "Given the \u0060root\u0060 of a binary tree, return its **depth**.\n\nThe **depth** of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5ea6da77-7e43-43e0-dd9d-e879ca0b1600/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3,null,null,4]\n\nOutput: 3\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: root = []\n\nOutput: 0\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= The number of nodes in the tree \u003C= 100\u0060.\n* \u0060-100 \u003C= Node.val \u003C= 100\u0060\n",
    "Difficulty": "Easy",
    "Video": "hTM3phVI6YQ",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n# RECURSIVE DFS\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -\u003E int:\n        if not root:\n            return 0\n\n        return 1 \u002B max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n\n# ITERATIVE DFS\n# class Solution:\n#     def maxDepth(self, root: Optional[TreeNode]) -\u003E int:\n#         stack = [[root, 1]]\n#         res = 0\n\n#         while stack:\n#             node, depth = stack.pop()\n\n#             if node:\n#                 res = max(res, depth)\n#                 stack.append([node.left, depth \u002B 1])\n#                 stack.append([node.right, depth \u002B 1])\n#         return res\n\n\n# BFS\n# class Solution:\n#     def maxDepth(self, root: Optional[TreeNode]) -\u003E int:\n#         q = deque()\n#         if root:\n#             q.append(root)\n\n#         level = 0\n\n#         while q:\n\n#             for i in range(len(q)):\n#                 node = q.popleft()\n#                 if node.left:\n#                     q.append(node.left)\n#                 if node.right:\n#                     q.append(node.right)\n#             level \u002B= 1\n#         return level\n"
  },
  {
    "Name": "Diameter of Binary Tree",
    "NcLink": "binary-tree-diameter/",
    "Pattern": "Trees",
    "Description": "The **diameter** of a binary tree is defined as the **length** of the longest path between *any two nodes within the tree*. The path does not necessarily have to pass through the root.\n    \nThe **length** of a path between two nodes in a binary tree is the number of edges between the nodes.\n\nGiven the root of a binary tree \u0060root\u0060, return the **diameter** of the tree.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/90e1d7a0-4322-4c5d-c59b-dde2bf92bb00/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,null,2,3,4,5]\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: 3 is the length of the path \u0060[1,2,3,5]\u0060 or \u0060[5,3,2,4]\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3]\n\nOutput: 2\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= number of nodes in the tree \u003C= 100\u0060\n* \u0060-100 \u003C= Node.val \u003C= 100\u0060\n",
    "Difficulty": "Easy",
    "Video": "K81C31ytOZE",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -\u003E int:\n        res = 0\n\n        def dfs(root):\n            nonlocal res\n\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            res = max(res, left \u002B right)\n\n            return 1 \u002B max(left, right)\n\n        dfs(root)\n        return res\n"
  },
  {
    "Name": "Balanced Binary Tree",
    "NcLink": "balanced-binary-tree/",
    "Pattern": "Trees",
    "Description": "Given a binary tree, return \u0060true\u0060 if it is **height-balanced** and \u0060false\u0060 otherwise.\n\nA **height-balanced** binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c19c3727-ea28-416c-3873-79ee75f2b400/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3,null,null,4]\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/24fcc2da-e012-4f9e-856e-040f200f3c00/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3,null,null,4,null,5]\n\nOutput: false\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: root = []\n\nOutput: true\n\u0060\u0060\u0060\n\n**Constraints:**\n* The number of nodes in the tree is in the range \u0060[0, 1000]\u0060.\n* \u0060-1000 \u003C= Node.val \u003C= 1000\u0060\n",
    "Difficulty": "Easy",
    "Video": "QfJsau0ItOY",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -\u003E bool:\n        def dfs(root):\n            if not root:\n                return [True, 0]\n\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = left[0] and right[0] and abs(left[1] - right[1]) \u003C= 1\n            return [balanced, 1 \u002B max(left[1], right[1])]\n\n        return dfs(root)[0]\n"
  },
  {
    "Name": "Same Tree",
    "NcLink": "same-binary-tree/",
    "Pattern": "Trees",
    "Description": "Given the roots of two binary trees \u0060p\u0060 and \u0060q\u0060, return \u0060true\u0060 if the trees are **equivalent**, otherwise return \u0060false\u0060.\n\nTwo binary trees are considered **equivalent** if they share the exact same structure and the nodes have the same values.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e78fc10c-4692-471f-5261-61e9be4f3a00/public)\n\n\u0060\u0060\u0060java\nInput: p = [1,2,3], q = [1,2,3]\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0b0ee764-c643-46ff-cb3f-86ce8b58ab00/public)\n\n\u0060\u0060\u0060java\nInput: p = [4,7], q = [4,null,7]\n\nOutput: false\n\u0060\u0060\u0060\n\n**Example 3:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/4d811f95-0488-490b-1f4f-fc5489df0f00/public)\n\n\u0060\u0060\u0060java\nInput: p = [1,2,3], q = [1,3,2]\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= The number of nodes in both trees \u003C= 100\u0060.\n* \u0060-100 \u003C= Node.val \u003C= 100\u0060\n",
    "Difficulty": "Easy",
    "Video": "vRbbcKXCxOw",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -\u003E bool:\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False\n"
  },
  {
    "Name": "Subtree of Another Tree",
    "NcLink": "subtree-of-a-binary-tree/",
    "Pattern": "Trees",
    "Description": "Given the roots of two binary trees \u0060root\u0060 and \u0060subRoot\u0060, return \u0060true\u0060 if there is a subtree of \u0060root\u0060 with the same structure and node values of \u0060subRoot\u0060 and \u0060false\u0060 otherwise.\n\nA subtree of a binary tree \u0060tree\u0060 is a tree that consists of a node in \u0060tree\u0060 and all of this node\u0027s descendants. The tree \u0060tree\u0060 could also be considered as a subtree of itself.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2991a77a-9664-46ed-528d-019e392f7400/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3,4,5], subRoot = [2,4,5]\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ae6114cb-23a0-457f-c441-0a82b7a58500/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3,4,5,null,null,6], subRoot = [2,4,5]\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= The number of nodes in both trees \u003C= 100\u0060.\n* \u0060-100 \u003C= root.val, subRoot.val \u003C= 100\u0060\n",
    "Difficulty": "Easy",
    "Video": "E36O5SWp-LE",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    \n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -\u003E bool:\n        if not subRoot:\n            return True\n        if not root:\n            return False\n\n        if self.sameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def sameTree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -\u003E bool:\n        if not root and not subRoot:\n            return True\n        if root and subRoot and root.val == subRoot.val:\n            return self.sameTree(root.left, subRoot.left) and self.sameTree(root.right, subRoot.right)\n        return False\n"
  },
  {
    "Name": "Lowest Common Ancestor of a Binary Search Tree",
    "NcLink": "lowest-common-ancestor-in-binary-search-tree/",
    "Pattern": "Trees",
    "Description": "Given a binary search tree (BST) where all node values are *unique*, and two nodes from the tree \u0060p\u0060 and \u0060q\u0060, return the lowest common ancestor (LCA) of the two nodes.\n\nThe lowest common ancestor between two nodes \u0060p\u0060 and \u0060q\u0060 is the lowest node in a tree \u0060T\u0060 such that both \u0060p\u0060 and \u0060q\u0060 as descendants. The ancestor is allowed to be a descendant of itself.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2080ee6a-3d27-4cd5-0db2-07672ead8200/public)\n\n\u0060\u0060\u0060java\nInput: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 8\n\nOutput: 5\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2080ee6a-3d27-4cd5-0db2-07672ead8200/public)\n\n\u0060\u0060\u0060java\nInput: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 4\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: The LCA of nodes 3 and 4 is 3, since a node can be a descendant of itself.\n\n\n**Constraints:**\n* \u00602 \u003C= The number of nodes in the tree \u003C= 100\u0060.\n* \u0060-100 \u003C= Node.val \u003C= 100\u0060\n* \u0060p != q\u0060\n* \u0060p\u0060 and \u0060q\u0060 will both exist in the BST.\n",
    "Difficulty": "Medium",
    "Video": "gs2LMfuOR9k",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -\u003E TreeNode:\n        while True:\n            if root.val \u003C p.val and root.val \u003C q.val:\n                root = root.right\n            elif root.val \u003E p.val and root.val \u003E q.val:\n                root = root.left\n            else:\n                return root\n"
  },
  {
    "Name": "Binary Tree Level Order Traversal",
    "NcLink": "level-order-traversal-of-binary-tree/",
    "Pattern": "Trees",
    "Description": "Given a binary tree \u0060root\u0060, return the level order traversal of it as a nested list, where each sublist contains the values of nodes at a particular level in the tree, from left to right.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a4639809-0754-4eda-221f-a4cd58bd9c00/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3,4,5,6,7]\n\nOutput: [[1],[2,3],[4,5,6,7]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: root = [1]\n\nOutput: [[1]]\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: root = []\n\nOutput: []\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= The number of nodes in both trees \u003C= 1000\u0060.\n* \u0060-1000 \u003C= Node.val \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "6ZnyEApgFYg",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -\u003E List[List[int]]:\n        res = []\n        q = deque()\n        if root:\n            q.append(root)\n\n        while q:\n            val = []\n\n            for i in range(len(q)):\n                node = q.popleft()\n                val.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(val)\n        return res\n"
  },
  {
    "Name": "Binary Tree Right Side View",
    "NcLink": "binary-tree-right-side-view/",
    "Pattern": "Trees",
    "Description": "You are given the \u0060root\u0060 of a binary tree. Return only the values of the nodes that are visible from the right side of the tree, ordered from top to bottom.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d348893a-8917-456c-9599-c405cfc4e000/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3]\n\nOutput: [1,3]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3,4,5,6,7]\n\nOutput: [1,3,7]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= number of nodes in the tree \u003C= 100\u0060\n* \u0060-100 \u003C= Node.val \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "d4zLyf32e3I",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -\u003E List[int]:\n        res = []\n        q = deque([root])\n\n        while q:\n            rightSide = None\n            qLen = len(q)\n\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    rightSide = node\n                    q.append(node.left)\n                    q.append(node.right)\n            if rightSide:\n                res.append(rightSide.val)\n        return res\n"
  },
  {
    "Name": "Count Good Nodes In Binary Tree",
    "NcLink": "count-good-nodes-in-binary-tree/",
    "Pattern": "Trees",
    "Description": "Within a binary tree, a node \u0060x\u0060 is considered **good** if the path from the root of the tree to the node \u0060x\u0060 contains no nodes with a value greater than the value of node \u0060x\u0060\n\nGiven the root of a binary tree \u0060root\u0060, return the number of **good** nodes within the tree.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9bf374f1-71fe-469e-2840-5d223d9d1b00/public)\n\n\u0060\u0060\u0060java\nInput: root = [2,1,1,3,null,1,5]\n\nOutput: 3\n\u0060\u0060\u0060\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/8df65da7-abac-4948-9a92-0bc7a8dda100/public)\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: root = [1,2,-1,3,4]\n\nOutput: 4\n\u0060\u0060\u0060\n\n\n**Constraints:**\n* \u00601 \u003C= number of nodes in the tree \u003C= 100\u0060\n* \u0060-100 \u003C= Node.val \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "7cp5imvDzl4",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def goodNodes(self, root: TreeNode) -\u003E int:\n        def dfs(node, maxVal):\n            if not node:\n                return 0\n\n            res = 1 if node.val \u003E= maxVal else 0\n            maxVal = max(maxVal, node.val)\n            res \u002B= dfs(node.left, maxVal)\n            res \u002B= dfs(node.right, maxVal)\n            return res\n\n        return dfs(root, root.val)\n"
  },
  {
    "Name": "Validate Binary Search Tree",
    "NcLink": "valid-binary-search-tree/",
    "Pattern": "Trees",
    "Description": "Given the \u0060root\u0060 of a binary tree, return \u0060true\u0060 if it is a **valid binary search tree**, otherwise return \u0060false\u0060.\n\nA **valid binary search tree** satisfies the following constraints:    \n* The left subtree of every node contains only nodes with keys **less than** the node\u0027s key.\n* The right subtree of every node contains only nodes with keys **greater than** the node\u0027s key.\n* Both the left and right subtrees are also binary search trees.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/18f9a316-8dc2-4e11-d304-51204454ac00/public)\n\n\u0060\u0060\u0060java\nInput: root = [2,1,3]\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6f14cb8d-efad-4221-2beb-fba2b19c8a00/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3]\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation: The root node\u0027s value is 1 but its left child\u0027s value is 2 which is greater than 1.\n\n**Constraints:**\n* \u00601 \u003C= The number of nodes in the tree \u003C= 1000\u0060.\n* \u0060-1000 \u003C= Node.val \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "s6ATEkipzow",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -\u003E bool:\n        def valid(node, left, right):\n            if not node:\n                return True\n            if not (left \u003C node.val \u003C right):\n                return False\n\n            return valid(node.left, left, node.val) and valid(\n                node.right, node.val, right\n            )\n\n        return valid(root, float(\u0022-inf\u0022), float(\u0022inf\u0022))\n"
  },
  {
    "Name": "Kth Smallest Element In a Bst",
    "NcLink": "kth-smallest-integer-in-bst/",
    "Pattern": "Trees",
    "Description": "Given the \u0060root\u0060 of a binary search tree, and an integer \u0060k\u0060, return the \u0060kth\u0060 smallest value (**1-indexed**) in the tree.\n\nA **binary search tree** satisfies the following constraints:    \n* The left subtree of every node contains only nodes with keys **less than** the node\u0027s key.\n* The right subtree of every node contains only nodes with keys **greater than** the node\u0027s key.\n* Both the left and right subtrees are also binary search trees.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/02eca3db-f72f-4277-7134-faec4f02e500/public)\n\n\u0060\u0060\u0060java\nInput: root = [2,1,3], k = 1\n\nOutput: 1\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/dca6c42d-2327-4036-f7f2-3e99d8203100/public)\n\n\u0060\u0060\u0060java\nInput: root = [4,3,5,2,null], k = 4\n\nOutput: 5\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= k \u003C= The number of nodes in the tree \u003C= 1000\u0060.\n* \u00600 \u003C= Node.val \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "5LUXSvjmGCw",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -\u003E int:\n        stack = []\n        curr = root\n\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            k -= 1\n            if k == 0:\n                return curr.val\n            curr = curr.right\n"
  },
  {
    "Name": "Construct Binary Tree From Preorder And Inorder Traversal",
    "NcLink": "binary-tree-from-preorder-and-inorder-traversal/",
    "Pattern": "Trees",
    "Description": "You are given two integer arrays \u0060preorder\u0060 and \u0060inorder\u0060.\n        \n* \u0060preorder\u0060 is the preorder traversal of a binary tree\n* \u0060inorder\u0060 is the inorder traversal of the same tree\n* Both arrays are of the same size and consist of unique values.\n\nRebuild the binary tree from the preorder and inorder traversals and return its root.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/938c14d3-6669-47ab-924b-a1a08640f200/public)\n\n\u0060\u0060\u0060java\nInput: preorder = [1,2,3,4], inorder = [2,1,3,4]\n\nOutput: [1,2,3,null,null,null,4]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: preorder = [1], inorder = [1]\n\nOutput: [1]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= inorder.length \u003C= 1000\u0060.\n* \u0060inorder.length == preorder.length\u0060\n* \u0060-1000 \u003C= preorder[i], inorder[i] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "ihj4IQGZ2zc",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -\u003E Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1 : mid \u002B 1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid \u002B 1 :], inorder[mid \u002B 1 :])\n        return root\n"
  },
  {
    "Name": "Binary Tree Maximum Path Sum",
    "NcLink": "binary-tree-maximum-path-sum/",
    "Pattern": "Trees",
    "Description": "Given the \u0060root\u0060 of a *non-empty* binary tree, return the maximum **path sum** of any *non-empty* path.\n\nA **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge connecting them. A node can *not* appear in the sequence more than once. The path does *not* necessarily need to include the root.\n\nThe **path sum** of a path is the sum of the node\u0027s values in the path.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9896b041-9021-44c2-ab3e-5cff76adf100/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3]\n\nOutput: 6\n\u0060\u0060\u0060\n\nExplanation: The path is 2 -\u003E 1 -\u003E 3 with a sum of 2 \u002B 1 \u002B 3 = 6.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/19ce1187-387e-4323-f2c9-1a317ab36200/public)\n\n\u0060\u0060\u0060java\nInput: root = [-15,10,20,null,null,15,5,-5]\n\nOutput: 40\n\u0060\u0060\u0060\n\nExplanation: The path is 15 -\u003E 20 -\u003E 5 with a sum of 15 \u002B 20 \u002B 5 = 40.\n\n**Constraints:**\n* \u00601 \u003C= The number of nodes in the tree \u003C= 1000\u0060.\n* \u0060-1000 \u003C= Node.val \u003C= 1000\u0060\n",
    "Difficulty": "Hard",
    "Video": "Hr5cWUld4vU",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -\u003E int:\n        res = [root.val]\n\n        def dfs(root):\n            if not root:\n                return 0\n\n            leftMax = dfs(root.left)\n            rightMax = dfs(root.right)\n            leftMax = max(leftMax, 0)\n            rightMax = max(rightMax, 0)\n\n            res[0] = max(res[0], root.val \u002B leftMax \u002B rightMax)\n            return root.val \u002B max(leftMax, rightMax)\n\n        dfs(root)\n        return res[0]\n"
  },
  {
    "Name": "Serialize And Deserialize Binary Tree",
    "NcLink": "serialize-and-deserialize-binary-tree/",
    "Pattern": "Trees",
    "Description": "Implement an algorithm to serialize and deserialize a binary tree.\n\nSerialization is the process of converting an in-memory structure into a sequence of bits so that it can be stored or sent across a network to be reconstructed later in another computer environment.\n\nYou just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. There is no additional restriction on how your serialization/deserialization algorithm should work.\n\n**Note:** The input/output format in the examples is the same as how NeetCode serializes a binary tree. You do not necessarily need to follow this format.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a9dfb17f-70e9-42a3-ba97-33cfd82f6100/public)\n\n\u0060\u0060\u0060java\nInput: root = [1,2,3,null,null,4,5]\n\nOutput: [1,2,3,null,null,4,5]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: root = []\n\nOutput: []\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= The number of nodes in the tree \u003C= 1000\u0060.\n* \u0060-1000 \u003C= Node.val \u003C= 1000\u0060\n",
    "Difficulty": "Hard",
    "Video": "u4JAi2JJhI8",
    "PythonSolution": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Codec:\n    \n    # Encodes a tree to a single string.\n    def serialize(self, root: Optional[TreeNode]) -\u003E str:\n        res = []\n\n        def dfs(node):\n            if not node:\n                res.append(\u0022N\u0022)\n                return\n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return \u0022,\u0022.join(res)\n        \n    # Decodes your encoded data to tree.\n    def deserialize(self, data: str) -\u003E Optional[TreeNode]:\n        vals = data.split(\u0022,\u0022)\n        self.i = 0\n\n        def dfs():\n            if vals[self.i] == \u0022N\u0022:\n                self.i \u002B= 1\n                return None\n            node = TreeNode(int(vals[self.i]))\n            self.i \u002B= 1\n            node.left = dfs()\n            node.right = dfs()\n            return node\n\n        return dfs()\n"
  },
  {
    "Name": "Kth Largest Element In a Stream",
    "NcLink": "kth-largest-integer-in-a-stream/",
    "Pattern": "Heap / Priority Queue",
    "Description": "Design a class to find the \u0060kth\u0060 largest integer in a stream of values, including duplicates. E.g. the \u00602nd\u0060 largest from [1, 2, 3, 3] is \u00603\u0060. The stream is not necessarily sorted.\n\nImplement the following methods:\n* \u0060constructor(int k, int[] nums)\u0060 Initializes the object given an integer \u0060k\u0060 and the stream of integers \u0060nums\u0060.\n* \u0060int add(int val)\u0060 Adds the integer \u0060val\u0060 to the stream and returns the \u0060kth\u0060 largest integer in the stream.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput:\n[\u0022KthLargest\u0022, [3, [1, 2, 3, 3]], \u0022add\u0022, [3], \u0022add\u0022, [5], \u0022add\u0022, [6], \u0022add\u0022, [7], \u0022add\u0022, [8]]\n\nOutput:\n[null, 3, 3, 3, 5, 6]\n\nExplanation:\nKthLargest kthLargest = new KthLargest(3, [1, 2, 3, 3]);\nkthLargest.add(3);   // return 3\nkthLargest.add(5);   // return 3\nkthLargest.add(6);   // return 3\nkthLargest.add(7);   // return 5\nkthLargest.add(8);   // return 6\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= k \u003C= 1000\u0060\n* \u00600 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-1000 \u003C= nums[i] \u003C= 1000\u0060\n* \u0060-1000 \u003C= val \u003C= 1000\u0060\n* There will always be at least \u0060k\u0060 integers in the stream when you search for the \u0060kth\u0060 integer.\n",
    "Difficulty": "Easy",
    "Video": "hOjcdrqMoQ8",
    "PythonSolution": "class KthLargest:\n    \n    def __init__(self, k: int, nums: List[int]):\n        self.minHeap, self.k = nums, k\n        heapq.heapify(self.minHeap)\n        while len(self.minHeap) \u003E k:\n            heapq.heappop(self.minHeap)\n\n    def add(self, val: int) -\u003E int:\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) \u003E self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]\n"
  },
  {
    "Name": "Last Stone Weight",
    "NcLink": "last-stone-weight/",
    "Pattern": "Heap / Priority Queue",
    "Description": "You are given an array of integers \u0060stones\u0060 where \u0060stones[i]\u0060 represents the weight of the \u0060ith\u0060 stone.\n\nWe want to run a simulation on the stones as follows:\n\n* At each step we choose the **two heaviest stones**, with weight \u0060x\u0060 and \u0060y\u0060 and smash them togethers\n* If \u0060x == y\u0060, both stones are destroyed\n* If \u0060x \u003C y\u0060, the stone of weight \u0060x\u0060 is destroyed, and the stone of weight \u0060y\u0060 has new weight \u0060y - x\u0060.\n\nContinue the simulation until there is no more than one stone remaining.\n\nReturn the weight of the last remaining stone or return \u00600\u0060 if none remain.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: stones = [2,3,6,2,4]\n\nOutput: 1\n\u0060\u0060\u0060\nExplanation: \nWe smash 6 and 4 and are left with a 2, so the array becomes [2,3,2,2].\nWe smash 3 and 2 and are left with a 1, so the array becomes [1,2,2].\nWe smash 2 and 2, so the array becomes [1].\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: stones = [1,2]\n\nOutput: 1\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= stones.length \u003C= 20\u0060\n* \u00601 \u003C= stones[i] \u003C= 100\u0060\n",
    "Difficulty": "Easy",
    "Video": "B-QCq79-Vfw",
    "PythonSolution": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -\u003E int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n\n        while len(stones) \u003E 1:\n            first = heapq.heappop(stones)\n            second = heapq.heappop(stones)\n            if second \u003E first:\n                heapq.heappush(stones, first - second)\n\n        stones.append(0)\n        return abs(stones[0])\n"
  },
  {
    "Name": "K Closest Points to Origin",
    "NcLink": "k-closest-points-to-origin/",
    "Pattern": "Heap / Priority Queue",
    "Description": "You are given an 2-D array \u0060points\u0060 where \u0060points[i] = [xi, yi]\u0060 represents the coordinates of a point on an X-Y axis plane. You are also given an integer \u0060k\u0060.\n    \nReturn the \u0060k\u0060 closest points to the origin \u0060(0, 0)\u0060. \n\nThe distance between two points is defined as the Euclidean distance (\u0060sqrt((x1 - x2)^2 \u002B (y1 - y2)^2))\u0060.\n\nYou may return the answer in **any order**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ffe90895-5c8e-47f1-6719-d5c0f656d700/public)\n\n\u0060\u0060\u0060java\nInput: points = [[0,2],[2,2]], k = 1\n\nOutput: [[0,2]]\n\u0060\u0060\u0060\n\nExplanation : The distance between \u0060(0, 2)\u0060 and the origin \u0060(0, 0)\u0060 is \u00602\u0060. The distance between \u0060(2, 2)\u0060 and the origin is \u0060sqrt(2^2 \u002B 2^2) = 2.82842\u0060. So the closest point to the origin is \u0060(0, 2)\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: points = [[0,2],[2,0],[2,2]], k = 2\n\nOutput: [[0,2],[2,0]]\n\u0060\u0060\u0060\n\nExplanation: The output \u0060[2,0],[0,2]\u0060 would also be accepted.\n\n**Constraints:**\n* \u00601 \u003C= k \u003C= points.length \u003C= 1000\u0060\n* \u0060-100 \u003C= points[i][0], points[i][1] \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "rI2EBUEMfTk",
    "PythonSolution": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -\u003E List[List[int]]:\n        minHeap = []\n        for x, y in points:\n            dist = (x ** 2) \u002B (y ** 2)\n            minHeap.append((dist, x, y))\n        \n        heapq.heapify(minHeap)\n        res = []\n        for _ in range(k):\n            _, x, y = heapq.heappop(minHeap)\n            res.append((x, y))\n        return res\n"
  },
  {
    "Name": "Kth Largest Element In An Array",
    "NcLink": "kth-largest-element-in-an-array/",
    "Pattern": "Heap / Priority Queue",
    "Description": "Given an unsorted array of integers \u0060nums\u0060 and an integer \u0060k\u0060, return the \u0060kth\u0060 largest element in the array.\n\nBy \u0060kth\u0060 largest element, we mean the \u0060kth\u0060 largest element in the sorted order, not the \u0060kth\u0060 distinct element.\n\nFollow-up: Can you solve it without sorting?\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [2,3,1,5,4], k = 2\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [2,3,1,1,5,5,4], k = 3\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= k \u003C= nums.length \u003C= 10000\u0060\n* \u0060-1000 \u003C= nums[i] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "XEmy13g1Qxc",
    "PythonSolution": "# Quick Select\n# Time complexity: O(n) in average, O(n^2) in worst case\nclass Solution:\n\n    def findKthLargest(self, nums: List[int], k: int) -\u003E int:\n        k = len(nums) - k\n        left, right = 0, len(nums) - 1\n\n        while left \u003C right:\n            pivot = self.partition(nums, left, right)\n\n            if pivot \u003C k:\n                left = pivot \u002B 1\n            elif pivot \u003E k:\n                right = pivot - 1\n            else:\n                break\n\n        return nums[k]\n\n    def partition(self, nums: List[int], left: int, right: int) -\u003E int:\n        pivot, fill = nums[right], left\n\n        for i in range(left, right):\n            if nums[i] \u003C= pivot:\n                nums[fill], nums[i] = nums[i], nums[fill]\n                fill \u002B= 1\n\n        nums[fill], nums[right] = nums[right], nums[fill]\n\n        return fill\n"
  },
  {
    "Name": "Task Scheduler",
    "NcLink": "task-scheduling/",
    "Pattern": "Heap / Priority Queue",
    "Description": "You are given an array of CPU  tasks \u0060tasks\u0060, where \u0060tasks[i]\u0060 is an uppercase english character from \u0060A\u0060 to \u0060Z\u0060. You are also given an integer \u0060n\u0060. \n    \nEach CPU cycle allows the completion of a single task, and tasks may be completed in any order.\n\nThe only constraint is that **identical** tasks must be separated by at least \u0060n\u0060 CPU cycles, to cooldown the CPU.\n\nReturn the *minimum number* of CPU cycles required to complete all tasks.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: tasks = [\u0022X\u0022,\u0022X\u0022,\u0022Y\u0022,\u0022Y\u0022], n = 2\n\nOutput: 5\n\u0060\u0060\u0060\n\nExplanation: A possible sequence is: X -\u003E Y -\u003E idle -\u003E X -\u003E Y.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: tasks = [\u0022A\u0022,\u0022A\u0022,\u0022A\u0022,\u0022B\u0022,\u0022C\u0022], n = 3\n\nOutput: 9\n\u0060\u0060\u0060\n\nExplanation: A possible sequence is: A -\u003E B -\u003E C -\u003E Idle -\u003E A -\u003E Idle -\u003E Idle -\u003E Idle -\u003E A.\n\n**Constraints:**\n* \u00601 \u003C= tasks.length \u003C= 1000\u0060\n* \u00600 \u003C= n \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "s8p8ukTyA2I",
    "PythonSolution": "class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -\u003E int:\n        count = Counter(tasks)\n        maxHeap = [-cnt for cnt in count.values()]\n        heapq.heapify(maxHeap)\n\n        time = 0\n        q = deque()  # pairs of [-cnt, idleTime]\n        while maxHeap or q:\n            time \u002B= 1\n\n            if not maxHeap:\n                time = q[0][1]\n            else:\n                cnt = 1 \u002B heapq.heappop(maxHeap)\n                if cnt:\n                    q.append([cnt, time \u002B n])\n            if q and q[0][1] == time:\n                heapq.heappush(maxHeap, q.popleft()[0])\n        return time\n"
  },
  {
    "Name": "Design Twitter",
    "NcLink": "design-twitter-feed/",
    "Pattern": "Heap / Priority Queue",
    "Description": "Implement a simplified version of Twitter which allows users to post tweets, follow/unfollow each other, and view the \u006010\u0060 most recent tweets within their own news feed.\n\nUsers and tweets are uniquely identified by their IDs (integers).\n\nImplement the following methods:\n\n* \u0060Twitter()\u0060 Initializes the twitter object.\n* \u0060void postTweet(int userId, int tweetId)\u0060 Publish a new tweet with ID \u0060tweetId\u0060 by the user \u0060userId\u0060. You may assume that each \u0060tweetId\u0060 is unique.\n* \u0060List\u003CInteger\u003E getNewsFeed(int userId)\u0060 Fetches at most the \u006010\u0060 most recent tweet IDs in the user\u0027s news feed. Each item must be posted by users who the user is following or by the user themself. Tweets IDs should be **ordered from most recent to least recent**.\n* \u0060void follow(int followerId, int followeeId)\u0060 The user with ID \u0060followerId\u0060 follows the user with ID \u0060followeeId\u0060.\n* \u0060void unfollow(int followerId, int followeeId)\u0060 The user with ID \u0060followerId\u0060 unfollows the user with ID \u0060followeeId\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput:\n[\u0022Twitter\u0022, \u0022postTweet\u0022, [1, 10], \u0022postTweet\u0022, [2, 20], \u0022getNewsFeed\u0022, [1], \u0022getNewsFeed\u0022, [2], \u0022follow\u0022, [1, 2], \u0022getNewsFeed\u0022, [1], \u0022getNewsFeed\u0022, [2], \u0022unfollow\u0022, [1, 2], \u0022getNewsFeed\u0022, [1]]\n\nOutput:\n[null, null, null, [10], [20], null, [20, 10], [20], null, [10]]\n\nExplanation:\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 10); // User 1 posts a new tweet with id = 10.\ntwitter.postTweet(2, 20); // User 2 posts a new tweet with id = 20.\ntwitter.getNewsFeed(1);   // User 1\u0027s news feed should only contain their own tweets -\u003E [10].\ntwitter.getNewsFeed(2);   // User 2\u0027s news feed should only contain their own tweets -\u003E [20].\ntwitter.follow(1, 2);     // User 1 follows user 2.\ntwitter.getNewsFeed(1);   // User 1\u0027s news feed should contain both tweets from user 1 and user 2 -\u003E [20, 10].\ntwitter.getNewsFeed(2);   // User 2\u0027s news feed should still only contain their own tweets -\u003E [20].\ntwitter.unfollow(1, 2);   // User 1 follows user 2.\ntwitter.getNewsFeed(1);   // User 1\u0027s news feed should only contain their own tweets -\u003E [10].\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= userId, followerId, followeeId \u003C= 100\u0060\n* \u00600 \u003C= tweetId \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "pNichitDD2E",
    "PythonSolution": "class Twitter:\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = defaultdict(list)  # userId -\u003E list of [count, tweetIds]\n        self.followMap = defaultdict(set)  # userId -\u003E set of followeeId\n\n    def postTweet(self, userId: int, tweetId: int) -\u003E None:\n        self.tweetMap[userId].append([self.count, tweetId])\n        self.count -= 1\n\n    def getNewsFeed(self, userId: int) -\u003E List[int]:\n        res = []\n        minHeap = []\n\n        self.followMap[userId].add(userId)\n        for followeeId in self.followMap[userId]:\n            if followeeId in self.tweetMap:\n                index = len(self.tweetMap[followeeId]) - 1\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n\n        while minHeap and len(res) \u003C 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index \u003E= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -\u003E None:\n        self.followMap[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -\u003E None:\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)\n"
  },
  {
    "Name": "Find Median From Data Stream",
    "NcLink": "find-median-in-a-data-stream/",
    "Pattern": "Heap / Priority Queue",
    "Description": "The **[median](https://en.wikipedia.org/wiki/Median)** is the middle value in a sorted list of integers. For lists of *even* length, there is no middle value, so the median is the [mean](https://en.wikipedia.org/wiki/Mean) of the two middle values.\n\nFor example:\n* For \u0060arr = [1,2,3]\u0060, the median is \u00602\u0060.\n* For \u0060arr = [1,2]\u0060, the median is \u0060(1 \u002B 2) / 2 = 1.5\u0060\n\nImplement the MedianFinder class:\n\n* \u0060MedianFinder()\u0060 initializes the \u0060MedianFinder\u0060 object.\n* \u0060void addNum(int num)\u0060 adds the integer \u0060num\u0060 from the data stream to the data structure.\n* \u0060double findMedian()\u0060 returns the median of all elements so far.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput:\n[\u0022MedianFinder\u0022, \u0022addNum\u0022, \u00221\u0022, \u0022findMedian\u0022, \u0022addNum\u0022, \u00223\u0022 \u0022findMedian\u0022, \u0022addNum\u0022, \u00222\u0022, \u0022findMedian\u0022]\n\nOutput:\n[null, null, 1.0, null, 2.0, null, 2.0]\n\nExplanation:\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.findMedian(); // return 1.0\nmedianFinder.addNum(3);    // arr = [1, 3]\nmedianFinder.findMedian(); // return 2.0\nmedianFinder.addNum(2);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060-100,000 \u003C= num \u003C= 100,000\u0060\n* \u0060findMedian\u0060 will only be called after adding at least one integer to the data structure.\n",
    "Difficulty": "Hard",
    "Video": "itmhHWaHupI",
    "PythonSolution": "class MedianFinder:\n    def __init__(self):\n        # two heaps, large, small, minheap, maxheap\n        # heaps should be equal size\n        self.small, self.large = [], []  # maxHeap, minHeap (python default)\n\n    def addNum(self, num: int) -\u003E None:\n        if self.large and num \u003E self.large[0]:\n            heapq.heappush(self.large, num)\n        else:\n            heapq.heappush(self.small, -1 * num)\n\n        if len(self.small) \u003E len(self.large) \u002B 1:\n            val = -1 * heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) \u003E len(self.small) \u002B 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -1 * val)\n\n    def findMedian(self) -\u003E float:\n        if len(self.small) \u003E len(self.large):\n            return -1 * self.small[0]\n        elif len(self.large) \u003E len(self.small):\n            return self.large[0]\n        return (-1 * self.small[0] \u002B self.large[0]) / 2.0\n"
  },
  {
    "Name": "Subsets",
    "NcLink": "subsets/",
    "Pattern": "Backtracking",
    "Description": "Given an array \u0060nums\u0060 of **unique** integers, return all possible subsets of \u0060nums\u0060.\n\nThe solution set must **not** contain duplicate subsets. You may return the solution in **any order**.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,3]\n\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [7]\n\nOutput: [[],[7]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 10\u0060\n* \u0060-10 \u003C= nums[i] \u003C= 10\u0060\n",
    "Difficulty": "Medium",
    "Video": "REOH22Xwdkk",
    "PythonSolution": "class Solution:\n    def subsets(self, nums: List[int]) -\u003E List[List[int]]:\n        res = []\n\n        subset = []\n\n        def dfs(i):\n            if i \u003E= len(nums):\n                res.append(subset.copy())\n                return\n            subset.append(nums[i])\n            dfs(i \u002B 1)\n            subset.pop()\n            dfs(i \u002B 1)\n\n        dfs(0)\n        return res\n"
  },
  {
    "Name": "Combination Sum",
    "NcLink": "combination-target-sum/",
    "Pattern": "Backtracking",
    "Description": "You are given an array of **distinct** integers \u0060nums\u0060 and a target integer \u0060target\u0060. Your task is to return a list of all **unique combinations** of \u0060nums\u0060 where the chosen numbers sum to \u0060target\u0060.\n\nThe **same** number may be chosen from \u0060nums\u0060 an **unlimited number of times**. Two combinations are the same if the frequency of each of the chosen numbers is the same, otherwise they are different.\n\nYou may return the combinations in **any order** and the order of the numbers in each combination can be in **any order**.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: \nnums = [2,5,6,9] \ntarget = 9\n\nOutput: [[2,2,5],[9]]\n\u0060\u0060\u0060\n\nExplanation:\n2 \u002B 2 \u002B 5 = 9. We use 2 twice, and 5 once.\n9 = 9. We use 9 once.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: \nnums = [3,4,5]\ntarget = 16\n\nOutput: [[3,3,3,3,4],[3,3,5,5],[4,4,4,4],[3,4,4,5]]\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: \nnums = [3]\ntarget = 5\n\nOutput: []\n\u0060\u0060\u0060\n\n**Constraints:**\n* All elements of \u0060nums\u0060 are **distinct**.\n* \u00601 \u003C= nums.length \u003C= 20\u0060\n* \u00602 \u003C= nums[i] \u003C= 30\u0060\n* \u00602 \u003C= target \u003C= 30\u0060\n",
    "Difficulty": "Medium",
    "Video": "GBKI9VSKdGg",
    "PythonSolution": "class Solution:\n    def combinationSum(self, nums: List[int], target: int) -\u003E List[List[int]]:\n        res = []\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if i \u003E= len(nums) or total \u003E target:\n                return\n\n            cur.append(nums[i])\n            dfs(i, cur, total \u002B nums[i])\n            cur.pop()\n            dfs(i \u002B 1, cur, total)\n\n        dfs(0, [], 0)\n        return res\n"
  },
  {
    "Name": "Permutations",
    "NcLink": "permutations/",
    "Pattern": "Backtracking",
    "Description": "Given an array \u0060nums\u0060 of **unique** integers, return all the possible permutations. You may return the answer in **any order**.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,3]\n\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [7]\n\nOutput: [[7]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 6\u0060\n* \u0060-10 \u003C= nums[i] \u003C= 10\u0060\n",
    "Difficulty": "Medium",
    "Video": "FZe0UqISmUw",
    "PythonSolution": "class Solution:\n    def permute(self, nums: List[int]) -\u003E List[List[int]]:\n        res = []\n\n        if len(nums) == 1:\n            return [nums[:]]\n\n        for i in range(len(nums)):\n            n = nums.pop(0)\n            perms = self.permute(nums)\n\n            for perm in perms:\n                perm.append(n)\n            res.extend(perms)\n            nums.append(n)\n        return res\n"
  },
  {
    "Name": "Subsets II",
    "NcLink": "subsets-ii/",
    "Pattern": "Backtracking",
    "Description": "You are given an array \u0060nums\u0060 of integers, which may contain duplicates. Return all possible subsets.\n\nThe solution must **not** contain duplicate subsets. You may return the solution in **any order**.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,1]\n\nOutput: [[],[1],[1,2],[1,1],[1,2,1],[2]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [7,7]\n\nOutput: [[],[7], [7,7]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 11\u0060\n* \u0060-20 \u003C= nums[i] \u003C= 20\u0060\n",
    "Difficulty": "Medium",
    "Video": "Vn2v6ajA7U0",
    "PythonSolution": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -\u003E List[List[int]]:\n        res = []\n        nums.sort()\n\n        def backtrack(i, subset):\n            if i == len(nums):\n                res.append(subset[::])\n                return\n\n            subset.append(nums[i])\n            backtrack(i \u002B 1, subset)\n            subset.pop()\n\n            while i \u002B 1 \u003C len(nums) and nums[i] == nums[i \u002B 1]:\n                i \u002B= 1\n            backtrack(i \u002B 1, subset)\n\n        backtrack(0, [])\n        return res\n"
  },
  {
    "Name": "Combination Sum II",
    "NcLink": "combination-target-sum-ii/",
    "Pattern": "Backtracking",
    "Description": "You are given an array of integers \u0060candidates\u0060, which may contain duplicates, and a target integer \u0060target\u0060. Your task is to return a list of all **unique combinations** of \u0060candidates\u0060 where the chosen numbers sum to \u0060target\u0060.\n\nEach element from \u0060candidates\u0060 may be chosen **at most once** within a combination. The solution set must not contain duplicate combinations.\n\nYou may return the combinations in **any order** and the order of the numbers in each combination can be in **any order**.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: candidates = [9,2,2,4,6,1,5], target = 8\n\nOutput: [\n  [1,2,5],\n  [2,2,4],\n  [2,6]\n]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: candidates = [1,2,3,4,5], target = 7\n\nOutput: [\n  [1,2,4],\n  [2,5],\n  [3,4]\n]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= candidates.length \u003C= 100\u0060\n* \u00601 \u003C= candidates[i] \u003C= 50\u0060\n* \u00601 \u003C= target \u003C= 30\u0060\n",
    "Difficulty": "Medium",
    "Video": "FOyRpNUSFeA",
    "PythonSolution": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -\u003E List[List[int]]:\n        res = []\n        candidates.sort()\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if total \u003E target or i == len(candidates):\n                return\n            # include candidates[i]\n            cur.append(candidates[i])\n            dfs(i \u002B 1, cur, total \u002B candidates[i])\n            cur.pop()\n\n            # skip candidates[i]\n            while i \u002B 1 \u003C len(candidates) and candidates[i] == candidates[i\u002B1]:\n                i \u002B= 1\n            dfs(i \u002B 1, cur, total)\n            \n        dfs(0, [], 0)\n        return res\n"
  },
  {
    "Name": "Word Search",
    "NcLink": "search-for-word/",
    "Pattern": "Backtracking",
    "Description": "Given a 2-D grid of characters \u0060board\u0060 and a string \u0060word\u0060, return \u0060true\u0060 if the word is present in the grid, otherwise return \u0060false\u0060.\n\nFor the word to be present it must be possible to form it with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7c1fcf82-71c8-4750-3ddd-4ab6a666a500/public)\n\n\u0060\u0060\u0060java\nInput: \nboard = [\n  [\u0022A\u0022,\u0022B\u0022,\u0022C\u0022,\u0022D\u0022],\n  [\u0022S\u0022,\u0022A\u0022,\u0022A\u0022,\u0022T\u0022],\n  [\u0022A\u0022,\u0022C\u0022,\u0022A\u0022,\u0022E\u0022]\n],\nword = \u0022CAT\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/79721392-44b6-4de7-c571-d3d1640ac100/public)\n\n\u0060\u0060\u0060java\nInput: \nboard = [\n  [\u0022A\u0022,\u0022B\u0022,\u0022C\u0022,\u0022D\u0022],\n  [\u0022S\u0022,\u0022A\u0022,\u0022A\u0022,\u0022T\u0022],\n  [\u0022A\u0022,\u0022C\u0022,\u0022A\u0022,\u0022E\u0022]\n],\nword = \u0022BAT\u0022\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= board.length, board[i].length \u003C= 5\u0060\n* \u00601 \u003C= word.length \u003C= 10\u0060\n* \u0060board\u0060 and \u0060word\u0060 consists of only lowercase and uppercase English letters.\n",
    "Difficulty": "Medium",
    "Video": "pfiQ_PS1g8E",
    "PythonSolution": "class Solution:\n    \n    def exist(self, board: List[List[str]], word: str) -\u003E bool:\n        m = len(board)\n        n = len(board[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0]:\n                    if self.dfs(board, word, 0, i, j, m, n):\n                        return True\n        \n        return False\n    \n    def dfs(self, board: List[List[str]], word: str, index: int, i: int, j: int, m: int, n: int):\n        if i \u003C 0 or i \u003E= m or j \u003C 0 or j \u003E= n or board[i][j] != word[index]:\n            return False\n        if index == len(word) - 1:\n            return True\n        \n        board[i][j] = \u0027#\u0027\n        \n        if (self.dfs(board, word, index \u002B 1, i - 1, j, m, n)\n            or self.dfs(board, word, index \u002B 1, i \u002B 1, j, m, n)\n            or self.dfs(board, word, index \u002B 1, i, j - 1, m, n)\n            or self.dfs(board, word, index \u002B 1, i, j \u002B 1, m, n)):\n            return True\n        \n        board[i][j] = word[index]\n        return False\n"
  },
  {
    "Name": "Palindrome Partitioning",
    "NcLink": "palindrome-partitioning/",
    "Pattern": "Backtracking",
    "Description": "Given a string \u0060s\u0060, split \u0060s\u0060 into substrings where every substring is a palindrome. Return all possible lists of palindromic substrings.\n\nYou may return the solution in **any order**.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022aab\u0022\n\nOutput: [[\u0022a\u0022,\u0022a\u0022,\u0022b\u0022],[\u0022aa\u0022,\u0022b\u0022]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022a\u0022\n\nOutput: [[\u0022a\u0022]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 20\u0060\n* \u0060s\u0060 contains only lowercase English letters.\n",
    "Difficulty": "Medium",
    "Video": "3jvWodd7ht0",
    "PythonSolution": "class Solution:\n    \n    def partition(self, s: str) -\u003E List[List[str]]:\n        res, part = [], []\n\n        def dfs(i):\n            if i \u003E= len(s):\n                res.append(part.copy())\n                return\n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    part.append(s[i : j \u002B 1])\n                    dfs(j \u002B 1)\n                    part.pop()\n\n        dfs(0)\n        return res\n\n    def isPali(self, s, l, r):\n        while l \u003C r:\n            if s[l] != s[r]:\n                return False\n            l, r = l \u002B 1, r - 1\n        return True\n"
  },
  {
    "Name": "Letter Combinations of a Phone Number",
    "NcLink": "combinations-of-a-phone-number/",
    "Pattern": "Backtracking",
    "Description": "You are given a string \u0060digits\u0060 made up of digits from \u00602\u0060 through \u00609\u0060 inclusive.\n\nEach digit (not including 1) is mapped to a set of characters as shown below:\n\nA digit could represent any one of the characters it maps to.\n\nReturn all possible letter combinations that \u0060digits\u0060 could represent. You may return the answer in **any order**.\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/796a0dc1-2fcd-4ebb-0686-28f9007ec800/public)\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: digits = \u002234\u0022\n\nOutput: [\u0022dg\u0022,\u0022dh\u0022,\u0022di\u0022,\u0022eg\u0022,\u0022eh\u0022,\u0022ei\u0022,\u0022fg\u0022,\u0022fh\u0022,\u0022fi\u0022]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: digits = \u0022\u0022\n\nOutput: []\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= digits.length \u003C= 4\u0060\n* \u00602 \u003C= digits[i] \u003C= 9\u0060\n",
    "Difficulty": "Medium",
    "Video": "0snEunUacZY",
    "PythonSolution": "class Solution:\n    def letterCombinations(self, digits: str) -\u003E List[str]:\n        res = []\n        digitToChar = {\n            \u00222\u0022: \u0022abc\u0022,\n            \u00223\u0022: \u0022def\u0022,\n            \u00224\u0022: \u0022ghi\u0022,\n            \u00225\u0022: \u0022jkl\u0022,\n            \u00226\u0022: \u0022mno\u0022,\n            \u00227\u0022: \u0022qprs\u0022,\n            \u00228\u0022: \u0022tuv\u0022,\n            \u00229\u0022: \u0022wxyz\u0022,\n        }\n\n        def backtrack(i, curStr):\n            if len(curStr) == len(digits):\n                res.append(curStr)\n                return\n            for c in digitToChar[digits[i]]:\n                backtrack(i \u002B 1, curStr \u002B c)\n\n        if digits:\n            backtrack(0, \u0022\u0022)\n\n        return res\n"
  },
  {
    "Name": "N Queens",
    "NcLink": "n-queens/",
    "Pattern": "Backtracking",
    "Description": "The **n-queens** puzzle is the problem of placing \u0060n\u0060 queens on an \u0060n x n\u0060 chessboard so that no two queens can attack each other.\n\nA **queen** in a chessboard can attack horizontally, vertically, and diagonally.\n\nGiven an integer \u0060n\u0060, return all distinct solutions to the **n-queens puzzle**.\n\nEach solution contains a unique board layout where the queen pieces are placed. \u0060\u0027Q\u0027\u0060 indicates a queen and \u0060\u0027.\u0027\u0060 indicates an empty space.\n\nYou may return the answer in **any order**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/cdf2b34d-7905-4388-db0b-9a120ebf4a00/public)\n\n\u0060\u0060\u0060java\nInput: n = 4\n\nOutput: [[\u0022.Q..\u0022,\u0022...Q\u0022,\u0022Q...\u0022,\u0022..Q.\u0022],[\u0022..Q.\u0022,\u0022Q...\u0022,\u0022...Q\u0022,\u0022.Q..\u0022]]\n\u0060\u0060\u0060\n\nExplanation: There are two different solutions to the 4-queens puzzle.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: n = 1\n\nOutput: [[\u0022Q\u0022]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= n \u003C= 8\u0060\n",
    "Difficulty": "Hard",
    "Video": "Ph95IHmRp5M",
    "PythonSolution": "class Solution:\n    def solveNQueens(self, n: int) -\u003E List[List[str]]:\n        col = set()\n        posDiag = set()\n        negDiag = set()\n\n        res = []\n        board = [[\u0022.\u0022] * n for i in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                copy = [\u0022\u0022.join(row) for row in board]\n                res.append(copy)\n                return\n\n            for c in range(n):\n                if c in col or (r \u002B c) in posDiag or (r - c) in negDiag:\n                    continue\n\n                col.add(c)\n                posDiag.add(r \u002B c)\n                negDiag.add(r - c)\n                board[r][c] = \u0022Q\u0022\n\n                backtrack(r \u002B 1)\n\n                col.remove(c)\n                posDiag.remove(r \u002B c)\n                negDiag.remove(r - c)\n                board[r][c] = \u0022.\u0022\n\n        backtrack(0)\n        return res\n"
  },
  {
    "Name": "Implement Trie Prefix Tree",
    "NcLink": "implement-prefix-tree/",
    "Pattern": "Tries",
    "Description": "A **prefix tree** (also known as a trie) is a tree data structure used to efficiently store and retrieve keys in a set of strings. Some applications of this data structure include auto-complete and spell checker systems.\n\nImplement the PrefixTree class:\n* \u0060PrefixTree()\u0060 Initializes the prefix tree object.\n* \u0060void insert(String word)\u0060 Inserts the string \u0060word\u0060 into the prefix tree.\n* \u0060boolean search(String word)\u0060 Returns \u0060true\u0060 if the string \u0060word\u0060 is in the prefix tree (i.e., was inserted before), and \u0060false\u0060 otherwise.\n* \u0060boolean startsWith(String prefix)\u0060 Returns \u0060true\u0060 if there is a previously inserted string \u0060word\u0060 that has the prefix \u0060prefix\u0060, and \u0060false\u0060 otherwise.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: \n[\u0022Trie\u0022, \u0022insert\u0022, \u0022dog\u0022, \u0022search\u0022, \u0022dog\u0022, \u0022search\u0022, \u0022do\u0022, \u0022startsWith\u0022, \u0022do\u0022, \u0022insert\u0022, \u0022do\u0022, \u0022search\u0022, \u0022do\u0022]\n\nOutput:\n[null, null, true, false, true, null, true]\n\nExplanation:\nPrefixTree prefixTree = new PrefixTree();\nprefixTree.insert(\u0022dog\u0022);\nprefixTree.search(\u0022dog\u0022);    // return true\nprefixTree.search(\u0022do\u0022);     // return false\nprefixTree.startsWith(\u0022do\u0022); // return true\nprefixTree.insert(\u0022do\u0022);\nprefixTree.search(\u0022do\u0022);     // return true\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= word.length, prefix.length \u003C= 1000\u0060\n* \u0060word\u0060 and \u0060prefix\u0060 are made up of lowercase English letters.\n",
    "Difficulty": "Medium",
    "Video": "oobqoCJlHA0",
    "PythonSolution": "class PrefixTreeNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.end = False\n\nclass PrefixTree:\n    def __init__(self):\n        self.root = PrefixTreeNode()\n\n    def insert(self, word: str) -\u003E None:\n        curr = self.root\n        for c in word:\n            i = ord(c) - ord(\u0022a\u0022)\n            if curr.children[i] == None:\n                curr.children[i] = PrefixTreeNode()\n            curr = curr.children[i]\n        curr.end = True\n\n    def search(self, word: str) -\u003E bool:\n        curr = self.root\n        for c in word:\n            i = ord(c) - ord(\u0022a\u0022)\n            if curr.children[i] == None:\n                return False\n            curr = curr.children[i]\n        return curr.end\n\n    def startsWith(self, prefix: str) -\u003E bool:\n        curr = self.root\n        for c in prefix:\n            i = ord(c) - ord(\u0022a\u0022)\n            if curr.children[i] == None:\n                return False\n            curr = curr.children[i]\n        return True\n"
  },
  {
    "Name": "Design Add And Search Words Data Structure",
    "NcLink": "design-word-search-data-structure/",
    "Pattern": "Tries",
    "Description": "Design a data structure that supports adding new words and searching for existing words.\n\nImplement the \u0060WordDictionary\u0060 class:\n\n* \u0060void addWord(word)\u0060 Adds \u0060word\u0060 to the data structure.\n* \u0060bool search(word)\u0060 Returns \u0060true\u0060 if there is any string in the data structure that matches \u0060word\u0060 or \u0060false\u0060 otherwise. \u0060word\u0060 may contain dots \u0060\u0027.\u0027\u0060 where dots can be matched with any letter.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput:\n[\u0022WordDictionary\u0022, \u0022addWord\u0022, \u0022day\u0022, \u0022addWord\u0022, \u0022bay\u0022, \u0022addWord\u0022, \u0022may\u0022, \u0022search\u0022, \u0022say\u0022, \u0022search\u0022, \u0022day\u0022, \u0022search\u0022, \u0022.ay\u0022, \u0022search\u0022, \u0022b..\u0022]\n\nOutput:\n[null, null, null, null, false, true, true, true]\n\nExplanation:\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\u0022day\u0022);\nwordDictionary.addWord(\u0022bay\u0022);\nwordDictionary.addWord(\u0022may\u0022);\nwordDictionary.search(\u0022say\u0022); // return false\nwordDictionary.search(\u0022day\u0022); // return true\nwordDictionary.search(\u0022.ay\u0022); // return true\nwordDictionary.search(\u0022b..\u0022); // return true\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= word.length \u003C= 20\u0060\n* \u0060word\u0060 in \u0060addWord\u0060 consists of lowercase English letters.\n* \u0060word\u0060 in \u0060search\u0060 consist of \u0060\u0027.\u0027\u0060 or lowercase English letters.\n",
    "Difficulty": "Medium",
    "Video": "BTf05gs_8iU",
    "PythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}  # a : TrieNode\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -\u003E None:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.word = True\n\n    def search(self, word: str) -\u003E bool:\n        def dfs(j, root):\n            cur = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n                if c == \u0022.\u0022:\n                    for child in cur.children.values():\n                        if dfs(i \u002B 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in cur.children:\n                        return False\n                    cur = cur.children[c]\n            return cur.word\n\n        return dfs(0, self.root)\n"
  },
  {
    "Name": "Word Search II",
    "NcLink": "search-for-word-ii/",
    "Pattern": "Tries",
    "Description": "Given a 2-D grid of characters \u0060board\u0060 and a list of strings \u0060words\u0060, return all words that are present in the grid.\n\nFor a word to be present it must be possible to form the word with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/06435c8e-bac3-49f5-5df7-77fd5dd42800/public)\n\n\u0060\u0060\u0060java\nInput:\nboard = [\n  [\u0022a\u0022,\u0022b\u0022,\u0022c\u0022,\u0022d\u0022],\n  [\u0022s\u0022,\u0022a\u0022,\u0022a\u0022,\u0022t\u0022],\n  [\u0022a\u0022,\u0022c\u0022,\u0022k\u0022,\u0022e\u0022],\n  [\u0022a\u0022,\u0022c\u0022,\u0022d\u0022,\u0022n\u0022]\n],\nwords = [\u0022bat\u0022,\u0022cat\u0022,\u0022back\u0022,\u0022backend\u0022,\u0022stack\u0022]\n\nOutput: [\u0022cat\u0022,\u0022back\u0022,\u0022backend\u0022]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6f244a10-78bf-4a30-0a5f-b8f3e03ce000/public)\n\n\u0060\u0060\u0060java\nInput:\nboard = [\n  [\u0022x\u0022,\u0022o\u0022],\n  [\u0022x\u0022,\u0022o\u0022]\n],\nwords = [\u0022xoxo\u0022]\n\nOutput: []\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= board.length, board[i].length \u003C= 10\u0060\n* \u0060board[i]\u0060 consists only of lowercase English letter.\n* \u00601 \u003C= words.length \u003C= 100\u0060\n* \u00601 \u003C= words[i].length \u003C= 10\u0060\n* \u0060words[i]\u0060 consists only of lowercase English letters.\n* All strings within \u0060words\u0060 are distinct.\n",
    "Difficulty": "Hard",
    "Video": "asbcE9mZz_U",
    "PythonSolution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n        self.refs = 0\n\n    def addWord(self, word):\n        cur = self\n        cur.refs \u002B= 1\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n            cur.refs \u002B= 1\n        cur.isWord = True\n\n    def removeWord(self, word):\n        cur = self\n        cur.refs -= 1\n        for c in word:\n            if c in cur.children:\n                cur = cur.children[c]\n                cur.refs -= 1\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -\u003E List[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n\n        ROWS, COLS = len(board), len(board[0])\n        res, visit = set(), set()\n\n        def dfs(r, c, node, word):\n            if (\n                r not in range(ROWS) \n                or c not in range(COLS)\n                or board[r][c] not in node.children\n                or node.children[board[r][c]].refs \u003C 1\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            node = node.children[board[r][c]]\n            word \u002B= board[r][c]\n            if node.isWord:\n                node.isWord = False\n                res.add(word)\n                root.removeWord(word)\n\n            dfs(r \u002B 1, c, node, word)\n            dfs(r - 1, c, node, word)\n            dfs(r, c \u002B 1, node, word)\n            dfs(r, c - 1, node, word)\n            visit.remove((r, c))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, root, \u0022\u0022)\n\n        return list(res)\n"
  },
  {
    "Name": "Number of Islands",
    "NcLink": "count-number-of-islands/",
    "Pattern": "Graphs",
    "Description": "Given a 2D grid \u0060grid\u0060 where \u0060\u00271\u0027\u0060 represents land and \u0060\u00270\u0027\u0060 represents water, count and return the number of islands.\n\nAn **island** is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. You may assume water is surrounding the grid (i.e., all the edges are water).   \n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: grid = [\n    [\u00220\u0022,\u00221\u0022,\u00221\u0022,\u00221\u0022,\u00220\u0022],\n    [\u00220\u0022,\u00221\u0022,\u00220\u0022,\u00221\u0022,\u00220\u0022],\n    [\u00221\u0022,\u00221\u0022,\u00220\u0022,\u00220\u0022,\u00220\u0022],\n    [\u00220\u0022,\u00220\u0022,\u00220\u0022,\u00220\u0022,\u00220\u0022]\n  ]\nOutput: 1\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: grid = [\n    [\u00221\u0022,\u00221\u0022,\u00220\u0022,\u00220\u0022,\u00221\u0022],\n    [\u00221\u0022,\u00221\u0022,\u00220\u0022,\u00220\u0022,\u00221\u0022],\n    [\u00220\u0022,\u00220\u0022,\u00221\u0022,\u00220\u0022,\u00220\u0022],\n    [\u00220\u0022,\u00220\u0022,\u00220\u0022,\u00221\u0022,\u00221\u0022]\n  ]\nOutput: 4\n\u0060\u0060\u0060\n\n\n**Constraints:**\n* \u00601 \u003C= grid.length, grid[i].length \u003C= 100\u0060\n* \u0060grid[i][j]\u0060 is \u0060\u00270\u0027\u0060 or \u0060\u00271\u0027\u0060.\n",
    "Difficulty": "Medium",
    "Video": "pV2kpPD66nE",
    "PythonSolution": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -\u003E int:\n        if not grid or not grid[0]:\n            return 0\n\n        islands = 0\n        visit = set()\n        rows, cols = len(grid), len(grid[0])\n\n        def dfs(r, c):\n            if (\n                r not in range(rows)\n                or c not in range(cols)\n                or grid[r][c] == \u00220\u0022\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n            for dr, dc in directions:\n                dfs(r \u002B dr, c \u002B dc)\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == \u00221\u0022 and (r, c) not in visit:\n                    islands \u002B= 1\n                    dfs(r, c)\n        return islands\n"
  },
  {
    "Name": "Max Area of Island",
    "NcLink": "max-area-of-island/",
    "Pattern": "Graphs",
    "Description": "You are given a matrix \u0060grid\u0060 where \u0060grid[i]\u0060 is either a \u00600\u0060 (representing water) or \u00601\u0060 (representing land).\n    \nAn island is defined as a group of \u00601\u0060\u0027s connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is defined as the number of cells within the island.\n\nReturn the maximum **area** of an island in \u0060grid\u0060. If no island exists, return \u00600\u0060.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/8eeb491c-c8ff-4ed6-78ed-ce4cf87d7200/public)\n\n\u0060\u0060\u0060java\nInput: grid = [\n  [0,1,1,0,1],\n  [1,0,1,0,1],\n  [0,1,1,0,1],\n  [0,1,0,0,1]\n]\n\nOutput: 6\n\u0060\u0060\u0060\nExplanation: \u00601\u0060\u0027s cannot be connected diagonally, so the maximum area of the island is \u00606\u0060.\n\n**Constraints:**\n* \u00601 \u003C= grid.length, grid[i].length \u003C= 50\u0060\n",
    "Difficulty": "Medium",
    "Video": "iJGr1OtmH0c",
    "PythonSolution": "class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -\u003E int:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n\n        def dfs(r, c):\n            if (\n                r \u003C 0\n                or r == ROWS\n                or c \u003C 0\n                or c == COLS\n                or grid[r][c] == 0\n                or (r, c) in visit\n            ):\n                return 0\n            visit.add((r, c))\n            return 1 \u002B dfs(r \u002B 1, c) \u002B dfs(r - 1, c) \u002B dfs(r, c \u002B 1) \u002B dfs(r, c - 1)\n\n        area = 0\n        for r in range(ROWS):\n            for c in range(COLS):\n                area = max(area, dfs(r, c))\n        return area\n"
  },
  {
    "Name": "Clone Graph",
    "NcLink": "clone-graph/",
    "Pattern": "Graphs",
    "Description": "Given a node in a connected undirected graph, return a deep copy of the graph.\n\nEach node in the graph contains an integer value and a list of its neighbors.\n\n\u0060\u0060\u0060java\nclass Node {\n    public int val;\n    public List\u003CNode\u003E neighbors;\n}\n\u0060\u0060\u0060\n\nThe graph is shown in the test cases as an adjacency list. **An adjacency list** is a mapping of nodes to lists, used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nFor simplicity, nodes values are numbered from 1 to \u0060n\u0060, where \u0060n\u0060 is the total number of nodes in the graph. The index of each node within the adjacency list is the same as the node\u0027s value (1-indexed).\n\nThe input node will always be the first node in the graph and have \u00601\u0060 as the value.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ca68c09d-4d0e-4d80-9c20-078c666cf900/public)\n\n\u0060\u0060\u0060java\nInput: adjList = [[2],[1,3],[2]]\n\nOutput: [[2],[1,3],[2]]\n\u0060\u0060\u0060\n\nExplanation: There are 3 nodes in the graph.\nNode 1: val = 1 and neighbors = [2].\nNode 2: val = 2 and neighbors = [1, 3].\nNode 3: val = 3 and neighbors = [2].\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/96c7fb34-26e8-42e0-5f5d-61b8b8c96800/public)\n\n\u0060\u0060\u0060java\nInput: adjList = [[]]\n\nOutput: [[]]\n\u0060\u0060\u0060\n\nExplanation: The graph has one node with no neighbors.\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: adjList = []\n\nOutput: []\n\u0060\u0060\u0060\n\nExplanation: The graph is empty.\n\n**Constraints:**\n* \u00600 \u003C= The number of nodes in the graph \u003C= 100\u0060.\n* \u00601 \u003C= Node.val \u003C= 100\u0060\n* There are no duplicate edges and no self-loops in the graph.\n",
    "Difficulty": "Medium",
    "Video": "mQeF6bN8hMk",
    "PythonSolution": "\u0022\u0022\u0022\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\u0022\u0022\u0022\n\nclass Solution:\n    def cloneGraph(self, node: Optional[\u0027Node\u0027]) -\u003E Optional[\u0027Node\u0027]:\n        oldToNew = {}\n\n        def dfs(node):\n            if node in oldToNew:\n                return oldToNew[node]\n\n            copy = Node(node.val)\n            oldToNew[node] = copy\n            for nei in node.neighbors:\n                copy.neighbors.append(dfs(nei))\n            return copy\n\n        return dfs(node) if node else None\n"
  },
  {
    "Name": "Walls And Gates",
    "NcLink": "islands-and-treasure/",
    "Pattern": "Graphs",
    "Description": "You are given a $m \\times n$ 2D \u0060grid\u0060 initialized with these three possible values:\n\n1. \u0060-1\u0060 - A water cell that *can not* be traversed.\n2. \u00600\u0060 - A treasure chest.\n3. \u0060INF\u0060 - A land cell that *can* be traversed. We use the integer \u00602^31 - 1 = 2147483647\u0060 to represent \u0060INF\u0060.\n\nFill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest than the value should remain \u0060INF\u0060.\n\nAssume the grid can only be traversed up, down, left, or right.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: [\n  [2147483647,-1,0,2147483647],\n  [2147483647,2147483647,2147483647,-1],\n  [2147483647,-1,2147483647,-1],\n  [0,-1,2147483647,2147483647]\n]\n\nOutput: [\n  [3,-1,0,1],\n  [2,2,1,-1],\n  [1,-1,2,-1],\n  [0,-1,3,4]\n]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: [\n  [0,-1],\n  [2147483647,2147483647]\n]\n\nOutput: [\n  [0,-1],\n  [1,2]\n]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060m == grid.length\u0060\n* \u0060n == grid[i].length\u0060\n* \u00601 \u003C= m, n \u003C= 100\u0060\n* \u0060grid[i][j]\u0060 is one of \u0060{-1, 0, 2147483647}\u0060\n",
    "Difficulty": "Medium",
    "Video": "e69C6xhiSQE",
    "PythonSolution": "class Solution:\n    def islandsAndTreasure(self, grid: List[List[int]]) -\u003E None:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n        q = deque()\n\n        def addCell(r, c):\n            if (\n                min(r, c) \u003C 0\n                or r == ROWS\n                or c == COLS\n                or (r, c) in visit\n                or grid[r][c] == -1\n            ):\n                return\n            visit.add((r, c))\n            q.append([r, c])\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 0:\n                    q.append([r, c])\n                    visit.add((r, c))\n\n        dist = 0\n        while q:\n            for i in range(len(q)):\n                r, c = q.popleft()\n                grid[r][c] = dist\n                addCell(r \u002B 1, c)\n                addCell(r - 1, c)\n                addCell(r, c \u002B 1)\n                addCell(r, c - 1)\n            dist \u002B= 1\n"
  },
  {
    "Name": "Rotting Oranges",
    "NcLink": "rotting-fruit/",
    "Pattern": "Graphs",
    "Description": "You are given a 2-D matrix \u0060grid\u0060. Each cell can have one of three possible values:\n* \u00600\u0060 representing an empty cell\n* \u00601\u0060 representing a fresh fruit\n* \u00602\u0060 representing a rotten fruit\n\nEvery minute, if a fresh fruit is horizontally or vertically adjacent to a rotten fruit, then the fresh fruit also becomes rotten.\n\nReturn the minimum number of minutes that must elapse until there are zero fresh fruits remaining. If this state is impossible within the grid, return \u0060-1\u0060.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5daa219c-ae90-4027-41c3-6ea4d9158300/public)\n\n\u0060\u0060\u0060java\nInput: grid = [[1,1,0],[0,1,1],[0,1,2]]\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: grid = [[1,0,1],[0,2,0],[1,0,1]]\n\nOutput: -1\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= grid.length, grid[i].length \u003C= 10\u0060\n",
    "Difficulty": "Medium",
    "Video": "y704fEOx0s0",
    "PythonSolution": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -\u003E int:\n        q = collections.deque()\n        fresh = 0\n        time = 0\n\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    fresh \u002B= 1\n                if grid[r][c] == 2:\n                    q.append((r, c))\n\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        while fresh \u003E 0 and q:\n            length = len(q)\n            for i in range(length):\n                r, c = q.popleft()\n\n                for dr, dc in directions:\n                    row, col = r \u002B dr, c \u002B dc\n                    if (\n                        row in range(len(grid))\n                        and col in range(len(grid[0]))\n                        and grid[row][col] == 1\n                    ):\n                        grid[row][col] = 2\n                        q.append((row, col))\n                        fresh -= 1\n            time \u002B= 1\n        return time if fresh == 0 else -1\n"
  },
  {
    "Name": "Pacific Atlantic Water Flow",
    "NcLink": "pacific-atlantic-water-flow/",
    "Pattern": "Graphs",
    "Description": "You are given a rectangular island \u0060heights\u0060 where \u0060heights[r][c]\u0060 represents the **height above sea level** of the cell at coordinate \u0060(r, c)\u0060.\n    \nThe islands borders the **Pacific Ocean** from the top and left sides, and borders the **Atlantic Ocean** from the bottom and right sides.\n\nWater can flow in **four directions** (up, down, left, or right) from a cell to a neighboring cell with **height equal or lower**. Water can also flow into the ocean from cells adjacent to the ocean.\n\nFind all cells where water can flow from that cell to **both** the Pacific and Atlantic oceans. Return it as a **2D list** where each element is a list \u0060[r, c]\u0060 representing the row and column of the cell. You may return the answer in **any order**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/3899fae1-ab18-4d6b-15b4-c7f7aa224700/public)\n\n\u0060\u0060\u0060java\nInput: heights = [\n  [4,2,7,3,4],\n  [7,4,6,4,7],\n  [6,3,5,3,6]\n]\n\nOutput: [[0,2],[0,4],[1,0],[1,1],[1,2],[1,3],[1,4],[2,0]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: heights = [[1],[1]]\n\nOutput: [[0,0],[0,1]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= heights.length, heights[r].length \u003C= 100\u0060\n* \u00600 \u003C= heights[r][c] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "s-VkcjHqkGI",
    "PythonSolution": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -\u003E List[List[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        pac, atl = set(), set()\n\n        def dfs(r, c, visit, prevHeight):\n            if (\n                (r, c) in visit\n                or r \u003C 0\n                or c \u003C 0\n                or r == ROWS\n                or c == COLS\n                or heights[r][c] \u003C prevHeight\n            ):\n                return\n            visit.add((r, c))\n            dfs(r \u002B 1, c, visit, heights[r][c])\n            dfs(r - 1, c, visit, heights[r][c])\n            dfs(r, c \u002B 1, visit, heights[r][c])\n            dfs(r, c - 1, visit, heights[r][c])\n\n        for c in range(COLS):\n            dfs(0, c, pac, heights[0][c])\n            dfs(ROWS - 1, c, atl, heights[ROWS - 1][c])\n\n        for r in range(ROWS):\n            dfs(r, 0, pac, heights[r][0])\n            dfs(r, COLS - 1, atl, heights[r][COLS - 1])\n\n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                if (r, c) in pac and (r, c) in atl:\n                    res.append([r, c])\n        return res\n"
  },
  {
    "Name": "Surrounded Regions",
    "NcLink": "surrounded-regions/",
    "Pattern": "Graphs",
    "Description": "You are given a 2-D matrix \u0060board\u0060 containing \u0060\u0027X\u0027\u0060 and \u0060\u0027O\u0027\u0060 characters.\n\nIf a continous, four-directionally connected group of \u0060\u0027O\u0027\u0060s is surrounded by \u0060\u0027X\u0027\u0060s, it is considered to be **surrounded**. \n\nChange all **surrounded** regions of \u0060\u0027O\u0027\u0060s to \u0060\u0027X\u0027\u0060s and do so **in-place** by modifying the input board.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9e6916bf-0e25-4e15-9619-cbc42d2d8f00/public)\n\n\u0060\u0060\u0060java\nInput: board = [\n  [\u0022X\u0022,\u0022X\u0022,\u0022X\u0022,\u0022X\u0022],\n  [\u0022X\u0022,\u0022O\u0022,\u0022O\u0022,\u0022X\u0022],\n  [\u0022X\u0022,\u0022O\u0022,\u0022O\u0022,\u0022X\u0022],\n  [\u0022X\u0022,\u0022X\u0022,\u0022X\u0022,\u0022O\u0022]\n]\n\nOutput: [\n  [\u0022X\u0022,\u0022X\u0022,\u0022X\u0022,\u0022X\u0022],\n  [\u0022X\u0022,\u0022X\u0022,\u0022X\u0022,\u0022X\u0022],\n  [\u0022X\u0022,\u0022X\u0022,\u0022X\u0022,\u0022X\u0022],\n  [\u0022X\u0022,\u0022X\u0022,\u0022X\u0022,\u0022O\u0022]\n]\n\u0060\u0060\u0060\n\nExplanation: Note that regions that are on the border are not considered surrounded regions.\n\n**Constraints:**\n* \u00601 \u003C= board.length, board[i].length \u003C= 200\u0060\n* \u0060board[i][j]\u0060 is \u0060\u0027X\u0027\u0060 or \u0060\u0027O\u0027\u0060.\n",
    "Difficulty": "Medium",
    "Video": "9z2BunfoZ5Y",
    "PythonSolution": "class Solution:\n    def solve(self, board: List[List[str]]) -\u003E None:\n        ROWS, COLS = len(board), len(board[0])\n\n        def capture(r, c):\n            if r \u003C 0 or c \u003C 0 or r == ROWS or c == COLS or board[r][c] != \u0022O\u0022:\n                return\n            board[r][c] = \u0022T\u0022\n            capture(r \u002B 1, c)\n            capture(r - 1, c)\n            capture(r, c \u002B 1)\n            capture(r, c - 1)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \u0022O\u0022 and (r in [0, ROWS - 1] or c in [0, COLS - 1]):\n                    capture(r, c)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \u0022O\u0022:\n                    board[r][c] = \u0022X\u0022\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \u0022T\u0022:\n                    board[r][c] = \u0022O\u0022\n"
  },
  {
    "Name": "Course Schedule",
    "NcLink": "course-schedule/",
    "Pattern": "Graphs",
    "Description": "You are given an array \u0060prerequisites\u0060 where \u0060prerequisites[i] = [a, b]\u0060 indicates that you **must** take course \u0060b\u0060 first if you want to take course \u0060a\u0060.\n\nThe pair \u0060[0, 1]\u0060, indicates that must take course \u00601\u0060 before taking course \u00600\u0060.\n\nThere are a total of \u0060numCourses\u0060 courses you are required to take, labeled from \u00600\u0060 to \u0060numCourses - 1\u0060. \n\nReturn \u0060true\u0060 if it is possible to finish all courses, otherwise return \u0060false\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: numCourses = 2, prerequisites = [[0,1]]\n\nOutput: true\n\u0060\u0060\u0060\nExplanation: First take course 1 (no prerequisites) and then take course 0.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: numCourses = 2, prerequisites = [[0,1],[1,0]]\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation: In order to take course 1 you must take course 0, and to take course 0 you must take course 1. So it is impossible.\n\n**Constraints:**\n* \u00601 \u003C= numCourses \u003C= 1000\u0060\n* \u00600 \u003C= prerequisites.length \u003C= 1000\u0060\n* All \u0060prerequisite\u0060 pairs are **unique**.\n",
    "Difficulty": "Medium",
    "Video": "EgI5nU9etnU",
    "PythonSolution": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -\u003E bool:\n        preMap = {i: [] for i in range(numCourses)}\n\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n\n        visiting = set()\n\n        def dfs(crs):\n            if crs in visiting:\n                return False\n            if preMap[crs] == []:\n                return True\n\n            visiting.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visiting.remove(crs)\n            preMap[crs] = []\n            return True\n\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n        return True\n"
  },
  {
    "Name": "Course Schedule II",
    "NcLink": "course-schedule-ii/",
    "Pattern": "Graphs",
    "Description": "You are given an array \u0060prerequisites\u0060 where \u0060prerequisites[i] = [a, b]\u0060 indicates that you **must** take course \u0060b\u0060 first if you want to take course \u0060a\u0060.\n\n* For example, the pair \u0060[0, 1]\u0060, indicates that to take course \u00600\u0060 you have to first take course \u00601\u0060.\n\nThere are a total of \u0060numCourses\u0060 courses you are required to take, labeled from \u00600\u0060 to \u0060numCourses - 1\u0060. \n\nReturn a valid ordering of courses you can take to finish all courses. If there are many valid answers, return **any** of them. If it\u0027s not possible to finish all courses, return an **empty array**.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: numCourses = 3, prerequisites = [[1,0]]\n\nOutput: [0,1,2]\n\u0060\u0060\u0060\n\nExplanation: We must ensure that course 0 is taken before course 1.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: numCourses = 3, prerequisites = [[0,1],[1,2],[2,0]]\n\nOutput: []\n\u0060\u0060\u0060\n\nExplanation: It\u0027s impossible to finish all courses.\n\n**Constraints:**\n* \u00601 \u003C= numCourses \u003C= 1000\u0060\n* \u00600 \u003C= prerequisites.length \u003C= 1000\u0060\n* All \u0060prerequisite\u0060 pairs are **unique**.\n",
    "Difficulty": "Medium",
    "Video": "Akt3glAwyfY",
    "PythonSolution": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -\u003E List[int]:\n        prereq = {c: [] for c in range(numCourses)}\n        for crs, pre in prerequisites:\n            prereq[crs].append(pre)\n\n        output = []\n        visit, cycle = set(), set()\n\n        def dfs(crs):\n            if crs in cycle:\n                return False\n            if crs in visit:\n                return True\n\n            cycle.add(crs)\n            for pre in prereq[crs]:\n                if dfs(pre) == False:\n                    return False\n            cycle.remove(crs)\n            visit.add(crs)\n            output.append(crs)\n            return True\n\n        for c in range(numCourses):\n            if dfs(c) == False:\n                return []\n        return output\n"
  },
  {
    "Name": "Graph Valid Tree",
    "NcLink": "valid-tree/",
    "Pattern": "Graphs",
    "Description": "Given \u0060n\u0060 nodes labeled from \u00600\u0060 to \u0060n - 1\u0060 and a list of **undirected** edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput:\nn = 5\nedges = [[0, 1], [0, 2], [0, 3], [1, 4]]\n\nOutput:\ntrue\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput:\nn = 5\nedges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]\n\nOutput:\nfalse\n\u0060\u0060\u0060\n\n**Note:**\n* You can assume that no duplicate edges will appear in edges. Since all edges are \u0060undirected\u0060, \u0060[0, 1]\u0060 is the same as \u0060[1, 0]\u0060 and thus will not appear together in edges.\n\n**Constraints:**\n* \u00601 \u003C= n \u003C= 100\u0060\n* \u00600 \u003C= edges.length \u003C= n * (n - 1) / 2\u0060\n",
    "Difficulty": "Medium",
    "Video": "bXsUuownnoQ",
    "PythonSolution": "class Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -\u003E bool:\n        if not n:\n            return True\n        adj = {i: [] for i in range(n)}\n        for n1, n2 in edges:\n            adj[n1].append(n2)\n            adj[n2].append(n1)\n\n        visit = set()\n\n        def dfs(i: int, prev: int) -\u003E bool:\n            if i in visit:\n                return False\n\n            visit.add(i)\n            for j in adj[i]:\n                if j == prev:\n                    continue\n                if not dfs(j, i):\n                    return False\n            return True\n\n        return dfs(0, -1) and n == len(visit)\n    "
  },
  {
    "Name": "Number of Connected Components In An Undirected Graph",
    "NcLink": "count-connected-components/",
    "Pattern": "Graphs",
    "Description": "There is an undirected graph with \u0060n\u0060 nodes. There is also an \u0060edges\u0060 array, where \u0060edges[i] = [a, b]\u0060 means that there is an edge between node \u0060a\u0060 and node \u0060b\u0060 in the graph.\n\nThe nodes are numbered from \u00600\u0060 to \u0060n - 1\u0060.\n\nReturn the total number of connected components in that graph.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput:\nn=3\nedges=[[0,1], [0,2]]\n\nOutput:\n1\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput:\nn=6\nedges=[[0,1], [1,2], [2,3], [4,5]]\n\nOutput:\n2\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= n \u003C= 100\u0060\n* \u00600 \u003C= edges.length \u003C= n * (n - 1) / 2\u0060\n",
    "Difficulty": "Medium",
    "Video": "8f1XPm4WOUc",
    "PythonSolution": "class UnionFind:\n\n    def __init__(self):\n        self.f = {}\n\n    def findParent(self, x: int) -\u003E int:\n        y = self.f.get(x, x)\n        if x != y:\n            y = self.f[x] = self.findParent(y)\n        return y\n\n    def union(self, x: int, y: int):\n\n        self.f[self.findParent(x)] = self.findParent(y)\n\nclass Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -\u003E int:\n        dsu = UnionFind()\n        for a, b in edges:\n            dsu.union(a, b)\n        return len(set(dsu.findParent(x) for x in range(n)))\n    "
  },
  {
    "Name": "Redundant Connection",
    "NcLink": "redundant-connection/",
    "Pattern": "Graphs",
    "Description": "You are given a connected **undirected graph** with \u0060n\u0060 nodes labeled from \u00601\u0060 to \u0060n\u0060. Initially, it contained no cycles and consisted of \u0060n-1\u0060 edges.\n\nWe have now added one additional edge to the graph. The edge has two **different** vertices chosen from \u00601\u0060 to \u0060n\u0060, and was not an edge that previously existed in the graph.\n\nThe graph is represented as an array \u0060edges\u0060 of length \u0060n\u0060 where \u0060edges[i] = [ai, bi]\u0060 represents an edge between nodes \u0060ai\u0060 and \u0060bi\u0060 in the graph.\n\nReturn an edge that can be removed so that the graph is still a connected non-cyclical graph. If there are multiple answers, return the edge that appears last in the input \u0060edges\u0060.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1a966522-e4d9-4215-18a1-4df7d26c3700/public)\n\n\u0060\u0060\u0060java\nInput: edges = [[1,2],[1,3],[3,4],[2,4]]\n\nOutput: [2,4]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5cf17b17-8758-4f0a-8829-99cea143b100/public)\n\n\u0060\u0060\u0060java\nInput: edges = [[1,2],[1,3],[1,4],[3,4],[4,5]]\n\nOutput: [3,4]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060n == edges.length\u0060\n* \u00603 \u003C= n \u003C= 100\u0060\n* \u00601 \u003C= edges[i][0] \u003C edges[i][1] \u003C= edges.length\u0060\n* There are no repeated edges and no self-loops in the input.\n",
    "Difficulty": "Medium",
    "Video": "FXWRE67PLL0",
    "PythonSolution": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -\u003E List[int]:\n        par = [i for i in range(len(edges) \u002B 1)]\n        rank = [1] * (len(edges) \u002B 1)\n\n        def find(n):\n            p = par[n]\n            while p != par[p]:\n                par[p] = par[par[p]]\n                p = par[p]\n            return p\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return False\n            if rank[p1] \u003E rank[p2]:\n                par[p2] = p1\n                rank[p1] \u002B= rank[p2]\n            else:\n                par[p1] = p2\n                rank[p2] \u002B= rank[p1]\n            return True\n\n        for n1, n2 in edges:\n            if not union(n1, n2):\n                return [n1, n2]\n"
  },
  {
    "Name": "Word Ladder",
    "NcLink": "word-ladder/",
    "Pattern": "Graphs",
    "Description": "You are given two words, \u0060beginWord\u0060 and \u0060endWord\u0060, and also a list of words \u0060wordList\u0060. All of the given words are of the same length, consisting of lowercase English letters, and are all distinct.\n\nYour goal is to transform \u0060beginWord\u0060 into \u0060endWord\u0060 by following the rules:\n    \n* You may transform \u0060beginWord\u0060 to any word within \u0060wordList\u0060, provided that at exactly one position the words have a different character, and the rest of the positions have the same characters.\n* You may repeat the previous step with the new word that you obtain, and you may do this as many times as needed.\n\nReturn the **minimum number of words within the transformation sequence** needed to obtain the \u0060endWord\u0060, or \u00600\u0060 if no such sequence exists.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: beginWord = \u0022cat\u0022, endWord = \u0022sag\u0022, wordList = [\u0022bat\u0022,\u0022bag\u0022,\u0022sag\u0022,\u0022dag\u0022,\u0022dot\u0022]\n\nOutput: 4\n\u0060\u0060\u0060\n\nExplanation: The transformation sequence is \u0060\u0022cat\u0022 -\u003E \u0022bat\u0022 -\u003E \u0022bag\u0022 -\u003E \u0022sag\u0022\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: beginWord = \u0022cat\u0022, endWord = \u0022sag\u0022, wordList = [\u0022bat\u0022,\u0022bag\u0022,\u0022sat\u0022,\u0022dag\u0022,\u0022dot\u0022]\n\nOutput: 0\n\u0060\u0060\u0060\n\nExplanation: There is no possible transformation sequence from \u0060\u0022cat\u0022\u0060 to \u0060\u0022sag\u0022\u0060 since the word \u0060\u0022sag\u0022\u0060 is not in the wordList.\n\n**Constraints:**\n* \u00601 \u003C= beginWord.length \u003C= 10\u0060\n* \u00601 \u003C= wordList.length \u003C= 100\u0060\n",
    "Difficulty": "Hard",
    "Video": "h9iTnkgv05E",
    "PythonSolution": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -\u003E int:\n        if endWord not in wordList:\n            return 0\n\n        nei = collections.defaultdict(list)\n        wordList.append(beginWord)\n        for word in wordList:\n            for j in range(len(word)):\n                pattern = word[:j] \u002B \u0022*\u0022 \u002B word[j \u002B 1 :]\n                nei[pattern].append(word)\n\n        visit = set([beginWord])\n        q = deque([beginWord])\n        res = 1\n        while q:\n            for i in range(len(q)):\n                word = q.popleft()\n                if word == endWord:\n                    return res\n                for j in range(len(word)):\n                    pattern = word[:j] \u002B \u0022*\u0022 \u002B word[j \u002B 1 :]\n                    for neiWord in nei[pattern]:\n                        if neiWord not in visit:\n                            visit.add(neiWord)\n                            q.append(neiWord)\n            res \u002B= 1\n        return 0\n"
  },
  {
    "Name": "Reconstruct Itinerary",
    "NcLink": "reconstruct-flight-path/",
    "Pattern": "Advanced Graphs",
    "Description": "You are given a list of flight tickets \u0060tickets\u0060 where \u0060tickets[i] = [from_i, to_i]\u0060 represent the source airport and the destination airport. \n\nEach \u0060from_i\u0060 and \u0060to_i\u0060 consists of three uppercase English letters.\n\nReconstruct the itinerary in order and return it.\n\nAll of the tickets belong to someone who originally departed from \u0060\u0022JFK\u0022\u0060. Your objective is to reconstruct the flight path that this person took, assuming each ticket was used exactly once.\n\nIf there are multiple valid flight paths, return the lexicographically smallest one.\n* For example, the itinerary \u0060[\u0022JFK\u0022, \u0022SEA\u0022]\u0060 has a smaller lexical order than \u0060[\u0022JFK\u0022, \u0022SFO\u0022]\u0060.\n\nYou may assume all the tickets form at least one valid flight path.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e5ea2ea5-da22-4c22-a5c1-5840dab7fb00/public)\n\n\u0060\u0060\u0060java\nInput: tickets = [[\u0022BUF\u0022,\u0022HOU\u0022],[\u0022HOU\u0022,\u0022SEA\u0022],[\u0022JFK\u0022,\u0022BUF\u0022]]\n\nOutput: [\u0022JFK\u0022,\u0022BUF\u0022,\u0022HOU\u0022,\u0022SEA\u0022]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9bfece1f-1fec-4618-4f95-31b2abcd3100/public)\n\n\u0060\u0060\u0060java\nInput: tickets = [[\u0022HOU\u0022,\u0022JFK\u0022],[\u0022SEA\u0022,\u0022JFK\u0022],[\u0022JFK\u0022,\u0022SEA\u0022],[\u0022JFK\u0022,\u0022HOU\u0022]]\n\nOutput: [\u0022JFK\u0022,\u0022HOU\u0022,\u0022JFK\u0022,\u0022SEA\u0022,\u0022JFK\u0022]\n\u0060\u0060\u0060\n\nExplanation: Another possible reconstruction is \u0060[\u0022JFK\u0022,\u0022SEA\u0022,\u0022JFK\u0022,\u0022HOU\u0022,\u0022JFK\u0022]\u0060 but it is lexicographically larger.\n\n**Constraints:**\n* \u00601 \u003C= tickets.length \u003C= 300\u0060\n* \u0060from_i != to_i\u0060\n",
    "Difficulty": "Hard",
    "Video": "ZyB_gQ8vqGA",
    "PythonSolution": "class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -\u003E List[str]:\n        adj = {src: [] for src, dst in tickets}\n        res = []\n\n        for src, dst in tickets:\n            adj[src].append(dst)\n\n        for key in adj:\n            adj[key].sort()\n\n        def dfs(adj, result, src):\n            if src in adj:\n                destinations = adj[src][:]\n                while destinations:\n                    dest = destinations[0]\n                    adj[src].pop(0)\n                    dfs(adj, res, dest)\n                    destinations = adj[src][:]\n            res.append(src)\n\n        dfs(adj, res, \u0022JFK\u0022)\n        res.reverse()\n\n        if len(res) != len(tickets) \u002B 1:\n            return []\n\n        return res\n"
  },
  {
    "Name": "Min Cost to Connect All Points",
    "NcLink": "min-cost-to-connect-points/",
    "Pattern": "Advanced Graphs",
    "Description": "You are given a 2-D integer array \u0060points\u0060, where \u0060points[i] = [xi, yi]\u0060. Each \u0060points[i]\u0060 represents a distinct point on a 2-D plane.\n\nThe cost of connecting two points \u0060[xi, yi]\u0060 and \u0060[xj, yj]\u0060 is the **manhattan distance** between the two points, i.e. \u0060|xi - xj| \u002B |yi - yj|\u0060.\n\nReturn the minimum cost to connect all points together, such that there exists exactly one path between each pair of points.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e0cd5270-73b5-42d4-3c3f-5451f795ca00/public)\n\n\u0060\u0060\u0060java\nInput: points = [[0,0],[2,2],[3,3],[2,4],[4,2]]\n\nOutput: 10\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= points.length \u003C= 1000\u0060\n* \u0060-1000 \u003C= xi, yi \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "f7JOBJIC-NA",
    "PythonSolution": "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -\u003E int:\n        N = len(points)\n        adj = {i: [] for i in range(N)}\n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i \u002B 1, N):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) \u002B abs(y1 - y2)\n                adj[i].append([dist, j])\n                adj[j].append([dist, i])\n\n        res = 0\n        visit = set()\n        minH = [[0, 0]]\n        while len(visit) \u003C N:\n            cost, i = heapq.heappop(minH)\n            if i in visit:\n                continue\n            res \u002B= cost\n            visit.add(i)\n            for neiCost, nei in adj[i]:\n                if nei not in visit:\n                    heapq.heappush(minH, [neiCost, nei])\n        return res\n"
  },
  {
    "Name": "Network Delay Time",
    "NcLink": "network-delay-time/",
    "Pattern": "Advanced Graphs",
    "Description": "You are given a network of \u0060n\u0060 directed nodes, labeled from \u00601\u0060 to \u0060n\u0060. You are also given \u0060times\u0060, a list of directed edges where \u0060times[i] = (ui, vi, ti)\u0060. \n    \n* \u0060ui\u0060 is the source node (an integer from \u00601\u0060 to \u0060n\u0060)\n* \u0060vi\u0060 is the target node (an integer from \u00601\u0060 to \u0060n\u0060)\n* \u0060ti\u0060 is the time it takes for a signal to travel from the source to the target node (an integer greater than or equal to \u00600\u0060).\n\nYou are also given an integer \u0060k\u0060, representing the node that we will send a signal from.\n\nReturn the **minimum** time it takes for all of the \u0060n\u0060 nodes to receive the signal. If it is impossible for all the nodes to receive the signal, return \u0060-1\u0060 instead.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ba9b9be8-b888-45d6-627a-e719d1ac4e00/public)\n\n\u0060\u0060\u0060java\nInput: times = [[1,2,1],[2,3,1],[1,4,4],[3,4,1]], n = 4, k = 1\n\nOutput: 3\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: times = [[1,2,1],[2,3,1]], n = 3, k = 2\n\nOutput: -1\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= k \u003C= n \u003C= 100\u0060\n* \u00601 \u003C= times.length \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "EaphyqKU4PQ",
    "PythonSolution": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -\u003E int:\n        edges = collections.defaultdict(list)\n        for u, v, w in times:\n            edges[u].append((v, w))\n\n        minHeap = [(0, k)]\n        visit = set()\n        t = 0\n        while minHeap:\n            w1, n1 = heapq.heappop(minHeap)\n            if n1 in visit:\n                continue\n            visit.add(n1)\n            t = w1\n\n            for n2, w2 in edges[n1]:\n                if n2 not in visit:\n                    heapq.heappush(minHeap, (w1 \u002B w2, n2))\n        return t if len(visit) == n else -1\n"
  },
  {
    "Name": "Swim In Rising Water",
    "NcLink": "swim-in-rising-water/",
    "Pattern": "Advanced Graphs",
    "Description": "You are given a square 2-D matrix of distinct integers \u0060grid\u0060 where each integer \u0060grid[i][j]\u0060 represents the elevation at position \u0060(i, j)\u0060.\n\nRain starts to fall at time = \u00600\u0060, which causes the water level to rise. At time \u0060t\u0060, the water level across the entire grid is \u0060t\u0060.\n\nYou may swim either horizontally or vertically in the grid between two adjacent squares if the original elevation of both squares is less than or equal to the water level at time \u0060t\u0060.\n\nStarting from the top left square \u0060(0, 0)\u0060, return the minimum amount of time it will take until it is possible to reach the bottom right square \u0060(n - 1, n - 1)\u0060.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/11a45dd8-625f-4be6-9fbb-a3b6ffcc1100/public)\n\n\u0060\u0060\u0060java\nInput: grid = [[0,1],[2,3]]\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: For a path to exist to the bottom right square \u0060grid[1][1]\u0060 the water elevation must be at least \u00603\u0060. At time \u0060t = 3\u0060, the water level is \u00603\u0060.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e585e59c-a1f9-4d10-538d-9e52bcdb6200/public)\n\n\u0060\u0060\u0060java\nInput: grid = [\n  [0,1,2,10],\n  [9,14,4,13],\n  [12,3,8,15],\n  [11,5,7,6]]\n]\n\nOutput: 8\n\u0060\u0060\u0060\n\nExplanation: The water level must be at least \u00608\u0060 to reach the bottom right square. The path is \u0060[0, 1, 2, 4, 8, 7, 6]\u0060.\n\n**Constraints:**\n* \u0060grid.length == grid[i].length\u0060\n* \u00601 \u003C= grid.length \u003C= 50\u0060\n* \u00600 \u003C= grid[i][j] \u003C n^2\u0060\n",
    "Difficulty": "Hard",
    "Video": "amvrKlMLuGY",
    "PythonSolution": "class Solution:\n    def swimInWater(self, grid: List[List[int]]) -\u003E int:\n        N = len(grid)\n        visit = set()\n        minH = [[grid[0][0], 0, 0]]  # (time/max-height, r, c)\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        visit.add((0, 0))\n        while minH:\n            t, r, c = heapq.heappop(minH)\n            if r == N - 1 and c == N - 1:\n                return t\n            for dr, dc in directions:\n                neiR, neiC = r \u002B dr, c \u002B dc\n                if (\n                    neiR \u003C 0\n                    or neiC \u003C 0\n                    or neiR == N\n                    or neiC == N\n                    or (neiR, neiC) in visit\n                ):\n                    continue\n                visit.add((neiR, neiC))\n                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])\n"
  },
  {
    "Name": "Alien Dictionary",
    "NcLink": "foreign-dictionary/",
    "Pattern": "Advanced Graphs",
    "Description": "There is a foreign language which uses the latin alphabet, but the order among letters is *not* \u0022a\u0022, \u0022b\u0022, \u0022c\u0022 ... \u0022z\u0022 as in English.\n\nYou receive a list of *non-empty* strings \u0060words\u0060 from the dictionary, where the words are **sorted lexicographically** based on the rules of this new language. \n\nDerive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid order of letters, return **any** of them.\n\nA string \u0060a\u0060 is lexicographically smaller than a string \u0060b\u0060 if either of the following is true:\n* The first letter where they differ is smaller in \u0060a\u0060 than in \u0060b\u0060.\n* There is no index \u0060i\u0060 such that \u0060a[i] != b[i]\u0060 *and* \u0060a.length \u003C b.length\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: [\u0022z\u0022,\u0022o\u0022]\n\nOutput: \u0022zo\u0022\n\u0060\u0060\u0060\n\nExplanation:\nFrom \u0022z\u0022 and \u0022o\u0022, we know \u0027z\u0027 \u003C \u0027o\u0027, so return \u0022zo\u0022.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: [\u0022hrn\u0022,\u0022hrf\u0022,\u0022er\u0022,\u0022enn\u0022,\u0022rfnn\u0022]\n\nOutput: \u0022hernf\u0022\n\u0060\u0060\u0060\n\nExplanation:\n* from \u0022hrn\u0022 and \u0022hrf\u0022, we know \u0027n\u0027 \u003C \u0027f\u0027\n* from \u0022hrf\u0022 and \u0022er\u0022, we know \u0027h\u0027 \u003C \u0027e\u0027\n* from \u0022er\u0022 and \u0022enn\u0022, we know get \u0027r\u0027 \u003C \u0027n\u0027\n* from \u0022enn\u0022 and \u0022rfnn\u0022 we know \u0027e\u0027\u003C\u0027r\u0027\n* so one possibile solution is \u0022hernf\u0022\n\n**Constraints:**\n* The input \u0060words\u0060 will contain characters only from lowercase \u0060\u0027a\u0027\u0060 to \u0060\u0027z\u0027\u0060.\n* \u00601 \u003C= words.length \u003C= 100\u0060\n* \u00601 \u003C= words[i].length \u003C= 100\u0060\n",
    "Difficulty": "Hard",
    "Video": "6kTZYvNNyps",
    "PythonSolution": "class Solution:\n    def foreignDictionary(self, words: List[str]) -\u003E str:\n        adj = {char: set() for word in words for char in word}\n\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i \u002B 1]\n            minLen = min(len(w1), len(w2))\n            if len(w1) \u003E len(w2) and w1[:minLen] == w2[:minLen]:\n                return \u0022\u0022\n            for j in range(minLen):\n                if w1[j] != w2[j]:\n                    adj[w1[j]].add(w2[j])\n                    break\n\n        visited = {}  # {char: bool} False visited, True current path\n        res = []\n\n        def dfs(char):\n            if char in visited:\n                return visited[char]\n\n            visited[char] = True\n\n            for neighChar in adj[char]:\n                if dfs(neighChar):\n                    return True\n\n            visited[char] = False\n            res.append(char)\n\n        for char in adj:\n            if dfs(char):\n                return \u0022\u0022\n\n        res.reverse()\n        return \u0022\u0022.join(res)\n"
  },
  {
    "Name": "Cheapest Flights Within K Stops",
    "NcLink": "cheapest-flight-path/",
    "Pattern": "Advanced Graphs",
    "Description": "There are \u0060n\u0060 airports, labeled from \u00600\u0060 to \u0060n - 1\u0060, which are connected by some flights. You are given an array \u0060flights\u0060 where \u0060flights[i] = [from_i, to_i, price_i]\u0060 represents a one-way flight from airport \u0060from_i\u0060 to airport \u0060to_i\u0060 with cost \u0060price_i\u0060. You may assume there are no duplicate flights and no flights from an airport to itself.\n\nYou are also given three integers \u0060src\u0060, \u0060dst\u0060, and \u0060k\u0060 where:\n\n* \u0060src\u0060 is the starting airport\n* \u0060dst\u0060 is the destination airport\n* \u0060src != dst\u0060\n* \u0060k\u0060 is the maximum number of stops you can make (not including \u0060src\u0060 and \u0060dst\u0060)\n\nReturn **the cheapest price** from \u0060src\u0060 to \u0060dst\u0060 with at most \u0060k\u0060 stops, or return \u0060-1\u0060 if it is impossible.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e272e71f-c38b-4db8-3c4e-1158418d2a00/public)\n\n\u0060\u0060\u0060java\nInput: n = 4, flights = [[0,1,200],[1,2,100],[1,3,300],[2,3,100]], src = 0, dst = 3, k = 1\n\nOutput: 500\n\u0060\u0060\u0060\n\nExplanation:\nThe optimal path with at most 1 stop from airport 0 to 3 is shown in red, with total cost \u0060200 \u002B 300 = 500\u0060.\nNote that the path \u0060[0 -\u003E 1 -\u003E 2 -\u003E 3]\u0060 costs only 400, and thus is cheaper, but it requires 2 stops, which is more than k.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/93e910ee-378d-4ac8-93e0-471df7ccf600/public)\n\n\u0060\u0060\u0060java\nInput: n = 3, flights = [[1,0,100],[1,2,200],[0,2,100]], src = 1, dst = 2, k = 1\n\nOutput: 200\n\u0060\u0060\u0060\n\nExplanation:\nThe optimal path with at most 1 stop from airport 1 to 2 is shown in red and has cost \u0060200\u0060.\n\n**Constraints:**\n* \u00601 \u003C= n \u003C= 100\u0060\n* \u0060fromi != toi\u0060\n* \u00601 \u003C= pricei \u003C= 1000\u0060\n* \u00600 \u003C= src, dst, k \u003C n\u0060\n",
    "Difficulty": "Medium",
    "Video": "5eIK3zUdYmE",
    "PythonSolution": "class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -\u003E int:\n        prices = [float(\u0022inf\u0022)] * n\n        prices[src] = 0\n\n        for i in range(k \u002B 1):\n            tmpPrices = prices.copy()\n\n            for s, d, p in flights:  # s=source, d=dest, p=price\n                if prices[s] == float(\u0022inf\u0022):\n                    continue\n                if prices[s] \u002B p \u003C tmpPrices[d]:\n                    tmpPrices[d] = prices[s] \u002B p\n            prices = tmpPrices\n        return -1 if prices[dst] == float(\u0022inf\u0022) else prices[dst]\n"
  },
  {
    "Name": "Climbing Stairs",
    "NcLink": "climbing-stairs/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "You are given an integer \u0060n\u0060 representing the number of steps to reach the top of a staircase. You can climb with either \u00601\u0060 or \u00602\u0060 steps at a time.\n    \nReturn the number of distinct ways to climb to the top of the staircase.   \n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: n = 2\n\nOutput: 2\n\u0060\u0060\u0060\n\nExplanation:\n1. \u00601 \u002B 1 = 2\u0060\n2. \u00602 = 2\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: n = 3\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation:\n1. \u00601 \u002B 1 \u002B 1 = 3\u0060\n2. \u00601 \u002B 2 = 3\u0060\n3. \u00602 \u002B 1 = 3\u0060\n\n**Constraints:**\n* \u00601 \u003C= n \u003C= 30\u0060\n",
    "Difficulty": "Easy",
    "Video": "Y0lT9Fck7qI",
    "PythonSolution": "class Solution:\n    def climbStairs(self, n: int) -\u003E int:\n        if n \u003C= 3:\n            return n\n        n1, n2 = 2, 3\n\n        for i in range(4, n \u002B 1):\n            temp = n1 \u002B n2\n            n1 = n2\n            n2 = temp\n        return n2\n"
  },
  {
    "Name": "Min Cost Climbing Stairs",
    "NcLink": "min-cost-climbing-stairs/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "You are given an array of integers \u0060cost\u0060 where \u0060cost[i]\u0060 is the cost of taking a step from the \u0060ith\u0060 floor of a staircase. After paying the cost, you can step to either the \u0060(i \u002B 1)th\u0060 floor or the \u0060(i \u002B 2)th\u0060 floor.\n\nYou may choose to start at the index \u00600\u0060 or the index \u00601\u0060 floor.\n\nReturn the minimum cost to reach the top of the staircase, i.e. just past the last index in \u0060cost\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: cost = [1,2,3]\n\nOutput: 2\n\u0060\u0060\u0060\n\nExplanation: We can start at index = \u00601\u0060 and pay the cost of \u0060cost[1] = 2\u0060 and take two steps to reach the top. The total cost is \u00602\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: cost = [1,2,1,2,1,1,1]\n\nOutput: 4\n\u0060\u0060\u0060\n\nExplanation: Start at index = \u00600\u0060.\n* Pay the cost of \u0060cost[0] = 1\u0060 and take two steps to reach index = \u00602\u0060.\n* Pay the cost of \u0060cost[2] = 1\u0060 and take two steps to reach index = \u00604\u0060.\n* Pay the cost of \u0060cost[4] = 1\u0060 and take two steps to reach index = \u00606\u0060.\n* Pay the cost of \u0060cost[6] = 1\u0060 and take one step to reach the top.\n* The total cost is \u00604\u0060.\n\n**Constraints:**\n* \u00602 \u003C= cost.length \u003C= 100\u0060\n* \u00600 \u003C= cost[i] \u003C= 100\u0060\n",
    "Difficulty": "Easy",
    "Video": "ktmzAZWkEZ0",
    "PythonSolution": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -\u003E int:\n        for i in range(len(cost) - 3, -1, -1):\n            cost[i] \u002B= min(cost[i \u002B 1], cost[i \u002B 2])\n\n        return min(cost[0], cost[1])\n"
  },
  {
    "Name": "House Robber",
    "NcLink": "house-robber/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "You are given an integer array \u0060nums\u0060 where \u0060nums[i]\u0060 represents the amount of money the \u0060i\u0060th house has. The houses are arranged in a straight line, i.e. the \u0060i\u0060th house is the neighbor of the \u0060(i-1)\u0060th and \u0060(i\u002B1)\u0060th house.\n\nYou are planning to rob money from the houses, but you cannot rob **two adjacent houses** because the security system will automatically alert the police if two adjacent houses were *both* broken into.\n\nReturn the *maximum* amount of money you can rob **without** alerting the police.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,1,3,3]\n\nOutput: 4\n\u0060\u0060\u0060\n\nExplanation: \u0060nums[0] \u002B nums[2] = 1 \u002B 3 = 4\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [2,9,8,3,6]\n\nOutput: 16\n\u0060\u0060\u0060\n\nExplanation: \u0060nums[0] \u002B nums[2] \u002B nums[4] = 2 \u002B 8 \u002B 6 = 16\u0060.\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 100\u0060\n* \u00600 \u003C= nums[i] \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "73r3KWiEvyk",
    "PythonSolution": "class Solution:\n    def rob(self, nums: List[int]) -\u003E int:\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            temp = max(n \u002B rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n        return rob2\n"
  },
  {
    "Name": "House Robber II",
    "NcLink": "house-robber-ii/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "You are given an integer array \u0060nums\u0060 where \u0060nums[i]\u0060 represents the amount of money the \u0060i\u0060th house has. The houses are arranged in a circle, i.e. the first house and the last house are neighbors.\n\nYou are planning to rob money from the houses, but you cannot rob **two adjacent houses** because the security system will automatically alert the police if two adjacent houses were *both* broken into.\n    \nReturn the *maximum* amount of money you can rob **without** alerting the police.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [3,4,3]\n\nOutput: 4\n\u0060\u0060\u0060\n\nExplanation: You cannot rob \u0060nums[0] \u002B nums[2] = 6\u0060 because \u0060nums[0]\u0060 and \u0060nums[2]\u0060 are adjacent houses. The maximum you can rob is \u0060nums[1] = 4\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [2,9,8,3,6]\n\nOutput: 15\n\u0060\u0060\u0060\n\nExplanation: You cannot rob \u0060nums[0] \u002B nums[2] \u002B nums[4] = 16\u0060 because \u0060nums[0]\u0060 and \u0060nums[4]\u0060 are adjacent houses. The maximum you can rob is \u0060nums[1] \u002B nums[4] = 15\u0060.\n\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 100\u0060\n* \u00600 \u003C= nums[i] \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "rWAJCfYYOvM",
    "PythonSolution": "class Solution:\n    \n    def rob(self, nums: List[int]) -\u003E int:\n        return max(nums[0], self.helper(nums[1:]), self.helper(nums[:-1]))\n\n    def helper(self, nums):\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            newRob = max(rob1 \u002B n, rob2)\n            rob1 = rob2\n            rob2 = newRob\n        return rob2\n"
  },
  {
    "Name": "Longest Palindromic Substring",
    "NcLink": "longest-palindromic-substring/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "Given a string \u0060s\u0060, return the longest substring of \u0060s\u0060 that is a *palindrome*.\n\nA **palindrome** is a string that reads the same forward and backward.\n\nIf there are multiple palindromic substrings that have the same length, return any one of them.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022ababd\u0022\n\nOutput: \u0022bab\u0022\n\u0060\u0060\u0060\n\nExplanation: Both \u0022aba\u0022 and \u0022bab\u0022 are valid answers.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022abbc\u0022\n\nOutput: \u0022bb\u0022\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 1000\u0060\n* \u0060s\u0060 contains only digits and English letters.\n",
    "Difficulty": "Medium",
    "Video": "XYQecbcd6_c",
    "PythonSolution": "class Solution:\n    def longestPalindrome(self, s: str) -\u003E str:\n        res = \u0022\u0022\n        resLen = 0\n\n        for i in range(len(s)):\n            # odd length\n            l, r = i, i\n            while l \u003E= 0 and r \u003C len(s) and s[l] == s[r]:\n                if (r - l \u002B 1) \u003E resLen:\n                    res = s[l : r \u002B 1]\n                    resLen = r - l \u002B 1\n                l -= 1\n                r \u002B= 1\n\n            # even length\n            l, r = i, i \u002B 1\n            while l \u003E= 0 and r \u003C len(s) and s[l] == s[r]:\n                if (r - l \u002B 1) \u003E resLen:\n                    res = s[l : r \u002B 1]\n                    resLen = r - l \u002B 1\n                l -= 1\n                r \u002B= 1\n\n        return res\n"
  },
  {
    "Name": "Palindromic Substrings",
    "NcLink": "palindromic-substrings/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "Given a string \u0060s\u0060, return the number of substrings within \u0060s\u0060 that are palindromes.\n\nA **palindrome** is a string that reads the same forward and backward.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022abc\u0022\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: \u0022a\u0022, \u0022b\u0022, \u0022c\u0022.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022aaa\u0022\n\nOutput: 6\n\u0060\u0060\u0060\n\nExplanation: \u0022a\u0022, \u0022a\u0022, \u0022a\u0022, \u0022aa\u0022, \u0022aa\u0022, \u0022aaa\u0022. Note that different substrings are counted as different palindromes even if the string contents are the same.\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 1000\u0060\n* \u0060s\u0060 consists of lowercase English letters.\n",
    "Difficulty": "Medium",
    "Video": "4RACzI5-du8",
    "PythonSolution": "class Solution:\n    \n    def countSubstrings(self, s: str) -\u003E int:\n        res = 0\n\n        for i in range(len(s)):\n            res \u002B= self.countPali(s, i, i)\n            res \u002B= self.countPali(s, i, i \u002B 1)\n        return res\n\n    def countPali(self, s, l, r):\n        res = 0\n        while l \u003E= 0 and r \u003C len(s) and s[l] == s[r]:\n            res \u002B= 1\n            l -= 1\n            r \u002B= 1\n        return res\n"
  },
  {
    "Name": "Decode Ways",
    "NcLink": "decode-ways/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "A string consisting of uppercase english characters can be encoded to a number using the following mapping:\n\n\u0060\u0060\u0060java\n\u0027A\u0027 -\u003E \u00221\u0022\n\u0027B\u0027 -\u003E \u00222\u0022\n...\n\u0027Z\u0027 -\u003E \u002226\u0022\n\u0060\u0060\u0060\n\nTo **decode** a message, digits must be grouped and then mapped back into letters using the reverse of the mapping above. There may be multiple ways to decode a message. For example, \u0060\u00221012\u0022\u0060 can be mapped into:\n\n* \u0060\u0022JAB\u0022\u0060 with the grouping \u0060(10 1 2)\u0060\n* \u0060\u0022JL\u0022\u0060 with the grouping \u0060(10 12)\u0060\n\nThe grouping \u0060(1 01 2)\u0060 is invalid because \u006001\u0060 cannot be mapped into a letter since it contains a leading zero.\n\nGiven a string \u0060s\u0060 containing only digits, return the number of ways to **decode** it. You can assume that the answer fits in a **32-bit** integer.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u002212\u0022\n\nOutput: 2\n\nExplanation: \u002212\u0022 could be decoded as \u0022AB\u0022 (1 2) or \u0022L\u0022 (12).\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u002201\u0022\n\nOutput: 0\n\u0060\u0060\u0060\n\nExplanation: \u002201\u0022 cannot be decoded because \u002201\u0022 cannot be mapped into a letter.\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 100\u0060\n* \u0060s\u0060 consists of digits\n",
    "Difficulty": "Medium",
    "Video": "6aEyTjOwlJU",
    "PythonSolution": "# Memoization solution \nclass Solution:\n    def numDecodings(self, s: str) -\u003E int:\n        dp = {len(s): 1}\n\n        def dfs(i):\n            if i in dp:\n                return dp[i]\n            if s[i] == \u00220\u0022:\n                return 0\n\n            res = dfs(i \u002B 1)\n            if i \u002B 1 \u003C len(s) and (\n                s[i] == \u00221\u0022 or s[i] == \u00222\u0022 and s[i \u002B 1] in \u00220123456\u0022\n            ):\n                res \u002B= dfs(i \u002B 2)\n            dp[i] = res\n            return res\n\n        return dfs(0)\n\n# Dynamic Programming solution\n# class Solution:\n#     def numDecodings(self, s: str) -\u003E int:\n#         dp = {len(s): 1}\n#         for i in range(len(s) - 1, -1, -1):\n#             if s[i] == \u00220\u0022:\n#                 dp[i] = 0\n#             else:\n#                 dp[i] = dp[i \u002B 1]\n\n#             if i \u002B 1 \u003C len(s) and (\n#                 s[i] == \u00221\u0022 or s[i] == \u00222\u0022 and s[i \u002B 1] in \u00220123456\u0022\n#             ):\n#                 dp[i] \u002B= dp[i \u002B 2]\n#         return dp[0]\n"
  },
  {
    "Name": "Coin Change",
    "NcLink": "coin-change/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "You are given an integer array \u0060coins\u0060 representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer \u0060amount\u0060 representing a target amount of money.\n\nReturn the fewest number of coins that you need to make up the *exact* target amount. If it is impossible to make up the amount, return \u0060-1\u0060.\n\nYou may assume that you have an unlimited number of each coin.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: coins = [1,5,10], amount = 12\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: 12 = 10 \u002B 1 \u002B 1. Note that we do not have to use every kind coin available.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: coins = [2], amount = 3\n\nOutput: -1\n\u0060\u0060\u0060\n\nExplanation: The amount of 3 cannot be made up with coins of 2.\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: coins = [1], amount = 0\n\nOutput: 0\n\u0060\u0060\u0060\n\nExplanation: Choosing 0 coins is a valid way to make up 0.\n\n**Constraints:**\n* \u00601 \u003C= coins.length \u003C= 10\u0060\n* \u00601 \u003C= coins[i] \u003C= 2^31 - 1\u0060\n* \u00600 \u003C= amount \u003C= 10000\u0060\n",
    "Difficulty": "Medium",
    "Video": "H9bfqozjoqs",
    "PythonSolution": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -\u003E int:\n        dp = [amount \u002B 1] * (amount \u002B 1)\n        dp[0] = 0\n\n        for a in range(1, amount \u002B 1):\n            for c in coins:\n                if a - c \u003E= 0:\n                    dp[a] = min(dp[a], 1 \u002B dp[a - c])\n        return dp[amount] if dp[amount] != amount \u002B 1 else -1\n"
  },
  {
    "Name": "Maximum Product Subarray",
    "NcLink": "maximum-product-subarray/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "Given an integer array \u0060nums\u0060, find a **subarray** that has the largest product within the array and return it.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\nYou can assume the output will fit into a **32-bit** integer.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,-3,4]\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [-2,-1]\n\nOutput: 2\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-10 \u003C= nums[i] \u003C= 10\u0060\n",
    "Difficulty": "Medium",
    "Video": "lXVy6YWFcRM",
    "PythonSolution": "class Solution:\n    def maxProduct(self, nums: List[int]) -\u003E int:\n        res = nums[0]\n        curMin, curMax = 1, 1\n\n        for n in nums:\n            tmp = curMax * n\n            curMax = max(n * curMax, n * curMin, n)\n            curMin = min(tmp, n * curMin, n)\n            res = max(res, curMax)\n        return res\n"
  },
  {
    "Name": "Word Break",
    "NcLink": "word-break/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "Given a string \u0060s\u0060 and a dictionary of strings \u0060wordDict\u0060, return \u0060true\u0060 if \u0060s\u0060 can be segmented into a space-separated sequence of dictionary words.\n\nYou are allowed to reuse words in the dictionary an unlimited number of times. You may assume all dictionary words are unique.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022neetcode\u0022, wordDict = [\u0022neet\u0022,\u0022code\u0022]\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: Return true because \u0022neetcode\u0022 can be split into \u0022neet\u0022 and \u0022code\u0022.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022applepenapple\u0022, wordDict = [\u0022apple\u0022,\u0022pen\u0022,\u0022ape\u0022]\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: Return true because \u0022applepenapple\u0022 can be split into \u0022apple\u0022, \u0022pen\u0022 and \u0022apple\u0022. Notice that we can reuse words and also not use all the words.\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022catsincars\u0022, wordDict = [\u0022cats\u0022,\u0022cat\u0022,\u0022sin\u0022,\u0022in\u0022,\u0022car\u0022]\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 200\u0060\n* \u00601 \u003C= wordDict.length \u003C= 100\u0060\n* \u00601 \u003C= wordDict[i].length \u003C= 20\u0060\n* \u0060s\u0060 and \u0060wordDict[i]\u0060 consist of only lowercase English letters.\n",
    "Difficulty": "Medium",
    "Video": "Sx9NNgInc3A",
    "PythonSolution": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -\u003E bool:\n        dp = [False] * (len(s) \u002B 1)\n        dp[len(s)] = True\n\n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i \u002B len(w)) \u003C= len(s) and s[i : i \u002B len(w)] == w:\n                    dp[i] = dp[i \u002B len(w)]\n                if dp[i]:\n                    break\n\n        return dp[0]\n"
  },
  {
    "Name": "Longest Increasing Subsequence",
    "NcLink": "longest-increasing-subsequence/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "Given an integer array \u0060nums\u0060, return the *length* of the longest strictly *increasing* subsequence.\n\nA **subsequence** is a sequence that can be derived from the given sequence by deleting some or no elements  without changing the relative order of the remaining characters.\n\n* For example, \u0060\u0022cat\u0022\u0060 is a subsequence of \u0060\u0022crabt\u0022\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [9,1,4,2,3,3,7]\n\nOutput: 4\n\u0060\u0060\u0060\n\nExplanation: The longest increasing subsequence is [1,2,3,7], which has a length of 4.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [0,3,1,3,2,3]\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-1000 \u003C= nums[i] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "cjWnW0hdF1Y",
    "PythonSolution": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -\u003E int:\n        LIS = [1] * len(nums)\n\n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i \u002B 1, len(nums)):\n                if nums[i] \u003C nums[j]:\n                    LIS[i] = max(LIS[i], 1 \u002B LIS[j])\n        return max(LIS)\n"
  },
  {
    "Name": "Partition Equal Subset Sum",
    "NcLink": "partition-equal-subset-sum/",
    "Pattern": "1-D Dynamic Programming",
    "Description": "You are given an array of positive integers \u0060nums\u0060.\n    \nReturn \u0060true\u0060 if you can partition the array into two subsets, \u0060subset1\u0060 and \u0060subset2\u0060 where \u0060sum(subset1) == sum(subset2)\u0060. Otherwise, return \u0060false\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,3,4]\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: The array can be partitioned as \u0060[1, 4]\u0060 and \u0060[2, 3]\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,3,4,5]\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 100\u0060\n* \u00601 \u003C= nums[i] \u003C= 50\u0060\n",
    "Difficulty": "Medium",
    "Video": "IsvocB5BJhw",
    "PythonSolution": "class Solution:\n    def canPartition(self, nums: List[int]) -\u003E bool:\n        if sum(nums) % 2:\n            return False\n\n        dp = set()\n        dp.add(0)\n        target = sum(nums) // 2\n\n        for i in range(len(nums) - 1, -1, -1):\n            nextDP = set()\n            for t in dp:\n                if (t \u002B nums[i]) == target:\n                    return True\n                nextDP.add(t \u002B nums[i])\n                nextDP.add(t)\n            dp = nextDP\n        return False\n"
  },
  {
    "Name": "Unique Paths",
    "NcLink": "count-paths/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "There is an \u0060m x n\u0060 grid where you are allowed to move either down or to the right at any point in time.\n\nGiven the two integers \u0060m\u0060 and \u0060n\u0060, return the number of possible unique paths that can be taken from the top-left corner of the grid (\u0060grid[0][0]\u0060) to the bottom-right corner (\u0060grid[m - 1][n - 1]\u0060).\n\nYou may assume the output will fit in a **32-bit** integer.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7eddce4e-2fc4-4c3a-bb0f-9d1060243500/public)\n\n\u0060\u0060\u0060java\nInput: m = 3, n = 6\n\nOutput: 21\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: m = 3, n = 3\n\nOutput: 6\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= m, n \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "IlEsdxuD4lY",
    "PythonSolution": "class Solution:\n    def uniquePaths(self, m: int, n: int) -\u003E int:\n        row = [1] * n\n\n        for i in range(m - 1):\n            newRow = [1] * n\n            for j in range(n - 2, -1, -1):\n                newRow[j] = newRow[j \u002B 1] \u002B row[j]\n            row = newRow\n        return row[0]\n"
  },
  {
    "Name": "Longest Common Subsequence",
    "NcLink": "longest-common-subsequence/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "Given two strings \u0060text1\u0060 and \u0060text2\u0060, return the length of the *longest common subsequence* between the two strings if one exists, otherwise return \u00600\u0060.\n\nA **subsequence** is a sequence that can be derived from the given sequence by deleting some or no elements  without changing the relative order of the remaining characters.\n\n* For example, \u0060\u0022cat\u0022\u0060 is a subsequence of \u0060\u0022crabt\u0022\u0060.\n\nA **common subsequence** of two strings is a subsequence that exists in both strings.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: text1 = \u0022cat\u0022, text2 = \u0022crabt\u0022 \n\nOutput: 3 \n\u0060\u0060\u0060\n\nExplanation: The longest common subsequence is \u0022cat\u0022 which has a length of 3.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: text1 = \u0022abcd\u0022, text2 = \u0022abcd\u0022\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: text1 = \u0022abcd\u0022, text2 = \u0022efgh\u0022\n\nOutput: 0\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= text1.length, text2.length \u003C= 1000\u0060\n* \u0060text1\u0060 and \u0060text2\u0060 consist of only lowercase English characters.\n",
    "Difficulty": "Medium",
    "Video": "Ua0GhsJSlWM",
    "PythonSolution": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -\u003E int:\n        dp = [[0 for j in range(len(text2) \u002B 1)] for i in range(len(text1) \u002B 1)]\n\n        for i in range(len(text1) - 1, -1, -1):\n            for j in range(len(text2) - 1, -1, -1):\n                if text1[i] == text2[j]:\n                    dp[i][j] = 1 \u002B dp[i \u002B 1][j \u002B 1]\n                else:\n                    dp[i][j] = max(dp[i][j \u002B 1], dp[i \u002B 1][j])\n\n        return dp[0][0]\n"
  },
  {
    "Name": "Best Time to Buy And Sell Stock With Cooldown",
    "NcLink": "buy-and-sell-crypto-with-cooldown/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "You are given an integer array \u0060prices\u0060 where \u0060prices[i]\u0060 is the price of NeetCoin on the \u0060ith\u0060 day.\n\nYou may buy and sell one NeetCoin multiple times with the following restrictions:\n* After you sell your NeetCoin, you cannot buy another one on the next day (i.e., there is a cooldown period of one day).\n* You may only own at most one NeetCoin at a time.\n\nYou may complete as many transactions as you like.\n\nReturn the **maximum profit** you can achieve. \n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: prices = [1,3,4,0,4]\n\nOutput: 6\n\u0060\u0060\u0060\n\nExplanation: Buy on day 0 (price = 1) and sell on day 1 (price = 3), profit = 3-1 = 2. Then buy on day 3 (price = 0) and sell on day 4 (price = 4), profit = 4-0 = 4. Total profit is 2 \u002B 4 = 6.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: prices = [1]\n\nOutput: 0\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= prices.length \u003C= 5000\u0060\n* \u00600 \u003C= prices[i] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "I7j0F7AHpb8",
    "PythonSolution": "class Solution:\n    def maxProfit(self, prices: List[int]) -\u003E int:\n        dp = {}  # key=(i, buying) val=max_profit\n\n        def dfs(i, buying):\n            if i \u003E= len(prices):\n                return 0\n            if (i, buying) in dp:\n                return dp[(i, buying)]\n\n            cooldown = dfs(i \u002B 1, buying)\n            if buying:\n                buy = dfs(i \u002B 1, not buying) - prices[i]\n                dp[(i, buying)] = max(buy, cooldown)\n            else:\n                sell = dfs(i \u002B 2, not buying) \u002B prices[i]\n                dp[(i, buying)] = max(sell, cooldown)\n            return dp[(i, buying)]\n\n        return dfs(0, True)\n"
  },
  {
    "Name": "Coin Change II",
    "NcLink": "coin-change-ii/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "You are given an integer array \u0060coins\u0060 representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer \u0060amount\u0060 representing a target amount of money.\n\nReturn the number of distinct combinations that total up to \u0060amount\u0060. If it\u0027s impossible to make up the amount, return \u00600\u0060.\n\nYou may assume that you have an unlimited number of each coin and that each value in \u0060coins\u0060 is unique.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: amount = 4, coins = [1,2,3]\n\nOutput: 4\n\u0060\u0060\u0060\n\nExplanation:\n* 1\u002B1\u002B1\u002B1 = 4\n* 1\u002B1\u002B2 = 4\n* 2\u002B2 = 4\n* 1\u002B3 = 4\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: amount = 7, coins = [2,4]\n\nOutput: 0\n\u0060\u0060\u0060\n\n\n**Constraints:**\n* \u00601 \u003C= coins.length \u003C= 100\u0060\n* \u00601 \u003C= coins[i] \u003C= 1000\u0060\n* \u00600 \u003C= amount \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "Mjy4hd2xgrs",
    "PythonSolution": "class Solution:\n    def change(self, amount: int, coins: List[int]) -\u003E int:\n        dp = [0] * (amount \u002B 1)\n        dp[0] = 1\n        for i in range(len(coins) - 1, -1, -1):\n            nextDP = [0] * (amount \u002B 1)\n            nextDP[0] = 1\n\n            for a in range(1, amount \u002B 1):\n                nextDP[a] = dp[a]\n                if a - coins[i] \u003E= 0:\n                    nextDP[a] \u002B= nextDP[a - coins[i]]\n            dp = nextDP\n        return dp[amount]\n"
  },
  {
    "Name": "Target Sum",
    "NcLink": "target-sum/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "You are given an array of integers \u0060nums\u0060 and an integer \u0060target\u0060.\n\nFor each number in the array, you can choose to either add or subtract it to a total sum. \n\n* For example, if \u0060nums = [1, 2]\u0060, one possible sum would be \u0060\u0022\u002B1-2=-1\u0022\u0060.\n\nIf \u0060nums=[1,1]\u0060, there are **two different ways** to sum the input numbers to get a sum of \u00600\u0060: \u0060\u0022\u002B1-1\u0022\u0060 and \u0060\u0022-1\u002B1\u0022\u0060.\n\nReturn the number of **different ways** that you can build the expression such that the total sum equals \u0060target\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [2,2,2], target = 2\n\nOutput: 3\n\u0060\u0060\u0060\nExplanation: There are 3 different ways to sum the input numbers to get a sum of 2.\n\u0060\u002B2 \u002B2 -2 = 2\u0060\n\u0060\u002B2 -2 \u002B2 = 2\u0060\n\u0060-2 \u002B2 \u002B2 = 2\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 20\u0060\n* \u00600 \u003C= nums[i] \u003C= 1000\u0060\n* \u0060-1000 \u003C= target \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "g0npyaQtAQM",
    "PythonSolution": "class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -\u003E int:\n        dp = {}  # (index, total) -\u003E # of ways\n\n        def backtrack(i, total):\n            if i == len(nums):\n                return 1 if total == target else 0\n            if (i, total) in dp:\n                return dp[(i, total)]\n\n            dp[(i, total)] = backtrack(i \u002B 1, total \u002B nums[i]) \u002B backtrack(\n                i \u002B 1, total - nums[i]\n            )\n            return dp[(i, total)]\n\n        return backtrack(0, 0)\n"
  },
  {
    "Name": "Interleaving String",
    "NcLink": "interleaving-string/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "You are given three strings \u0060s1\u0060, \u0060s2\u0060, and \u0060s3\u0060. Return \u0060true\u0060 if \u0060s3\u0060 is formed by **interleaving** \u0060s1\u0060 and \u0060s2\u0060 together or \u0060false\u0060 otherwise.\n\n**Interleaving** two strings \u0060s\u0060 and \u0060t\u0060 is done by dividing \u0060s\u0060 and \u0060t\u0060 into \u0060n\u0060 and \u0060m\u0060 substrings respectively, where the following conditions are met\n\n* \u0060|n - m| \u003C= 1\u0060, i.e. the difference between the number of substrings of \u0060s\u0060 and \u0060t\u0060 is at most \u00601\u0060.\n* \u0060s = s1 \u002B s2 \u002B ... \u002B sn\u0060\n* \u0060t = t1 \u002B t2 \u002B ... \u002B tm\u0060\n* **Interleaving** \u0060s\u0060 and \u0060t\u0060 is  \u0060s1 \u002B t1 \u002B s2 \u002B t2 \u002B ...\u0060 or \u0060t1 \u002B s1 \u002B t2 \u002B s2 \u002B ...\u0060\n\nYou may assume that \u0060s1\u0060, \u0060s2\u0060 and \u0060s3\u0060 consist of lowercase English letters.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fc30feb8-d898-4b9f-3667-4e2c98a1a900/public)\n\n\u0060\u0060\u0060java\nInput: s1 = \u0022aaaa\u0022, s2 = \u0022bbbb\u0022, s3 = \u0022aabbbbaa\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: We can split \u0060s1\u0060 into \u0060[\u0022aa\u0022, \u0022aa\u0022]\u0060, \u0060s2\u0060 can remain as \u0060\u0022bbbb\u0022\u0060 and \u0060s3\u0060 is formed by interleaving \u0060[\u0022aa\u0022, \u0022aa\u0022]\u0060 and \u0060\u0022bbbb\u0022\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s1 = \u0022\u0022, s2 = \u0022\u0022, s3 = \u0022\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: s1 = \u0022abc\u0022, s2 = \u0022xyz\u0022, s3 = \u0022abxzcy\u0022\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation: We can\u0027t split \u0060s3\u0060 into \u0060[\u0022ab\u0022, \u0022xz\u0022, \u0022cy\u0022]\u0060 as the order of characters is not maintained.\n\n\n**Constraints:**\n* \u00600 \u003C= s1.length, s2.length \u003C= 50\u0060\n* \u00600 \u003C= s3.length \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "3Rw3p9LrgvE",
    "PythonSolution": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -\u003E bool:\n        if len(s1) \u002B len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) \u002B 1) for i in range(len(s1) \u002B 1)]\n        dp[len(s1)][len(s2)] = True\n\n        for i in range(len(s1), -1, -1):\n            for j in range(len(s2), -1, -1):\n                if i \u003C len(s1) and s1[i] == s3[i \u002B j] and dp[i \u002B 1][j]:\n                    dp[i][j] = True\n                if j \u003C len(s2) and s2[j] == s3[i \u002B j] and dp[i][j \u002B 1]:\n                    dp[i][j] = True\n        return dp[0][0]\n"
  },
  {
    "Name": "Longest Increasing Path In a Matrix",
    "NcLink": "longest-increasing-path-in-matrix/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "You are given a 2-D grid of integers \u0060matrix\u0060, where each integer is greater than or equal to \u00600\u0060. \n    \nReturn the length of the longest strictly increasing path within \u0060matrix\u0060.\n\nFrom each cell within the path, you can move either horizontally or vertically. You **may not** move **diagonally**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c302dea2-1695-4edb-e1b3-91e96d9bb700/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [[5,5,3],[2,3,6],[1,1,1]]\n\nOutput: 4\n\u0060\u0060\u0060\n\nExplanation: The longest increasing path is \u0060[1, 2, 3, 6]\u0060 or \u0060[1, 2, 3, 5]\u0060.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/72004ec9-6f68-464c-93c1-0ba0b384c700/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [[1,2,3],[2,1,4],[7,6,5]]\n\nOutput: 7\n\u0060\u0060\u0060\n\nExplanation: The longest increasing path is \u0060[1, 2, 3, 4, 5, 6, 7]\u0060.\n\n**Constraints:**\n* \u00601 \u003C= matrix.length, matrix[i].length \u003C= 100\u0060\n",
    "Difficulty": "Hard",
    "Video": "wCc_nd-GiEc",
    "PythonSolution": "class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -\u003E int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        dp = {}  # (r, c) -\u003E LIP\n\n        def dfs(r, c, prevVal):\n            if r \u003C 0 or r == ROWS or c \u003C 0 or c == COLS or matrix[r][c] \u003C= prevVal:\n                return 0\n            if (r, c) in dp:\n                return dp[(r, c)]\n\n            res = 1\n            res = max(res, 1 \u002B dfs(r \u002B 1, c, matrix[r][c]))\n            res = max(res, 1 \u002B dfs(r - 1, c, matrix[r][c]))\n            res = max(res, 1 \u002B dfs(r, c \u002B 1, matrix[r][c]))\n            res = max(res, 1 \u002B dfs(r, c - 1, matrix[r][c]))\n            dp[(r, c)] = res\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, -1)\n        return max(dp.values())\n"
  },
  {
    "Name": "Distinct Subsequences",
    "NcLink": "count-subsequences/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "You are given two strings \u0060s\u0060 and \u0060t\u0060, both consisting of english letters.\n    \nReturn the number of distinct **subsequences** of \u0060s\u0060 which are equal to \u0060t\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022caaat\u0022, t = \u0022cat\u0022\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: Rhere are 3 ways you can generate \u0060\u0022cat\u0022\u0060 from \u0060s\u0060.\n* (c)aa(at)\n* (c)a(a)a(t)\n* (ca)aa(t)\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022xxyxy\u0022, t = \u0022xy\u0022\n\nOutput: 5\n\u0060\u0060\u0060\n\nExplanation: There are 5 ways you can generate \u0060\u0022xy\u0022\u0060 from \u0060s\u0060.\n* (x)x(y)xy\n* (x)xyx(y)\n* x(x)(y)xy\n* x(x)yx(y)\n* xxy(x)(y)\n\n\n**Constraints:**\n* \u00601 \u003C= s.length, t.length \u003C= 1000\u0060\n* \u0060s\u0060 and \u0060t\u0060 consist of English letters.\n",
    "Difficulty": "Hard",
    "Video": "-RDzMJ33nx8",
    "PythonSolution": "class Solution:\n    def numDistinct(self, s: str, t: str) -\u003E int:\n        cache = {}\n\n        for i in range(len(s) \u002B 1):\n            cache[(i, len(t))] = 1\n        for j in range(len(t)):\n            cache[(len(s), j)] = 0\n\n        for i in range(len(s) - 1, -1, -1):\n            for j in range(len(t) - 1, -1, -1):\n                if s[i] == t[j]:\n                    cache[(i, j)] = cache[(i \u002B 1, j \u002B 1)] \u002B cache[(i \u002B 1, j)]\n                else:\n                    cache[(i, j)] = cache[(i \u002B 1, j)]\n        return cache[(0, 0)]\n"
  },
  {
    "Name": "Edit Distance",
    "NcLink": "edit-distance/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "You are given two strings \u0060word1\u0060 and \u0060word2\u0060, each consisting of lowercase English letters.\n\nYou are allowed to perform three operations on \u0060word1\u0060 an unlimited number of times:\n\n* Insert a character at any position\n* Delete a character at any position\n* Replace a character at any position\n\nReturn the minimum number of operations to make \u0060word1\u0060 equal \u0060word2\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: word1 = \u0022monkeys\u0022, word2 = \u0022money\u0022\n\nOutput: 2\n\u0060\u0060\u0060\n\nExplanation: \n\u0060monkeys\u0060 -\u003E \u0060monkey\u0060 (remove \u0060s\u0060)\n\u0060monkey\u0060 -\u003E \u0060monkey\u0060  (remove \u0060k\u0060)\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: word1 = \u0022neatcdee\u0022, word2 = \u0022neetcode\u0022\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: \n\u0060neatcdee\u0060 -\u003E \u0060neetcdee\u0060  (replace \u0060a\u0060 with \u0060e\u0060)\n\u0060neetcdee\u0060 -\u003E \u0060neetcde\u0060   (remove last \u0060e\u0060)\n\u0060neetcde\u0060  -\u003E \u0060neetcode\u0060  (insert \u0060o\u0060)\n\n**Constraints:**\n* \u00600 \u003C= word1.length, word2.length \u003C= 100\u0060\n* \u0060word1\u0060 and \u0060word2\u0060 consist of lowercase English letters.\n",
    "Difficulty": "Medium",
    "Video": "XYi2-LPrwm4",
    "PythonSolution": "class Solution:\n    def minDistance(self, word1: str, word2: str) -\u003E int:\n        dp = [[float(\u0022inf\u0022)] * (len(word2) \u002B 1) for i in range(len(word1) \u002B 1)]\n\n        for j in range(len(word2) \u002B 1):\n            dp[len(word1)][j] = len(word2) - j\n        for i in range(len(word1) \u002B 1):\n            dp[i][len(word2)] = len(word1) - i\n\n        for i in range(len(word1) - 1, -1, -1):\n            for j in range(len(word2) - 1, -1, -1):\n                if word1[i] == word2[j]:\n                    dp[i][j] = dp[i \u002B 1][j \u002B 1]\n                else:\n                    dp[i][j] = 1 \u002B min(dp[i \u002B 1][j], dp[i][j \u002B 1], dp[i \u002B 1][j \u002B 1])\n        return dp[0][0]\n"
  },
  {
    "Name": "Burst Balloons",
    "NcLink": "burst-balloons/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "You are given an array of integers \u0060nums\u0060 of size \u0060n\u0060. The \u0060ith\u0060 element represents a balloon with an integer value of \u0060nums[i]\u0060. You must burst all of the balloons.\n\nIf you burst the \u0060ith\u0060 balloon, you will receive \u0060nums[i - 1] * nums[i] * nums[i \u002B 1]\u0060 coins. If \u0060i - 1\u0060 or \u0060i \u002B 1\u0060 goes out of bounds of the array, then assume the out of bounds value is 1.\n\nReturn the maximum number of coins you can receive by bursting all of the balloons.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [4,2,3,7]\n\nOutput: 167\n\nExplanation:\nnums = [4,2,3,7] --\u003E [4,3,7] --\u003E [4,7] --\u003E [7] --\u003E []\ncoins =  4*2*3    \u002B   4*3*7   \u002B  1*4*7  \u002B 1*7*1 = 143\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060n == nums.length\u0060\n* \u00601 \u003C= n \u003C= 300\u0060\n* \u00600 \u003C= nums[i] \u003C= 100\u0060\n",
    "Difficulty": "Hard",
    "Video": "VFskby7lUbw",
    "PythonSolution": "class Solution:\n    def maxCoins(self, nums: List[int]) -\u003E int:\n        cache = {}\n        nums = [1] \u002B nums \u002B [1]\n\n        for offset in range(2, len(nums)):\n            for left in range(len(nums) - offset):\n                right = left \u002B offset\n                for pivot in range(left \u002B 1, right):\n                    coins = nums[left] * nums[pivot] * nums[right]\n                    coins \u002B= cache.get((left, pivot), 0) \u002B cache.get((pivot, right), 0)\n                    cache[(left, right)] = max(coins, cache.get((left, right), 0))\n        return cache.get((0, len(nums) - 1), 0)\n"
  },
  {
    "Name": "Regular Expression Matching",
    "NcLink": "regular-expression-matching/",
    "Pattern": "2-D Dynamic Programming",
    "Description": "You are given an input string \u0060s\u0060 consisting of lowercase english letters, and a pattern \u0060p\u0060 consisting of lowercase english letters, as well as \u0060\u0027.\u0027\u0060, and \u0060\u0027*\u0027\u0060 characters.\n    \nReturn \u0060true\u0060 if the pattern matches the **entire** input string, otherwise return \u0060false\u0060.\n\n* \u0060\u0027.\u0027\u0060 Matches any single character\n* \u0060\u0027*\u0027\u0060 Matches zero or more of the preceding element.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022aa\u0022, p = \u0022.b\u0022\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation: Regardless of which character we choose for the \u0060\u0027.\u0027\u0060 in the pattern, we cannot match the second character in the input string.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022nnn\u0022, p = \u0022n*\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: \u0060\u0027*\u0027\u0060 means zero or more of the preceding element, \u0060\u0027n\u0027\u0060. We choose \u0060\u0027n\u0027\u0060 to repeat three times.\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022xyz\u0022, p = \u0022.*z\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: The pattern \u0060\u0022.*\u0022\u0060 means zero or more of any character, so we choose \u0060\u0022..\u0022\u0060 to match \u0060\u0022xy\u0022\u0060 and \u0060\u0022z\u0022\u0060 to match \u0060\u0022z\u0022\u0060.\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 20\u0060\n* \u00601 \u003C= p.length \u003C= 20\u0060\n* Each appearance of \u0060\u0027*\u0027\u0060, will be preceded by a valid character or \u0060\u0027.\u0027\u0060.\n",
    "Difficulty": "Hard",
    "Video": "HAA8mgxlov8",
    "PythonSolution": "class Solution:\n    def isMatch(self, s: str, p: str) -\u003E bool:\n        cache = [[False] * (len(p) \u002B 1) for i in range(len(s) \u002B 1)]\n        cache[len(s)][len(p)] = True\n\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                match = i \u003C len(s) and (s[i] == p[j] or p[j] == \u0022.\u0022)\n\n                if (j \u002B 1) \u003C len(p) and p[j \u002B 1] == \u0022*\u0022:\n                    cache[i][j] = cache[i][j \u002B 2]\n                    if match:\n                        cache[i][j] = cache[i \u002B 1][j] or cache[i][j]\n                elif match:\n                    cache[i][j] = cache[i \u002B 1][j \u002B 1]\n\n        return cache[0][0]\n"
  },
  {
    "Name": "Maximum Subarray",
    "NcLink": "maximum-subarray/",
    "Pattern": "Greedy",
    "Description": "Given an array of integers \u0060nums\u0060, find the subarray with the largest sum and return the sum.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [2,-3,4,-2,2,1,-1,4]\n\nOutput: 8\n\u0060\u0060\u0060\n\nExplanation: The subarray [4,-2,2,1,-1,4] has the largest sum 8.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [-1]\n\nOutput: -1\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 1000\u0060\n* \u0060-1000 \u003C= nums[i] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "5WZl3MMT0Eg",
    "PythonSolution": "class Solution:\n    def maxSubArray(self, nums: List[int]) -\u003E int:\n        res = nums[0]\n\n        total = 0\n        for n in nums:\n            total \u002B= n\n            res = max(res, total)\n            if total \u003C 0:\n                total = 0\n        return res\n"
  },
  {
    "Name": "Jump Game",
    "NcLink": "jump-game/",
    "Pattern": "Greedy",
    "Description": "You are given an integer array \u0060nums\u0060 where each element \u0060nums[i]\u0060 indicates your maximum jump length at that position.\n\nReturn \u0060true\u0060 if you can reach the last index starting from index \u00600\u0060, or \u0060false\u0060 otherwise.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,0,1,0]\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: First jump from index 0 to 1, then from index 1 to 3, and lastly from index 3 to 4.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,1,0,1]\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 1000\u0060\n* \u00600 \u003C= nums[i] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "Yan0cv2cLy8",
    "PythonSolution": "class Solution:\n    def canJump(self, nums: List[int]) -\u003E bool:\n        goal = len(nums) - 1\n\n        for i in range(len(nums) - 2, -1, -1):\n            if i \u002B nums[i] \u003E= goal:\n                goal = i\n        return goal == 0\n"
  },
  {
    "Name": "Jump Game II",
    "NcLink": "jump-game-ii/",
    "Pattern": "Greedy",
    "Description": "You are given an array of integers \u0060nums\u0060, where \u0060nums[i]\u0060 represents the maximum length of a jump towards the right from index \u0060i\u0060. For example, if you are at \u0060nums[i]\u0060, you can jump to any index \u0060i \u002B j\u0060 where:\n\n* \u0060j \u003C= nums[i]\u0060\n* \u0060i \u002B j \u003C nums.length\u0060\n\nYou are initially positioned at \u0060nums[0]\u0060.\n\nReturn the minimum number of jumps to reach the last position in the array (index \u0060nums.length - 1\u0060). You may assume there is always a valid answer.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [2,4,1,1,1,1]\n\nOutput: 2\n\u0060\u0060\u0060\n\nExplanation: Jump from index \u00600\u0060 to index \u00601\u0060, then jump from index \u00601\u0060 to the last index.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [2,1,2,1,0]\n\nOutput: 2\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 1000\u0060\n* \u00600 \u003C= nums[i] \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "dJ7sWiOoK7g",
    "PythonSolution": "class Solution:\n    def jump(self, nums: List[int]) -\u003E int:\n        l, r = 0, 0\n        res = 0\n        while r \u003C (len(nums) - 1):\n            maxJump = 0\n            for i in range(l, r \u002B 1):\n                maxJump = max(maxJump, i \u002B nums[i])\n            l = r \u002B 1\n            r = maxJump\n            res \u002B= 1\n        return res\n"
  },
  {
    "Name": "Gas Station",
    "NcLink": "gas-station/",
    "Pattern": "Greedy",
    "Description": "There are \u0060n\u0060 gas stations along a circular route. You are given two integer arrays \u0060gas\u0060 and \u0060cost\u0060 where:\n\n* \u0060gas[i]\u0060 is the amount of gas at the \u0060ith\u0060 station.\n* \u0060cost[i]\u0060 is the amount of gas needed to travel from the \u0060ith\u0060 station to the \u0060(i \u002B 1)th\u0060 station. (The last station is connected to the first station)\n\nYou have a car that can store an unlimited amount of gas, but you begin the journey with an empty tank at one of the gas stations.\n\nReturn the starting gas station\u0027s index such that you can travel around the circuit once in the clockwise direction. If it\u0027s impossible, then return \u0060-1\u0060.\n\nIt\u0027s guaranteed that at most one solution exists.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: gas = [1,2,3,4], cost = [2,2,4,1]\n\nOutput: 3\n\u0060\u0060\u0060\n\nExplanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 \u002B 4 = 4\nTravel to station 0. Your tank = 4 - 1 \u002B 1 = 3\nTravel to station 1. Your tank = 3 - 2 \u002B 2 = 3\nTravel to station 2. Your tank = 3 - 2 \u002B 3 = 4\nTravel to station 3. Your tank = 2 - 4 \u002B 4 = 2\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: gas = [1,2,3], cost = [2,3,2]\n\nOutput: -1\n\u0060\u0060\u0060\n\nExplanation:\nYou can\u0027t start at station 0 or 1, since there isn\u0027t enough gas to travel to the next station.\nIf you start at station 2, you can move to station 0, and then station 1. \nAt station 1 your tank = 0 \u002B 3 - 2 \u002B 1 - 2 = 0.\nYou\u0027re stuck at station 1, so you can\u0027t travel around the circuit.\n\n**Constraints:**\n* \u00601 \u003C= gas.length == cost.length \u003C= 1000\u0060\n* \u00600 \u003C= gas[i], cost[i] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "lJwbPZGo05A",
    "PythonSolution": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -\u003E int:\n        if sum(gas) \u003C sum(cost):\n            return -1\n\n        total = 0\n        res = 0\n        for i in range(len(gas)):\n            total \u002B= (gas[i] - cost[i])\n\n            if total \u003C 0:\n                total = 0\n                res = i \u002B 1\n        \n        return res\n"
  },
  {
    "Name": "Hand of Straights",
    "NcLink": "hand-of-straights/",
    "Pattern": "Greedy",
    "Description": "You are given an integer array \u0060hand\u0060 where \u0060hand[i]\u0060 is the value written on the \u0060ith\u0060 card and an integer \u0060groupSize\u0060.\n    \nYou want to rearrange the cards into groups so that each group is of size \u0060groupSize\u0060, and card values are consecutively increasing by \u00601\u0060.\n\nReturn \u0060true\u0060 if it\u0027s possible to rearrange the cards in this way, otherwise, return \u0060false\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: hand = [1,2,4,2,3,5,3,4], groupSize = 4\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: The cards can be rearranged as \u0060[1,2,3,4]\u0060 and \u0060[2,3,4,5]\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: hand = [1,2,3,3,4,5,6,7], groupSize = 4\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation: The closest we can get is \u0060[1,2,3,4]\u0060 and \u0060[3,5,6,7]\u0060, but the cards in the second group are not consecutive.\n\n**Constraints:**\n* \u00601 \u003C= hand.length \u003C= 1000\u0060\n* \u00600 \u003C= hand[i] \u003C= 1000\u0060\n* \u00601 \u003C= groupSize \u003C= hand.length\u0060\n",
    "Difficulty": "Medium",
    "Video": "amnrMCVd2YI",
    "PythonSolution": "class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -\u003E bool:\n        if len(hand) % groupSize:\n            return False\n\n        count = {}\n        for n in hand:\n            count[n] = 1 \u002B count.get(n, 0)\n\n        minH = list(count.keys())\n        heapq.heapify(minH)\n        while minH:\n            first = minH[0]\n            for i in range(first, first \u002B groupSize):\n                if i not in count:\n                    return False\n                count[i] -= 1\n                if count[i] == 0:\n                    if i != minH[0]:\n                        return False\n                    heapq.heappop(minH)\n        return True\n"
  },
  {
    "Name": "Merge Triplets to Form Target Triplet",
    "NcLink": "merge-triplets-to-form-target/",
    "Pattern": "Greedy",
    "Description": "You are given a 2D array of integers \u0060triplets\u0060, where \u0060triplets[i] = [ai, bi, ci]\u0060 represents the \u0060ith\u0060 **triplet**. You are also given an array of integers \u0060target = [x, y, z]\u0060 which is the triplet we want to obtain.\n    \nTo obtain \u0060target\u0060, you may apply the following operation on \u0060triplets\u0060 zero or more times:\n\nChoose two **different** triplets \u0060triplets[i]\u0060 and \u0060triplets[j]\u0060 and update \u0060triplets[j]\u0060 to become \u0060[max(ai, aj), max(bi, bj), max(ci, cj)]\u0060.\n    * E.g. if \u0060triplets[i] = [1, 3, 1]\u0060 and \u0060triplets[j] = [2, 1, 2]\u0060, \u0060triplets[j]\u0060 will be updated to \u0060[max(1, 2), max(3, 1), max(1, 2)] = [2, 3, 2]\u0060.\n\nReturn \u0060true\u0060 if it is possible to obtain \u0060target\u0060 as an **element** of \u0060triplets\u0060, or \u0060false\u0060 otherwise.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: triplets = [[1,2,3],[7,1,1]], target = [7,2,3]\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: \nChoose the first and second triplets, update the second triplet to be [max(1, 7), max(2, 1), max(3, 1)] = [7, 2, 3].\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: triplets = [[2,5,6],[1,4,4],[5,7,5]], target = [5,4,6]\n\nOutput: false\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= triplets.length \u003C= 1000\u0060\n* \u00601 \u003C= ai, bi, ci, x, y, z \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "kShkQLQZ9K4",
    "PythonSolution": "class Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -\u003E bool:\n        good = set()\n\n        for t in triplets:\n            if t[0] \u003E target[0] or t[1] \u003E target[1] or t[2] \u003E target[2]:\n                continue\n            for i, v in enumerate(t):\n                if v == target[i]:\n                    good.add(i)\n        return len(good) == 3\n"
  },
  {
    "Name": "Partition Labels",
    "NcLink": "partition-labels/",
    "Pattern": "Greedy",
    "Description": "You are given a string \u0060s\u0060 consisting of lowercase english letters. \n    \nWe want to split the string into as many substrings as possible, while ensuring that each letter appears in at most one substring.\n\nReturn a list of integers representing the size of these substrings in the order they appear in the string.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022xyxxyzbzbbisl\u0022\n\nOutput: [5, 5, 1, 1, 1]\n\u0060\u0060\u0060\n\nExplanation: The string can be split into \u0060[\u0022xyxxy\u0022, \u0022zbzbb\u0022, \u0022i\u0022, \u0022s\u0022, \u0022l\u0022]\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022abcabc\u0022\n\nOutput: [6]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "B7m8UmZE-vw",
    "PythonSolution": "class Solution:\n    def partitionLabels(self, S: str) -\u003E List[int]:\n        count = {}\n        res = []\n        i, length = 0, len(S)\n        for j in range(length):\n            c = S[j]\n            count[c] = j\n\n        curLen = 0\n        goal = 0\n        while i \u003C length:\n            c = S[i]\n            goal = max(goal, count[c])\n            curLen \u002B= 1\n\n            if goal == i:\n                res.append(curLen)\n                curLen = 0\n            i \u002B= 1\n        return res\n"
  },
  {
    "Name": "Valid Parenthesis String",
    "NcLink": "valid-parenthesis-string/",
    "Pattern": "Greedy",
    "Description": "You are given a string \u0060s\u0060 which contains only three types of characters: \u0060\u0027(\u0027\u0060, \u0060\u0027)\u0027\u0060 and \u0060\u0027*\u0027\u0060. \n    \nReturn \u0060true\u0060 if \u0060s\u0060 is **valid**, otherwise return \u0060false\u0060.\n\nA string is valid if it follows all of the following rules:\n\n* Every left parenthesis \u0060\u0027(\u0027\u0060 must have a corresponding right parenthesis \u0060\u0027)\u0027\u0060.\n* Every right parenthesis \u0060\u0027)\u0027\u0060 must have a corresponding left parenthesis \u0060\u0027(\u0027\u0060.\n* Left parenthesis \u0060\u0027(\u0027\u0060 must go before the corresponding right parenthesis \u0060\u0027)\u0027\u0060.\n* A \u0060\u0027*\u0027\u0060 could be treated as a right parenthesis \u0060\u0027)\u0027\u0060 character or a left parenthesis \u0060\u0027(\u0027\u0060 character, or as an empty string \u0060\u0022\u0022\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022((**)\u0022\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: One of the \u0060\u0027*\u0027\u0060 could be a \u0060\u0027)\u0027\u0060 and the other could be an empty string.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: s = \u0022(((*)\u0022\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation: The string is not valid because there is an extra \u0060\u0027(\u0027\u0060 at the beginning, regardless of the extra \u0060\u0027*\u0027\u0060.\n\n**Constraints:**\n* \u00601 \u003C= s.length \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "QhPdNS143Qg",
    "PythonSolution": "class Solution:\n    def checkValidString(self, s: str) -\u003E bool:\n        leftMin, leftMax = 0, 0\n\n        for c in s:\n            if c == \u0022(\u0022:\n                leftMin, leftMax = leftMin \u002B 1, leftMax \u002B 1\n            elif c == \u0022)\u0022:\n                leftMin, leftMax = leftMin - 1, leftMax - 1\n            else:\n                leftMin, leftMax = leftMin - 1, leftMax \u002B 1\n            if leftMax \u003C 0:\n                return False\n            if leftMin \u003C 0:\n                leftMin = 0\n        return leftMin == 0\n"
  },
  {
    "Name": "Insert Interval",
    "NcLink": "insert-new-interval/",
    "Pattern": "Intervals",
    "Description": "You are given an array of non-overlapping intervals \u0060intervals\u0060 where \u0060intervals[i] = [start_i, end_i]\u0060 represents the start and the end time of the \u0060ith\u0060 interval. \u0060intervals\u0060 is initially sorted in ascending order by \u0060start_i\u0060.\n\nYou are given another interval \u0060newInterval = [start, end]\u0060.\n\nInsert \u0060newInterval\u0060 into \u0060intervals\u0060 such that \u0060intervals\u0060 is still sorted in ascending order by \u0060start_i\u0060 and also \u0060intervals\u0060 still does not have any overlapping intervals. You may merge the overlapping intervals if needed.\n\nReturn \u0060intervals\u0060 after adding \u0060newInterval\u0060.\n\nNote: Intervals are *non-overlapping* if they have no common point. For example, [1,2] and [3,4] are non-overlapping, but [1,2] and [2,3] are overlapping.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: intervals = [[1,3],[4,6]], newInterval = [2,5]\n\nOutput: [[1,6]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: intervals = [[1,2],[3,5],[9,10]], newInterval = [6,7]\n\nOutput: [[1,2],[3,5],[6,7],[9,10]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00600 \u003C= intervals.length \u003C= 1000\u0060\n* \u0060newInterval.length == intervals[i].length == 2\u0060\n* \u00600 \u003C= start \u003C= end \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "A8NUOmlwOlM",
    "PythonSolution": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -\u003E List[List[int]]:\n        res = []\n\n        for i in range(len(intervals)):\n            if newInterval[1] \u003C intervals[i][0]:\n                res.append(newInterval)\n                return res \u002B intervals[i:]\n            elif newInterval[0] \u003E intervals[i][1]:\n                res.append(intervals[i])\n            else:\n                newInterval = [\n                    min(newInterval[0], intervals[i][0]),\n                    max(newInterval[1], intervals[i][1]),\n                ]\n        res.append(newInterval)\n        return res\n"
  },
  {
    "Name": "Merge Intervals",
    "NcLink": "merge-intervals/",
    "Pattern": "Intervals",
    "Description": "Given an array of \u0060intervals\u0060 where \u0060intervals[i] = [start_i, end_i]\u0060, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nYou may return the answer in **any order**.\n\nNote: Intervals are *non-overlapping* if they have no common point. For example, \u0060[1, 2]\u0060 and \u0060[3, 4]\u0060 are non-overlapping, but \u0060[1, 2]\u0060 and \u0060[2, 3]\u0060 are overlapping.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: intervals = [[1,3],[1,5],[6,7]]\n\nOutput: [[1,5],[6,7]]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: intervals = [[1,2],[2,3]]\n\nOutput: [[1,3]]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= intervals.length \u003C= 1000\u0060\n* \u0060intervals[i].length == 2\u0060\n* \u00600 \u003C= start \u003C= end \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "44H3cEC2fFM",
    "PythonSolution": "class Solution:\n    def merge(self, intervals: List[List[int]]) -\u003E List[List[int]]:\n        intervals.sort(key=lambda pair: pair[0])\n        output = [intervals[0]]\n\n        for start, end in intervals:\n            lastEnd = output[-1][1]\n\n            if start \u003C= lastEnd:\n                output[-1][1] = max(lastEnd, end)\n            else:\n                output.append([start, end])\n        return output\n"
  },
  {
    "Name": "Non Overlapping Intervals",
    "NcLink": "non-overlapping-intervals/",
    "Pattern": "Intervals",
    "Description": "Given an array of intervals \u0060intervals\u0060 where \u0060intervals[i] = [start_i, end_i]\u0060, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\nNote: Intervals are *non-overlapping* even if they have a common point. For example, \u0060[1, 3]\u0060 and \u0060[2, 4]\u0060 are overlapping, but \u0060[1, 2]\u0060 and \u0060[2, 3]\u0060 are non-overlapping.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: intervals = [[1,2],[2,4],[1,4]]\n\nOutput: 1\n\u0060\u0060\u0060\n\nExplanation: After [1,4] is removed, the rest of the intervals are non-overlapping.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: intervals = [[1,2],[2,4]]\n\nOutput: 0\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= intervals.length \u003C= 1000\u0060\n* \u0060intervals[i].length == 2\u0060\n* \u0060-50000 \u003C= starti \u003C endi \u003C= 50000\u0060\n",
    "Difficulty": "Medium",
    "Video": "nONCGxWoUfM",
    "PythonSolution": "class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -\u003E int:\n        intervals.sort()\n        res = 0\n        prevEnd = intervals[0][1]\n        \n        for start, end in intervals[1:]:\n            if start \u003E= prevEnd:\n                prevEnd = end\n            else:\n                res \u002B= 1\n                prevEnd = min(end, prevEnd)\n        return res\n"
  },
  {
    "Name": "Meeting Rooms",
    "NcLink": "meeting-schedule/",
    "Pattern": "Intervals",
    "Description": "Given an array of meeting time interval objects consisting of start and end times \u0060[[start_1,end_1],[start_2,end_2],...] (start_i \u003C end_i)\u0060, determine if a person could add all meetings to their schedule without any conflicts.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: intervals = [(0,30),(5,10),(15,20)]\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation:\n* \u0060(0,30)\u0060 and \u0060(5,10)\u0060 will conflict\n* \u0060(0,30)\u0060 and \u0060(15,20)\u0060 will conflict\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: intervals = [(5,8),(9,15)]\n\nOutput: true\n\u0060\u0060\u0060\n\n**Note:**\n* (0,8),(8,10) is not considered a conflict at 8\n\n**Constraints:**\n* \u00600 \u003C= intervals.length \u003C= 500\u0060\n* \u00600 \u003C= intervals[i].start \u003C intervals[i].end \u003C= 1,000,000\u0060\n",
    "Difficulty": "Easy",
    "Video": "PaJxqZVPhbg",
    "PythonSolution": "\u0022\u0022\u0022\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\u0022\u0022\u0022\n\nclass Solution:\n    def canAttendMeetings(self, intervals: List[Interval]) -\u003E bool:\n        intervals.sort(key=lambda i: i.start)\n\n        for i in range(1, len(intervals)):\n            i1 = intervals[i - 1]\n            i2 = intervals[i]\n\n            if i1.end \u003E i2.start:\n                return False\n        return True\n"
  },
  {
    "Name": "Meeting Rooms II",
    "NcLink": "meeting-schedule-ii/",
    "Pattern": "Intervals",
    "Description": "Given an array of meeting time interval objects consisting of start and end times \u0060[[start_1,end_1],[start_2,end_2],...] (start_i \u003C end_i)\u0060, find the minimum number of days required to schedule all meetings without any conflicts.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: intervals = [(0,40),(5,10),(15,20)]\n\nOutput: 2\n\u0060\u0060\u0060\n\nExplanation:\nday1: (0,40)\nday2: (5,10),(15,20)\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: intervals = [(4,9)]\n\nOutput: 1\n\u0060\u0060\u0060\n\n**Note:**\n* (0,8),(8,10) is not considered a conflict at 8\n\n**Constraints:**\n* \u00600 \u003C= intervals.length \u003C= 500\u0060\n* \u00600 \u003C= intervals[i].start \u003C intervals[i].end \u003C= 1,000,000\u0060\n",
    "Difficulty": "Medium",
    "Video": "FdzJmTCVyJU",
    "PythonSolution": "\u0022\u0022\u0022\nDefinition of Interval:\nclass Interval(object):\n    def __init__(self, start, end):\n        self.start = start\n        self.end = end\n\u0022\u0022\u0022\n\nclass Solution:\n    def minMeetingRooms(self, intervals: List[Interval]) -\u003E int:\n        time = []\n        for i in intervals:\n            start, end = i.start, i.end\n            time.append((start, 1))\n            time.append((end, -1))\n        \n        time.sort(key=lambda x: (x[0], x[1]))\n        \n        count = 0\n        max_count = 0\n        for t in time:\n            count \u002B= t[1]\n            max_count = max(max_count, count)\n        return max_count\n"
  },
  {
    "Name": "Minimum Interval to Include Each Query",
    "NcLink": "minimum-interval-including-query/",
    "Pattern": "Intervals",
    "Description": "You are given a 2D integer array \u0060intervals\u0060, where \u0060intervals[i] = [left_i, right_i]\u0060 represents the \u0060ith\u0060 interval starting at \u0060left_i\u0060 and ending at \u0060right_i\u0060 **(inclusive)**. \n\nYou are also given an integer array of query points \u0060queries\u0060. The result of \u0060query[j]\u0060 is the **length of the shortest interval** \u0060i\u0060 such that \u0060left_i \u003C= queries[j] \u003C= right_i\u0060. If no such interval exists, the result of this query is \u0060-1\u0060.\n\nReturn an array \u0060output\u0060 where \u0060output[j]\u0060 is the result of \u0060query[j]\u0060.\n\nNote: The length of an interval is calculated as \u0060right_i - left_i \u002B 1\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: intervals = [[1,3],[2,3],[3,7],[6,6]], queries = [2,3,1,7,6,8]\n\nOutput: [2,2,3,5,1,-1]\n\u0060\u0060\u0060\n\nExplanation:\n- Query = 2: The interval \u0060[2,3]\u0060 is the smallest one containing 2, it\u0027s length is 2.\n- Query = 3: The interval \u0060[2,3]\u0060 is the smallest one containing 3, it\u0027s length is 2.\n- Query = 1: The interval \u0060[1,3]\u0060 is the smallest one containing 1, it\u0027s length is 3.\n- Query = 7: The interval \u0060[3,7]\u0060 is the smallest one containing 7, it\u0027s length is 5.\n- Query = 6: The interval \u0060[6,6]\u0060 is the smallest one containing 6, it\u0027s length is 1.\n- Query = 8: There is no interval containing 8.\n\n\n**Constraints:**\n* \u00601 \u003C= intervals.length \u003C= 1000\u0060\n* \u00601 \u003C= queries.length \u003C= 1000\u0060\n* \u00601 \u003C= left_i \u003C= right_i \u003C= 10000\u0060\n* \u00601 \u003C= queries[j] \u003C= 10000\u0060\n",
    "Difficulty": "Hard",
    "Video": "5hQ5WWW5awQ",
    "PythonSolution": "class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -\u003E List[int]:\n        intervals.sort()\n        minHeap = []\n        res = {}\n        i = 0\n        for q in sorted(queries):\n            while i \u003C len(intervals) and intervals[i][0] \u003C= q:\n                l, r = intervals[i]\n                heapq.heappush(minHeap, (r - l \u002B 1, r))\n                i \u002B= 1\n\n            while minHeap and minHeap[0][1] \u003C q:\n                heapq.heappop(minHeap)\n            res[q] = minHeap[0][0] if minHeap else -1\n        return [res[q] for q in queries]\n"
  },
  {
    "Name": "Rotate Image",
    "NcLink": "rotate-matrix/",
    "Pattern": "Math \u0026 Geometry",
    "Description": "Given a square \u0060n x n\u0060 matrix of integers \u0060matrix\u0060, rotate it by 90 degrees *clockwise*.\n\nYou must rotate the matrix *in-place*. Do not allocate another 2D matrix and do the rotation.\n\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e13e93ed-4fdb-49e4-f971-de1e30356600/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [\n  [1,2],\n  [3,4]\n]\n\nOutput: [\n  [3,1],\n  [4,2]\n]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/37d34844-e6a0-4809-0895-f15e782efe00/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n]\n\nOutput: [\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060n == matrix.length == matrix[i].length\u0060\n* \u00601 \u003C= n \u003C= 20\u0060\n* \u0060-1000 \u003C= matrix[i][j] \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "fMSJSS7eO1w",
    "PythonSolution": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -\u003E None:\n        l, r = 0, len(matrix) - 1\n        while l \u003C r:\n            for i in range(r - l):\n                top, bottom = l, r\n\n                # save the topleft\n                topLeft = matrix[top][l \u002B i]\n\n                # move bottom left into top left\n                matrix[top][l \u002B i] = matrix[bottom - i][l]\n\n                # move bottom right into bottom left\n                matrix[bottom - i][l] = matrix[bottom][r - i]\n\n                # move top right into bottom right\n                matrix[bottom][r - i] = matrix[top \u002B i][r]\n\n                # move top left into top right\n                matrix[top \u002B i][r] = topLeft\n            r -= 1\n            l \u002B= 1\n"
  },
  {
    "Name": "Spiral Matrix",
    "NcLink": "spiral-matrix/",
    "Pattern": "Math \u0026 Geometry",
    "Description": "Given an \u0060m x n\u0060 matrix of integers \u0060matrix\u0060, return a list of all elements within the matrix in *spiral order*.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fe678b92-8606-4e07-ce70-08ec3479aa00/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [[1,2],[3,4]]\n\nOutput: [1,2,4,3]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/8a460616-db14-4ccf-068b-00aa6d398400/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\n\nOutput: [1,2,3,6,9,8,7,4,5]\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= matrix.length, matrix[i].length \u003C= 10\u0060\n* \u0060-100 \u003C= matrix[i][j] \u003C= 100\u0060\n",
    "Difficulty": "Medium",
    "Video": "BJnMZNwUk1M",
    "PythonSolution": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -\u003E List[int]:\n        res = []\n        left, right = 0, len(matrix[0])\n        top, bottom = 0, len(matrix)\n\n        while left \u003C right and top \u003C bottom:\n            for i in range(left, right):\n                res.append(matrix[top][i])\n            top \u002B= 1\n            for i in range(top, bottom):\n                res.append(matrix[i][right - 1])\n            right -= 1\n            if not (left \u003C right and top \u003C bottom):\n                break\n            for i in range(right - 1, left - 1, -1):\n                res.append(matrix[bottom - 1][i])\n            bottom -= 1\n            for i in range(bottom - 1, top - 1, -1):\n                res.append(matrix[i][left])\n            left \u002B= 1\n\n        return res\n"
  },
  {
    "Name": "Set Matrix Zeroes",
    "NcLink": "set-zeroes-in-matrix/",
    "Pattern": "Math \u0026 Geometry",
    "Description": "Given an \u0060m x n\u0060 matrix of integers \u0060matrix\u0060, if an element is \u00600\u0060, set its entire row and column to \u00600\u0060\u0027s.\n\nYou must update the matrix *in-place*.\n\n**Follow up:** Could you solve it using \u0060O(1)\u0060 space?\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/49ffd14e-b32b-4ed8-e0d0-9378e5eb9b00/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [\n  [0,1],\n  [1,1]\n]\n\nOutput: [\n  [0,0],\n  [0,1]\n]\n\u0060\u0060\u0060\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/04d99cc8-e453-464d-888c-58d0a95daf00/public)\n\n\u0060\u0060\u0060java\nInput: matrix = [\n  [1,2,3],\n  [4,0,5],\n  [6,7,8]\n]\n\nOutput: [\n  [1,0,3],\n  [0,0,0],\n  [6,0,8]\n]\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= matrix.length, matrix[0].length \u003C= 100\u0060\n* \u0060-2^31 \u003C= matrix[i][j] \u003C= (2^31) - 1\u0060\n",
    "Difficulty": "Medium",
    "Video": "T41rL0L3Pnw",
    "PythonSolution": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -\u003E None:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        rowZero = False\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if matrix[r][c] == 0:\n                    matrix[0][c] = 0\n                    if r \u003E 0:\n                        matrix[r][0] = 0\n                    else:\n                        rowZero = True\n\n        for r in range(1, ROWS):\n            for c in range(1, COLS):\n                if matrix[0][c] == 0 or matrix[r][0] == 0:\n                    matrix[r][c] = 0\n\n        if matrix[0][0] == 0:\n            for r in range(ROWS):\n                matrix[r][0] = 0\n\n        if rowZero:\n            for c in range(COLS):\n                matrix[0][c] = 0\n"
  },
  {
    "Name": "Happy Number",
    "NcLink": "non-cyclical-number/",
    "Pattern": "Math \u0026 Geometry",
    "Description": "A **non-cyclical number** is an integer defined by the following algorithm:\n\n* Given a positive integer, replace it with the sum of the squares of its digits.\n* Repeat the above step until the number equals \u00601\u0060, or it **loops infinitely in a cycle** which does not include \u00601\u0060.\n* If it stops at \u00601\u0060, then the number is a **non-cyclical number**.\n\nGiven a positive integer \u0060n\u0060, return \u0060true\u0060 if it is a **non-cyclical number**, otherwise return \u0060false\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: n = 100\n\nOutput: true\n\u0060\u0060\u0060\n\nExplanation: 1^2 \u002B 0^2 \u002B 0^2 = 1\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: n = 101\n\nOutput: false\n\u0060\u0060\u0060\n\nExplanation:\n1^2 \u002B 0^2 \u002B 1^2 = 2\n2^2 = 4\n4^2 = 16\n1^2 \u002B 6^2 = 37\n3^2 \u002B 7^2 = 58\n5^2 \u002B 8^2 = 89\n8^2 \u002B 9^2 = 145\n1^2 \u002B 4^2 \u002B 5^2 = 42\n4^2 \u002B 2^2 = 20\n2^2 \u002B 0^2 = 4 (This number has already been seen)\n\n**Constraints:**\n* \u00601 \u003C= n \u003C= 1000\u0060\n",
    "Difficulty": "Easy",
    "Video": "ljz85bxOYJ0",
    "PythonSolution": "class Solution:\n    def isHappy(self, n: int) -\u003E bool:\n        slow, fast = n, self.sumSquareDigits(n)\n\n        while slow != fast:\n            fast = self.sumSquareDigits(fast)\n            fast = self.sumSquareDigits(fast)\n            slow = self.sumSquareDigits(slow)\n\n        return True if fast == 1 else False\n\n    def sumSquareDigits(self, n):\n        output = 0\n        while n:\n            output \u002B= (n % 10) ** 2\n            n = n // 10\n        return output\n"
  },
  {
    "Name": "Plus One",
    "NcLink": "plus-one/",
    "Pattern": "Math \u0026 Geometry",
    "Description": "You are given an integer array \u0060digits\u0060, where each \u0060digits[i]\u0060 is the \u0060ith\u0060 digit of a large integer. It is ordered from most significant to least significant digit, and it will not contain any leading zero.\n\nReturn the digits of the given integer after incrementing it by one.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: digits = [1,2,3,4]\n\nOutput: [1,2,3,5]\n\u0060\u0060\u0060\n\nExplanation \u00601234\u0060 \u002B \u00601\u0060 = \u00601235\u0060.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: digits = [9,9,9]\n\nOutput: [1,0,0,0]\n\u0060\u0060\u0060\n\n\n**Constraints:**\n* \u00601 \u003C= digits.length \u003C= 100\u0060\n* \u00600 \u003C= digits[i] \u003C= 9\u0060\n",
    "Difficulty": "Easy",
    "Video": "jIaA8boiG1s",
    "PythonSolution": "class Solution:\n    def plusOne(self, digits: List[int]) -\u003E List[int]:\n        one = 1\n        i = 0\n        digits = digits[::-1]\n\n        while one:\n            if i \u003C len(digits):\n                if digits[i] == 9:\n                    digits[i] = 0\n                else:\n                    digits[i] \u002B= 1\n                    one = 0\n            else:\n                digits.append(one)\n                one = 0\n            i \u002B= 1\n        return digits[::-1]\n"
  },
  {
    "Name": "Pow(x, n)",
    "NcLink": "pow-x-n/",
    "Pattern": "Math \u0026 Geometry",
    "Description": "\u0060Pow(x, n)\u0060 is a mathematical function to calculate the value of \u0060x\u0060 raised to the power of \u0060n\u0060 (i.e., \u0060x^n\u0060).\n    \nGiven a floating-point value \u0060x\u0060 and an integer value \u0060n\u0060, implement the \u0060myPow(x, n)\u0060 function, which calculates \u0060x\u0060 raised to the power \u0060n\u0060.\n\nYou may **not** use any built-in library functions.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: x = 2.00000, n = 5\n\nOutput: 32.00000\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: x = 1.10000, n = 10\n\nOutput: 2.59374\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: x = 2.00000, n = -3\n\nOutput: 0.12500\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060-100.0 \u003C x \u003C 100.0\u0060\n* \u0060-1000 \u003C= n \u003C= 1000\u0060\n* \u0060n\u0060 is an integer.\n* If \u0060x = 0\u0060, then \u0060n\u0060 will be positive.\n",
    "Difficulty": "Medium",
    "Video": "g9YQyYi4IQQ",
    "PythonSolution": "class Solution:\n    def myPow(self, x: float, n: int) -\u003E float:\n        def helper(x, n):\n            if x == 0:\n                return 0\n            if n == 0:\n                return 1\n\n            res = helper(x * x, n // 2)\n            return x * res if n % 2 else res\n\n        res = helper(x, abs(n))\n        return res if n \u003E= 0 else 1 / res\n"
  },
  {
    "Name": "Multiply Strings",
    "NcLink": "multiply-strings/",
    "Pattern": "Math \u0026 Geometry",
    "Description": "You are given two strings \u0060num1\u0060 and \u0060num2\u0060 that represent non-negative integers. \n    \nReturn the product of \u0060num1\u0060 and \u0060num2\u0060 in the form of a string.\n\nAssume that neither \u0060num1\u0060 nor \u0060num2\u0060 contain any leading zero, unless they are the number \u00600\u0060 itself.\n\n**Note**: You can not use any built-in library to convert the inputs directly into integers.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: num1 = \u00223\u0022, num2 = \u00224\u0022\n\nOutput: \u002212\u0022\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: num1 = \u0022111\u0022, num2 = \u0022222\u0022\n\nOutput: \u002224642\u0022\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= num1.length, num2.length \u003C= 200\u0060\n* \u0060num1\u0060 and \u0060num2\u0060 consist of digits only.\n",
    "Difficulty": "Medium",
    "Video": "1vZswirL8Y8",
    "PythonSolution": "class Solution:\n    def multiply(self, num1: str, num2: str) -\u003E str:\n        if \u00220\u0022 in [num1, num2]:\n            return \u00220\u0022\n\n        res = [0] * (len(num1) \u002B len(num2))\n        num1, num2 = num1[::-1], num2[::-1]\n        for i1 in range(len(num1)):\n            for i2 in range(len(num2)):\n                digit = int(num1[i1]) * int(num2[i2])\n                res[i1 \u002B i2] \u002B= digit\n                res[i1 \u002B i2 \u002B 1] \u002B= res[i1 \u002B i2] // 10\n                res[i1 \u002B i2] = res[i1 \u002B i2] % 10\n\n        res, beg = res[::-1], 0\n        while beg \u003C len(res) and res[beg] == 0:\n            beg \u002B= 1\n        res = map(str, res[beg:])\n        return \u0022\u0022.join(res)\n"
  },
  {
    "Name": "Detect Squares",
    "NcLink": "count-squares/",
    "Pattern": "Math \u0026 Geometry",
    "Description": "You are given a stream of points consisting of x-y coordinates on a 2-D plane. Points can be added and queried as follows:\n\n* **Add** - new points can be added to the stream into a data structure. Duplicate points are allowed and should be treated as separate points.\n* **Query** - Given a single query point, **count** the number of ways to choose three additional points from the data structure such that the three points and the query point form a **square**. The square must have all sides parallel to the x-axis and y-axis, i.e. no diagonal squares are allowed. Recall that a **square** must have four equal sides.\n\n\nImplement the \u0060CountSquares\u0060 class:\n* \u0060CountSquares()\u0060 Initializes the object.\n* \u0060void add(int[] point)\u0060 Adds a new point \u0060point = [x, y]\u0060.\n* \u0060int count(int[] point)\u0060 Counts the number of ways to form valid **squares** with point \u0060point = [x, y]\u0060 as described above.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/4ff69d9c-cd7d-43fa-bad1-e718fc207600/public)\n\n\u0060\u0060\u0060java\nInput: \n[\u0022CountSquares\u0022, \u0022add\u0022, [[1, 1]], \u0022add\u0022, [[2, 2]], \u0022add\u0022, [[1, 2]], \u0022count\u0022, [[2, 1]], \u0022count\u0022, [[3, 3]], \u0022add\u0022, [[2, 2]], \u0022count\u0022, [[2, 1]]]\n       \nOutput:\n[null, null, null, null, 1, 0, null, 2]\n\nExplanation:\nCountSquares countSquares = new CountSquares();\ncountSquares.add([1, 1]);\ncountSquares.add([2, 2]);\ncountSquares.add([1, 2]);\n\ncountSquares.count([2, 1]);   // return 1.\ncountSquares.count([3, 3]);   // return 0.\ncountSquares.add([2, 2]);     // Duplicate points are allowed.\ncountSquares.count([2, 1]);   // return 2. \n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060point.length == 2\u0060\n* \u00600 \u003C= x, y \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "bahebearrDc",
    "PythonSolution": "class CountSquares:\n    def __init__(self):\n        self.ptsCount = defaultdict(int)\n        self.pts = []\n\n    def add(self, point: List[int]) -\u003E None:\n        self.ptsCount[tuple(point)] \u002B= 1\n        self.pts.append(point)\n\n    def count(self, point: List[int]) -\u003E int:\n        res = 0\n        px, py = point\n        for x, y in self.pts:\n            if (abs(py - y) != abs(px - x)) or x == px or y == py:\n                continue\n            res \u002B= self.ptsCount[(x, py)] * self.ptsCount[(px, y)]\n        return res\n"
  },
  {
    "Name": "Single Number",
    "NcLink": "single-number/",
    "Pattern": "Bit Manipulation",
    "Description": "You are given a **non-empty** array of integers \u0060nums\u0060. Every integer appears twice except for one.\n\nReturn the integer that appears only once.\n\nYou must implement a solution with $O(n)$ runtime complexity and use only $O(1)$ extra space.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [3,2,3]\n\nOutput: 2\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [7,6,6,7,8]\n\nOutput: 8\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 10000\u0060\n* \u0060-10000 \u003C= nums[i] \u003C= 10000\u0060\n",
    "Difficulty": "Easy",
    "Video": "qMPX1AOa83k",
    "PythonSolution": "class Solution:\n    def singleNumber(self, nums: List[int]) -\u003E int:\n        res = 0\n        for n in nums:\n            res = n ^ res\n        return res\n"
  },
  {
    "Name": "Number of 1 Bits",
    "NcLink": "number-of-one-bits/",
    "Pattern": "Bit Manipulation",
    "Description": "You are given an unsigned integer \u0060n\u0060. Return the number of \u00601\u0060 bits in its binary representation.\n\nYou may assume \u0060n\u0060 is a non-negative integer which fits within 32-bits.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: n = 00000000000000000000000000010111\n\nOutput: 4\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: n = 01111111111111111111111111111101\n\nOutput: 30\n\u0060\u0060\u0060\n",
    "Difficulty": "Easy",
    "Video": "5Km3utixwZs",
    "PythonSolution": "class Solution:\n    def hammingWeight(self, n: int) -\u003E int:\n        res = 0\n        while n:\n            n \u0026= n - 1\n            res \u002B= 1\n        return res\n"
  },
  {
    "Name": "Counting Bits",
    "NcLink": "counting-bits/",
    "Pattern": "Bit Manipulation",
    "Description": "Given an integer \u0060n\u0060, count the number of \u00601\u0060\u0027s in the binary representation of every number in the range \u0060[0, n]\u0060.\n    \nReturn an array \u0060output\u0060 where \u0060output[i]\u0060 is the number of \u00601\u0060\u0027s in the binary representation of \u0060i\u0060.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: n = 4\n\nOutput: [0,1,1,2,1]\n\u0060\u0060\u0060\n\nExplanation:\n0 --\u003E 0\n1 --\u003E 1\n2 --\u003E 10\n3 --\u003E 11\n4 --\u003E 100\n\n**Constraints:**\n* \u00600 \u003C= n \u003C= 1000\u0060\n",
    "Difficulty": "Easy",
    "Video": "RyBM56RIWrM",
    "PythonSolution": "class Solution:\n    def countBits(self, n: int) -\u003E List[int]:\n        dp = [0] * (n \u002B 1)\n        offset = 1\n\n        for i in range(1, n \u002B 1):\n            if offset * 2 == i:\n                offset = i\n            dp[i] = 1 \u002B dp[i - offset]\n        return dp\n"
  },
  {
    "Name": "Reverse Bits",
    "NcLink": "reverse-bits/",
    "Pattern": "Bit Manipulation",
    "Description": "Given a 32-bit unsigned integer \u0060n\u0060, reverse the bits of the binary representation of \u0060n\u0060 and return the result.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: n = 00000000000000000000000000010101\n\nOutput:    2818572288 (10101000000000000000000000000000)\n\u0060\u0060\u0060\n\nExplanation: Reversing \u006000000000000000000000000000010101\u0060, which represents the unsigned integer \u006021\u0060, gives us \u006010101000000000000000000000000000\u0060 which represents the unsigned integer \u00602818572288\u0060.\n",
    "Difficulty": "Easy",
    "Video": "UcoN6UjAI64",
    "PythonSolution": "class Solution:\n    def reverseBits(self, n: int) -\u003E int:\n        res = 0\n        for i in range(32):\n            bit = (n \u003E\u003E i) \u0026 1\n            res \u002B= (bit \u003C\u003C (31 - i))\n        return res\n"
  },
  {
    "Name": "Missing Number",
    "NcLink": "missing-number/",
    "Pattern": "Bit Manipulation",
    "Description": "Given an array \u0060nums\u0060 containing \u0060n\u0060 integers in the range \u0060[0, n]\u0060 without any duplicates, return the single number in the range that is missing from \u0060nums\u0060.\n\n**Follow-up**: Could you implement a solution using only \u0060O(1)\u0060 extra space complexity and \u0060O(n)\u0060 runtime complexity?\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: nums = [1,2,3]\n\nOutput: 0\n\u0060\u0060\u0060\n\nExplanation: Since there are 3 numbers, the range is [0,3]. The missing number is 0 since it does not appear in nums.\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: nums = [0,2]\n\nOutput: 1\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u00601 \u003C= nums.length \u003C= 1000\u0060\n",
    "Difficulty": "Easy",
    "Video": "WnPLSRLSANE",
    "PythonSolution": "class Solution:\n    def missingNumber(self, nums: List[int]) -\u003E int:\n        res = len(nums)\n\n        for i in range(len(nums)):\n            res \u002B= i - nums[i]\n        return res\n"
  },
  {
    "Name": "Sum of Two Integers",
    "NcLink": "sum-of-two-integers/",
    "Pattern": "Bit Manipulation",
    "Description": "Given two integers \u0060a\u0060 and \u0060b\u0060, return the sum of the two integers without using the \u0060\u002B\u0060 and \u0060-\u0060 operators.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: a = 1, b = 1\n\nOutput: 2\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: a = 4, b = 7\n\nOutput: 11\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060-1000 \u003C= a, b \u003C= 1000\u0060\n",
    "Difficulty": "Medium",
    "Video": "gVUrDV4tZfY",
    "PythonSolution": "class Solution:\n    def getSum(self, a: int, b: int) -\u003E int:\n        def add(a, b):\n            if not a or not b:\n                return a or b\n            return add(a ^ b, (a \u0026 b) \u003C\u003C 1)\n\n        if a * b \u003C 0:  \n            if a \u003E 0:\n                return self.getSum(b, a)\n            if add(~a, 1) == b: \n                return 0\n            if add(~a, 1) \u003C b:  \n                return add(~add(add(~a, 1), add(~b, 1)), 1)  \n\n        return add(a, b)  \n"
  },
  {
    "Name": "Reverse Integer",
    "NcLink": "reverse-integer/",
    "Pattern": "Bit Manipulation",
    "Description": "You are given a signed 32-bit integer \u0060x\u0060.\n    \nReturn \u0060x\u0060 after reversing each of its digits. After reversing, if \u0060x\u0060 goes outside the signed 32-bit integer range \u0060[-2^31, 2^31 - 1]\u0060, then return \u00600\u0060 instead.\n\nSolve the problem without using integers that are outside the signed 32-bit integer range.\n\n**Example 1:**\n\n\u0060\u0060\u0060java\nInput: x = 1234\n\nOutput: 4321\n\u0060\u0060\u0060\n\n**Example 2:**\n\n\u0060\u0060\u0060java\nInput: x = -1234\n\nOutput: -4321\n\u0060\u0060\u0060\n\n**Example 3:**\n\n\u0060\u0060\u0060java\nInput: x = 1234236467\n\nOutput: 0\n\u0060\u0060\u0060\n\n**Constraints:**\n* \u0060-2^31 \u003C= x \u003C= 2^31 - 1\u0060\n",
    "Difficulty": "Medium",
    "Video": "HAgLH58IgJQ",
    "PythonSolution": "class Solution:\n    def reverse(self, x: int) -\u003E int:\n        MIN = -2147483648  # -2^31,\n        MAX = 2147483647  #  2^31 - 1\n\n        res = 0\n        while x:\n            digit = int(math.fmod(x, 10))\n            x = int(x / 10)\n\n            if res \u003E MAX // 10 or (res == MAX // 10 and digit \u003E MAX % 10):\n                return 0\n            if res \u003C MIN // 10 or (res == MIN // 10 and digit \u003C MIN % 10):\n                return 0\n            res = (res * 10) \u002B digit\n\n        return res\n"
  }
]